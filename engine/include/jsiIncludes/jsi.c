/* jsi.h : External API header file for Jsi. */
#ifndef __JSI_H__
#define __JSI_H__

#define JSI_VERSION_MAJOR   2
#define JSI_VERSION_MINOR   4
#define JSI_VERSION_RELEASE 37

#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))

#ifndef JSI_EXTERN
#define JSI_EXTERN extern
#endif

#ifdef offsetof
#define Jsi_Offset(type, field) ((long) offsetof(type, field))
#else
#define Jsi_Offset(type, field) ((long) ((char *) &((type *) 0)->field))
#endif

#ifndef __GNUC__
#define __attribute__(X)
#endif

#ifndef __USE_XOPEN
#define __USE_XOPEN
#endif
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#ifdef __WIN32
#define __USE_MINGW_ANSI_STDIO 1
#endif

#include <stdbool.h>
#include <inttypes.h>
#include <stdint.h>
#include <time.h>
#include <sys/stat.h>
#include <stdio.h> 
#include <dirent.h>

/* --TYPEDEFS-- */
typedef int64_t Jsi_Wide;
typedef uint64_t Jsi_UWide;
typedef long double ldouble;
#ifdef JSI_USE_LONG_DOUBLE
typedef ldouble Jsi_Number;
#define JSI_NUMLMOD "L"
#else
typedef double Jsi_Number;
#define JSI_NUMLMOD
#endif
typedef double time_d;
typedef int64_t time_w;
typedef uint32_t Jsi_Sig; // Signature field

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned long ulong;
typedef unsigned short ushort;
#define JSI_NUMGFMT JSI_NUMLMOD "g"
#define JSI_NUMFFMT JSI_NUMLMOD "f"
#define JSI_NUMEFMT JSI_NUMLMOD "e"
/* -- */


/* --ENUMS-- */
typedef enum {
    /* Jsi Return Codes. */
    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,
    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,    
} Jsi_RC;

typedef enum {
    JSI_MAP_NONE, JSI_MAP_HASH, JSI_MAP_TREE, JSI_MAP_LIST /*, JSI_MAP_STACK */
} Jsi_Map_Type;

typedef enum {
    JSI_KEYS_STRING = 0,    // A string that gets stored in hash.
    JSI_KEYS_STRINGKEY = 1, // A pointer to strings in another hash such as Jsi_KeyLookup()
    JSI_KEYS_ONEWORD = 2,   // A pointer.
    JSI_KEYS_RESERVED = 3,  // Unused.
    JSI_KEYS_STRUCT_MINSIZE = 4 // Any number >= 4 is the number of bytes in a struct/key.
} Jsi_Key_Type;

typedef enum {
    JSI_OT_UNDEF,       /* Undefined */
    JSI_OT_BOOL,        /* Boolean object, use d.val */
    JSI_OT_NUMBER,      /* Number object, use d.num */
    JSI_OT_STRING,      /* String object, use d.str */
    JSI_OT_OBJECT,      /* Common object */
    JSI_OT_ARRAY,       /* NOT A REAL TYPE: is just an JSI_OT_OBJECT with array elements */
    JSI_OT_FUNCTION,    /* Function object, use d.fobj */
    JSI_OT_REGEXP,      /* RegExp object, use d.robj */
    JSI_OT_ITER,        /* Iter object, use d.iobj */
    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */
    JSI_OT__MAX = JSI_OT_USEROBJ
} Jsi_otype;

typedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */
    JSI_VT_UNDEF,       /* undefined    none        none            none                */
    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */
    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */
    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */
    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */
    JSI_VT_NULL,        /* null         none        none            none                */
    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */
    JSI_VT__MAX = JSI_VT_VARIABLE
} Jsi_vtype;

typedef enum {
    JSI_TT_UNDEFINED= (1<<JSI_OT_UNDEF),    //  0x1
    JSI_TT_BOOLEAN  = (1<<JSI_OT_BOOL),     //  0x2
    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),   //  0x4
    JSI_TT_STRING   = (1<<JSI_OT_STRING),   //  0x8
    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),   //  0x10
    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),    //  0x20
    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION), //  0x40
    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),   //  0x80
    JSI_TT_ITEROBJ  = (1<<JSI_OT_ITER),     //  0x100
    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),  //  0x200
    JSI_TT_NULL     = (1<<(JSI_OT_USEROBJ+1)),//0x400
    JSI_TT_ANY      = (1<<(JSI_OT_USEROBJ+2)),//0x800
    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+3)) //0x1000
} Jsi_ttype;

typedef enum {
    /* General flags. */
    JSI_NONE=0, JSI_NO_ERRMSG=1, 
    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,
    JSI_CMP_EXACT=0x4,
    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_AUTOINDEX=0x8,
    JSI_EVAL_RETURN         =0x10, // Return top of stack as result
    JSI_EVAL_ONCE           =0x20, // Source files only once.

    /* Flags for Jsi_CmdProc */
    JSI_CALL_CONSTRUCTOR    =0x1,
    JSI_CALL_BUILTIN        =0x2,
    
    JSI_CMDSPEC_ISOBJ       = 0x1,
    JSI_CMDSPEC_PROTO       = 0x2,
    JSI_CMDSPEC_NONTHIS     = 0x4,
    JSI_CMDSPEC_SUBCMDS     = 0x8,      // Has sub-commands.
    
    JSI_CMD_HAS_ATTR        = 0x100,
    JSI_CMD_IS_CONSTRUCTOR  = 0x200,
    JSI_CMD_IS_OBJ          = 0x400,
    JSI_CMD_MASK            = 0xffff,
    
    JSI_OM_READONLY         = 0x01,     /* ecma read-only */
    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */
    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */
    JSI_OM_INNERSHARED      = 0x08,
    JSI_OM_ISARRAYLIST      = 0x10,
    JSI_OM_ISSTRKEY         = 0x20,
    JSI_OM_UNUSED           = 0x40,
    JSI_OM_ISSTATIC         = 0x80,
    
    JSI_LOG_BUG=0,   JSI_LOG_ERROR,     JSI_LOG_WARN,
    JSI_LOG_INFO,    JSI_LOG_DEBUG,     JSI_LOG_PARSE,
    
    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_DICT = 0x4,
    
    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,
    
    JSI_TREE_ORDER_IN=0, JSI_TREE_ORDER_PRE=0x10, JSI_TREE_ORDER_POST=0x20, // Jsi_TreeSearchFirst()
    JSI_TREE_ORDER_LEVEL=0x30, JSI_TREE_ORDER_MASK=0x30,
    JSI_TREE_SEARCH_KEY=0x10, // Use key even if NULL
    JSI_TREE_USERFLAG_MASK=0x7f,
    JSI_LIST_REVERSE=0x8, // Jsi_ListSearchFirst
    JSI_MUTEX_RECURSIVE=2,
    
    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,
    JSI_FS_COMPRESS=0x100,
    JSI_FSMODESIZE=15,
    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,
    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,
    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,
    
    JSI_OUTPUT_QUOTE = 0x1,
    JSI_OUTPUT_JSON = 0x2,
    JSI_OUTPUT_NEWLINES = 0x4,
    JSI_OUTPUT_STDERR = 0x8,
    JSI_JSON_STATIC_DEFAULT =100,
    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */
    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadbee0,

    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,
    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,

    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */
    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */
    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */
    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */
    
    JSI_MAX_NUMBER_STRING=50

} Jsi_Enums; /* Debugging is easier with enums than #define. */

/* -- */


/* --STRUCTS-- */

typedef struct Jsi_Interp Jsi_Interp;
typedef struct Jsi_Obj Jsi_Obj;
typedef struct Jsi_Value Jsi_Value;
typedef struct Jsi_Func Jsi_Func;
typedef struct Jsi_IterObj Jsi_IterObj;
typedef struct Jsi_FuncObj Jsi_FuncObj;
typedef struct Jsi_UserObjReg Jsi_UserObjReg;
typedef struct Jsi_UserObj Jsi_UserObj;
typedef struct Jsi_HashEntry Jsi_HashEntry;
typedef struct Jsi_Hash Jsi_Hash;
typedef struct Jsi_HashSearch Jsi_HashSearch;
typedef struct Jsi_TreeEntry Jsi_TreeEntry;
typedef struct Jsi_Tree Jsi_Tree;
typedef struct Jsi_TreeSearch Jsi_TreeSearch;
typedef struct Jsi_List Jsi_List;
typedef struct Jsi_ListEntry Jsi_ListEntry;
typedef struct Jsi_ListSearch Jsi_ListSearch;
typedef struct Jsi_Map Jsi_Map;
typedef struct Jsi_MapEntry Jsi_MapEntry;
typedef struct Jsi_MapSearch Jsi_MapSearch;
typedef struct Jsi_Regex_ Jsi_Regex;
typedef struct Jsi_Db Jsi_Db;
typedef struct Jsi_DbBinds Jsi_DbBinds;
typedef struct Jsi_Mutex Jsi_Mutex;
typedef struct Jsi_ScopeStrs Jsi_ScopeStrs;
typedef struct Jsi_OpCodes Jsi_OpCodes;
typedef struct Jsi_Chan* Jsi_Channel;
typedef struct Jsi_CS_Ctx Jsi_CS_Ctx;
typedef struct Jsi_OptionSpec Jsi_OptionSpec;

#if JSI__CDATATYPCHECK // Normally we re-purpose Jsi_OptionSpec, but this is for type-checking.
typedef struct Jsi_StructSpec Jsi_StructSpec;
typedef struct Jsi_EnumSpec Jsi_EnumSpec;
typedef struct Jsi_VarSpec Jsi_VarSpec;
#else
typedef struct Jsi_OptionSpec Jsi_StructSpec;
typedef struct Jsi_OptionSpec Jsi_EnumSpec;
typedef struct Jsi_OptionSpec Jsi_VarSpec;
#endif

typedef Jsi_RC (Jsi_InitProc)(Jsi_Interp *interp, int release); // When release>1, the main interp is exiting.
typedef Jsi_RC (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);
typedef Jsi_RC (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);
typedef Jsi_RC (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v, struct Jsi_OptionSpec* spec, void *record);
typedef void (Jsi_DeleteVoidProc)(void *data);
typedef Jsi_RC (Jsi_csgset)(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet);


/* -- */


/* --INTERP-- */

/* Options and flags for Jsi_InterpNew/Jsi_Main */
typedef struct {
    int argc;                   // Arguments from main().
    char **argv;                // ...
    Jsi_InitProc* initProc;     // Initialization proc
    uint mem_debug:2;           // Memory debug level;
    bool no_interactive:1;  // Jsi_Main: do not invoke interactive mode, even with no script arg.
    bool auto_delete:1;     // Jsi_Main: auto delete interp upon return.
    bool no_exit:1;         // Do not exit, even on error.
    uint reserved:11;           // Reserved for future use.
    int exitCode:16;            // Call exit with this code.
    Jsi_Interp* interp;         // Jsi_InterpNew sets this to let Jsi_Main use this interp.
    void *reserved2[8];         // Reserved for future
} Jsi_InterpOpts;

JSI_EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts); /*STUB = 1*/
JSI_EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/
JSI_EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/
JSI_EXTERN Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/
JSI_EXTERN bool Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/
JSI_EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/
JSI_EXTERN const char* Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr); /*STUB = 7*/
JSI_EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 8*/
JSI_EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc); /*STUB = 9*/
JSI_EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 10*/
JSI_EXTERN bool Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 11*/
JSI_EXTERN Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* file, int toWrite); /*STUB = 12*/
JSI_EXTERN Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts); /*STUB = 13*/
/* -- */


/* --MEMORY-- */
JSI_EXTERN void* Jsi_Malloc(uint size); /*STUB = 14*/
JSI_EXTERN void* Jsi_Calloc(uint n, uint size); /*STUB = 15*/
JSI_EXTERN void* Jsi_Realloc(void *m, uint size); /*STUB = 16*/
JSI_EXTERN void  Jsi_Free(void *m); /*STUB = 17*/
JSI_EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 18*/
JSI_EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 19*/
JSI_EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 20*/
JSI_EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 21*/
JSI_EXTERN bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 22*/
JSI_EXTERN Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m); /*STUB = 23*/
/* -- */


/* --STRINGS-- */
JSI_EXTERN uint Jsi_Strlen(const char *str); /*STUB = 24*/
JSI_EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 25*/
JSI_EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 26*/
JSI_EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 27*/
JSI_EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 28*/
JSI_EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 29*/
JSI_EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 30*/
JSI_EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 31*/
JSI_EXTERN char* Jsi_Strdup(const char *n); /*STUB = 32*/
JSI_EXTERN char* Jsi_Strrchr(const char *str, int c); /*STUB = 33*/
JSI_EXTERN char* Jsi_Strstr(const char *str, const char *sub); /*STUB = 34*/
JSI_EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint n); /*STUB = 35*/
JSI_EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 36*/
JSI_EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 37*/
JSI_EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 38*/
#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))

/* Dynamic strings. */
#ifndef JSI_DSTRING_STATIC_SIZE
#define JSI_DSTRING_STATIC_SIZE 200
#endif

typedef struct {
#define JSI_DSTRING_DECL_FIELDS(siz) \
    const char *strA; /* Allocated string, or = {"string"}.*/ \
    uint len;       /* Length of string. */ \
    uint spaceAvl;  /* Amount of space available or allocated. */ \
    uint staticSize;/* The sizeof "Str", or 0 if used "= {}" */ \
    char Str[siz];  /* Static string */
    JSI_DSTRING_DECL_FIELDS(JSI_DSTRING_STATIC_SIZE)
} Jsi_DString;

/* Declares a custom Jsi_DString* variable with other than default size... */
#define JSI_DSTRING_VAR(namPtr, siz) \
    struct { JSI_DSTRING_DECL_FIELDS(siz) } _STATIC_##namPtr; \
    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \
    namPtr->staticSize = siz; namPtr->strA=0; \
    namPtr->Str[0] = 0; namPtr->spaceAvl = namPtr->len = 0

JSI_EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 39*/
JSI_EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 40*/  __attribute__((sentinel));
JSI_EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 41*/
JSI_EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 42*/
JSI_EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 43*/
JSI_EXTERN uint    Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 44*/
JSI_EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 45*/ __attribute__((format (printf,2,3)));
JSI_EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 46*/
JSI_EXTERN uint    Jsi_DSSetLength(Jsi_DString *dsPtr, uint length);  /*STUB = 47*/
JSI_EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 48*/
/* -- */


/* --FUNC/VAR/CMD-- */
typedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);
typedef Jsi_RC (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
#define Jsi_CmdProcDecl(name,...) Jsi_RC name(Jsi_Interp *interp, Jsi_Value *args, \
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)

typedef struct Jsi_CmdSpec {
    const char *name;       /* Cmd name */
    Jsi_CmdProc *proc;      /* Command handler */
    int minArgs;
    int maxArgs;            /* Max args or -1 */
    const char *argStr;     /* Argument description */
    const char *help;       /* Short help string. */
    uint retType;           /* Return type(s) or'ed Jsi_otype. */
    int flags;              /* JSI_CMD_* flags. */
    const char *info;       /* Detailed description. Use JSI_DETAIL macro. */
    Jsi_OptionSpec *opts;   /* Options for arg, default is first. */
    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */
    void *reserved[4];      /* reserved for internal use. */
} Jsi_CmdSpec;

typedef struct {
    char *str;
    int32_t len;
    uint32_t flags;
} Jsi_String;

JSI_EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 49*/
JSI_EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 50*/
JSI_EXTERN void* Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var);  /*STUB = 51*/
JSI_EXTERN Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 52*/
JSI_EXTERN Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 53*/
JSI_EXTERN Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 54*/
JSI_EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 55*/
JSI_EXTERN bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 56*/
JSI_EXTERN bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 57*/
JSI_EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 58*/
JSI_EXTERN Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 59*/
JSI_EXTERN Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 60*/
JSI_EXTERN Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 61*/
JSI_EXTERN Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 62*/
JSI_EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 63*/
JSI_EXTERN Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr); /*STUB = 64*/
JSI_EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 65*/
JSI_EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 66*/
JSI_EXTERN Jsi_Value* Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj); /*STUB = 67*/
JSI_EXTERN Jsi_RC Jsi_PkgProvide(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc); /*STUB = 68*/
JSI_EXTERN Jsi_Number Jsi_PkgRequire(Jsi_Interp *interp, const char *name, int version); /*STUB = 69*/
JSI_EXTERN Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr); /*STUB = 70*/
/* -- */

/* UTF-8 and Unicode */
typedef int32_t Jsi_UniChar;
JSI_EXTERN uint Jsi_NumUtfBytes(char c); /*STUB = 71*/
JSI_EXTERN uint Jsi_NumUtfChars(const char *utf, int length); /*STUB = 72*/
JSI_EXTERN uint Jsi_UtfGetIndex(const char *utf, int index, char outbuf[5]); /*STUB = 73*/
JSI_EXTERN const char* Jsi_UtfAtIndex(const char *utf, int index); /*STUB = 74*/
JSI_EXTERN uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest); /*STUB = 75*/
JSI_EXTERN uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *ch); /*STUB = 76*/
JSI_EXTERN uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *ch, int upper); /*STUB = 77*/
JSI_EXTERN uint Jsi_UtfDecode(const char *str, char* oututf); /*STUB = 78*/
JSI_EXTERN uint Jsi_UtfEncode(const char *utf, char *outstr); /*STUB = 79*/
JSI_EXTERN char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr); /*STUB = 80*/
JSI_EXTERN int Jsi_UtfIndexToOffset(const char *utf, int index); /*STUB = 81*/
/* -- */


/* --OBJECT-- */
JSI_EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 82*/
JSI_EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 83*/
JSI_EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 84*/
JSI_EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 85*/
JSI_EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 86*/

JSI_EXTERN bool      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 87*/
JSI_EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len); /*STUB = 88*/
JSI_EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 89*/
JSI_EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 90*/
JSI_EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 91*/
JSI_EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 92*/
JSI_EXTERN Jsi_RC      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 93*/
JSI_EXTERN Jsi_RC      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 94*/
JSI_EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 95*/
JSI_EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 96*/
/* -- */


/* --VALUE-- */
JSI_EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 97*/
JSI_EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 98*/
JSI_EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 99*/

JSI_EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 100*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 101*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 102*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, uchar *s, uint len); /*STUB = 103*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 104*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 105*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 106*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count); /*STUB = 107*/
JSI_EXTERN Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) ; /*STUB = 108*/

JSI_EXTERN Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 109*/
JSI_EXTERN Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 110*/
JSI_EXTERN Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n); /*STUB = 111*/
JSI_EXTERN Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 112*/
JSI_EXTERN Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 113*/
JSI_EXTERN Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 114*/
JSI_EXTERN Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 115*/
JSI_EXTERN Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 116*/
JSI_EXTERN Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val); /*STUB = 117*/
JSI_EXTERN Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 118*/

JSI_EXTERN bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 119*/
JSI_EXTERN bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 120*/
JSI_EXTERN bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 121*/
JSI_EXTERN bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/
JSI_EXTERN bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 123*/
JSI_EXTERN bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 124*/
JSI_EXTERN bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 125*/
JSI_EXTERN bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 126*/
JSI_EXTERN bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 127*/
JSI_EXTERN bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 128*/
JSI_EXTERN bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 129*/

JSI_EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 130*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 131*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 132*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 133*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 134*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 135*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, uchar *s, int len); /*STUB = 136*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 137*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 138*/
JSI_EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 139*/
JSI_EXTERN bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 140*/
#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))

JSI_EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 141*/
JSI_EXTERN Jsi_RC       Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 142*/
JSI_EXTERN Jsi_RC       Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 143*/
JSI_EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 144*/
JSI_EXTERN Jsi_RC       Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 145*/

JSI_EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 146*/
JSI_EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 147*/
JSI_EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 148*/
JSI_EXTERN uchar*   Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 149*/
JSI_EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 150*/
JSI_EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 151*/
JSI_EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 152*/
JSI_EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 153*/
JSI_EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 154*/
JSI_EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 155*/
JSI_EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 156*/
JSI_EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 157*/
JSI_EXTERN Jsi_RC Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 158*/

JSI_EXTERN Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 159*/
JSI_EXTERN Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 160*/
JSI_EXTERN Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 161*/
JSI_EXTERN Jsi_Value* Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *arg1); /*STUB = 162*/
JSI_EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 163*/
JSI_EXTERN Jsi_Value* Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 164*/
JSI_EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 165*/
JSI_EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 166*/
#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)

#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)
JSI_EXTERN void Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 167*/
JSI_EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 168*/
JSI_EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 169*/
JSI_EXTERN bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 170*/
JSI_EXTERN Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 171*/

JSI_EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 172*/
JSI_EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 173*/
JSI_EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 174*/
JSI_EXTERN Jsi_Value* Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val); /*STUB = 175*/
JSI_EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 176*/
JSI_EXTERN bool  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 177*/
/* -- */


/* --USEROBJ-- */
typedef bool (Jsi_UserObjIsTrueProc)(void *data);
typedef bool (Jsi_UserObjIsEquProc)(void *data1, void *data2);
typedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);

typedef struct Jsi_UserObjReg {
    const char *name;
    Jsi_CmdSpec *spec;
    Jsi_DeleteProc *freefun;
    Jsi_UserObjIsTrueProc *istrue;
    Jsi_UserObjIsEquProc *isequ;
} Jsi_UserObjReg;

JSI_EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 178*/
JSI_EXTERN Jsi_RC Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 179*/
JSI_EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 180*/
JSI_EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 181*/
/* -- */


/* --UTILITY-- */
#define JSI_NOTUSED(n) n=n /* Eliminate annoying compiler warning. */
JSI_EXTERN char* Jsi_NumberToString(Jsi_Number d, char *buf, int bsiz); /*STUB = 182*/
JSI_EXTERN Jsi_Number Jsi_Version(void); /*STUB = 183*/
JSI_EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 184*/
JSI_EXTERN Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 185*/
JSI_EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 186*/
JSI_EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 187*/
JSI_EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 188*/
JSI_EXTERN Jsi_RC Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 189*/
JSI_EXTERN Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, Jsi_Value *ret); /*STUB = 190*/
JSI_EXTERN bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 191*/
JSI_EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 192*/
JSI_EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 193*/
JSI_EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 194*/
JSI_EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 195*/
JSI_EXTERN Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 196*/
JSI_EXTERN Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 197*/ __attribute__((format (printf,3,4)));
JSI_EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dStr); /*STUB = 198*/
JSI_EXTERN Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 199*/
JSI_EXTERN Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 200*/
JSI_EXTERN Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags); /*STUB = 201*/
JSI_EXTERN Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 202*/
JSI_EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 203*/
JSI_EXTERN Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n); /*STUB = 204*/
JSI_EXTERN Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 205*/
JSI_EXTERN Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 206*/
JSI_EXTERN Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 207*/
JSI_EXTERN Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 208*/
JSI_EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *splitCh, Jsi_DString *dStr); /*STUB = 209*/
JSI_EXTERN Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 210*/
JSI_EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 211*/
JSI_EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 212*/
JSI_EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 213*/
JSI_EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 214*/
JSI_EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton); /*STUB = 215*/
JSI_EXTERN Jsi_RC Jsi_GetIndex( Jsi_Interp *interp, const char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 216*/
JSI_EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 217*/
JSI_EXTERN Jsi_RC  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 218*/
JSI_EXTERN Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 219*/
JSI_EXTERN Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 220*/
JSI_EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 221*/
JSI_EXTERN Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags); /*STUB = 222*/
JSI_EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 223*/
JSI_EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 224*/
JSI_EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 225*/
JSI_EXTERN Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 226*/
JSI_EXTERN Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr); /*STUB = 227*/
JSI_EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 228*/
#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)
#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)

typedef enum { Jsi_CHash_SHA2_256, Jsi_CHash_SHA1, Jsi_CHash_MD5, Jsi_CHash_SHA3_224, 
    Jsi_CHash_SHA3_384, Jsi_CHash_SHA3_512, Jsi_CHash_SHA3_256 } Jsi_CryptoHashType;

JSI_EXTERN Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt); /*STUB = 229*/
JSI_EXTERN Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex); /*STUB = 230*/
JSI_EXTERN Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *buf, bool decode); /*STUB = 231*/
JSI_EXTERN void Jsi_ToHexStr(const uchar *indata, int inlen, char *out); /*STUB = 232*/
JSI_EXTERN int Jsi_FromHexStr(const char *in, uchar *outdata); /*STUB = 233*/
JSI_EXTERN uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len); /*STUB = 234*/

JSI_EXTERN int Jsi_NumberIsInfinity(Jsi_Number a);  /*STUB = 235*/
JSI_EXTERN bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2);  /*STUB = 236*/
JSI_EXTERN bool Jsi_NumberIsFinite(Jsi_Number value);  /*STUB = 237*/
JSI_EXTERN bool Jsi_NumberIsInteger(Jsi_Number n);  /*STUB = 238*/
JSI_EXTERN bool Jsi_NumberIsNaN(Jsi_Number a);  /*STUB = 239*/
JSI_EXTERN bool Jsi_NumberIsNormal(Jsi_Number a);  /*STUB = 240*/
JSI_EXTERN bool Jsi_NumberIsSubnormal(Jsi_Number a);  /*STUB = 241*/
JSI_EXTERN bool Jsi_NumberIsWide(Jsi_Number n);  /*STUB = 242*/
JSI_EXTERN Jsi_Number Jsi_NumberInfinity(int i);  /*STUB = 243*/
JSI_EXTERN Jsi_Number Jsi_NumberNaN(void);  /*STUB = 244*/
JSI_EXTERN void Jsi_NumberDtoA(Jsi_Number value, char* buf, int bsiz, int prec);  /*STUB = 245*/
JSI_EXTERN void Jsi_NumberItoA10(int value, char* buf, int bsiz);  /*STUB = 246*/
JSI_EXTERN void Jsi_NumberUtoA10(unsigned int value, char* buf, int bsiz);  /*STUB = 247*/

/* -- */

#define JSI_WORDKEY_CAST (void*)(uintptr_t)

struct Jsi_MapOpts;

typedef Jsi_RC (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);
typedef Jsi_RC (Jsi_TreeDeleteProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);
typedef Jsi_RC (Jsi_MapDeleteProc)(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *data);
typedef Jsi_Value *(Jsi_MapFmtKeyProc)(Jsi_MapEntry* hPtr, struct Jsi_MapOpts *opts, int flags);
typedef Jsi_RC (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);
typedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);

typedef struct Jsi_MapOpts {
    Jsi_Map_Type mapType; // Read-only
    Jsi_Key_Type keyType; // Read-only
    Jsi_Interp *interp;
    Jsi_Wide flags;
    void *user, *user2;
    Jsi_MapFmtKeyProc *fmtKeyProc;
    Jsi_RBCompareProc *compareTreeProc;
    union {
        Jsi_RC (*freeHashProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);
        Jsi_RC (*freeTreeProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);
        Jsi_RC (*freeListProc)(Jsi_Interp *interp, Jsi_ListEntry *hPtr, void *data);
    };
    union {
        Jsi_RC (*lockHashProc) (Jsi_Hash *tablePtr, int lock);
        Jsi_RC (*lockTreeProc) (Jsi_Tree *tablePtr, int lock);
    };
} Jsi_MapOpts;

/* --HASH-- */
typedef struct Jsi_HashSearch {
    Jsi_Hash *tablePtr;
    unsigned long nextIndex; 
    Jsi_HashEntry *nextEntryPtr;
} Jsi_HashSearch;

JSI_EXTERN Jsi_Hash* Jsi_HashNew(Jsi_Interp *interp, uint keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 248*/
JSI_EXTERN Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set); /*STUB = 249*/
JSI_EXTERN void Jsi_HashDelete(Jsi_Hash *hashPtr); /*STUB = 250*/
JSI_EXTERN void Jsi_HashClear(Jsi_Hash *hashPtr); /*STUB = 251*/
JSI_EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, const void *key, void *value); /*STUB = 252*/
JSI_EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, const void *key, int flags); /*STUB = 253*/
JSI_EXTERN bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key); /*STUB = 254*/
JSI_EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 255*/
JSI_EXTERN Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 256*/
JSI_EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 257*/
JSI_EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 258*/
JSI_EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 259*/
JSI_EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, bool *isNew); /*STUB = 260*/
JSI_EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 261*/
JSI_EXTERN Jsi_HashEntry* Jsi_HashSearchFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 262*/
JSI_EXTERN Jsi_HashEntry* Jsi_HashSearchNext (Jsi_HashSearch *searchPtr); /*STUB = 263*/
JSI_EXTERN uint Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 264*/
/* -- */


/* --TREE-- */

typedef struct Jsi_TreeSearch {
    Jsi_Tree *treePtr;
    uint top, max, left, epoch; 
    int flags;
    Jsi_TreeEntry *staticPtrs[200], *current;
    Jsi_TreeEntry **Ptrs;
} Jsi_TreeSearch;

JSI_EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, uint keyType, Jsi_TreeDeleteProc *freeProc); /*STUB = 265*/
JSI_EXTERN Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set); /*STUB = 266*/
JSI_EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 267*/
JSI_EXTERN void Jsi_TreeClear(Jsi_Tree *treePtr); /*STUB = 268*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 269*/
JSI_EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 270*/
JSI_EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 271*/
JSI_EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 272*/
JSI_EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 273*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 274*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew); /*STUB = 275*/
JSI_EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 276*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey); /*STUB = 277*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr); /*STUB = 278*/
JSI_EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr); /*STUB = 279*/
JSI_EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 280*/
JSI_EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 281*/
JSI_EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags); /*STUB = 282*/
JSI_EXTERN bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key); /*STUB = 283*/
JSI_EXTERN uint Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 284*/ 
JSI_EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 285*/
JSI_EXTERN Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 286*/
/* -- */


/* --LIST-- */
typedef struct Jsi_List {
    uint sig;
    int numEntries;
    Jsi_ListEntry *head;
    Jsi_ListEntry *tail;
    Jsi_MapOpts opts;
} Jsi_List;

typedef struct Jsi_ListEntry {
    uint sig;
    Jsi_Map_Type typ;    
    struct Jsi_ListEntry *next;
    struct Jsi_ListEntry *prev;
    Jsi_List *list;
    void *value;
} Jsi_ListEntry;

typedef struct Jsi_ListSearch {
    int flags;
    Jsi_List *tablePtr;
    unsigned long nextIndex; 
    Jsi_ListEntry *nextEntryPtr;
} Jsi_ListSearch;

JSI_EXTERN Jsi_List* Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc); /*STUB = 287*/
JSI_EXTERN Jsi_RC Jsi_ListConf(Jsi_List *list, Jsi_MapOpts *opts, bool set); /*STUB = 288*/
JSI_EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 289*/
JSI_EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 290*/
//#define Jsi_ListSet(l, before, value) Jsi_ListPush(l, before, Jsi_ListEntryNew(l, value))
//#define Jsi_ListGet(l, le) (le)->value 
//#define Jsi_ListKeyGet(le) (le)
//#define Jsi_ListKeysDump(interp, list, ret, flags) JSI_ERROR
JSI_EXTERN void* Jsi_ListValueGet(Jsi_ListEntry *list); /*STUB = 291*/
JSI_EXTERN void Jsi_ListValueSet(Jsi_ListEntry *list, const void *value); /*STUB = 292*/
//#define Jsi_ListEntryFind(l, le) (le)
JSI_EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list, const void *value, Jsi_ListEntry *before); /*STUB = 293*/
JSI_EXTERN int Jsi_ListEntryDelete(Jsi_ListEntry *entry); /*STUB = 294*/
JSI_EXTERN Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *search, int flags); /*STUB = 295*/
JSI_EXTERN Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *search); /*STUB = 296*/
JSI_EXTERN uint Jsi_ListSize(Jsi_List *list); /*STUB = 297*/
/* end of hash-compat functions. */

JSI_EXTERN Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *entry, Jsi_ListEntry *before); /*STUB = 298*/
JSI_EXTERN Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *entry); /*STUB = 299*/
#define Jsi_ListPushFront(list,entry)   Jsi_ListPush(list, entry, list->head)
#define Jsi_ListPushBack(list,entry)    Jsi_ListPush(list, entry, NULL)
#define Jsi_ListPushFrontNew(list,v)    Jsi_ListEntryNew(list, v, list->head)
#define Jsi_ListPushBackNew(list,v)     Jsi_ListEntryNew(list, v, NULL)
#define Jsi_ListPopFront(list)          Jsi_ListPop(list, list->head)
#define Jsi_ListPopBack(list)           Jsi_ListPop(list, list->tail)
#define Jsi_ListEntryNext(entry)        (entry)->next 
#define Jsi_ListEntryPrev(entry)        (entry)->prev
#define Jsi_ListGetFront(list)          (list)->head
#define Jsi_ListGetBack(list)           (list)->tail

/* -- */


/* --STACK-- */
typedef struct {
    int len;
    int maxlen;
    void **vector;
} Jsi_Stack;

JSI_EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 300*/
JSI_EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 301*/
JSI_EXTERN int Jsi_StackSize(Jsi_Stack *stack); /*STUB = 302*/
JSI_EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 303*/
JSI_EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 304*/
JSI_EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 305*/
JSI_EXTERN void* Jsi_StackUnshift(Jsi_Stack *stack); /*STUB = 306*/
JSI_EXTERN void* Jsi_StackHead(Jsi_Stack *stack); /*STUB = 307*/
JSI_EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 308*/
/* -- */

/* --MAP-- */
typedef struct Jsi_MapSearch {
    Jsi_Map_Type typ;
    union {
        Jsi_TreeSearch tree;
        Jsi_HashSearch hash;
        Jsi_ListSearch list;
    } v;
} Jsi_MapSearch;

JSI_EXTERN Jsi_Map* Jsi_MapNew(Jsi_Interp *interp, Jsi_Map_Type mapType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc); /*STUB = 309*/
JSI_EXTERN Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set); /*STUB = 310*/
JSI_EXTERN void Jsi_MapDelete (Jsi_Map *mapPtr); /*STUB = 311*/
JSI_EXTERN void Jsi_MapClear (Jsi_Map *mapPtr); /*STUB = 312*/
JSI_EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value); /*STUB = 313*/
JSI_EXTERN void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags); /*STUB = 314*/
JSI_EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags); /*STUB = 315*/
JSI_EXTERN Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags); /*STUB = 316*/
JSI_EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 317*/
JSI_EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value); /*STUB = 318*/
JSI_EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key); /*STUB = 319*/
JSI_EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew); /*STUB = 320*/
JSI_EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 321*/
JSI_EXTERN Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags); /*STUB = 322*/
JSI_EXTERN Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *srchPtr); /*STUB = 323*/
JSI_EXTERN void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr);  /*STUB = 324*/
JSI_EXTERN uint Jsi_MapSize(Jsi_Map *mapPtr); /*STUB = 325*/


// Define typed wrappers for 5 main Map functions: Set, Get, KeyGet, EntryFind, EntryNew
#define JSI_MAP_EXTN(Prefix, keyType, valType) \
JSI_EXTERN Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value); \
JSI_EXTERN valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key); \
JSI_EXTERN keyType Prefix ## _KeyGet(Jsi_MapEntry *h); \
JSI_EXTERN Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key); \
JSI_EXTERN Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew);

#define JSI_MAP_DEFN(Prefix, keyType, valType) \
Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value) { return Jsi_MapSet(mapPtr, (void*)key, (void*)value); } \
valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key) { return (valType)Jsi_MapGet(mapPtr, (void*)key); } \
keyType Prefix ## _KeyGet(Jsi_MapEntry *h) { return (keyType)Jsi_MapKeyGet(h); } \
Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key) { return  Jsi_MapEntryFind(mapPtr, (void*)key); } \
Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew) { return  Jsi_MapEntryNew(mapPtr, (void*)key, isNew); }
   
/* -- */


/* --OPTIONS-- */
typedef Jsi_RC (Jsi_OptionParseProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record, Jsi_Wide flags);
typedef Jsi_RC (Jsi_OptionFormatProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record, Jsi_Wide flags);
typedef Jsi_RC (Jsi_OptionFormatStringProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);
typedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);

typedef Jsi_RC (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);

typedef struct {
    const char *name;
    Jsi_OptionParseProc *parseProc;
    Jsi_OptionFormatProc *formatProc;
    Jsi_OptionFreeProc *freeProc;
    const char *help;
    const char *info;
    void* data;
} Jsi_OptionCustom;

typedef enum {
    JSI_OPTION_BOOL=1,
    JSI_OPTION_INT8,  JSI_OPTION_INT16,  JSI_OPTION_INT32,  JSI_OPTION_INT64,
    JSI_OPTION_UINT8, JSI_OPTION_UINT16, JSI_OPTION_UINT32, JSI_OPTION_UINT64,
    JSI_OPTION_FLOAT,
    JSI_OPTION_DOUBLE,    // Same as NUMBER when !JSI_USE_LONG_DOUBLE.
    JSI_OPTION_LDOUBLE,   // A long double
    JSI_OPTION_STRBUF,    // Fixed size string buffer.
    JSI_OPTION_TIME_W,    // Jsi_Wide: milliseconds since Jan 1, 1970.
    JSI_OPTION_TIME_D,    // double: milliseconds since Jan 1, 1970.
    // Non-portable fields start here
    JSI_OPTION_TIME_T,    // time_t: seconds since Jan 1, 1970. 
    JSI_OPTION_SIZE_T,
    JSI_OPTION_SSIZE_T,
    JSI_OPTION_INTPTR_T,  // Int big enough to store a pointer.
    JSI_OPTION_UINTPTR_T, 
    JSI_OPTION_NUMBER,    // Same as DOUBLE when !JSI_USE_LONG_DOUBLE.
    JSI_OPTION_INT, JSI_OPTION_UINT,
    JSI_OPTION_LONG, JSI_OPTION_ULONG, JSI_OPTION_SHORT, JSI_OPTION_USHORT,
    JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY,
    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY, JSI_OPTION_REGEXP,
    JSI_OPTION_FUNC,      // Note: .data can contain string args to check
    JSI_OPTION_USEROBJ,   // Note: .data can contain string obj name to check
    JSI_OPTION_CUSTOM,    // Note: set .custom, .data, etc.
    JSI_OPTION_END
} Jsi_OptionId;

typedef const char* Jsi_Strkey;
#ifdef __cplusplus
typedef void* Jsi_Strbuf;
#else
typedef char Jsi_Strbuf[];
#endif

// Union of all builtin types.
typedef union {
    bool           BOOL;
    int8_t         INT8;
    int16_t        INT16;
    int32_t        INT32;
    int64_t        INT64;
    uint8_t        UINT8;
    uint16_t       UINT16;
    uint32_t       UINT32;
    uint64_t       UINT64;
    float          FLOAT;
    double         DOUBLE;
    ldouble        LDOUBLE;
    Jsi_Number     NUMBER;
    char*          STRBUF;
    time_d         TIME_D;
    time_w         TIME_W;
    time_t         TIME_T;
    size_t         SIZE_T;
    ssize_t        SSIZE_T;
    intptr_t       INTPTR_T;
    uintptr_t      UINTPTR_T;
    int            INT;
    uint           UINT;
    long           LONG;
    ulong          ULONG;
    short          SHORT;
    ushort         USHORT;
    Jsi_DString    DSTRING;
    const char*    STRKEY;
    Jsi_Value*     STRING;
    Jsi_Value*     VALUE;
    Jsi_Value*     VAR;
    Jsi_Value*     OBJ;
    Jsi_Value*     ARRAY;
    Jsi_Value*     REGEXP;
    Jsi_Value*     FUNC;
    Jsi_Value*     USEROBJ;
    void*          CUSTOM;
    Jsi_csgset*    OPT_BITS;
    struct Jsi_OptionSpec* OPT_CARRAY;
} Jsi_OptionValue;

typedef union { /* Field used at compile-time by JSI_OPT() to provide type checking for the var */
    bool           *ini_BOOL;
    int8_t         *ini_INT8;
    int16_t        *ini_INT16;
    int32_t        *ini_INT32;
    int64_t        *ini_INT64;
    uint8_t        *ini_UINT8;
    uint16_t       *ini_UINT16;
    uint32_t       *ini_UINT32;
    uint64_t       *ini_UINT64;
    float          *ini_FLOAT;
    double         *ini_DOUBLE;
    ldouble        *ini_LDOUBLE;
    Jsi_Number     *ini_NUMBER;
#ifdef __cplusplus
    Jsi_Strbuf      ini_STRBUF;
#else
    Jsi_Strbuf      *ini_STRBUF;
#endif
    time_t         *ini_TIME_T;
    time_w         *ini_TIME_W;
    time_d         *ini_TIME_D;
    size_t         *ini_SIZE_T;
    ssize_t        *ini_SSIZE_T;
    intptr_t       *ini_INTPTR_T;
    uintptr_t      *ini_UINTPTR_T;
    int            *ini_INT;
    uint           *ini_UINT;
    long           *ini_LONG;
    ulong          *ini_ULONG;
    short          *ini_SHORT;
    ushort         *ini_USHORT;
    Jsi_DString    *ini_DSTRING;
    const char*    *ini_STRKEY;
    Jsi_Value*     *ini_VALUE;
    Jsi_Value*     *ini_STRING;
    Jsi_Value*     *ini_VAR;
    Jsi_Value*     *ini_OBJ;
    Jsi_Value*     *ini_ARRAY;
    Jsi_Value*     *ini_REGEXP;
    Jsi_Value*     *ini_FUNC;
    Jsi_Value*     *ini_USEROBJ;
    void           *ini_CUSTOM;
    Jsi_csgset     *ini_OPT_BITS;
    struct Jsi_OptionSpec *ini_OPT_CARRAY;
} Jsi_OptionInitVal;

typedef struct {
    Jsi_OptionId id;
    const char *idName, *cName;
    int size;
    const char *fmt, *xfmt, *sfmt, *help;
    Jsi_OptionValue init;
    Jsi_Wide flags;
    Jsi_Wide user;
    void *extData;              /* Extension data. */
} Jsi_OptionType;

struct Jsi_OptionSpec {
#define JSI_OPTIONSPEC_FIELDS() \
    Jsi_OptionId id; \
    const char *name;           /* The field name. */ \
    uint offset;                /* Jsi_Offset of field. */ \
    uint size;                  /* The sizeof() of field. */ \
    Jsi_OptionInitVal iniVal;   /* Initialization value */ \
    const char *help;           /* A short one-line help string, without newlines. */ \
    Jsi_Wide flags;             /* Lower 32 bits: the JSI_OPTS_* flags below. Upper 32 for custom/other. */ \
    Jsi_OptionCustom *custom;   /* Custom handler. */ \
    void *data;                 /* User data for custom options: eg. the bit for BOOLBIT. */ \
    const char *info;           /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/ \
    const char *tname;          /* Type name for field or external name used by the DB interface. */ \
    Jsi_Wide value;             /* Value field. */ \
    uint32_t bits;              /* Size of bitfield */ \
    uint32_t boffset;           /* Bit offset of field (or struct) */ \
    uint32_t idx;               /* Index (of field) */ \
    uint32_t ssig;              /* Signature (for struct) */ \
    uint32_t crc;               /* Crc (for struct) */ \
    const char *userData;       /* User data. */ \
    void *extData;              /* Extension data. */ \
    const Jsi_OptionType *type;
JSI_OPTIONSPEC_FIELDS()
};

/* JSI_OPT is a macro used for option definitions, eg:
 * 
 *      typedef struct { int debug; int bool; } MyStruct;
 * 
 *      Jsi_OptionSpec MyOptions[] = {
 *          JSI_OPT(BOOL,  MyStruct,  debug ),
 *          JSI_OPT(INT,   MyStruct,  max,   .help="Max value"),
 *          JSI_OPT_END(   MyStruct, .help="My first struct" )
 *      }
*/

#define JSI_OPT(typ, strct, nam, ...) \
    { .id=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \
      .iniVal={.ini_##typ=(&((strct *) 0)->nam)}, ##__VA_ARGS__ }

#define JSI_OPT_END(strct, ...) { .id=JSI_OPTION_END, .name=#strct, .offset=__LINE__, .size=sizeof(strct), \
      .iniVal={.ini_CUSTOM=(void*)__FILE__}, ##__VA_ARGS__}

#define JSI_OPT_BITS(strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) \
    { .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=0, .size=0, \
        .iniVal={.ini_OPT_BITS=&bsget}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchBitfield, .data=bdata,\
        .info=0, .tname=#nam, .value=0, .bits=0, .boffset=0, .idx=fidx }

#define JSI_OPT_CARRAY(strct, nam, hlp, flgs, aropt, siz, tnam) \
    { .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \
        .iniVal={.ini_OPT_CARRAY=aropt}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchCArray, .data=(void*)aropt,\
        .info=0, .tname=tnam, .value=siz }

#define JSI_OPT_CARRAY_ITEM(typ, strct, nam, ...) \
    { .id=JSI_OPTION_##typ, .name=#nam, .offset=0, .size=sizeof(((strct *) 0)->nam), \
      .iniVal={.ini_##typ=(&((strct *) 0)->nam[0])}, ##__VA_ARGS__ }

#define JSI_OPT_END_IDX(opt) ((sizeof(opt)/sizeof(opt[0]))-1)

/* builtin handler for Custom. */
#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* An Enum: choices are in .data=stringlist */
#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits in an int: choices are in .data=stringlist */
#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs: subspec is in .data={...} */
#define Jsi_Opt_SwitchBitfield      (Jsi_OptionCustom*)0x4 /* Struct bitfields: used by "jsish -c" */
#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Callback to verify Jsi_Value* correctness in .data=func. */
#define Jsi_Opt_SwitchCArray        (Jsi_OptionCustom*)0x6 /* C Array described in .data=type. */
#define Jsi_Opt_SwitchNull          (Jsi_OptionCustom*)0x7 /* Set is ignored, and get returns null */

enum {
    /* Jsi_OptionsProcess() flags */
    JSI_OPTS_PREFIX         =   (1<<27), /* Allow matching unique prefix of object members. */
    JSI_OPTS_IS_UPDATE      =   (1<<28), /* This is an update/conf (do not reset the specified flags) */
    JSI_OPTS_IGNORE_EXTRA   =   (1<<29), /* Ignore extra members not found in spec. */
    JSI_OPTS_FORCE_STRICT   =   (1<<30), /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */
    JSI_OPTS_VERBOSE        =   (1<<31), /* Dump verbose options */

    /* Jsi_OptionSpec flags. */
    JSI_OPT_IS_SPECIFIED    =   (1<<0),   /* User set the option. */
    JSI_OPT_INIT_ONLY       =   (1<<1),   /* Allow set only at init, disallowing update/conf. */
    JSI_OPT_READ_ONLY       =   (1<<2),   /* Value can not be set. */
    JSI_OPT_NO_DUPVALUE     =   (1<<3),   /* Values are not to be duped. */
    JSI_OPT_NO_CLEAR        =   (1<<4),   /* Values are not to be cleared: watch for memory leaks */
    JSI_OPT_DB_DIRTY        =   (1<<8),   /* Used to limit DB updates. */
    JSI_OPT_DB_IGNORE       =   (1<<9),   /* Field is not to be used for DB. */
    JSI_OPT_DB_ROWID        =   (1<<10),  /* Field used by DB to store rowid. */
    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */
    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */
    JSI_OPT_BITSET_BOOL     =   (1<<13),  /* Treat bitset custom field as bool instead of an int. */
    JSI_OPT_TIME_DATEONLY   =   (1<<14),  /* Time field is date only. */
    JSI_OPT_TIME_TIMEONLY   =   (1<<15),  /* Time field is time only. */
    JSI_OPT_IS_BITS         =   (1<<16),  /* Is a C bit-field. */
    JSI_OPT_FMT_STRING      =   (1<<17),  /* Format value (eg. time) as string. */
    JSI_OPT_FMT_NUMBER      =   (1<<18),  /* Format value (eg. enum) as number. */
    JSI_OPT_FMT_HEX         =   (1<<19),  /* Format number in hex. */
    JSI_OPT_STRICT          =   (1<<20),  /* Strict mode. */
    JSI_OPT_FIELDSETUP      =   (1<<21),  /* Field has been setup. */
    JSI_OPT_COERCE          =   (1<<22),  /* Coerce input value to required type. */
    JSI_OPT_NO_SIG          =   (1<<23),  /* No signature. */
    JSI_OPT_ENUM_SPEC       =   (1<<24),  /* Enum has spec rather than a list of strings. */
    JSI_OPT_ENUM_UNSIGNED   =   (1<<25),  /* Enum value is unsigned. */
    JSI_OPT_ENUM_EXACT      =   (1<<26),  /* Enum must be an exact match. */
    JSI_OPT_REQUIRED        =   (1<<27),  /* Field must be specified (if not IS_UPDATE). */
    JSI_OPTIONS_USER_FIRSTBIT  =   32,    /* First bit of user flags: the lower 32 bits are internal. */
};

JSI_EXTERN const Jsi_OptionType* Jsi_OptionTypeInfo(Jsi_OptionId typ); /*STUB = 326*/
JSI_EXTERN Jsi_OptionType* Jsi_TypeLookup(Jsi_Interp* interp, const char *typ); /*STUB = 327*/
JSI_EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Wide flags); /*STUB = 328*/
JSI_EXTERN int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags); /*STUB = 329*/
JSI_EXTERN Jsi_RC Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Value **ret, Jsi_Wide flags); /*STUB = 330*/
JSI_EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Wide flags); /*STUB = 331*/
JSI_EXTERN Jsi_RC Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags); /*STUB = 332*/
JSI_EXTERN Jsi_RC Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* data, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags); /*STUB = 333*/
JSI_EXTERN Jsi_RC Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, Jsi_Wide flags); /*STUB = 334*/
JSI_EXTERN int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 335*/ __attribute__((sentinel));
JSI_EXTERN bool Jsi_OptionsValid(Jsi_Interp *interp, Jsi_OptionSpec* spec);  /*STUB = 336*/
JSI_EXTERN const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema);
JSI_EXTERN Jsi_OptionSpec* Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags); /*STUB = 337*/
JSI_EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 338*/
JSI_EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 339*/
/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */
JSI_EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 340*/
JSI_EXTERN const Jsi_OptionSpec* Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs);  /*STUB = 341*/
/* -- */


/* --THREADS/MUTEX-- */
JSI_EXTERN Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 342*/
JSI_EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 343*/
JSI_EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 344*/
JSI_EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 345*/
JSI_EXTERN void* Jsi_CurrentThread(void); /*STUB = 346*/
JSI_EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 347*/
/* -- */


/* --LOGGING-- */
#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)
#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)
#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)
#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)
#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)

JSI_EXTERN Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint level, const char *format,...)  /*STUB = 348*/ __attribute__((format (printf,3,4)));


/* --EVENTS-- */
typedef struct {
    uint sig;
    uint id;
    int evType;                 /* Is signal handler. */
    int sigNum;
    int once;                   /* Execute once */
    long initialms;             /* initial relative timer value */
    long when_sec;              /* seconds */
    long when_ms;               /* milliseconds */
    uint count;         /* Times executed */
    Jsi_HashEntry *hPtr;
    Jsi_Value *funcVal;         /* JS Function to call. */
    Jsi_EventHandlerProc *handler;  /* C-function handler. */
    void *data;
} Jsi_Event;

JSI_EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 349*/
JSI_EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 350*/
JSI_EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 351*/
/* -- */


/* --JSON-- */
#define JSI_JSON_DECLARE(p, tokens, maxsz) \
    Jsi_JsonParser p = {0}; \
    Jsi_JsonTok tokens[maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT]; \
    Jsi_JsonInit(&p, tokens, maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT)

typedef enum {
    JSI_JTYPE_PRIMITIVE = 0,
    JSI_JTYPE_OBJECT = 1,
    JSI_JTYPE_ARRAY = 2,
    JSI_JTYPE_STRING = 3,
    JSI_JTYPE_INVALID=-1
} Jsi_JsonTypeEnum;

typedef enum {
    JSI_JSON_ERR_NOMEM = -1,
    JSI_JSON_ERR_INVAL = -2,
    JSI_JSON_ERR_PART = -3,
    JSI_JSON_ERR_NONE = 0
} Jsi_JsonErrEnum;

typedef struct {
    Jsi_JsonTypeEnum type;
    int start;
    int end;
    uint size;
    int parent;
} Jsi_JsonTok;

typedef struct {
    uint pos;           /* offset in the JSON string */
    uint toknext;       /* next token to allocate */
    int toksuper;       /* superior token node, e.g parent object or array */
    Jsi_JsonTok *tokens, *static_tokens;
    uint num_tokens;
    int no_malloc;      /* Disable parser dynamic growth tokens array. */
    bool strict;/* Strict parsing. */
    Jsi_Wide flags;
    const char *errStr;
    void *reserved[4];     /* Reserved for future */
} Jsi_JsonParser;


JSI_EXTERN void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *static_tokens, uint num_tokens); /*STUB = 352*/
JSI_EXTERN void Jsi_JsonReset(Jsi_JsonParser *parser); /*STUB = 353*/
JSI_EXTERN void Jsi_JsonFree(Jsi_JsonParser *parser); /*STUB = 354*/
JSI_EXTERN Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js); /*STUB = 355*/
JSI_EXTERN Jsi_JsonTok* Jsi_JsonGetToken(Jsi_JsonParser *parser, uint index); /*STUB = 356*/
JSI_EXTERN Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, uint index); /*STUB = 357*/
JSI_EXTERN int Jsi_JsonTokLen(Jsi_JsonParser *parser, uint index); /*STUB = 358*/
JSI_EXTERN const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *len); /*STUB = 359*/
JSI_EXTERN const char* Jsi_JsonGetTypename(int type); /*STUB = 360*/
JSI_EXTERN const char* Jsi_JsonGetErrname(int code); /*STUB = 361*/
JSI_EXTERN void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js); /*STUB = 362*/
/* -- */


/* --VFS-- */
struct Jsi_LoadHandle; struct Jsi_LoadHandle;

typedef struct Jsi_LoadHandle Jsi_LoadHandle;
typedef struct stat Jsi_StatBuf;
typedef struct dirent Jsi_Dirent;

typedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);
typedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);
typedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);
typedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);
typedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);
typedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);
typedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);
typedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);
typedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);
typedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);
typedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);
typedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);
typedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);
typedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);
typedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);
typedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);
typedef int (Jsi_FSGetcProc)(Jsi_Channel chan);
typedef int (Jsi_FSEofProc)(Jsi_Channel chan);
typedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, uint len);
typedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);
typedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);
typedef int (Jsi_FSPutsProc)(Jsi_Channel chan, const char* str);
typedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);
typedef int (Jsi_FSFlushProc)(Jsi_Channel chan);
typedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);
typedef int (Jsi_FSTellProc)(Jsi_Channel chan);
typedef int (Jsi_FSCloseProc)(Jsi_Channel chan);
typedef int (Jsi_FSRewindProc)(Jsi_Channel chan);
typedef bool (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);
typedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,
  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));

typedef struct Jsi_Filesystem {
    const char *typeName;
    int structureLength;    
    int version;
    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;
    Jsi_FSRealPathProc *realpathProc;
    Jsi_FSStatProc *statProc;
    Jsi_FSLstatProc *lstatProc;
    Jsi_FSAccessProc *accessProc;
    Jsi_FSChmodProc *chmodProc;
    Jsi_FSOpenProc *openProc;
    Jsi_FSScandirProc *scandirProc;
    Jsi_FSReadProc *readProc;
    Jsi_FSWriteProc *writeProc;
    Jsi_FSGetsProc *getsProc;
    Jsi_FSGetcProc *getcProc;
    Jsi_FSUngetcProc *ungetcProc;
    Jsi_FSPutsProc *putsProc;
    
    Jsi_FSFlushProc *flushProc;
    Jsi_FSSeekProc *seekProc;
    Jsi_FSTellProc *tellProc;
    Jsi_FSEofProc *eofProc;
    Jsi_FSTruncateProc *truncateProc;
    Jsi_FSRewindProc *rewindProc;
    Jsi_FSCloseProc *closeProc;
    Jsi_FSLinkProc *linkProc;
    Jsi_FSReadlinkProc *readlinkProc;
    Jsi_FSListVolumesProc *listVolumesProc;
    Jsi_FSCreateDirectoryProc *createDirectoryProc;
    Jsi_FSRemoveProc *removeProc;
    Jsi_FSRenameProc *renameProc;
    void *reserved[10];     /* Reserved for future */
} Jsi_Filesystem;

typedef struct Jsi_Chan {
    Jsi_Interp *interp;
    FILE *fp;
    const char *fname;  /* May be set by fs or by source */
    Jsi_Filesystem *fsPtr;
    int isNative;
    int flags;
    char modes[JSI_FSMODESIZE];
    void *data;
    void *reserved[4];     /* Reserved for future */
} Jsi_Chan;

JSI_EXTERN Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 363*/
JSI_EXTERN Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 364*/
JSI_EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 365*/
JSI_EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 366*/
JSI_EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 367*/
JSI_EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 368*/
JSI_EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 369*/
JSI_EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 370*/
JSI_EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 371*/
JSI_EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 372*/
JSI_EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 373*/
JSI_EXTERN int Jsi_Eof(Jsi_Channel chan); /*STUB = 374*/
JSI_EXTERN int Jsi_Close(Jsi_Channel chan); /*STUB = 375*/
JSI_EXTERN int Jsi_Read(Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 376*/
JSI_EXTERN int Jsi_Write(Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 377*/
JSI_EXTERN Jsi_Wide Jsi_Seek(Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 378*/
JSI_EXTERN Jsi_Wide Jsi_Tell(Jsi_Channel chan); /*STUB = 379*/
JSI_EXTERN int Jsi_Truncate(Jsi_Channel chan, uint len); /*STUB = 380*/
JSI_EXTERN Jsi_Wide Jsi_Rewind(Jsi_Channel chan); /*STUB = 381*/
JSI_EXTERN int Jsi_Flush(Jsi_Channel chan); /*STUB = 382*/
JSI_EXTERN int Jsi_Getc(Jsi_Channel chan); /*STUB = 383*/
JSI_EXTERN int Jsi_Printf(Jsi_Channel chan, const char *fmt, ...) /*STUB = 384*/ __attribute__((format (printf,2,3))); 
JSI_EXTERN int Jsi_Ungetc(Jsi_Channel chan, int ch); /*STUB = 385*/
JSI_EXTERN char* Jsi_Gets(Jsi_Channel chan, char *s, int size); /*STUB = 386*/
JSI_EXTERN int Jsi_Puts(Jsi_Channel chan, const char *str); /*STUB = 387*/

typedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);
typedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);
JSI_EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 388*/
JSI_EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 389*/
JSI_EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 390*/
JSI_EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 391*/
JSI_EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 392*/
JSI_EXTERN bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 393*/
JSI_EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 394*/
JSI_EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 395*/

JSI_EXTERN Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 396*/
JSI_EXTERN int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 397*/
#ifndef JSI_ZVFS_DIR
#define JSI_ZVFS_DIR "/zvfs"
#endif
/* -- */



/* --DATABASE-- */

JSI_EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 398*/
JSI_EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 399*/

/* -- */


/* --CData-- */

// Static definitions for CData
#if JSI__CDATATYPCHECK
typedef struct Jsi_StructSpec { JSI_OPTIONSPEC_FIELDS() } Jsi_StructSpec;
typedef struct Jsi_EnumSpec { JSI_OPTIONSPEC_FIELDS() } Jsi_EnumSpec;
typedef struct Jsi_VarSpec { JSI_OPTIONSPEC_FIELDS() } Jsi_VarSpec;
#else
#endif


typedef struct Jsi_CData_Static {
    const char* name;
    Jsi_StructSpec* structs;
    Jsi_EnumSpec* enums;
    Jsi_VarSpec *vars;
    Jsi_OptionType* types;
    struct Jsi_CData_Static* nextPtr;
} Jsi_CData_Static;

/* Struct for Carray to bind Data/Option pairs to individual SQLite binding chars. */
typedef struct Jsi_CDataDb {
#define JSI_DBDATA_FIELDS \
    Jsi_StructSpec *sf;     /* Struct fields for data. */ \
    void *data;             /* Data pointer for array/map */ \
    uint arrSize;           /* If an array, number of elements: 0 means 1. */ \
    char prefix;            /* Sqlite char bind prefix. One of: '@' '$' ':' '?' or 0 for any */ \
    Jsi_StructSpec* slKey;  /* Struct for key (for map using a struct key). */ \
    int (*callback)(Jsi_Interp *interp, struct Jsi_CDataDb* obPtr, void *data); /* C callback for select queries. */ \
    uint maxSize;           /* Limit size of array/map*/ \
    bool noAuto;            /* Do not auto-create map keys. */ \
    bool isPtrs;            /* "data" an array of pointers. */ \
    bool isPtr2;            /* "data" is pointer to pointers, which is updated. */ \
    bool isMap;             /* "data" is a map: use Jsi_MapConf() for details. */ \
    bool memClear;          /* Before query free and zero all data (eg. DStrings). */ \
    bool memFree;           /* Reset as per mem_clear, then free data items. Query may be empty. */ \
    bool dirtyOnly;         /* Sqlite dirty filter for UPDATE/INSERT/REPLACE. */ \
    bool noBegin;           /* Disable wrapping UPDATE in BEGIN/COMMIT. */ \
    bool noCache;           /* Disable Db caching statement. */ \
    bool noStatic;          /* Disable binding text with SQLITE_STATIC. */ \
    intptr_t reserved[4];   /* Internal use. */
JSI_DBDATA_FIELDS
} Jsi_CDataDb;

JSI_EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *cd, const char *query); /*STUB = 400*/
JSI_EXTERN Jsi_CDataDb* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 401*/
JSI_EXTERN Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics); /*STUB = 402*/
JSI_EXTERN Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname); /*STUB = 403*/ /*LAST*/
/* -- */


/* String */
typedef char STRING1[(1<<0)+1]; // Include a char for the null byte.
typedef char STRING2[(1<<1)+1];
typedef char STRING4[(1<<2)+1];
typedef char STRING8[(1<<3)+1];
typedef char STRING16[(1<<4)+1];
typedef char STRING32[(1<<5)+1];
typedef char STRING64[(1<<6)+1];
typedef char STRING128[(1<<7)+1];
typedef char STRING256[(1<<8)+1];
typedef char STRING512[(1<<9)+1];
typedef char STRING1024[(1<<10)+1];
typedef char STRING2048[(1<<11)+1];
typedef char STRING4096[(1<<12)+1];
typedef char STRING8192[(1<<13)+1];
typedef char STRING16384[(1<<14)+1];
typedef char STRING32768[(1<<15)+1];
typedef char STRING65536[(1<<16)+1];

/* -- */


#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \
    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \
    +sizeof(Jsi_CDataDb)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \
    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String))

#ifndef JSI_OMIT_STUBS
#ifdef JSI_USE_STUBS
#ifndef JSISTUBCALL
#define JSISTUBCALL(ptr,func) ptr->func
#endif
#include "jsiStubs.h"
#else
#define JSI_EXTENSION_INI
#define Jsi_StubsInit(i,f) JSI_OK
#endif
#endif


/* Optional compile-out commands/options string information. */
#ifdef JSI_OMIT_INFO
#define JSI_INFO(n) NULL
#endif
#ifndef JSI_INFO
#define JSI_INFO(n) n
#endif

#endif /* __JSI_H__ */


#ifndef JSI_IN_AMALGAMATION
#define JSI_IN_AMALGAMATION
#define _GNU_SOURCE
#define JSI_AMALGAMATION
#if JSI__MINIZ==1
/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Change History
     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):
       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug
        would only have occured in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()
        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).
       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size
       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.
         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).
       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes
       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.
       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
       - Merged MZ_FORCEINLINE fix from hdeanclark
       - Fix <time.h> include before config #ifdef, thanks emil.brink
       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can
        set it to 1 for real-time compression).
       - Merged in some compiler fixes from paulharris's github repro.
       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.
       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.
       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled
         - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch
     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).
     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and re-ran a randomized regression test on ~500k files.
       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly
        "Use of the comma-operator in a tested expression.." analysis warning, which I purposely use to work around a MSVC compiler warning).
       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.
       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.
       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.
       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)
       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).
     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.
      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.
     5/28/11 v1.11 - Added statement from unlicense.org
     5/27/11 v1.10 - Substantial compressor optimizations:
      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a
      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).
      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.
      - Refactored the compression code for better readability and maintainability.
      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large
       drop in throughput on some files).
     5/15/11 v1.09 - Initial stable release.

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/

#ifndef MINIZ_HEADER_INCLUDED
#define MINIZ_HEADER_INCLUDED

#include <stdlib.h>

// Defines to completely disable specific portions of miniz.c:
// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.

// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.
//#define MINIZ_NO_STDIO

// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or
// get/set file times, and the C run-time funcs that get/set times won't be called.
// The current downside is the times written to your archives will be from 1979.
//#define MINIZ_NO_TIME

// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
//#define MINIZ_NO_ARCHIVE_APIS

// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.
//#define MINIZ_NO_ARCHIVE_WRITING_APIS

// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.
//#define MINIZ_NO_ZLIB_APIS

// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.
//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES

// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
//#define MINIZ_NO_MALLOC

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
  // TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
  #define MINIZ_NO_TIME
#endif

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
  #include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
#define MINIZ_X86_OR_X64_CPU 1
#endif

#if (__BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
#define MINIZ_LITTLE_ENDIAN 1
#endif

#if MINIZ_X86_OR_X64_CPU
// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).
#define MINIZ_HAS_64BIT_REGISTERS 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

// ------------------- zlib-style API Definitions.

// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
typedef unsigned long mz_ulong;

// mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.
void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

// Compression strategies.
enum { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };

// Method
#define MZ_DEFLATED 8

#ifndef MINIZ_NO_ZLIB_APIS

// Heap allocation callbacks.
// Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

#define MZ_VERSION          "9.1.15"
#define MZ_VERNUM           0x91F0
#define MZ_VER_MAJOR        9
#define MZ_VER_MINOR        1
#define MZ_VER_REVISION     15
#define MZ_VER_SUBREVISION  0

// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).
enum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };

// Return status codes. MZ_PARAM_ERROR is non-standard.
enum { MZ_OK = 0, MZ_STREAM_END = 1, MZ_NEED_DICT = 2, MZ_ERRNO = -1, MZ_STREAM_ERROR = -2, MZ_DATA_ERROR = -3, MZ_MEM_ERROR = -4, MZ_BUF_ERROR = -5, MZ_VERSION_ERROR = -6, MZ_PARAM_ERROR = -10000 };

// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
enum { MZ_NO_COMPRESSION = 0, MZ_BEST_SPEED = 1, MZ_BEST_COMPRESSION = 9, MZ_UBER_COMPRESSION = 10, MZ_DEFAULT_LEVEL = 6, MZ_DEFAULT_COMPRESSION = -1 };

// Window bits
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

// Compression/decompression stream struct.
typedef struct mz_stream_s
{
  /*const*/ unsigned char *next_in;     // pointer to next byte to read
  unsigned int avail_in;            // number of bytes available at next_in
  mz_ulong total_in;                // total number of bytes consumed so far

  unsigned char *next_out;          // pointer to next byte to write
  unsigned int avail_out;           // number of bytes that can be written to next_out
  mz_ulong total_out;               // total number of bytes produced so far

  char *msg;                        // error msg (unused)
  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree

  mz_alloc_func zalloc;             // optional heap allocation function (defaults to malloc)
  mz_free_func zfree;               // optional heap free function (defaults to free)
  void *opaque;                     // heap alloc function user pointer

  int data_type;                    // data_type (unused)
  mz_ulong adler;                   // adler32 of the source or uncompressed data
  mz_ulong reserved;                // not used
} mz_stream;

typedef mz_stream *mz_streamp;

// Returns the version string of miniz.c.
const char *mz_version(void);

// mz_deflateInit() initializes a compressor with default options:
// Parameters:
//  pStream must point to an initialized mz_stream struct.
//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
//  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
//  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
//  MZ_PARAM_ERROR if the input parameters are bogus.
//  MZ_MEM_ERROR on out of memory.
int mz_deflateInit(mz_streamp pStream, int level);

// mz_deflateInit2() is like mz_deflate(), except with more control:
// Additional parameters:
//   method must be MZ_DEFLATED
//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

// Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
int mz_deflateReset(mz_streamp pStream);

// mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.
// Return values:
//   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
//   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
int mz_deflate(mz_streamp pStream, int flush);

// mz_deflateEnd() deinitializes a compressor:
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
int mz_deflateEnd(mz_streamp pStream);

// mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.
mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

// Single-call compression functions mz_compress() and mz_compress2():
// Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.
int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

// mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().
mz_ulong mz_compressBound(mz_ulong source_len);

// Initializes a decompressor.
int mz_inflateInit(mz_streamp pStream);

// mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).
int mz_inflateInit2(mz_streamp pStream, int window_bits);

// Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
//   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
//   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
// Return values:
//   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
//   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_DATA_ERROR if the deflate stream is invalid.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again
//   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
int mz_inflate(mz_streamp pStream, int flush);

// Deinitializes a decompressor.
int mz_inflateEnd(mz_streamp pStream);

// Single-call decompression.
// Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.
int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);

// Returns a string description of the specified error code, or NULL if the error code is invalid.
const char *mz_error(int err);

// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.
// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
  typedef unsigned char Byte;
  typedef unsigned int uInt;
  typedef mz_ulong uLong;
  typedef Byte Bytef;
  typedef uInt uIntf;
  typedef char charf;
  typedef int intf;
  typedef void *voidpf;
  typedef uLong uLongf;
  typedef void *voidp;
  typedef void *const voidpc;
  #define Z_NULL                0
  #define Z_NO_FLUSH            MZ_NO_FLUSH
  #define Z_PARTIAL_FLUSH       MZ_PARTIAL_FLUSH
  #define Z_SYNC_FLUSH          MZ_SYNC_FLUSH
  #define Z_FULL_FLUSH          MZ_FULL_FLUSH
  #define Z_FINISH              MZ_FINISH
  #define Z_BLOCK               MZ_BLOCK
  #define Z_OK                  MZ_OK
  #define Z_STREAM_END          MZ_STREAM_END
  #define Z_NEED_DICT           MZ_NEED_DICT
  #define Z_ERRNO               MZ_ERRNO
  #define Z_STREAM_ERROR        MZ_STREAM_ERROR
  #define Z_DATA_ERROR          MZ_DATA_ERROR
  #define Z_MEM_ERROR           MZ_MEM_ERROR
  #define Z_BUF_ERROR           MZ_BUF_ERROR
  #define Z_VERSION_ERROR       MZ_VERSION_ERROR
  #define Z_PARAM_ERROR         MZ_PARAM_ERROR
  #define Z_NO_COMPRESSION      MZ_NO_COMPRESSION
  #define Z_BEST_SPEED          MZ_BEST_SPEED
  #define Z_BEST_COMPRESSION    MZ_BEST_COMPRESSION
  #define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
  #define Z_DEFAULT_STRATEGY    MZ_DEFAULT_STRATEGY
  #define Z_FILTERED            MZ_FILTERED
  #define Z_HUFFMAN_ONLY        MZ_HUFFMAN_ONLY
  #define Z_RLE                 MZ_RLE
  #define Z_FIXED               MZ_FIXED
  #define Z_DEFLATED            MZ_DEFLATED
  #define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
  #define alloc_func            mz_alloc_func
  #define free_func             mz_free_func
  #define internal_state        mz_internal_state
  #define z_stream              mz_stream
  #define deflateInit           mz_deflateInit
  #define deflateInit2          mz_deflateInit2
  #define deflateReset          mz_deflateReset
  #define deflate               mz_deflate
  #define deflateEnd            mz_deflateEnd
  #define deflateBound          mz_deflateBound
  #define compress              mz_compress
  #define compress2             mz_compress2
  #define compressBound         mz_compressBound
  #define inflateInit           mz_inflateInit
  #define inflateInit2          mz_inflateInit2
  #define inflate               mz_inflate
  #define inflateEnd            mz_inflateEnd
  #define uncompress            mz_uncompress
  #define crc32                 mz_crc32
  #define adler32               mz_adler32
  #define MAX_WBITS             15
  #define MAX_MEM_LEVEL         9
  #define zError                mz_error
  #define ZLIB_VERSION          MZ_VERSION
  #define ZLIB_VERNUM           MZ_VERNUM
  #define ZLIB_VER_MAJOR        MZ_VER_MAJOR
  #define ZLIB_VER_MINOR        MZ_VER_MINOR
  #define ZLIB_VER_REVISION     MZ_VER_REVISION
  #define ZLIB_VER_SUBREVISION  MZ_VER_SUBREVISION
  #define zlibVersion           mz_version
  #define zlib_version          mz_version()
#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES

#endif // MINIZ_NO_ZLIB_APIS

// ------------------- Types and macros

typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef long long mz_int64;
typedef unsigned long long mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

// An attempt to work around MSVC's spammy "warning C4127: conditional expression is constant" message.
#ifdef _MSC_VER
   #define MZ_MACRO_END while (0, 0)
#else
   #define MZ_MACRO_END while (0)
#endif

// ------------------- ZIP archive reading/writing

#ifndef MINIZ_NO_ARCHIVE_APIS

enum
{
  MZ_ZIP_MAX_IO_BUF_SIZE = 64*1024,
  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
};

typedef struct
{
  mz_uint32 m_file_index;
  mz_uint32 m_central_dir_ofs;
  mz_uint16 m_version_made_by;
  mz_uint16 m_version_needed;
  mz_uint16 m_bit_flag;
  mz_uint16 m_method;
#ifndef MINIZ_NO_TIME
  time_t m_time;
#endif
  mz_uint32 m_crc32;
  mz_uint64 m_comp_size;
  mz_uint64 m_uncomp_size;
  mz_uint16 m_internal_attr;
  mz_uint32 m_external_attr;
  mz_uint64 m_local_header_ofs;
  mz_uint32 m_comment_size;
  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum
{
  MZ_ZIP_MODE_INVALID = 0,
  MZ_ZIP_MODE_READING = 1,
  MZ_ZIP_MODE_WRITING = 2,
  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef struct mz_zip_archive_tag
{
  mz_uint64 m_archive_size;
  mz_uint64 m_central_directory_file_ofs;
  mz_uint m_total_files;
  mz_zip_mode m_zip_mode;

  mz_uint m_file_offset_alignment;

  mz_alloc_func m_pAlloc;
  mz_free_func m_pFree;
  mz_realloc_func m_pRealloc;
  void *m_pAlloc_opaque;

  mz_file_read_func m_pRead;
  mz_file_write_func m_pWrite;
  void *m_pIO_opaque;

  mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef enum
{
  MZ_ZIP_FLAG_CASE_SENSITIVE                = 0x0100,
  MZ_ZIP_FLAG_IGNORE_PATH                   = 0x0200,
  MZ_ZIP_FLAG_COMPRESSED_DATA               = 0x0400,
  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
} mz_zip_flags;

// ZIP archive reading

// Inits a ZIP archive reader.
// These functions read and validate the archive's central directory.
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags);
mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
#endif

// Returns the total number of files in the archive.
mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

// Returns detailed information about an archive file entry.
mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

// Determines if an archive file entry is a directory entry.
mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);
mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

// Retrieves the filename of an archive file entry.
// Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.
mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

// Attempts to locates a file in the archive's central directory.
// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
// Returns -1 if the file cannot be found.
int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

// Extracts a archive file to a memory buffer using no memory allocation.
mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

// Extracts a archive file to a memory buffer.
mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

// Extracts a archive file to a dynamically allocated heap buffer.
void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

// Extracts a archive file using a callback function to output the file's data.
mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

#ifndef MINIZ_NO_STDIO
// Extracts a archive file to a disk file and sets its last accessed and modified times.
// This function only extracts files, not archive directory records.
mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);
#endif

// Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.
mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

// ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

// Inits a ZIP archive writer.
mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
#endif

// Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
// For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.
// For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).
// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.
// Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before
// the archive is finalized the file's central directory will be hosed.
mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);

// Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.
// To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);
mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

#ifndef MINIZ_NO_STDIO
// Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
#endif

// Adds a file to an archive by fully cloning the data from another archive.
// This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index);

// Finalizes the archive by writing the central directory records followed by the end of central directory record.
// After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().
// An archive must be manually finalized by calling this function for it to be valid.
mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize);

// Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.
// Note for the archive to be valid, it must have been finalized before ending.
mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

// Misc. high-level helper functions:

// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

// Reads a single file from an archive into a heap block.
// Returns NULL on failure.
void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint zip_flags);

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

// ------------------- Low-level Decompression API Definitions

// Decompression flags used by tinfl_decompress().
// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.
// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.
// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).
// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.
enum
{
  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
  TINFL_FLAG_HAS_MORE_INPUT = 2,
  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
  TINFL_FLAG_COMPUTE_ADLER32 = 8
};

// High level decompression functions:
// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.
// On return:
//  Function returns a pointer to the decompressed data, or NULL on failure.
//  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.
//  The caller must call mz_free() on the returned block when it's no longer needed.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.
// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.
// Returns 1 on success or 0 on failure.
typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);
int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;

// Max size of LZ dictionary.
#define TINFL_LZ_DICT_SIZE 32768

// Return status.
typedef enum
{
  TINFL_STATUS_BAD_PARAM = -3,
  TINFL_STATUS_ADLER32_MISMATCH = -2,
  TINFL_STATUS_FAILED = -1,
  TINFL_STATUS_DONE = 0,
  TINFL_STATUS_NEEDS_MORE_INPUT = 1,
  TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

// Initializes the decompressor to its initial state.
#define tinfl_init(r) do { (r)->m_state = 0; } MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.
// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.
tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

// Internal/private bits follow.
enum
{
  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,
  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

typedef struct
{
  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
} tinfl_huff_table;

#if MINIZ_HAS_64BIT_REGISTERS
  #define TINFL_USE_64BIT_BITBUF 1
#endif

#if TINFL_USE_64BIT_BITBUF
  typedef mz_uint64 tinfl_bit_buf_t;
  #define TINFL_BITBUF_SIZE (64)
#else
  typedef mz_uint32 tinfl_bit_buf_t;
  #define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
  tinfl_bit_buf_t m_bit_buf;
  size_t m_dist_from_out_buf_start;
  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

// ------------------- Low-level Compression API Definitions

// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).
#define TDEFL_LESS_MEMORY 0

// tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):
// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).
enum
{
  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF
};

// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.
// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).
// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.
// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).
// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
// The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).
enum
{
  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,
  TDEFL_COMPUTE_ADLER32               = 0x02000,
  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,
  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
  TDEFL_RLE_MATCHES                   = 0x10000,
  TDEFL_FILTER_MATCHES                = 0x20000,
  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,
  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000
};

// High level compression functions:
// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
//  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.
//  The caller must free() the returned block when it's no longer needed.
void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.
// Returns 0 on failure.
size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

// Compresses an image to a compressed PNG file in memory.
// On entry:
//  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. 
//  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.
//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pLen_out will be set to the size of the PNG image file.
//  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

// Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);

// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.
mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum { TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258 };

// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).
#if TDEFL_LESS_MEMORY
enum { TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
#else
enum { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
#endif

// The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.
typedef enum
{
  TDEFL_STATUS_BAD_PARAM = -2,
  TDEFL_STATUS_PUT_BUF_FAILED = -1,
  TDEFL_STATUS_OKAY = 0,
  TDEFL_STATUS_DONE = 1,
} tdefl_status;

// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
typedef enum
{
  TDEFL_NO_FLUSH = 0,
  TDEFL_SYNC_FLUSH = 2,
  TDEFL_FULL_FLUSH = 3,
  TDEFL_FINISH = 4
} tdefl_flush;

// tdefl's compression state structure.
typedef struct
{
  tdefl_put_buf_func_ptr m_pPut_buf_func;
  void *m_pPut_buf_user;
  mz_uint m_flags, m_max_probes[2];
  int m_greedy_parsing;
  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
  tdefl_status m_prev_return_status;
  const void *m_pIn_buf;
  void *m_pOut_buf;
  size_t *m_pIn_buf_size, *m_pOut_buf_size;
  tdefl_flush m_flush;
  const mz_uint8 *m_pSrc;
  size_t m_src_buf_left, m_out_buf_ofs;
  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

// Initializes the compressor.
// There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.
// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.
// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.
// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)
tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.
tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.
// tdefl_compress_buffer() always consumes the entire input buffer.
tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.
#ifndef MINIZ_NO_ZLIB_APIS
// Create tdefl_compress() flags given zlib-style compression parameters.
// level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)
// window_bits may be -15 (raw deflate) or 15 (zlib)
// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);
#endif // #ifndef MINIZ_NO_ZLIB_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_INCLUDED

// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)

#ifndef MINIZ_HEADER_FILE_ONLY

typedef unsigned char mz_validate_uint16[sizeof(mz_uint16)==2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32)==4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64)==8 ? 1 : -1];

#include <string.h>
#include <assert.h>

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
  #define MZ_MALLOC(x) NULL
  #define MZ_FREE(x) (void)x, ((void)0)
  #define MZ_REALLOC(p, x) NULL
#else
  #define MZ_MALLOC(x) malloc(x)
  #define MZ_FREE(x) free(x)
  #define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a,b) (((a)>(b))?(a):(b))
#define MZ_MIN(a,b) (((a)<(b))?(a):(b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  #define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
  #define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
  #define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
  #define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#ifdef _MSC_VER
  #define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
  #define MZ_FORCEINLINE inline __attribute__((__always_inline__))
#else
  #define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
  extern "C" {
#endif

// ------------------- zlib-style API's

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
{
  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16); size_t block_len = buf_len % 5552;
  if (!ptr) return MZ_ADLER32_INIT;
  while (buf_len) {
    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
    }
    for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
  }
  return (s2 << 16) + s1;
}

// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
  static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
  mz_uint32 crcu32 = (mz_uint32)crc;
  if (!ptr) return MZ_CRC32_INIT;
  crcu32 = ~crcu32; while (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)]; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)]; }
  return ~crcu32;
}

void mz_free(void *p)
{
  MZ_FREE(p);
}

#ifndef MINIZ_NO_ZLIB_APIS

static void *def_alloc_func(void *opaque, size_t items, size_t size) { (void)opaque, (void)items, (void)size; return MZ_MALLOC(items * size); }
static void def_free_func(void *opaque, void *address) { (void)opaque, (void)address; MZ_FREE(address); }
static void *def_realloc_func(void *opaque, void *address, size_t items, size_t size) { (void)opaque, (void)address, (void)items, (void)size; return MZ_REALLOC(address, items * size); }

const char *mz_version(void)
{
  return MZ_VERSION;
}

int mz_deflateInit(mz_streamp pStream, int level)
{
  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
  tdefl_compressor *pComp;
  mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

  if (!pStream) return MZ_STREAM_ERROR;
  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))) return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = MZ_ADLER32_INIT;
  pStream->msg = NULL;
  pStream->reserved = 0;
  pStream->total_in = 0;
  pStream->total_out = 0;
  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
  if (!pStream->zfree) pStream->zfree = def_free_func;

  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
  if (!pComp)
    return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pComp;

  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
  {
    mz_deflateEnd(pStream);
    return MZ_PARAM_ERROR;
  }

  return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream)
{
  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;
  pStream->total_in = pStream->total_out = 0;
  tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);
  return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush)
{
  size_t in_bytes, out_bytes;
  mz_ulong orig_total_in, orig_total_out;
  int mz_status = MZ_OK;

  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;
  if (!pStream->avail_out) return MZ_BUF_ERROR;

  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;

  if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

  orig_total_in = pStream->total_in; orig_total_out = pStream->total_out;
  for ( ; ; )
  {
    tdefl_status defl_status;
    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;

    defl_status = tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);

    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_uint)out_bytes;

    if (defl_status < 0)
    {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else if (defl_status == TDEFL_STATUS_DONE)
    {
      mz_status = MZ_STREAM_END;
      break;
    }
    else if (!pStream->avail_out)
      break;
    else if ((!pStream->avail_in) && (flush != MZ_FINISH))
    {
      if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
        break;
      return MZ_BUF_ERROR; // Can't make forward progress without some input.
    }
  }
  return mz_status;
}

int mz_deflateEnd(mz_streamp pStream)
{
  if (!pStream) return MZ_STREAM_ERROR;
  if (pStream->state)
  {
    pStream->zfree(pStream->opaque, pStream->state);
    pStream->state = NULL;
  }
  return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
{
  (void)pStream;
  // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)
  return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
{
  int status;
  mz_stream stream;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;

  stream.next_in = (unsigned char *)pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_deflateInit(&stream, level);
  if (status != MZ_OK) return status;

  status = mz_deflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END)
  {
    mz_deflateEnd(&stream);
    return (status == MZ_OK) ? MZ_BUF_ERROR : status;
  }

  *pDest_len = stream.total_out;
  return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
  return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len)
{
  return mz_deflateBound(NULL, source_len);
}

typedef struct
{
  tinfl_decompressor m_decomp;
  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed; int m_window_bits;
  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
  tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits)
{
  inflate_state *pDecomp;
  if (!pStream) return MZ_STREAM_ERROR;
  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = 0;
  pStream->msg = NULL;
  pStream->total_in = 0;
  pStream->total_out = 0;
  pStream->reserved = 0;
  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
  if (!pStream->zfree) pStream->zfree = def_free_func;

  pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
  if (!pDecomp) return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pDecomp;

  tinfl_init(&pDecomp->m_decomp);
  pDecomp->m_dict_ofs = 0;
  pDecomp->m_dict_avail = 0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = 1;
  pDecomp->m_has_flushed = 0;
  pDecomp->m_window_bits = window_bits;

  return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream)
{
   return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflate(mz_streamp pStream, int flush)
{
  inflate_state* pState;
  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
  size_t in_bytes, out_bytes, orig_avail_in;
  tinfl_status status;

  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;

  pState = (inflate_state*)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = pStream->avail_in;

  first_call = pState->m_first_call; pState->m_first_call = 0;
  if (pState->m_last_status < 0) return MZ_DATA_ERROR;

  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
  pState->m_has_flushed |= (flush == MZ_FINISH);

  if ((flush == MZ_FINISH) && (first_call))
  {
    // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.
    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;
    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes; pStream->total_in += (mz_uint)in_bytes;
    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes; pStream->total_out += (mz_uint)out_bytes;

    if (status < 0)
      return MZ_DATA_ERROR;
    else if (status != TINFL_STATUS_DONE)
    {
      pState->m_last_status = TINFL_STATUS_FAILED;
      return MZ_BUF_ERROR;
    }
    return MZ_STREAM_END;
  }
  // flush != MZ_FINISH then we must assume there's more input.
  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

  if (pState->m_dict_avail)
  {
    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
    return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
  }

  for ( ; ; )
  {
    in_bytes = pStream->avail_in;
    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
    pState->m_last_status = status;

    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tinfl_get_adler32(&pState->m_decomp);

    pState->m_dict_avail = (mz_uint)out_bytes;

    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

    if (status < 0)
       return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
      return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.
    else if (flush == MZ_FINISH)
    {
       // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
       if (status == TINFL_STATUS_DONE)
          return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
       // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.
       else if (!pStream->avail_out)
          return MZ_BUF_ERROR;
    }
    else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
      break;
  }

  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream)
{
  if (!pStream)
    return MZ_STREAM_ERROR;
  if (pStream->state)
  {
    pStream->zfree(pStream->opaque, pStream->state);
    pStream->state = NULL;
  }
  return MZ_OK;
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
  mz_stream stream;
  int status;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;

  stream.next_in = (unsigned char *)pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_inflateInit(&stream);
  if (status != MZ_OK)
    return status;

  status = mz_inflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END)
  {
    mz_inflateEnd(&stream);
    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
  }
  *pDest_len = stream.total_out;

  return mz_inflateEnd(&stream);
}

const char *mz_error(int err)
{
  static struct { int m_err; const char *m_pDesc; } s_error_descs[] =
  {
    { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" },
    { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
  };
  mz_uint i; for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;
  return NULL;
}

#endif //MINIZ_NO_ZLIB_APIS

// ------------------- Low-level Decompression (completely independent from all compression API's)

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN switch(r->m_state) { case 0:
#define TINFL_CR_RETURN(state_index, result) do { status = result; r->m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END
#define TINFL_CR_FINISH }

// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never
// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.
#define TINFL_GET_BYTE(state_index, c) do { \
  if (pIn_buf_cur >= pIn_buf_end) { \
    for ( ; ; ) { \
      if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) { \
        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \
        if (pIn_buf_cur < pIn_buf_end) { \
          c = *pIn_buf_cur++; \
          break; \
        } \
      } else { \
        c = 0; \
        break; \
      } \
    } \
  } else c = *pIn_buf_cur++; } MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf & ((1 << (n)) - 1); bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END

// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.
// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a
// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the
// bit buffer contains >=15 bits (deflate's max. Huffman code size).
#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \
  do { \
    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \
    if (temp >= 0) { \
      code_len = temp >> 9; \
      if ((code_len) && (num_bits >= code_len)) \
      break; \
    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) { \
       code_len = TINFL_FAST_LOOKUP_BITS; \
       do { \
          temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \
       } while ((temp < 0) && (num_bits >= (code_len + 1))); if (temp >= 0) break; \
    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; \
  } while (num_bits < 15);

// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read
// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully
// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.
// The slow path is only executed at the very end of the input buffer.
#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \
  int temp; mz_uint code_len, c; \
  if (num_bits < 15) { \
    if ((pIn_buf_end - pIn_buf_cur) < 2) { \
       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \
    } else { \
       bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \
    } \
  } \
  if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0) \
    code_len = temp >> 9, temp &= 511; \
  else { \
    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; } while (temp < 0); \
  } sym = temp; bit_buf >>= code_len; num_bits -= code_len; } MZ_MACRO_END

tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
{
  static const int s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };
  static const int s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
  static const int s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
  static const int s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
  static const mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
  static const int s_min_table_sizes[3] = { 257, 1, 4 };

  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; tinfl_bit_buf_t bit_buf;
  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

  // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).
  if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; return TINFL_STATUS_BAD_PARAM; }

  num_bits = r->m_num_bits; bit_buf = r->m_bit_buf; dist = r->m_dist; counter = r->m_counter; num_extra = r->m_num_extra; dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  TINFL_CR_BEGIN

  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0; r->m_z_adler32 = r->m_check_adler32 = 1;
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
  {
    TINFL_GET_BYTE(1, r->m_zhdr0); TINFL_GET_BYTE(2, r->m_zhdr1);
    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
    if (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }
  }

  do
  {
    TINFL_GET_BITS(3, r->m_final, 3); r->m_type = r->m_final >> 1;
    if (r->m_type == 0)
    {
      TINFL_SKIP_BITS(5, num_bits & 7);
      for (counter = 0; counter < 4; ++counter) { if (num_bits) TINFL_GET_BITS(6, r->m_raw_header[counter], 8); else TINFL_GET_BYTE(7, r->m_raw_header[counter]); }
      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }
      while ((counter) && (num_bits))
      {
        TINFL_GET_BITS(51, dist, 8);
        while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }
        *pOut_buf_cur++ = (mz_uint8)dist;
        counter--;
      }
      while (counter)
      {
        size_t n; while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }
        while (pIn_buf_cur >= pIn_buf_end)
        {
          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)
          {
            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
          }
          else
          {
            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
          }
        }
        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;
      }
    }
    else if (r->m_type == 3)
    {
      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
    }
    else
    {
      if (r->m_type == 1)
      {
        mz_uint8 *p = r->m_tables[0].m_code_size; mz_uint i;
        r->m_table_sizes[0] = 288; r->m_table_sizes[1] = 32; TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
        for ( i = 0; i <= 143; ++i) *p++ = 8; for ( ; i <= 255; ++i) *p++ = 9; for ( ; i <= 279; ++i) *p++ = 7; for ( ; i <= 287; ++i) *p++ = 8;
      }
      else
      {
        for (counter = 0; counter < 3; counter++) { TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]); r->m_table_sizes[counter] += s_min_table_sizes[counter]; }
        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size); for (counter = 0; counter < r->m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }
        r->m_table_sizes[2] = 19;
      }
      for ( ; (int)r->m_type >= 0; r->m_type--)
      {
        int tree_next, tree_cur; tinfl_huff_table *pTable;
        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &r->m_tables[r->m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable->m_look_up); MZ_CLEAR_OBJ(pTable->m_tree);
        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i) total_syms[pTable->m_code_size[i]]++;
        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;
        for (i = 1; i <= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) << 1)); }
        if ((65536 != total) && (used_syms > 1))
        {
          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
        }
        for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
        {
          mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index]; if (!code_size) continue;
          cur_code = next_code[code_size]++; for (l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1);
          if (code_size <= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size << 9) | sym_index); while (rev_code < TINFL_FAST_LOOKUP_SIZE) { pTable->m_look_up[rev_code] = k; rev_code += (1 << code_size); } continue; }
          if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }
          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
          {
            tree_cur -= ((rev_code >>= 1) & 1);
            if (!pTable->m_tree[-tree_cur - 1]) { pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } else tree_cur = pTable->m_tree[-tree_cur - 1];
          }
          tree_cur -= ((rev_code >>= 1) & 1); pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
        }
        if (r->m_type == 2)
        {
          for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]); )
          {
            mz_uint s; TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]); if (dist < 16) { r->m_len_codes[counter++] = (mz_uint8)dist; continue; }
            if ((dist == 16) && (!counter))
            {
              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
            }
            num_extra = "\02\03\07"[dist - 16]; TINFL_GET_BITS(18, s, num_extra); s += "\03\03\013"[dist - 16];
            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s); counter += s;
          }
          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
          {
            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
          }
          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]); TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
        }
      }
      for ( ; ; )
      {
        mz_uint8 *pSrc;
        for ( ; ; )
        {
          if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
          {
            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
            if (counter >= 256)
              break;
            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }
            *pOut_buf_cur++ = (mz_uint8)counter;
          }
          else
          {
            int sym2; mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
            if (num_bits < 30) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits); pIn_buf_cur += 4; num_bits += 32; }
#else
            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
#endif
            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
              code_len = sym2 >> 9;
            else
            {
              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
            }
            counter = sym2; bit_buf >>= code_len; num_bits -= code_len;
            if (counter & 256)
              break;

#if !TINFL_USE_64BIT_BITBUF
            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
#endif
            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
              code_len = sym2 >> 9;
            else
            {
              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
            }
            bit_buf >>= code_len; num_bits -= code_len;

            pOut_buf_cur[0] = (mz_uint8)counter;
            if (sym2 & 256)
            {
              pOut_buf_cur++;
              counter = sym2;
              break;
            }
            pOut_buf_cur[1] = (mz_uint8)sym2;
            pOut_buf_cur += 2;
          }
        }
        if ((counter &= 511) == 256) break;

        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];
        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }

        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];
        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }

        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
        if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
        {
          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
        }

        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
        {
          while (counter--)
          {
            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }
            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
          }
          continue;
        }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
        else if ((counter >= 9) && (counter <= dist))
        {
          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
          do
          {
            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
            pOut_buf_cur += 8;
          } while ((pSrc += 8) < pSrc_end);
          if ((counter &= 7) < 3)
          {
            if (counter)
            {
              pOut_buf_cur[0] = pSrc[0];
              if (counter > 1)
                pOut_buf_cur[1] = pSrc[1];
              pOut_buf_cur += counter;
            }
            continue;
          }
        }
#endif
        do
        {
          pOut_buf_cur[0] = pSrc[0];
          pOut_buf_cur[1] = pSrc[1];
          pOut_buf_cur[2] = pSrc[2];
          pOut_buf_cur += 3; pSrc += 3;
        } while ((int)(counter -= 3) > 2);
        if ((int)counter > 0)
        {
          pOut_buf_cur[0] = pSrc[0];
          if ((int)counter > 1)
            pOut_buf_cur[1] = pSrc[1];
          pOut_buf_cur += counter;
        }
      }
    }
  } while (!(r->m_final & 1));
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
  {
    TINFL_SKIP_BITS(32, num_bits & 7); for (counter = 0; counter < 4; ++counter) { mz_uint s; if (num_bits) TINFL_GET_BITS(41, s, 8); else TINFL_GET_BYTE(42, s); r->m_z_adler32 = (r->m_z_adler32 << 8) | s; }
  }
  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
  TINFL_CR_FINISH

common_exit:
  r->m_num_bits = num_bits; r->m_bit_buf = bit_buf; r->m_dist = dist; r->m_counter = counter; r->m_num_extra = num_extra; r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
  if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
  {
    const mz_uint8 *ptr = pOut_buf_next; size_t buf_len = *pOut_buf_size;
    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16; size_t block_len = buf_len % 5552;
    while (buf_len)
    {
      for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
      {
        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
      }
      for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
    }
    r->m_check_adler32 = (s2 << 16) + s1; if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;
  }
  return status;
}

// Higher level helper functions.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0;
  *pOut_len = 0;
  tinfl_init(&decomp);
  for ( ; ; )
  {
    size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,
      (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
    {
      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
    }
    src_buf_ofs += src_buf_size;
    *pOut_len += dst_buf_size;
    if (status == TINFL_STATUS_DONE) break;
    new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;
    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
    if (!pNew_buf)
    {
      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
    }
    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;
  }
  return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&decomp);
  status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  int result = 0;
  tinfl_decompressor decomp;
  mz_uint8 *pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE); size_t in_buf_ofs = 0, dict_ofs = 0;
  if (!pDict)
    return TINFL_STATUS_FAILED;
  tinfl_init(&decomp);
  for ( ; ; )
  {
    size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
      (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
    in_buf_ofs += in_buf_size;
    if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
      break;
    if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
    {
      result = (status == TINFL_STATUS_DONE);
      break;
    }
    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
  }
  MZ_FREE(pDict);
  *pIn_buf_size = in_buf_ofs;
  return result;
}

// ------------------- Low-level Compression (independent from all decompression API's)

// Purposely making these tables static for faster init and thread safety.
static const mz_uint16 s_tdefl_len_sym[256] = {
  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,
  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,
  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,
  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,
  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,
  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,
  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,
  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };

static const mz_uint8 s_tdefl_len_extra[256] = {
  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };

static const mz_uint8 s_tdefl_small_dist_sym[512] = {
  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };

static const mz_uint8 s_tdefl_small_dist_extra[512] = {
  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7 };

static const mz_uint8 s_tdefl_large_dist_sym[128] = {
  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,
  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };

static const mz_uint8 s_tdefl_large_dist_extra[128] = {
  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };

// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.
typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;
static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)
{
  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);
  for (i = 0; i < num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }
  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
  {
    const mz_uint32* pHist = &hist[pass << 8];
    mz_uint offsets[256], cur_ofs = 0;
    for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
    for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }
  }
  return pCur_syms;
}

// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
  int root, leaf, next, avbl, used, dpth;
  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }
  A[0].m_key += A[1].m_key; root = 0; leaf = 2;
  for (next=1; next < n-1; next++)
  {
    if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (mz_uint16)next; } else A[next].m_key = A[leaf++].m_key;
    if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } else A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
  }
  A[n-2].m_key = 0; for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;
  avbl = 1; used = dpth = 0; root = n-2; next = n-1;
  while (avbl>0)
  {
    while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }
    while (avbl>used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }
    avbl = 2*used; dpth++; used = 0;
  }
}

// Limits canonical Huffman code table's max code size.
enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
  int i; mz_uint32 total = 0; if (code_list_len <= 1) return;
  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];
  for (i = max_code_size; i > 0; i--) total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
  while (total != (1UL << max_code_size))
  {
    pNum_codes[max_code_size]--;
    for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
    total--;
  }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
{
  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);
  if (static_table)
  {
    for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;
  }
  else
  {
    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
    int num_used_syms = 0;
    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
    for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }

    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;

    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
      for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
  }

  next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);

  for (i = 0; i < table_len; i++)
  {
    mz_uint rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
    code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);
    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
  }
}

#define TDEFL_PUT_BITS(b, l) do { \
  mz_uint bits = b; mz_uint len = l; MZ_ASSERT(bits <= ((1U << len) - 1U)); \
  d->m_bit_buffer |= (bits << d->m_bits_in); d->m_bits_in += len; \
  while (d->m_bits_in >= 8) { \
    if (d->m_pOutput_buf < d->m_pOutput_buf_end) \
      *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
      d->m_bit_buffer >>= 8; \
      d->m_bits_in -= 8; \
  } \
} MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \
  if (rle_repeat_count < 3) { \
    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \
  } else { \
    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \
} rle_repeat_count = 0; } }

#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \
  if (rle_z_count < 3) { \
    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \
  } else if (rle_z_count <= 10) { \
    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \
  } else { \
    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
} rle_z_count = 0; } }

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
  int num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

  d->m_huff_count[0][256] = 1;

  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;

  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;

  memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
  for (i = 0; i < total_code_sizes_to_pack; i++)
  {
    mz_uint8 code_size = code_sizes_to_pack[i];
    if (!code_size)
    {
      TDEFL_RLE_PREV_CODE_SIZE();
      if (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }
    }
    else
    {
      TDEFL_RLE_ZERO_CODE_SIZE();
      if (code_size != prev_code_size)
      {
        TDEFL_RLE_PREV_CODE_SIZE();
        d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;
      }
      else if (++rle_repeat_count == 6)
      {
        TDEFL_RLE_PREV_CODE_SIZE();
      }
    }
    prev_code_size = code_size;
  }
  if (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } else { TDEFL_RLE_ZERO_CODE_SIZE(); }

  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

  TDEFL_PUT_BITS(2, 2);

  TDEFL_PUT_BITS(num_lit_codes - 257, 5);
  TDEFL_PUT_BITS(num_dist_codes - 1, 5);

  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
  for (i = 0; (int)i < num_bit_lengths; i++) TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

  for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )
  {
    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
    if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
  }
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
  mz_uint i;
  mz_uint8 *p = &d->m_huff_code_sizes[0][0];

  for (i = 0; i <= 143; ++i) *p++ = 8;
  for ( ; i <= 255; ++i) *p++ = 9;
  for ( ; i <= 279; ++i) *p++ = 7;
  for ( ; i <= 287; ++i) *p++ = 8;

  memset(d->m_huff_code_sizes[1], 5, 32);

  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

  TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) << bits_in); bits_in += (l); }

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
  {
    if (flags == 1)
      flags = *pLZ_codes++ | 0x100;

    if (flags & 1)
    {
      mz_uint s0, s1, n0, n1, sym, num_extra_bits;
      mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;

      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

      // This sequence coaxes MSVC into using cmov's vs. jmp's.
      s0 = s_tdefl_small_dist_sym[match_dist & 511];
      n0 = s_tdefl_small_dist_extra[match_dist & 511];
      s1 = s_tdefl_large_dist_sym[match_dist >> 8];
      n1 = s_tdefl_large_dist_extra[match_dist >> 8];
      sym = (match_dist < 512) ? s0 : s1;
      num_extra_bits = (match_dist < 512) ? n0 : n1;

      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
    }
    else
    {
      mz_uint lit = *pLZ_codes++;
      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
      {
        flags >>= 1;
        lit = *pLZ_codes++;
        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
        {
          flags >>= 1;
          lit = *pLZ_codes++;
          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
      }
    }

    if (pOutput_buf >= d->m_pOutput_buf_end)
      return MZ_FALSE;

    *(mz_uint64*)pOutput_buf = bit_buffer;
    pOutput_buf += (bits_in >> 3);
    bit_buffer >>= (bits_in & ~7);
    bits_in &= 7;
  }

#undef TDEFL_PUT_BITS_FAST

  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = 0;
  d->m_bit_buffer = 0;

  while (bits_in)
  {
    mz_uint32 n = MZ_MIN(bits_in, 16);
    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
    bit_buffer >>= n;
    bits_in -= n;
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_uint flags;
  mz_uint8 *pLZ_codes;

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
  {
    if (flags == 1)
      flags = *pLZ_codes++ | 0x100;
    if (flags & 1)
    {
      mz_uint sym, num_extra_bits;
      mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8)); pLZ_codes += 3;

      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

      if (match_dist < 512)
      {
        sym = s_tdefl_small_dist_sym[match_dist]; num_extra_bits = s_tdefl_small_dist_extra[match_dist];
      }
      else
      {
        sym = s_tdefl_large_dist_sym[match_dist >> 8]; num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
      }
      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
    }
    else
    {
      mz_uint lit = *pLZ_codes++;
      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
    }
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
  if (static_block)
    tdefl_start_static_block(d);
  else
    tdefl_start_dynamic_block(d);
  return tdefl_compress_lz_codes(d);
}

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
  mz_uint saved_bit_buf, saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  mz_bool comp_block_succeeded = MZ_FALSE;
  int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
  mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

  MZ_ASSERT(!d->m_output_flush_remaining);
  d->m_output_flush_ofs = 0;
  d->m_output_flush_remaining = 0;

  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
  {
    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);
  }

  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

  pSaved_output_buf = d->m_pOutput_buf; saved_bit_buf = d->m_bit_buffer; saved_bits_in = d->m_bits_in;

  if (!use_raw_block)
    comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

  // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.
  if ( ((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
       ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size) )
  {
    mz_uint i; d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    TDEFL_PUT_BITS(0, 2);
    if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
    {
      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
    }
    for (i = 0; i < d->m_total_lz_bytes; ++i)
    {
      TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
    }
  }
  // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.
  else if (!comp_block_succeeded)
  {
    d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    tdefl_compress_block(d, MZ_TRUE);
  }

  if (flush)
  {
    if (flush == TDEFL_FINISH)
    {
      if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d->m_adler32; for (i = 0; i < 4; i++) { TDEFL_PUT_BITS((a >> 24) & 0xFF, 8); a <<= 8; } }
    }
    else
    {
      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); } for (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z & 0xFFFF, 16); }
    }
  }

  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8; d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes; d->m_total_lz_bytes = 0; d->m_block_index++;

  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
  {
    if (d->m_pPut_buf_func)
    {
      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
    }
    else if (pOutput_buf_start == d->m_output_buf)
    {
      int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
      d->m_out_buf_ofs += bytes_to_copy;
      if ((n -= bytes_to_copy) != 0)
      {
        d->m_output_flush_ofs = bytes_to_copy;
        d->m_output_flush_remaining = n;
      }
    }
    else
    {
      d->m_out_buf_ofs += n;
    }
  }

  return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;
  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
  for ( ; ; )
  {
    for ( ; ; )
    {
      if (--num_probes_left == 0) return;
      #define TDEFL_PROBE \
        next_probe_pos = d->m_next[probe_pos]; \
        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
        if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;
      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
    }
    if (!dist) break; q = (const mz_uint16*)(d->m_dict + probe_pos); if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue; p = s; probe_len = 32;
    do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
                   (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
    if (!probe_len)
    {
      *pMatch_dist = dist; *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN); break;
    }
    else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len)
    {
      *pMatch_dist = dist; if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;
      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
    }
  }
}
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint8 *s = d->m_dict + pos, *p, *q;
  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
  for ( ; ; )
  {
    for ( ; ; )
    {
      if (--num_probes_left == 0) return;
      #define TDEFL_PROBE \
        next_probe_pos = d->m_next[probe_pos]; \
        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
        if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;
      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
    }
    if (!dist) break; p = s; q = d->m_dict + probe_pos; for (probe_len = 0; probe_len < max_match_len; probe_len++) if (*p++ != *q++) break;
    if (probe_len > match_len)
    {
      *pMatch_dist = dist; if ((*pMatch_len = match_len = probe_len) == max_match_len) return;
      c0 = d->m_dict[pos + match_len]; c1 = d->m_dict[pos + match_len - 1];
    }
  }
}
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
  // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.
  mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
  {
    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
    mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
    d->m_src_buf_left -= num_bytes_to_process;
    lookahead_size += num_bytes_to_process;

    while (num_bytes_to_process)
    {
      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
      d->m_pSrc += n;
      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
      num_bytes_to_process -= n;
    }

    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;

    while (lookahead_size >= 4)
    {
      mz_uint cur_match_dist, cur_match_len = 1;
      mz_uint8 *pCur_dict = d->m_dict + cur_pos;
      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
      mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
      mz_uint probe_pos = d->m_hash[hash];
      d->m_hash[hash] = (mz_uint16)lookahead_pos;

      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
      {
        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
        mz_uint32 probe_len = 32;
        do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
        if (!probe_len)
          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)))
        {
          cur_match_len = 1;
          *pLZ_code_buf++ = (mz_uint8)first_trigram;
          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
          d->m_huff_count[0][(mz_uint8)first_trigram]++;
        }
        else
        {
          mz_uint32 s0, s1;
          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

          cur_match_dist--;

          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
          pLZ_code_buf += 3;
          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
        }
      }
      else
      {
        *pLZ_code_buf++ = (mz_uint8)first_trigram;
        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
        d->m_huff_count[0][(mz_uint8)first_trigram]++;
      }

      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }

      total_lz_bytes += cur_match_len;
      lookahead_pos += cur_match_len;
      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
      MZ_ASSERT(lookahead_size >= cur_match_len);
      lookahead_size -= cur_match_len;

      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
      {
        int n;
        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
        if ((n = tdefl_flush_block(d, 0)) != 0)
          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
      }
    }

    while (lookahead_size)
    {
      mz_uint8 lit = d->m_dict[cur_pos];

      total_lz_bytes++;
      *pLZ_code_buf++ = lit;
      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }

      d->m_huff_count[0][lit]++;

      lookahead_pos++;
      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
      lookahead_size--;

      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
      {
        int n;
        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
        if ((n = tdefl_flush_block(d, 0)) != 0)
          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
      }
    }
  }

  d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
  return MZ_TRUE;
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
{
  d->m_total_lz_bytes++;
  *d->m_pLZ_code_buf++ = lit;
  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }
  d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
  mz_uint32 s0, s1;

  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

  d->m_total_lz_bytes += match_len;

  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

  match_dist -= 1;
  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8); d->m_pLZ_code_buf += 3;

  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }

  s0 = s_tdefl_small_dist_sym[match_dist & 511]; s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;

  if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
  const mz_uint8 *pSrc = d->m_pSrc; size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;

  while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
  {
    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
    // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.
    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
    {
      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;
      src_buf_left -= num_bytes_to_process;
      d->m_lookahead_size += num_bytes_to_process;
      while (pSrc != pSrc_end)
      {
        mz_uint8 c = *pSrc++; d->m_dict[dst_pos] = c; if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK; ins_pos++;
      }
    }
    else
    {
      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
      {
        mz_uint8 c = *pSrc++;
        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        src_buf_left--;
        d->m_dict[dst_pos] = c;
        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
        {
          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
        }
      }
    }
    d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
      break;

    // Simple lazy/greedy parsing state machine.
    len_to_move = 1; cur_match_dist = 0; cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1); cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
    {
      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
      {
        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
        cur_match_len = 0; while (cur_match_len < d->m_lookahead_size) { if (d->m_dict[cur_pos + cur_match_len] != c) break; cur_match_len++; }
        if (cur_match_len < TDEFL_MIN_MATCH_LEN) cur_match_len = 0; else cur_match_dist = 1;
      }
    }
    else
    {
      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
    }
    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
    {
      cur_match_dist = cur_match_len = 0;
    }
    if (d->m_saved_match_len)
    {
      if (cur_match_len > d->m_saved_match_len)
      {
        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
        if (cur_match_len >= 128)
        {
          tdefl_record_match(d, cur_match_len, cur_match_dist);
          d->m_saved_match_len = 0; len_to_move = cur_match_len;
        }
        else
        {
          d->m_saved_lit = d->m_dict[cur_pos]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
        }
      }
      else
      {
        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
        len_to_move = d->m_saved_match_len - 1; d->m_saved_match_len = 0;
      }
    }
    else if (!cur_match_dist)
      tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
    {
      tdefl_record_match(d, cur_match_len, cur_match_dist);
      len_to_move = cur_match_len;
    }
    else
    {
      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
    }
    // Move the lookahead forward by len_to_move bytes.
    d->m_lookahead_pos += len_to_move;
    MZ_ASSERT(d->m_lookahead_size >= len_to_move);
    d->m_lookahead_size -= len_to_move;
    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
    // Check if it's time to flush the current LZ codes to the internal output buffer.
    if ( (d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
         ( (d->m_total_lz_bytes > 31*1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) )
    {
      int n;
      d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
      if ((n = tdefl_flush_block(d, 0)) != 0)
        return (n < 0) ? MZ_FALSE : MZ_TRUE;
    }
  }

  d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
  return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
  if (d->m_pIn_buf_size)
  {
    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
  }

  if (d->m_pOut_buf_size)
  {
    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
    d->m_output_flush_ofs += (mz_uint)n;
    d->m_output_flush_remaining -= (mz_uint)n;
    d->m_out_buf_ofs += n;

    *d->m_pOut_buf_size = d->m_out_buf_ofs;
  }

  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
  if (!d)
  {
    if (pIn_buf_size) *pIn_buf_size = 0;
    if (pOut_buf_size) *pOut_buf_size = 0;
    return TDEFL_STATUS_BAD_PARAM;
  }

  d->m_pIn_buf = pIn_buf; d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf; d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (const mz_uint8 *)(pIn_buf); d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
  d->m_out_buf_ofs = 0;
  d->m_flush = flush;

  if ( ((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf) )
  {
    if (pIn_buf_size) *pIn_buf_size = 0;
    if (pOut_buf_size) *pOut_buf_size = 0;
    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
  }
  d->m_wants_to_finish |= (flush == TDEFL_FINISH);

  if ((d->m_output_flush_remaining) || (d->m_finished))
    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
  {
    if (!tdefl_compress_fast(d))
      return d->m_prev_return_status;
  }
  else
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  {
    if (!tdefl_compress_normal(d))
      return d->m_prev_return_status;
  }

  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
    d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
  {
    if (tdefl_flush_block(d, flush) < 0)
      return d->m_prev_return_status;
    d->m_finished = (flush == TDEFL_FINISH);
    if (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d->m_hash); MZ_CLEAR_OBJ(d->m_next); d->m_dict_size = 0; }
  }

  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
{
  MZ_ASSERT(d->m_pPut_buf_func); return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  d->m_pPut_buf_func = pPut_buf_func; d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)(flags); d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3; d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);
  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8;
  d->m_pOutput_buf = d->m_output_buf; d->m_pOutput_buf_end = d->m_output_buf; d->m_prev_return_status = TDEFL_STATUS_OKAY;
  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0; d->m_adler32 = 1;
  d->m_pIn_buf = NULL; d->m_pOut_buf = NULL;
  d->m_pIn_buf_size = NULL; d->m_pOut_buf_size = NULL;
  d->m_flush = TDEFL_NO_FLUSH; d->m_pSrc = NULL; d->m_src_buf_left = 0; d->m_out_buf_ofs = 0;
  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
  return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
{
  return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
{
  return d->m_adler32;
}

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  tdefl_compressor *pComp; mz_bool succeeded; if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
  pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor)); if (!pComp) return MZ_FALSE;
  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
  succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
  MZ_FREE(pComp); return succeeded;
}

typedef struct
{
  size_t m_size, m_capacity;
  mz_uint8 *m_pBuf;
  mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
{
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + len;
  if (new_size > p->m_capacity)
  {
    size_t new_capacity = p->m_capacity; mz_uint8 *pNew_buf; if (!p->m_expandable) return MZ_FALSE;
    do { new_capacity = MZ_MAX(128U, new_capacity << 1U); } while (new_size > new_capacity);
    pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity); if (!pNew_buf) return MZ_FALSE;
    p->m_pBuf = pNew_buf; p->m_capacity = new_capacity;
  }
  memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len); p->m_size = new_size;
  return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
  if (!pOut_len) return MZ_FALSE; else *pOut_len = 0;
  out_buf.m_expandable = MZ_TRUE;
  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;
  *pOut_len = out_buf.m_size; return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
  if (!pOut_buf) return 0;
  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;
  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;
  return out_buf.m_size;
}

#ifndef MINIZ_NO_ZLIB_APIS
static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };

// level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
{
  mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

  if (!level) comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
  else if (strategy == MZ_FILTERED) comp_flags |= TDEFL_FILTER_MATCHES;
  else if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= ~TDEFL_MAX_PROBES_MASK;
  else if (strategy == MZ_FIXED) comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
  else if (strategy == MZ_RLE) comp_flags |= TDEFL_RLE_MATCHES;

  return comp_flags;
}
#endif //MINIZ_NO_ZLIB_APIS

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable:4204) // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)
#endif

// Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
// This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
  static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };
  tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor)); tdefl_output_buffer out_buf; int i, bpl = w * num_chans, y, z; mz_uint32 c; *pLen_out = 0;
  if (!pComp) return NULL;
  MZ_CLEAR_OBJ(out_buf); out_buf.m_expandable = MZ_TRUE; out_buf.m_capacity = 57+MZ_MAX(64, (1+bpl)*h); if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) { MZ_FREE(pComp); return NULL; }
  // write dummy header
  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);
  // compress image data
  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
  for (y = 0; y < h; ++y) { tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH); tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH); }
  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) { MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  // write real header
  *pLen_out = out_buf.m_size-41;
  {
    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
    mz_uint8 pnghdr[41]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
      0,0,(mz_uint8)(w>>8),(mz_uint8)w,0,0,(mz_uint8)(h>>8),(mz_uint8)h,8,chans[num_chans],0,0,0,0,0,0,0,
      (mz_uint8)(*pLen_out>>24),(mz_uint8)(*pLen_out>>16),(mz_uint8)(*pLen_out>>8),(mz_uint8)*pLen_out,0x49,0x44,0x41,0x54};
    c=(mz_uint32)mz_crc32(MZ_CRC32_INIT,pnghdr+12,17); for (i=0; i<4; ++i, c<<=8) ((mz_uint8*)(pnghdr+29))[i]=(mz_uint8)(c>>24);
    memcpy(out_buf.m_pBuf, pnghdr, 41);
  }
  // write footer (IDAT CRC-32, followed by IEND chunk)
  if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) { *pLen_out = 0; MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT,out_buf.m_pBuf+41-4, *pLen_out+4); for (i=0; i<4; ++i, c<<=8) (out_buf.m_pBuf+out_buf.m_size-16)[i] = (mz_uint8)(c >> 24);
  // compute final size of file, grab compressed data buffer and return
  *pLen_out += 57; MZ_FREE(pComp); return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

#ifdef _MSC_VER
#pragma warning (pop)
#endif

// ------------------- .ZIP archive reading

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef MINIZ_NO_STDIO
  #define MZ_FILE void *
#else
  #include <stdio.h>
  #include <sys/stat.h>

  #if defined(_MSC_VER) || defined(__MINGW64__)
    static FILE *mz_fopen(const char *pFilename, const char *pMode)
    {
      FILE* pFile = NULL;
      fopen_s(&pFile, pFilename, pMode);
      return pFile;
    }
    static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
    {
      FILE* pFile = NULL;
      if (freopen_s(&pFile, pPath, pMode, pStream))
        return NULL;
      return pFile;
    }
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN mz_fopen
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 _ftelli64
    #define MZ_FSEEK64 _fseeki64
    #define MZ_FILE_STAT_STRUCT _stat
    #define MZ_FILE_STAT _stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN mz_freopen
    #define MZ_DELETE_FILE remove
  #elif defined(__MINGW32__)
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello64
    #define MZ_FSEEK64 fseeko64
    #define MZ_FILE_STAT_STRUCT _stat
    #define MZ_FILE_STAT _stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #elif defined(__TINYC__)
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftell
    #define MZ_FSEEK64 fseek
    #define MZ_FILE_STAT_STRUCT stat
    #define MZ_FILE_STAT stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #elif defined(__GNUC__) && _LARGEFILE64_SOURCE
    #ifndef MINIZ_NO_TIME
      #include <utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen64(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello64
    #define MZ_FSEEK64 fseeko64
    #define MZ_FILE_STAT_STRUCT stat64
    #define MZ_FILE_STAT stat64
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
    #define MZ_DELETE_FILE remove
  #else
    #ifndef MINIZ_NO_TIME
      #include <utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello
    #define MZ_FSEEK64 fseeko
    #define MZ_FILE_STAT_STRUCT stat
    #define MZ_FILE_STAT stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #endif // #ifdef _MSC_VER
#endif // #ifdef MINIZ_NO_STDIO

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

// Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.
enum
{
  // ZIP archive identifiers and record sizes
  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50, MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50, MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
  // Central directory header record offsets
  MZ_ZIP_CDH_SIG_OFS = 0, MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4, MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6, MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
  MZ_ZIP_CDH_METHOD_OFS = 10, MZ_ZIP_CDH_FILE_TIME_OFS = 12, MZ_ZIP_CDH_FILE_DATE_OFS = 14, MZ_ZIP_CDH_CRC32_OFS = 16,
  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20, MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24, MZ_ZIP_CDH_FILENAME_LEN_OFS = 28, MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32, MZ_ZIP_CDH_DISK_START_OFS = 34, MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36, MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38, MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
  // Local directory header offsets
  MZ_ZIP_LDH_SIG_OFS = 0, MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4, MZ_ZIP_LDH_BIT_FLAG_OFS = 6, MZ_ZIP_LDH_METHOD_OFS = 8, MZ_ZIP_LDH_FILE_TIME_OFS = 10,
  MZ_ZIP_LDH_FILE_DATE_OFS = 12, MZ_ZIP_LDH_CRC32_OFS = 14, MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18, MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26, MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
  // End of central directory offsets
  MZ_ZIP_ECDH_SIG_OFS = 0, MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4, MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6, MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10, MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12, MZ_ZIP_ECDH_CDIR_OFS_OFS = 16, MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
};

typedef struct
{
  void *m_p;
  size_t m_size, m_capacity;
  mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag
{
  mz_zip_array m_central_dir;
  mz_zip_array m_central_dir_offsets;
  mz_zip_array m_sorted_central_dir_offsets;
  MZ_FILE *m_pFile;
  void *m_pMem;
  size_t m_mem_size;
  size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
{
  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
  memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
{
  void *pNew_p; size_t new_capacity = min_new_capacity; MZ_ASSERT(pArray->m_element_size); if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;
  if (growing) { new_capacity = MZ_MAX(1, pArray->m_capacity); while (new_capacity < min_new_capacity) new_capacity *= 2; }
  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;
  pArray->m_p = pNew_p; pArray->m_capacity = new_capacity;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
{
  if (new_capacity > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE; }
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
  if (new_size > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE; }
  pArray->m_size = new_size;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
{
  size_t orig_size = pArray->m_size; if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;
  memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
  struct tm tm;
  memset(&tm, 0, sizeof(tm)); tm.tm_isdst = -1;
  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900; tm.tm_mon = ((dos_date >> 5) & 15) - 1; tm.tm_mday = dos_date & 31;
  tm.tm_hour = (dos_time >> 11) & 31; tm.tm_min = (dos_time >> 5) & 63; tm.tm_sec = (dos_time << 1) & 62;
  return mktime(&tm);
}

static void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef _MSC_VER
  struct tm tm_struct;
  struct tm *tm = &tm_struct;
  errno_t err = localtime_s(tm, &time);
  if (err)
  {
    *pDOS_date = 0; *pDOS_time = 0;
    return;
  }
#else
  struct tm *tm = localtime(&time);
#endif
  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif

#ifndef MINIZ_NO_STDIO
static mz_bool mz_zip_get_file_modified_time(const char *pFilename, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef MINIZ_NO_TIME
  (void)pFilename; *pDOS_date = *pDOS_time = 0;
#else
  struct MZ_FILE_STAT_STRUCT file_stat;
  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
    return MZ_FALSE;
  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
#endif // #ifdef MINIZ_NO_TIME
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time, time_t modified_time)
{
  struct utimbuf t; t.actime = access_time; t.modtime = modified_time;
  return !utime(pFilename, &t);
}
#endif // #ifndef MINIZ_NO_TIME
#endif // #ifndef MINIZ_NO_STDIO

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint32 flags)
{
  (void)flags;
  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
    return MZ_FALSE;

  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
  pZip->m_archive_size = 0;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
    return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE; pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE)
  {
    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
      break;
    pL++; pR++;
  }
  return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b) do { mz_uint32 t = a; a = b; b = t; } MZ_MACRO_END

// Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)
static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
  const int size = pZip->m_total_files;
  int start = (size - 2) >> 1, end;
  while (start >= 0)
  {
    int child, root = start;
    for ( ; ; )
    {
      if ((child = (root << 1) + 1) >= size)
        break;
      child += (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));
      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
        break;
      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
    }
    start--;
  }

  end = size - 1;
  while (end > 0)
  {
    int child, root = 0;
    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
    for ( ; ; )
    {
      if ((child = (root << 1) + 1) >= end)
        break;
      child += (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));
      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
        break;
      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
    }
    end--;
  }
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint32 flags)
{
  mz_uint cdir_size, num_this_disk, cdir_disk_index;
  mz_uint64 cdir_ofs;
  mz_int64 cur_file_ofs;
  const mz_uint8 *p;
  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)]; mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
  mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
  // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.
  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  // Find the end of central directory record by scanning the file from the end towards the beginning.
  cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
  for ( ; ; )
  {
    int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
      return MZ_FALSE;
    for (i = n - 4; i >= 0; --i)
      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        break;
    if (i >= 0)
    {
      cur_file_ofs += i;
      break;
    }
    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
      return MZ_FALSE;
    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
  }
  // Read and verify the end of central directory record.
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||
      ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
    return MZ_FALSE;

  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
  if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
    return MZ_FALSE;

  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;

  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
    return MZ_FALSE;

  pZip->m_central_directory_file_ofs = cdir_ofs;

  if (pZip->m_total_files)
  {
     mz_uint i, n;

    // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.
    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
      return MZ_FALSE;

    if (sort_central_dir)
    {
      if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
        return MZ_FALSE;
    }

    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
      return MZ_FALSE;

    // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).
    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
    {
      mz_uint total_header_size, comp_size, decomp_size, disk_index;
      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
        return MZ_FALSE;
      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
      if (sort_central_dir)
        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))
        return MZ_FALSE;
      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
      if ((disk_index != num_this_disk) && (disk_index != 1))
        return MZ_FALSE;
      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
        return MZ_FALSE;
      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
        return MZ_FALSE;
      n -= total_header_size; p += total_header_size;
    }
  }

  if (sort_central_dir)
    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

  return MZ_TRUE;
}

mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags)
{
  if ((!pZip) || (!pZip->m_pRead))
    return MZ_FALSE;
  if (!mz_zip_reader_init_internal(pZip, flags))
    return MZ_FALSE;
  pZip->m_archive_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
  return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags)
{
  if (!mz_zip_reader_init_internal(pZip, flags))
    return MZ_FALSE;
  pZip->m_archive_size = size;
  pZip->m_pRead = mz_zip_mem_read_func;
  pZip->m_pIO_opaque = pZip;
#ifdef __cplusplus
  pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
  pZip->m_pState->m_pMem = (void *)pMem;
#endif
  pZip->m_pState->m_mem_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    return 0;
  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
{
  mz_uint64 file_size;
  MZ_FILE *pFile = MZ_FOPEN(pFilename, "rb");
  if (!pFile)
    return MZ_FALSE;
  if (MZ_FSEEK64(pFile, 0, SEEK_END))
  {
    MZ_FCLOSE(pFile);
    return MZ_FALSE;
  }
  file_size = MZ_FTELL64(pFile);
  if (!mz_zip_reader_init_internal(pZip, flags))
  {
    MZ_FCLOSE(pFile);
    return MZ_FALSE;
  }
  pZip->m_pRead = mz_zip_file_read_func;
  pZip->m_pIO_opaque = pZip;
  pZip->m_pState->m_pFile = pFile;
  pZip->m_archive_size = file_size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
{
  return pZip ? pZip->m_total_files : 0;
}

static MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
{
  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return NULL;
  return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_uint m_bit_flag;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
    return MZ_FALSE;
  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  return (m_bit_flag & 1);
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_uint filename_len, external_attr;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
    return MZ_FALSE;

  // First see if the filename ends with a '/' character.
  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_len)
  {
    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
      return MZ_TRUE;
  }

  // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.
  // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.
  // FIXME: Remove this check? Is it necessary - we already check the filename.
  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  if ((external_attr & 0x10) != 0)
    return MZ_TRUE;

  return MZ_FALSE;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if ((!p) || (!pStat))
    return MZ_FALSE;

  // Unpack the central directory record.
  pStat->m_file_index = file_index;
  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
  pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

  // Copy as much of the filename and comment as possible.
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n); pStat->m_filename[n] = '\0';

  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
  pStat->m_comment_size = n;
  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n); pStat->m_comment[n] = '\0';

  return MZ_TRUE;
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
{
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p) { if (filename_buf_size) pFilename[0] = '\0'; return 0; }
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_buf_size)
  {
    n = MZ_MIN(n, filename_buf_size - 1);
    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pFilename[n] = '\0';
  }
  return n + 1;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
{
  mz_uint i;
  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
    return 0 == memcmp(pA, pB, len);
  for (i = 0; i < len; ++i)
    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
      return MZ_FALSE;
  return MZ_TRUE;
}

static MZ_FORCEINLINE int mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
{
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE)
  {
    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
      break;
    pL++; pR++;
  }
  return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
  const int size = pZip->m_total_files;
  const mz_uint filename_len = (mz_uint)strlen(pFilename);
  int l = 0, h = size - 1;
  while (l <= h)
  {
    int m = (l + h) >> 1, file_index = pIndices[m], comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
    if (!comp)
      return file_index;
    else if (comp < 0)
      l = m + 1;
    else
      h = m - 1;
  }
  return -1;
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
{
  mz_uint file_index; size_t name_len, comment_len;
  if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return -1;
  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
    return mz_zip_reader_locate_file_binary_search(pZip, pName);
  name_len = strlen(pName); if (name_len > 0xFFFF) return -1;
  comment_len = pComment ? strlen(pComment) : 0; if (comment_len > 0xFFFF) return -1;
  for (file_index = 0; file_index < pZip->m_total_files; file_index++)
  {
    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    if (filename_len < name_len)
      continue;
    if (comment_len)
    {
      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
      const char *pFile_comment = pFilename + filename_len + file_extra_len;
      if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags)))
        continue;
    }
    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
    {
      int ofs = filename_len - 1;
      do
      {
        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
          break;
      } while (--ofs >= 0);
      ofs++;
      pFilename += ofs; filename_len -= ofs;
    }
    if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))
      return file_index;
  }
  return -1;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  int status = TINFL_STATUS_DONE;
  mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  tinfl_decompressor inflator;

  if ((buf_size) && (!pBuf))
    return MZ_FALSE;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
    return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
    return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
    return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
    return MZ_FALSE;

  // Ensure supplied output buffer is large enough.
  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
  if (buf_size < needed_size)
    return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
    return MZ_FALSE;

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
  {
    // The file is stored or the caller has requested the compressed data.
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
      return MZ_FALSE;
    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
  }

  // Decompress the file either directly from memory or from a file input buffer.
  tinfl_init(&inflator);

  if (pZip->m_pState->m_pMem)
  {
    // Read directly from the archive in memory.
    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
    read_buf_size = read_buf_avail = file_stat.m_comp_size;
    comp_remaining = 0;
  }
  else if (pUser_read_buf)
  {
    // Use a user provided read buffer.
    if (!user_read_buf_size)
      return MZ_FALSE;
    pRead_buf = (mz_uint8 *)pUser_read_buf;
    read_buf_size = user_read_buf_size;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }
  else
  {
    // Temporarily allocate a read buffer.
    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
#ifdef _MSC_VER
    if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
#else
    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
#endif
      return MZ_FALSE;
    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
      return MZ_FALSE;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }

  do
  {
    size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
    {
      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
      {
        status = TINFL_STATUS_FAILED;
        break;
      }
      cur_file_ofs += read_buf_avail;
      comp_remaining -= read_buf_avail;
      read_buf_ofs = 0;
    }
    in_buf_size = (size_t)read_buf_avail;
    status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
    read_buf_avail -= in_buf_size;
    read_buf_ofs += in_buf_size;
    out_buf_ofs += out_buf_size;
  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

  if (status == TINFL_STATUS_DONE)
  {
    // Make sure the entire file was decompressed, and check its CRC.
    if ((out_buf_ofs != file_stat.m_uncomp_size) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
      status = TINFL_STATUS_FAILED;
  }

  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
{
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
{
  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
  mz_uint64 comp_size, uncomp_size, alloc_size;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  void *pBuf;

  if (pSize)
    *pSize = 0;
  if (!p)
    return NULL;

  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);

  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
#ifdef _MSC_VER
  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#else
  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#endif
    return NULL;
  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
    return NULL;

  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
    return NULL;
  }

  if (pSize) *pSize = (size_t)alloc_size;
  return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
  {
    if (pSize) *pSize = 0;
    return MZ_FALSE;
  }
  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
  int status = TINFL_STATUS_DONE; mz_uint file_crc32 = MZ_CRC32_INIT;
  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf = NULL; void *pWrite_buf = NULL;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
    return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
    return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
    return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
    return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
    return MZ_FALSE;

  // Decompress the file either directly from memory or from a file input buffer.
  if (pZip->m_pState->m_pMem)
  {
    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
    read_buf_size = read_buf_avail = file_stat.m_comp_size;
    comp_remaining = 0;
  }
  else
  {
    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
      return MZ_FALSE;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
  {
    // The file is stored or the caller has requested the compressed data.
    if (pZip->m_pState->m_pMem)
    {
#ifdef _MSC_VER
      if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
#else
      if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
#endif
        return MZ_FALSE;
      if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
        status = TINFL_STATUS_FAILED;
      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
      cur_file_ofs += file_stat.m_comp_size;
      out_buf_ofs += file_stat.m_comp_size;
      comp_remaining = 0;
    }
    else
    {
      while (comp_remaining)
      {
        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
        {
          status = TINFL_STATUS_FAILED;
          break;
        }

        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
          file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);

        if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
        {
          status = TINFL_STATUS_FAILED;
          break;
        }
        cur_file_ofs += read_buf_avail;
        out_buf_ofs += read_buf_avail;
        comp_remaining -= read_buf_avail;
      }
    }
  }
  else
  {
    tinfl_decompressor inflator;
    tinfl_init(&inflator);

    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
      status = TINFL_STATUS_FAILED;
    else
    {
      do
      {
        mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
        {
          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
          cur_file_ofs += read_buf_avail;
          comp_remaining -= read_buf_avail;
          read_buf_ofs = 0;
        }

        in_buf_size = (size_t)read_buf_avail;
        status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
        read_buf_avail -= in_buf_size;
        read_buf_ofs += in_buf_size;

        if (out_buf_size)
        {
          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
          file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
        }
      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
    }
  }

  if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
  {
    // Make sure the entire file was decompressed, and check its CRC.
    if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32))
      status = TINFL_STATUS_FAILED;
  }

  if (!pZip->m_pState->m_pMem)
    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  if (pWrite_buf)
    pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
{
  (void)ofs; return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
{
  mz_bool status;
  mz_zip_archive_file_stat file_stat;
  MZ_FILE *pFile;
  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;
  pFile = MZ_FOPEN(pDst_filename, "wb");
  if (!pFile)
    return MZ_FALSE;
  status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
  if (MZ_FCLOSE(pFile) == EOF)
    return MZ_FALSE;
#ifndef MINIZ_NO_TIME
  if (status)
    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif
  return status;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
{
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return MZ_FALSE;

  if (pZip->m_pState)
  {
    mz_zip_internal_state *pState = pZip->m_pState; pZip->m_pState = NULL;
    mz_zip_array_clear(pZip, &pState->m_central_dir);
    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
    if (pState->m_pFile)
    {
      MZ_FCLOSE(pState->m_pFile);
      pState->m_pFile = NULL;
    }
#endif // #ifndef MINIZ_NO_STDIO

    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  }
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}
#endif

// ------------------- .ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static void mz_write_le16(mz_uint8 *p, mz_uint16 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); }
static void mz_write_le32(mz_uint8 *p, mz_uint32 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); p[2] = (mz_uint8)(v >> 16); p[3] = (mz_uint8)(v >> 24); }
#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
{
  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
    return MZ_FALSE;

  if (pZip->m_file_offset_alignment)
  {
    // Ensure user specified file offset alignment is a power of 2.
    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
      return MZ_FALSE;
  }

  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_archive_size = existing_size;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
    return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
  return MZ_TRUE;
}

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
#ifdef _MSC_VER
  if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#else
  if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#endif
    return 0;
  if (new_size > pState->m_mem_capacity)
  {
    void *pNew_block;
    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity); while (new_capacity < new_size) new_capacity *= 2;
    if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
      return 0;
    pState->m_pMem = pNew_block; pState->m_mem_capacity = new_capacity;
  }
  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
  pState->m_mem_size = (size_t)new_size;
  return n;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
{
  pZip->m_pWrite = mz_zip_heap_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
    return MZ_FALSE;
  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
  {
    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
    {
      mz_zip_writer_end(pZip);
      return MZ_FALSE;
    }
    pZip->m_pState->m_mem_capacity = initial_allocation_size;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    return 0;
  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
{
  MZ_FILE *pFile;
  pZip->m_pWrite = mz_zip_file_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
    return MZ_FALSE;
  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb")))
  {
    mz_zip_writer_end(pZip);
    return MZ_FALSE;
  }
  pZip->m_pState->m_pFile = pFile;
  if (size_to_reserve_at_beginning)
  {
    mz_uint64 cur_ofs = 0; char buf[4096]; MZ_CLEAR_OBJ(buf);
    do
    {
      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
      {
        mz_zip_writer_end(pZip);
        return MZ_FALSE;
      }
      cur_ofs += n; size_to_reserve_at_beginning -= n;
    } while (size_to_reserve_at_beginning);
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
{
  mz_zip_internal_state *pState;
  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return MZ_FALSE;
  // No sense in trying to write to an archive that's already at the support max size
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  pState = pZip->m_pState;

  if (pState->m_pFile)
  {
#ifdef MINIZ_NO_STDIO
    pFilename; return MZ_FALSE;
#else
    // Archive is being read from stdio - try to reopen as writable.
    if (pZip->m_pIO_opaque != pZip)
      return MZ_FALSE;
    if (!pFilename)
      return MZ_FALSE;
    pZip->m_pWrite = mz_zip_file_write_func;
    if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
    {
      // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.
      mz_zip_reader_end(pZip);
      return MZ_FALSE;
    }
#endif // #ifdef MINIZ_NO_STDIO
  }
  else if (pState->m_pMem)
  {
    // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.
    if (pZip->m_pIO_opaque != pZip)
      return MZ_FALSE;
    pState->m_mem_capacity = pState->m_mem_size;
    pZip->m_pWrite = mz_zip_heap_write_func;
  }
  // Archive is being read via a user provided read function - make sure the user has specified a write function too.
  else if (!pZip->m_pWrite)
    return MZ_FALSE;

  // Start writing new files at the archive's current central directory location.
  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_central_directory_file_ofs = 0;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
{
  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
}

typedef struct
{
  mz_zip_archive *m_pZip;
  mz_uint64 m_cur_archive_file_ofs;
  mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, int len, void *pUser)
{
  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
    return MZ_FALSE;
  pState->m_cur_archive_file_ofs += len;
  pState->m_comp_size += len;
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
{
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size, const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
  size_t orig_central_dir_size = pState->m_central_dir.m_size;
  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

  // No zip64 support yet
  if ((local_header_ofs > 0xFFFFFFFF) || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
    return MZ_FALSE;

  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
  {
    // Try to push the central directory array back into its original state.
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
{
  // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.
  if (*pArchive_name == '/')
    return MZ_FALSE;
  while (*pArchive_name)
  {
    if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
      return MZ_FALSE;
    pArchive_name++;
  }
  return MZ_TRUE;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
{
  mz_uint32 n;
  if (!pZip->m_file_offset_alignment)
    return 0;
  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
  return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
{
  char buf[4096];
  memset(buf, 0, MZ_MIN(sizeof(buf), n));
  while (n)
  {
    mz_uint32 s = MZ_MIN(sizeof(buf), n);
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
      return MZ_FALSE;
    cur_file_ofs += s; n -= s;
  }
  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
  mz_uint16 method = 0, dos_time = 0, dos_date = 0;
  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  tdefl_compressor *pComp = NULL;
  mz_bool store_data_uncompressed;
  mz_zip_internal_state *pState;

  if ((int)level_and_flags < 0)
    level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;
  store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
    return MZ_FALSE;

  pState = pZip->m_pState;

  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
    return MZ_FALSE;
  // No zip64 support yet
  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;

#ifndef MINIZ_NO_TIME
  {
    time_t cur_time; time(&cur_time);
    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
  }
#endif // #ifndef MINIZ_NO_TIME

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
    return MZ_FALSE;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
  {
    // Set DOS Subdirectory attribute bit.
    ext_attributes |= 0x10;
    // Subdirectories cannot contain data.
    if ((buf_size) || (uncomp_size))
      return MZ_FALSE;
  }

  // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)
  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
    return MZ_FALSE;

  if ((!store_data_uncompressed) && (buf_size))
  {
    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
      return MZ_FALSE;
  }

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
  {
    uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);
    uncomp_size = buf_size;
    if (uncomp_size <= 3)
    {
      level = 0;
      store_data_uncompressed = MZ_TRUE;
    }
  }

  if (store_data_uncompressed)
  {
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
      return MZ_FALSE;
    }

    cur_archive_file_ofs += buf_size;
    comp_size = buf_size;

    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
      method = MZ_DEFLATED;
  }
  else if (buf_size)
  {
    mz_zip_writer_add_state state;

    state.m_pZip = pZip;
    state.m_cur_archive_file_ofs = cur_archive_file_ofs;
    state.m_comp_size = 0;

    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
      return MZ_FALSE;
    }

    comp_size = state.m_comp_size;
    cur_archive_file_ofs = state.m_cur_archive_file_ofs;

    method = MZ_DEFLATED;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
  pComp = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
    return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
    return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
    return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  MZ_FILE *pSrc_file = NULL;

  if ((int)level_and_flags < 0)
    level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
    return MZ_FALSE;
  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
    return MZ_FALSE;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))
    return MZ_FALSE;
    
  pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
  if (!pSrc_file)
    return MZ_FALSE;
  MZ_FSEEK64(pSrc_file, 0, SEEK_END);
  uncomp_size = MZ_FTELL64(pSrc_file);
  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

  if (uncomp_size > 0xFFFFFFFF)
  {
    // No zip64 support yet
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  if (uncomp_size <= 3)
    level = 0;

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
  {
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
  {
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (uncomp_size)
  {
    mz_uint64 uncomp_remaining = uncomp_size;
    void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
    if (!pRead_buf)
    {
      MZ_FCLOSE(pSrc_file);
      return MZ_FALSE;
    }

    if (!level)
    {
      while (uncomp_remaining)
      {
        mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))
        {
          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
          MZ_FCLOSE(pSrc_file);
          return MZ_FALSE;
        }
        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
        uncomp_remaining -= n;
        cur_archive_file_ofs += n;
      }
      comp_size = uncomp_size;
    }
    else
    {
      mz_bool result = MZ_FALSE;
      mz_zip_writer_add_state state;
      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
      if (!pComp)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      state.m_pZip = pZip;
      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
      state.m_comp_size = 0;

      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      for ( ; ; )
      {
        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
        tdefl_status status;

        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
          break;

        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
        uncomp_remaining -= in_buf_size;

        status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);
        if (status == TDEFL_STATUS_DONE)
        {
          result = MZ_TRUE;
          break;
        }
        else if (status != TDEFL_STATUS_OKAY)
          break;
      }

      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

      if (!result)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      comp_size = state.m_comp_size;
      cur_archive_file_ofs = state.m_cur_archive_file_ofs;

      method = MZ_DEFLATED;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  }

  MZ_FCLOSE(pSrc_file); pSrc_file = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
    return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
    return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
    return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index)
{
  mz_uint n, bit_flags, num_alignment_padding_bytes;
  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
  size_t orig_central_dir_size;
  mz_zip_internal_state *pState;
  void *pBuf; const mz_uint8 *pSrc_central_header;

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
    return MZ_FALSE;
  if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))
    return MZ_FALSE;
  pState = pZip->m_pState;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
  cur_dst_file_ofs = pZip->m_archive_size;

  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;
  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
    return MZ_FALSE;
  cur_dst_file_ofs += num_alignment_padding_bytes;
  local_dir_header_ofs = cur_dst_file_ofs;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }

  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);

  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))
    return MZ_FALSE;

  while (comp_bytes_remaining)
  {
    n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }
    cur_src_file_ofs += n;

    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }
    cur_dst_file_ofs += n;

    comp_bytes_remaining -= n;
  }

  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
  if (bit_flags & 8)
  {
    // Copy data descriptor
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }

    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }

    cur_src_file_ofs += n;
    cur_dst_file_ofs += n;
  }
  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

  // no zip64 support yet
  if (cur_dst_file_ofs > 0xFFFFFFFF)
    return MZ_FALSE;

  orig_central_dir_size = pState->m_central_dir.m_size;

  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
    return MZ_FALSE;

  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n))
  {
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  if (pState->m_central_dir.m_size > 0xFFFFFFFF)
    return MZ_FALSE;
  n = (mz_uint32)orig_central_dir_size;
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
  {
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  pZip->m_total_files++;
  pZip->m_archive_size = cur_dst_file_ofs;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState;
  mz_uint64 central_dir_ofs, central_dir_size;
  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
    return MZ_FALSE;

  pState = pZip->m_pState;

  // no zip64 support yet
  if ((pZip->m_total_files > 0xFFFF) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  central_dir_ofs = 0;
  central_dir_size = 0;
  if (pZip->m_total_files)
  {
    // Write central directory
    central_dir_ofs = pZip->m_archive_size;
    central_dir_size = pState->m_central_dir.m_size;
    pZip->m_central_directory_file_ofs = central_dir_ofs;
    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
      return MZ_FALSE;
    pZip->m_archive_size += central_dir_size;
  }

  // Write end of central directory record
  MZ_CLEAR_OBJ(hdr);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);

  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr))
    return MZ_FALSE;
#ifndef MINIZ_NO_STDIO
  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
    return MZ_FALSE;
#endif // #ifndef MINIZ_NO_STDIO

  pZip->m_archive_size += sizeof(hdr);

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize)
{
  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))
    return MZ_FALSE;
  if (pZip->m_pWrite != mz_zip_heap_write_func)
    return MZ_FALSE;
  if (!mz_zip_writer_finalize_archive(pZip))
    return MZ_FALSE;

  *pBuf = pZip->m_pState->m_pMem;
  *pSize = pZip->m_pState->m_mem_size;
  pZip->m_pState->m_pMem = NULL;
  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState;
  mz_bool status = MZ_TRUE;
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
    return MZ_FALSE;

  pState = pZip->m_pState;
  pZip->m_pState = NULL;
  mz_zip_array_clear(pZip, &pState->m_central_dir);
  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
  if (pState->m_pFile)
  {
    MZ_FCLOSE(pState->m_pFile);
    pState->m_pFile = NULL;
  }
#endif // #ifndef MINIZ_NO_STDIO

  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
    pState->m_pMem = NULL;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
  return status;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
  mz_bool status, created_new_archive = MZ_FALSE;
  mz_zip_archive zip_archive;
  struct MZ_FILE_STAT_STRUCT file_stat;
  MZ_CLEAR_OBJ(zip_archive);
  if ((int)level_and_flags < 0)
     level_and_flags = MZ_DEFAULT_LEVEL;
  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;
  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
  {
    // Create a new archive.
    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))
      return MZ_FALSE;
    created_new_archive = MZ_TRUE;
  }
  else
  {
    // Append to an existing archive.
    if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
      return MZ_FALSE;
    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename))
    {
      mz_zip_reader_end(&zip_archive);
      return MZ_FALSE;
    }
  }
  status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
  // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)
  if (!mz_zip_writer_finalize_archive(&zip_archive))
    status = MZ_FALSE;
  if (!mz_zip_writer_end(&zip_archive))
    status = MZ_FALSE;
  if ((!status) && (created_new_archive))
  {
    // It's a new archive and something went wrong, so just delete it.
    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
    (void)ignoredStatus;
  }
  return status;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
{
  int file_index;
  mz_zip_archive zip_archive;
  void *p = NULL;

  if (pSize)
    *pSize = 0;

  if ((!pZip_filename) || (!pArchive_name))
    return NULL;

  MZ_CLEAR_OBJ(zip_archive);
  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
    return NULL;

  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)
    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);

  mz_zip_reader_end(&zip_archive);
  return p;
}

#endif // #ifndef MINIZ_NO_STDIO

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_FILE_ONLY

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/
#endif //JSI__MINIZ==1 
#if JSI__READLINE==1
/* linenoise.c -- guerrilla line editing library against the idea that a
 * line editing lib needs to be 20,000 lines of C code.
 *
 * You can find the latest source code at:
 *
 *   http://github.com/antirez/linenoise
 *
 * Does a number of crazy assumptions that happen to be true in 99.9999% of
 * the 2010 UNIX computers around.
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (c) 2010-2016, Salvatore Sanfilippo <antirez at gmail dot com>
 * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ------------------------------------------------------------------------
 *
 * References:
 * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
 * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
 *
 * Todo list:
 * - Filter bogus Ctrl+<char> combinations.
 * - Win32 support
 *
 * Bloat:
 * - History search like Ctrl+r in readline?
 *
 * List of escape sequences used by this program, we do everything just
 * with three sequences. In order to be so cheap we may have some
 * flickering effect with some slow terminal, but the lesser sequences
 * the more compatible.
 *
 * EL (Erase Line)
 *    Sequence: ESC [ n K
 *    Effect: if n is 0 or missing, clear from cursor to end of line
 *    Effect: if n is 1, clear from beginning of line to cursor
 *    Effect: if n is 2, clear entire line
 *
 * CUF (CUrsor Forward)
 *    Sequence: ESC [ n C
 *    Effect: moves cursor forward n chars
 *
 * CUB (CUrsor Backward)
 *    Sequence: ESC [ n D
 *    Effect: moves cursor backward n chars
 *
 * The following is used to get the terminal width if getting
 * the width with the TIOCGWINSZ ioctl fails
 *
 * DSR (Device Status Report)
 *    Sequence: ESC [ 6 n
 *    Effect: reports the current cusor position as ESC [ n ; m R
 *            where n is the row and m is the column
 *
 * When multi line mode is enabled, we also use an additional escape
 * sequence. However multi line editing is disabled by default.
 *
 * CUU (Cursor Up)
 *    Sequence: ESC [ n A
 *    Effect: moves cursor up of n chars.
 *
 * CUD (Cursor Down)
 *    Sequence: ESC [ n B
 *    Effect: moves cursor down of n chars.
 *
 * When linenoiseClearScreen() is called, two additional escape sequences
 * are used in order to clear the screen and position the cursor at home
 * position.
 *
 * CUP (Cursor position)
 *    Sequence: ESC [ H
 *    Effect: moves the cursor to upper left corner
 *
 * ED (Erase display)
 *    Sequence: ESC [ 2 J
 *    Effect: clear the whole screen
 *
 */

#include <termios.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "linenoise.h"

#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
#define LINENOISE_MAX_LINE 4096
static const char *unsupported_term[] = {"dumb","cons25","emacs",NULL};
static linenoiseCompletionCallback *completionCallback = NULL;
static linenoiseHintsCallback *hintsCallback = NULL;
static linenoiseFreeHintsCallback *freeHintsCallback = NULL;

static struct termios orig_termios; /* In order to restore at exit.*/
static int rawmode = 0; /* For atexit() function to check if restore is needed*/
static int mlmode = 0;  /* Multi line mode. Default is single line. */
static int atexit_registered = 0; /* Register atexit just 1 time. */
static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
static int history_len = 0;
static char **history = NULL;

/* The linenoiseState structure represents the state during line editing.
 * We pass this state to functions implementing specific editing
 * functionalities. */
struct linenoiseState {
    int ifd;            /* Terminal stdin file descriptor. */
    int ofd;            /* Terminal stdout file descriptor. */
    char *buf;          /* Edited line buffer. */
    size_t buflen;      /* Edited line buffer size. */
    const char *prompt; /* Prompt to display. */
    size_t plen;        /* Prompt length. */
    size_t pos;         /* Current cursor position. */
    size_t oldpos;      /* Previous refresh cursor position. */
    size_t len;         /* Current edited line length. */
    size_t cols;        /* Number of columns in terminal. */
    size_t maxrows;     /* Maximum num of rows used so far (multiline mode) */
    int history_index;  /* The history index we are currently editing. */
};

enum KEY_ACTION{
    KEY_NULL = 0,       /* NULL */
    CTRL_A = 1,         /* Ctrl+a */
    CTRL_B = 2,         /* Ctrl-b */
    CTRL_C = 3,         /* Ctrl-c */
    CTRL_D = 4,         /* Ctrl-d */
    CTRL_E = 5,         /* Ctrl-e */
    CTRL_F = 6,         /* Ctrl-f */
    CTRL_H = 8,         /* Ctrl-h */
    TAB = 9,            /* Tab */
    CTRL_K = 11,        /* Ctrl+k */
    CTRL_L = 12,        /* Ctrl+l */
    ENTER = 13,         /* Enter */
    CTRL_N = 14,        /* Ctrl-n */
    CTRL_P = 16,        /* Ctrl-p */
    CTRL_T = 20,        /* Ctrl-t */
    CTRL_U = 21,        /* Ctrl+u */
    CTRL_W = 23,        /* Ctrl+w */
    ESC = 27,           /* Escape */
    BACKSPACE =  127    /* Backspace */
};

static void linenoiseAtExit(void);
int linenoiseHistoryAdd(const char *line);
static void refreshLine(struct linenoiseState *l);

/* Debugging macro. */
#if 0
FILE *lndebug_fp = NULL;
#define lndebug(...) \
    do { \
        if (lndebug_fp == NULL) { \
            lndebug_fp = fopen("/tmp/lndebug.txt","a"); \
            fprintf(lndebug_fp, \
            "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", \
            (int)l->len,(int)l->pos,(int)l->oldpos,plen,rows,rpos, \
            (int)l->maxrows,old_rows); \
        } \
        fprintf(lndebug_fp, ", " __VA_ARGS__); \
        fflush(lndebug_fp); \
    } while (0)
#else
#define lndebug(fmt, ...)
#endif

/* ======================= Low level terminal handling ====================== */

/* Set if to use or not the multi line mode. */
void linenoiseSetMultiLine(int ml) {
    mlmode = ml;
}

/* Return true if the terminal name is in the list of terminals we know are
 * not able to understand basic escape sequences. */
static int isUnsupportedTerm(void) {
    char *term = getenv("TERM");
    int j;

    if (term == NULL) return 0;
    for (j = 0; unsupported_term[j]; j++)
        if (!strcasecmp(term,unsupported_term[j])) return 1;
    return 0;
}

/* Raw mode: 1960 magic shit. */
static int enableRawMode(int fd) {
    struct termios raw;

    if (!isatty(STDIN_FILENO)) goto fatal;
    if (!atexit_registered) {
        atexit(linenoiseAtExit);
        atexit_registered = 1;
    }
    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;

    raw = orig_termios;  /* modify the original mode */
    /* input modes: no break, no CR to NL, no parity check, no strip char,
     * no start/stop output control. */
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    /* output modes - disable post processing */
    raw.c_oflag &= ~(OPOST);
    /* control modes - set 8 bit chars */
    raw.c_cflag |= (CS8);
    /* local modes - choing off, canonical off, no extended functions,
     * no signal chars (^Z,^C) */
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
    /* control chars - set return condition: min number of bytes and timer.
     * We want read to return every single byte, without timeout. */
    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */

    /* put terminal in raw mode after flushing */
    if (tcsetattr(fd,TCSADRAIN,&raw) < 0) goto fatal;
    rawmode = 1;
    return 0;

fatal:
    errno = ENOTTY;
    return -1;
}

static void disableRawMode(int fd) {
    /* Don't even check the return value as it's too late. */
    if (rawmode && tcsetattr(fd,TCSADRAIN,&orig_termios) != -1)
        rawmode = 0;
}

/* Use the ESC [6n escape sequence to query the horizontal cursor position
 * and return it. On error -1 is returned, on success the position of the
 * cursor. */
static int getCursorPosition(int ifd, int ofd) {
    char buf[32];
    int cols, rows;
    unsigned int i = 0;

    /* Report cursor location */
    if (write(ofd, "\x1b[6n", 4) != 4) return -1;

    /* Read the response: ESC [ rows ; cols R */
    while (i < sizeof(buf)-1) {
        if (read(ifd,buf+i,1) != 1) break;
        if (buf[i] == 'R') break;
        i++;
    }
    buf[i] = '\0';

    /* Parse it. */
    if (buf[0] != ESC || buf[1] != '[') return -1;
    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
    return cols;
}

/* Try to get the number of columns in the current terminal, or assume 80
 * if it fails. */
static int getColumns(int ifd, int ofd) {
    struct winsize ws;

    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
        /* ioctl() failed. Try to query the terminal itself. */
        int start, cols;

        /* Get the initial position so we can restore it later. */
        start = getCursorPosition(ifd,ofd);
        if (start == -1) goto failed;

        /* Go to right margin and get position. */
        if (write(ofd,"\x1b[999C",6) != 6) goto failed;
        cols = getCursorPosition(ifd,ofd);
        if (cols == -1) goto failed;

        /* Restore position. */
        if (cols > start) {
            char seq[32];
            snprintf(seq,32,"\x1b[%dD",cols-start);
            if (write(ofd,seq,strlen(seq)) == -1) {
                /* Can't recover... */
            }
        }
        return cols;
    } else {
        return ws.ws_col;
    }

failed:
    return 80;
}

/* Clear the screen. Used to handle ctrl+l */
void linenoiseClearScreen(void) {
    if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
        /* nothing to do, just to avoid warning. */
    }
}

/* Beep, used for completion when there is nothing to complete or when all
 * the choices were already shown. */
static void linenoiseBeep(void) {
    fprintf(stderr, "\x7");
    fflush(stderr);
}

/* ============================== Completion ================================ */

/* Free a list of completion option populated by linenoiseAddCompletion(). */
static void freeCompletions(linenoiseCompletions *lc) {
    size_t i;
    for (i = 0; i < lc->len; i++)
        free(lc->cvec[i]);
    if (lc->cvec != NULL)
        free(lc->cvec);
}

/* This is an helper function for linenoiseEdit() and is called when the
 * user types the <tab> key in order to complete the string currently in the
 * input.
 *
 * The state of the editing is encapsulated into the pointed linenoiseState
 * structure as described in the structure definition. */
static int completeLine(struct linenoiseState *ls) {
    linenoiseCompletions lc = { 0, NULL };
    int nread, nwritten;
    char c = 0;

    completionCallback(ls->buf,&lc);
    if (lc.len == 0) {
        linenoiseBeep();
    } else {
        size_t stop = 0, i = 0;

        while(!stop) {
            /* Show completion or original buffer */
            if (i < lc.len) {
                struct linenoiseState saved = *ls;

                ls->len = ls->pos = strlen(lc.cvec[i]);
                ls->buf = lc.cvec[i];
                refreshLine(ls);
                ls->len = saved.len;
                ls->pos = saved.pos;
                ls->buf = saved.buf;
            } else {
                refreshLine(ls);
            }

            nread = read(ls->ifd,&c,1);
            if (nread <= 0) {
                freeCompletions(&lc);
                return -1;
            }

            switch(c) {
                case 9: /* tab */
                    i = (i+1) % (lc.len+1);
                    if (i == lc.len) linenoiseBeep();
                    break;
                case 27: /* escape */
                    /* Re-show original buffer */
                    if (i < lc.len) refreshLine(ls);
                    stop = 1;
                    break;
                default:
                    /* Update buffer and return */
                    if (i < lc.len) {
                        nwritten = snprintf(ls->buf,ls->buflen,"%s",lc.cvec[i]);
                        ls->len = ls->pos = nwritten;
                    }
                    stop = 1;
                    break;
            }
        }
    }

    freeCompletions(&lc);
    return c; /* Return last read character */
}

/* Register a callback function to be called for tab-completion. */
void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
    completionCallback = fn;
}

/* Register a hits function to be called to show hits to the user at the
 * right of the prompt. */
void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
    hintsCallback = fn;
}

/* Register a function to free the hints returned by the hints callback
 * registered with linenoiseSetHintsCallback(). */
void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
    freeHintsCallback = fn;
}

/* This function is used by the callback function registered by the user
 * in order to add completion options given the input string when the
 * user typed <tab>. See the example.c source code for a very easy to
 * understand example. */
void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
    size_t len = strlen(str);
    char *copy, **cvec;

    copy = (char*)malloc(len+1);
    if (copy == NULL) return;
    memcpy(copy,str,len+1);
    cvec = (char**)realloc(lc->cvec,sizeof(char*)*(lc->len+1));
    if (cvec == NULL) {
        free(copy);
        return;
    }
    lc->cvec = cvec;
    lc->cvec[lc->len++] = copy;
}

/* =========================== Line editing ================================= */

/* We define a very simple "append buffer" structure, that is an heap
 * allocated string where we can append to. This is useful in order to
 * write all the escape sequences in a buffer and flush them to the standard
 * output in a single call, to avoid flickering effects. */
struct abuf {
    char *b;
    int len;
};

static void abInit(struct abuf *ab) {
    ab->b = NULL;
    ab->len = 0;
}

static void abAppend(struct abuf *ab, const char *s, int len) {
    char *newc = (char*)realloc(ab->b,ab->len+len);

    if (newc == NULL) return;
    memcpy(newc+ab->len,s,len);
    ab->b = newc;
    ab->len += len;
}

static void abFree(struct abuf *ab) {
    free(ab->b);
}

/* Helper of refreshSingleLine() and refreshMultiLine() to show hints
 * to the right of the prompt. */
void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
    char seq[64];
    if (hintsCallback && plen+l->len < l->cols) {
        int color = -1, bold = 0;
        char *hint = hintsCallback(l->buf,&color,&bold);
        if (hint) {
            int hintlen = strlen(hint);
            int hintmaxlen = l->cols-(plen+l->len);
            if (hintlen > hintmaxlen) hintlen = hintmaxlen;
            if (bold == 1 && color == -1) color = 37;
            if (color != -1 || bold != 0)
                snprintf(seq,64,"\033[%d;%d;49m",bold,color);
            abAppend(ab,seq,strlen(seq));
            abAppend(ab,hint,hintlen);
            if (color != -1 || bold != 0)
                abAppend(ab,"\033[0m",4);
            /* Call the function to free the hint returned. */
            if (freeHintsCallback) freeHintsCallback(hint);
        }
    }
}

/* Single line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
static void refreshSingleLine(struct linenoiseState *l) {
    char seq[64];
    size_t plen = strlen(l->prompt);
    int fd = l->ofd;
    char *buf = l->buf;
    size_t len = l->len;
    size_t pos = l->pos;
    struct abuf ab;

    while((plen+pos) >= l->cols) {
        buf++;
        len--;
        pos--;
    }
    while (plen+len > l->cols) {
        len--;
    }

    abInit(&ab);
    /* Cursor to left edge */
    snprintf(seq,64,"\r");
    abAppend(&ab,seq,strlen(seq));
    /* Write the prompt and the current buffer content */
    abAppend(&ab,l->prompt,strlen(l->prompt));
    abAppend(&ab,buf,len);
    /* Show hits if any. */
    refreshShowHints(&ab,l,plen);
    /* Erase to right */
    snprintf(seq,64,"\x1b[0K");
    abAppend(&ab,seq,strlen(seq));
    /* Move cursor to original position. */
    snprintf(seq,64,"\r\x1b[%dC", (int)(pos+plen));
    abAppend(&ab,seq,strlen(seq));
    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
    abFree(&ab);
}

/* Multi line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
static void refreshMultiLine(struct linenoiseState *l) {
    char seq[64];
    int plen = strlen(l->prompt);
    int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */
    int rpos = (plen+l->oldpos+l->cols)/l->cols; /* cursor relative row. */
    int rpos2; /* rpos after refresh. */
    int col; /* colum position, zero-based. */
    int old_rows = l->maxrows;
    int fd = l->ofd, j;
    struct abuf ab;

    /* Update maxrows if needed. */
    if (rows > (int)l->maxrows) l->maxrows = rows;

    /* First step: clear all the lines used before. To do so start by
     * going to the last row. */
    abInit(&ab);
    if (old_rows-rpos > 0) {
        lndebug("go down %d", old_rows-rpos);
        snprintf(seq,64,"\x1b[%dB", old_rows-rpos);
        abAppend(&ab,seq,strlen(seq));
    }

    /* Now for every row clear it, go up. */
    for (j = 0; j < old_rows-1; j++) {
        lndebug("clear+up");
        snprintf(seq,64,"\r\x1b[0K\x1b[1A");
        abAppend(&ab,seq,strlen(seq));
    }

    /* Clean the top line. */
    lndebug("clear");
    snprintf(seq,64,"\r\x1b[0K");
    abAppend(&ab,seq,strlen(seq));

    /* Write the prompt and the current buffer content */
    abAppend(&ab,l->prompt,strlen(l->prompt));
    abAppend(&ab,l->buf,l->len);

    /* Show hits if any. */
    refreshShowHints(&ab,l,plen);

    /* If we are at the very end of the screen with our prompt, we need to
     * emit a newline and move the prompt to the first column. */
    if (l->pos &&
        l->pos == l->len &&
        (l->pos+plen) % l->cols == 0)
    {
        lndebug("<newline>");
        abAppend(&ab,"\n",1);
        snprintf(seq,64,"\r");
        abAppend(&ab,seq,strlen(seq));
        rows++;
        if (rows > (int)l->maxrows) l->maxrows = rows;
    }

    /* Move cursor to right position. */
    rpos2 = (plen+l->pos+l->cols)/l->cols; /* current cursor relative row. */
    lndebug("rpos2 %d", rpos2);

    /* Go up till we reach the expected positon. */
    if (rows-rpos2 > 0) {
        lndebug("go-up %d", rows-rpos2);
        snprintf(seq,64,"\x1b[%dA", rows-rpos2);
        abAppend(&ab,seq,strlen(seq));
    }

    /* Set column. */
    col = (plen+(int)l->pos) % (int)l->cols;
    lndebug("set col %d", 1+col);
    if (col)
        snprintf(seq,64,"\r\x1b[%dC", col);
    else
        snprintf(seq,64,"\r");
    abAppend(&ab,seq,strlen(seq));

    lndebug("\n");
    l->oldpos = l->pos;

    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
    abFree(&ab);
}

/* Calls the two low level functions refreshSingleLine() or
 * refreshMultiLine() according to the selected mode. */
static void refreshLine(struct linenoiseState *l) {
    if (mlmode)
        refreshMultiLine(l);
    else
        refreshSingleLine(l);
}

/* Insert the character 'c' at cursor current position.
 *
 * On error writing to the terminal -1 is returned, otherwise 0. */
int linenoiseEditInsert(struct linenoiseState *l, char c) {
    if (l->len < l->buflen) {
        if (l->len == l->pos) {
            l->buf[l->pos] = c;
            l->pos++;
            l->len++;
            l->buf[l->len] = '\0';
            if ((!mlmode && l->plen+l->len < l->cols && !hintsCallback)) {
                /* Avoid a full update of the line in the
                 * trivial case. */
                if (write(l->ofd,&c,1) == -1) return -1;
            } else {
                refreshLine(l);
            }
        } else {
            memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);
            l->buf[l->pos] = c;
            l->len++;
            l->pos++;
            l->buf[l->len] = '\0';
            refreshLine(l);
        }
    }
    return 0;
}

/* Move cursor on the left. */
void linenoiseEditMoveLeft(struct linenoiseState *l) {
    if (l->pos > 0) {
        l->pos--;
        refreshLine(l);
    }
}

/* Move cursor on the right. */
void linenoiseEditMoveRight(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos++;
        refreshLine(l);
    }
}

/* Move cursor to the start of the line. */
void linenoiseEditMoveHome(struct linenoiseState *l) {
    if (l->pos != 0) {
        l->pos = 0;
        refreshLine(l);
    }
}

/* Move cursor to the end of the line. */
void linenoiseEditMoveEnd(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos = l->len;
        refreshLine(l);
    }
}

/* Substitute the currently edited line with the next or previous history
 * entry as specified by 'dir'. */
#define LINENOISE_HISTORY_NEXT 0
#define LINENOISE_HISTORY_PREV 1
void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
    if (history_len > 1) {
        /* Update the current history entry before to
         * overwrite it with the next one. */
        free(history[history_len - 1 - l->history_index]);
        history[history_len - 1 - l->history_index] = strdup(l->buf);
        /* Show the new entry */
        l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
        if (l->history_index < 0) {
            l->history_index = 0;
            return;
        } else if (l->history_index >= history_len) {
            l->history_index = history_len-1;
            return;
        }
        strncpy(l->buf,history[history_len - 1 - l->history_index],l->buflen);
        l->buf[l->buflen-1] = '\0';
        l->len = l->pos = strlen(l->buf);
        refreshLine(l);
    }
}

/* Delete the character at the right of the cursor without altering the cursor
 * position. Basically this is what happens with the "Delete" keyboard key. */
void linenoiseEditDelete(struct linenoiseState *l) {
    if (l->len > 0 && l->pos < l->len) {
        memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Backspace implementation. */
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Delete the previosu word, maintaining the cursor at the start of the
 * current word. */
void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
    size_t old_pos = l->pos;
    size_t diff;

    while (l->pos > 0 && l->buf[l->pos-1] == ' ')
        l->pos--;
    while (l->pos > 0 && l->buf[l->pos-1] != ' ')
        l->pos--;
    diff = old_pos - l->pos;
    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
    l->len -= diff;
    refreshLine(l);
}

/* This function is the core of the line editing capability of linenoise.
 * It expects 'fd' to be already in "raw mode" so that every key pressed
 * will be returned ASAP to read().
 *
 * The resulting string is put into 'buf' when the user type enter, or
 * when ctrl+d is typed.
 *
 * The function returns the length of the current buffer. */
static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)
{
    struct linenoiseState l;

    /* Populate the linenoise state that we pass to functions implementing
     * specific editing functionalities. */
    l.ifd = stdin_fd;
    l.ofd = stdout_fd;
    l.buf = buf;
    l.buflen = buflen;
    l.prompt = prompt;
    l.plen = strlen(prompt);
    l.oldpos = l.pos = 0;
    l.len = 0;
    l.cols = getColumns(stdin_fd, stdout_fd);
    l.maxrows = 0;
    l.history_index = 0;

    /* Buffer starts empty. */
    l.buf[0] = '\0';
    l.buflen--; /* Make sure there is always space for the nulterm */

    /* The latest history entry is always our current buffer, that
     * initially is just an empty string. */
    linenoiseHistoryAdd("");

    if (write(l.ofd,prompt,l.plen) == -1) return -1;
    while(1) {
        char c;
        int nread;
        char seq[3];

        nread = read(l.ifd,&c,1);
        if (nread <= 0) return l.len;

        /* Only autocomplete when the callback is set. It returns < 0 when
         * there was an error reading from fd. Otherwise it will return the
         * character that should be handled next. */
        if (c == 9 && completionCallback != NULL) {
            c = completeLine(&l);
            /* Return on errors */
            if (c < 0) return l.len;
            /* Read next character when 0 */
            if (c == 0) continue;
        }

        switch(c) {
        case ENTER:    /* enter */
            history_len--;
            free(history[history_len]);
            if (mlmode) linenoiseEditMoveEnd(&l);
            if (hintsCallback) {
                /* Force a refresh without hints to leave the previous
                 * line as the user typed it after a newline. */
                linenoiseHintsCallback *hc = hintsCallback;
                hintsCallback = NULL;
                refreshLine(&l);
                hintsCallback = hc;
            }
            return (int)l.len;
        case CTRL_C:     /* ctrl-c */
            errno = EAGAIN;
            return -1;
        case BACKSPACE:   /* backspace */
        case 8:     /* ctrl-h */
            linenoiseEditBackspace(&l);
            break;
        case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the
                            line is empty, act as end-of-file. */
            if (l.len > 0) {
                linenoiseEditDelete(&l);
            } else {
                history_len--;
                free(history[history_len]);
                return -1;
            }
            break;
        case CTRL_T:    /* ctrl-t, swaps current character with previous. */
            if (l.pos > 0 && l.pos < l.len) {
                int aux = buf[l.pos-1];
                buf[l.pos-1] = buf[l.pos];
                buf[l.pos] = aux;
                if (l.pos != l.len-1) l.pos++;
                refreshLine(&l);
            }
            break;
        case CTRL_B:     /* ctrl-b */
            linenoiseEditMoveLeft(&l);
            break;
        case CTRL_F:     /* ctrl-f */
            linenoiseEditMoveRight(&l);
            break;
        case CTRL_P:    /* ctrl-p */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
            break;
        case CTRL_N:    /* ctrl-n */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
            break;
        case ESC:    /* escape sequence */
            /* Read the next two bytes representing the escape sequence.
             * Use two calls to handle slow terminals returning the two
             * chars at different times. */
            if (read(l.ifd,seq,1) == -1) break;
            if (read(l.ifd,seq+1,1) == -1) break;

            /* ESC [ sequences. */
            if (seq[0] == '[') {
                if (seq[1] >= '0' && seq[1] <= '9') {
                    /* Extended escape, read additional byte. */
                    if (read(l.ifd,seq+2,1) == -1) break;
                    if (seq[2] == '~') {
                        switch(seq[1]) {
                        case '3': /* Delete key. */
                            linenoiseEditDelete(&l);
                            break;
                        }
                    }
                } else {
                    switch(seq[1]) {
                    case 'A': /* Up */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
                        break;
                    case 'B': /* Down */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
                        break;
                    case 'C': /* Right */
                        linenoiseEditMoveRight(&l);
                        break;
                    case 'D': /* Left */
                        linenoiseEditMoveLeft(&l);
                        break;
                    case 'H': /* Home */
                        linenoiseEditMoveHome(&l);
                        break;
                    case 'F': /* End*/
                        linenoiseEditMoveEnd(&l);
                        break;
                    }
                }
            }

            /* ESC O sequences. */
            else if (seq[0] == 'O') {
                switch(seq[1]) {
                case 'H': /* Home */
                    linenoiseEditMoveHome(&l);
                    break;
                case 'F': /* End*/
                    linenoiseEditMoveEnd(&l);
                    break;
                }
            }
            break;
        default:
            if (linenoiseEditInsert(&l,c)) return -1;
            break;
        case CTRL_U: /* Ctrl+u, delete the whole line. */
            buf[0] = '\0';
            l.pos = l.len = 0;
            refreshLine(&l);
            break;
        case CTRL_K: /* Ctrl+k, delete from current to end of line. */
            buf[l.pos] = '\0';
            l.len = l.pos;
            refreshLine(&l);
            break;
        case CTRL_A: /* Ctrl+a, go to the start of the line */
            linenoiseEditMoveHome(&l);
            break;
        case CTRL_E: /* ctrl+e, go to the end of the line */
            linenoiseEditMoveEnd(&l);
            break;
        case CTRL_L: /* ctrl+l, clear screen */
            linenoiseClearScreen();
            refreshLine(&l);
            break;
        case CTRL_W: /* ctrl+w, delete previous word */
            linenoiseEditDeletePrevWord(&l);
            break;
        }
    }
    return l.len;
}

/* This special mode is used by linenoise in order to print scan codes
 * on screen for debugging / development purposes. It is implemented
 * by the linenoise_example program using the --keycodes option. */
void linenoisePrintKeyCodes(void) {
    char quit[4];

    printf("Linenoise key codes debugging mode.\n"
            "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
    if (enableRawMode(STDIN_FILENO) == -1) return;
    memset(quit,' ',4);
    while(1) {
        char c;
        int nread;

        nread = read(STDIN_FILENO,&c,1);
        if (nread <= 0) continue;
        memmove(quit,quit+1,sizeof(quit)-1); /* shift string to left. */
        quit[sizeof(quit)-1] = c; /* Insert current char on the right. */
        if (memcmp(quit,"quit",sizeof(quit)) == 0) break;

        printf("'%c' %02x (%d) (type quit to exit)\n",
            isprint(c) ? c : '?', (int)c, (int)c);
        printf("\r"); /* Go left edge manually, we are in raw mode. */
        fflush(stdout);
    }
    disableRawMode(STDIN_FILENO);
}

/* This function calls the line editing function linenoiseEdit() using
 * the STDIN file descriptor set in raw mode. */
static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
    int count;

    if (buflen == 0) {
        errno = EINVAL;
        return -1;
    }

    if (enableRawMode(STDIN_FILENO) == -1) return -1;
    count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
    disableRawMode(STDIN_FILENO);
    printf("\n");
    return count;
}

/* This function is called when linenoise() is called with the standard
 * input file descriptor not attached to a TTY. So for example when the
 * program using linenoise is called in pipe or with a file redirected
 * to its standard input. In this case, we want to be able to return the
 * line regardless of its length (by default we are limited to 4k). */
static char *linenoiseNoTTY(void) {
    char *line = NULL;
    size_t len = 0, maxlen = 0;

    while(1) {
        if (len == maxlen) {
            if (maxlen == 0) maxlen = 16;
            maxlen *= 2;
            char *oldval = line;
            line = (char*)realloc(line,maxlen);
            if (line == NULL) {
                if (oldval) free(oldval);
                return NULL;
            }
        }
        int c = fgetc(stdin);
        if (c == EOF || c == '\n') {
            if (c == EOF && len == 0) {
                free(line);
                return NULL;
            } else {
                line[len] = '\0';
                return line;
            }
        } else {
            line[len] = c;
            len++;
        }
    }
}

/* The high level function that is the main API of the linenoise library.
 * This function checks if the terminal has basic capabilities, just checking
 * for a blacklist of stupid terminals, and later either calls the line
 * editing function or uses dummy fgets() so that you will be able to type
 * something even in the most desperate of the conditions. */
char *linenoise(const char *prompt) {
    char buf[LINENOISE_MAX_LINE];
    int count;

    if (!isatty(STDIN_FILENO)) {
        /* Not a tty: read from file / pipe. In this mode we don't want any
         * limit to the line size, so we call a function to handle that. */
        return linenoiseNoTTY();
    } else if (isUnsupportedTerm()) {
        size_t len;

        printf("%s",prompt);
        fflush(stdout);
        if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;
        len = strlen(buf);
        while(len && (buf[len-1] == '\n' || buf[len-1] == '\r')) {
            len--;
            buf[len] = '\0';
        }
        return strdup(buf);
    } else {
        count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);
        if (count == -1) return NULL;
        return strdup(buf);
    }
}

/* This is just a wrapper the user may want to call in order to make sure
 * the linenoise returned buffer is freed with the same allocator it was
 * created with. Useful when the main program is using an alternative
 * allocator. */
void linenoiseFree(void *ptr) {
    free(ptr);
}

/* ================================ History ================================= */

/* Free the history, but does not reset it. Only used when we have to
 * exit() to avoid memory leaks are reported by valgrind & co. */
static void freeHistory(void) {
    if (history) {
        int j;

        for (j = 0; j < history_len; j++)
            free(history[j]);
        free(history);
    }
}

/* At exit we'll try to fix the terminal to the initial conditions. */
static void linenoiseAtExit(void) {
    disableRawMode(STDIN_FILENO);
    freeHistory();
}

/* This is the API call to add a new entry in the linenoise history.
 * It uses a fixed array of char pointers that are shifted (memmoved)
 * when the history max length is reached in order to remove the older
 * entry and make room for the new one, so it is not exactly suitable for huge
 * histories, but will work well for a few hundred of entries.
 *
 * Using a circular buffer is smarter, but a bit more complex to handle. */
int linenoiseHistoryAdd(const char *line) {
    char *linecopy;

    if (history_max_len == 0) return 0;

    /* Initialization on first call. */
    if (history == NULL) {
        history = (char**)malloc(sizeof(char*)*history_max_len);
        if (history == NULL) return 0;
        memset(history,0,(sizeof(char*)*history_max_len));
    }

    /* Don't add duplicated lines. */
    if (history_len && !strcmp(history[history_len-1], line)) return 0;

    /* Add an heap allocated copy of the line in the history.
     * If we reached the max length, remove the older line. */
    linecopy = strdup(line);
    if (!linecopy) return 0;
    if (history_len == history_max_len) {
        free(history[0]);
        memmove(history,history+1,sizeof(char*)*(history_max_len-1));
        history_len--;
    }
    history[history_len] = linecopy;
    history_len++;
    return 1;
}

/* Set the maximum length for the history. This function can be called even
 * if there is already some history, the function will make sure to retain
 * just the latest 'len' elements if the new history length value is smaller
 * than the amount of items already inside the history. */
int linenoiseHistorySetMaxLen(int len) {
    char **newc;

    if (len < 1) return 0;
    if (history) {
        int tocopy = history_len;

        newc = (char**)malloc(sizeof(char*)*len);
        if (newc == NULL) return 0;

        /* If we can't copy everything, free the elements we'll not use. */
        if (len < tocopy) {
            int j;

            for (j = 0; j < tocopy-len; j++) free(history[j]);
            tocopy = len;
        }
        memset(newc,0,sizeof(char*)*len);
        memcpy(newc,history+(history_len-tocopy), sizeof(char*)*tocopy);
        free(history);
        history = newc;
    }
    history_max_len = len;
    if (history_len > history_max_len)
        history_len = history_max_len;
    return 1;
}

/* Save the history in the specified file. On success 0 is returned
 * otherwise -1 is returned. */
int linenoiseHistorySave(const char *filename) {
    mode_t old_umask = umask(S_IXUSR|S_IRWXG|S_IRWXO);
    FILE *fp;
    int j;

    fp = fopen(filename,"w");
    umask(old_umask);
    if (fp == NULL) return -1;
    chmod(filename,S_IRUSR|S_IWUSR);
    for (j = 0; j < history_len; j++)
        fprintf(fp,"%s\n",history[j]);
    fclose(fp);
    return 0;
}

/* Load the history from the specified file. If the file does not exist
 * zero is returned and no operation is performed.
 *
 * If the file exists and the operation succeeded 0 is returned, otherwise
 * on error -1 is returned. */
int linenoiseHistoryLoad(const char *filename) {
    FILE *fp = fopen(filename,"r");
    char buf[LINENOISE_MAX_LINE];

    if (fp == NULL) return -1;

    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
        char *p;

        p = strchr(buf,'\r');
        if (!p) p = strchr(buf,'\n');
        if (p) *p = '\0';
        linenoiseHistoryAdd(buf);
    }
    fclose(fp);
    return 0;
}
#endif //JSI__READLINE==1
struct jsi_Pstate;
#if defined(_WIN32) || defined(WIN32)
#ifndef JSI_WIN32COMPAT_H
#define JSI_WIN32COMPAT_H

typedef unsigned int uint;
/* TODO: bring in external regex ..
typedef struct { int n; } regex_t;
typedef struct { int n; } regmatch_t; */

enum {
    DT_UNKNOWN = 0, DT_FIFO = 1, DT_CHR = 2, DT_DIR = 4,
    DT_BLK = 6, DT_REG = 8, DT_LNK = 10, DT_SOCK = 12, DT_WHT = 14
};


/* Compatibility for Windows (mingw and msvc, not cygwin */

#include <time.h>
#include <dirent.h>
char * strptime(const char *buf, const char *fmt, struct tm *tm);

#define MAXNAMLEN FILENAME_MAX 
int scandir( const char *dirname, struct dirent ***namelist, int (*select)(const struct dirent *), 
     int (*compar)( const struct dirent **, const struct dirent ** ) 
);
int alphasort( const struct dirent **d1, const struct dirent **d2 ); 
int istrcmp( const char *s1, const char *s2 ); 

#define HAVE_DLOPEN
void *dlopen(const char *path, int mode);
int dlclose(void *handle);
void *dlsym(void *handle, const char *symbol);
char *dlerror(void);

extern time_t internal_timegm(struct tm *t);

/* MS CRT always uses three digits after 'e' */
#define JSI_SPRINTF_DOUBLE_NEEDS_FIX

#ifdef _MSC_VER
/* These are msvc vs gcc */

#if _MSC_VER >= 1000
    #pragma warning(disable:4146)
#endif

#include <limits.h>
#define jsi_wide _int64
#ifndef LLONG_MAX
    #define LLONG_MAX    9223372036854775807I64
#endif
#ifndef LLONG_MIN
    #define LLONG_MIN    (-LLONG_MAX - 1I64)
#endif
#define JSI_WIDE_MIN LLONG_MIN
#define JSI_WIDE_MAX LLONG_MAX
#define JSI_WIDE_MODIFIER "I64d"
#define strcasecmp _stricmp
#define strtoull _strtoui64
#define snprintf _snprintf

#include <io.h>

struct timeval {
    long tv_sec;
    long tv_usec;
};

int gettimeofday(struct timeval *tv, void *unused);

#define HAVE_OPENDIR
struct dirent {
    char *d_name;
};

typedef struct DIR {
    long                handle; /* -1 for failed rewind */
    struct _finddata_t  info;
    struct dirent       result; /* d_name null iff first time */
    char                *name;  /* null-terminated char string */
} DIR;

DIR *opendir(const char *name);
int closedir(DIR *dir);
struct dirent *readdir(DIR *dir);
#endif /* _MSC_VER */

#endif


#endif /* WIN32 */
#ifndef _REGEX_H
#define _REGEX_H

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__WIN32) || defined(__FreeBSD__)
#define CHARCLASS_NAME_MAX 14
#define RE_DUP_MAX 255
#else
#include <features.h>
#endif

#if __STDC_VERSION__ < 199901L
#define restrict /* nothing */
#endif

#define __NEED_regoff_t
#define __NEED_size_t

//#include <bits/alltypes.h>

typedef struct re_pattern_buffer {
    size_t re_nsub;
    void *__opaque, *__padding[4];
    size_t __nsub2;
    char __padding2;
} regex_t;

#ifndef regoff_t
#define regoff_t int
#endif

typedef struct {
    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;

#define REG_EXTENDED    1
#define REG_ICASE       2
#define REG_NEWLINE     4
#define REG_NOSUB       8

#define REG_NOTBOL      1
#define REG_NOTEOL      2

#define REG_OK          0
#define REG_NOMATCH     1
#define REG_BADPAT      2
#define REG_ECOLLATE    3
#define REG_ECTYPE      4
#define REG_EESCAPE     5
#define REG_ESUBREG     6
#define REG_EBRACK      7
#define REG_EPAREN      8
#define REG_EBRACE      9
#define REG_BADBR       10
#define REG_ERANGE      11
#define REG_ESPACE      12
#define REG_BADRPT      13

#define REG_ENOSYS      -1

int regcomp(regex_t *__restrict, const char *__restrict, int);
int regexec(const regex_t *__restrict, const char *__restrict, size_t, regmatch_t *__restrict, int);
void regfree(regex_t *);

size_t regerror(int, const regex_t *__restrict, char *__restrict, size_t);

#ifdef __cplusplus
}
#endif

#endif
/*
  tre-internal.h - TRE internal definitions

  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef JSI_AMALGAMATION
#include <regex.h>
#endif
#include <wchar.h>
#include <wctype.h>

#undef  TRE_MBSTATE

//#define NDEBUG

#define TRE_REGEX_T_FIELD __opaque
typedef int reg_errcode_t;

typedef wchar_t tre_char_t;

#define DPRINT(msg) do { } while(0)

#define elementsof(x)	( sizeof(x) / sizeof(x[0]) )

#define tre_mbrtowc(pwc, s, n, ps) (mbtowc((pwc), (s), (n)))

/* Wide characters. */
typedef wint_t tre_cint_t;
#define TRE_CHAR_MAX 0x10ffff

#define tre_isalnum iswalnum
#define tre_isalpha iswalpha
#define tre_isblank iswblank
#define tre_iscntrl iswcntrl
#define tre_isdigit iswdigit
#define tre_isgraph iswgraph
#define tre_islower iswlower
#define tre_isprint iswprint
#define tre_ispunct iswpunct
#define tre_isspace iswspace
#define tre_isupper iswupper
#define tre_isxdigit iswxdigit

#define tre_tolower towlower
#define tre_toupper towupper
#define tre_strlen  wcslen

/* Use system provided iswctype() and wctype(). */
typedef wctype_t tre_ctype_t;
#define tre_isctype iswctype
#define tre_ctype   wctype

/* Returns number of bytes to add to (char *)ptr to make it
   properly aligned for the type. */
#define ALIGN(ptr, type) \
  ((((long)ptr) % sizeof(type)) \
   ? (sizeof(type) - (((long)ptr) % sizeof(type))) \
   : 0)

#undef MAX
#undef MIN
#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define MIN(a, b) (((a) <= (b)) ? (a) : (b))

/* TNFA transition type. A TNFA state is an array of transitions,
   the terminator is a transition with NULL `state'. */
typedef struct tnfa_transition tre_tnfa_transition_t;

struct tnfa_transition {
  /* Range of accepted characters. */
  tre_cint_t code_min;
  tre_cint_t code_max;
  /* Pointer to the destination state. */
  tre_tnfa_transition_t *state;
  /* ID number of the destination state. */
  int state_id;
  /* -1 terminated array of tags (or NULL). */
  int *tags;
  /* Assertion bitmap. */
  int assertions;
  /* Assertion parameters. */
  union {
    /* Character class assertion. */
    tre_ctype_t rclass;
    /* Back reference assertion. */
    int backref;
  } u;
  /* Negative character class assertions. */
  tre_ctype_t *neg_classes;
};


/* Assertions. */
#define ASSERT_AT_BOL		  1   /* Beginning of line. */
#define ASSERT_AT_EOL		  2   /* End of line. */
#define ASSERT_CHAR_CLASS	  4   /* Character class in `class'. */
#define ASSERT_CHAR_CLASS_NEG	  8   /* Character classes in `neg_classes'. */
#define ASSERT_AT_BOW		 16   /* Beginning of word. */
#define ASSERT_AT_EOW		 32   /* End of word. */
#define ASSERT_AT_WB		 64   /* Word boundary. */
#define ASSERT_AT_WB_NEG	128   /* Not a word boundary. */
#define ASSERT_BACKREF		256   /* A back reference in `backref'. */
#define ASSERT_LAST		256

/* Tag directions. */
typedef enum {
  TRE_TAG_MINIMIZE = 0,
  TRE_TAG_MAXIMIZE = 1
} tre_tag_direction_t;

/* Instructions to compute submatch register values from tag values
   after a successful match.  */
struct tre_submatch_data {
  /* Tag that gives the value for rm_so (submatch start offset). */
  int so_tag;
  /* Tag that gives the value for rm_eo (submatch end offset). */
  int eo_tag;
  /* List of submatches this submatch is contained in. */
  int *parents;
};

typedef struct tre_submatch_data tre_submatch_data_t;


/* TNFA definition. */
typedef struct tnfa tre_tnfa_t;

struct tnfa {
  tre_tnfa_transition_t *transitions;
  unsigned int num_transitions;
  tre_tnfa_transition_t *initial;
  tre_tnfa_transition_t *final;
  tre_submatch_data_t *submatch_data;
  char *firstpos_chars;
  int first_char;
  unsigned int num_submatches;
  tre_tag_direction_t *tag_directions;
  int *minimal_tags;
  int num_tags;
  int num_minimals;
  int end_tag;
  int num_states;
  int cflags;
  int have_backrefs;
  int have_approx;
};

/* from tre-mem.h: */

#define TRE_MEM_BLOCK_SIZE 1024

typedef struct tre_list {
  void *data;
  struct tre_list *next;
} tre_list_t;

typedef struct tre_mem_struct {
  tre_list_t *blocks;
  tre_list_t *current;
  char *ptr;
  size_t n;
  int failed;
  void **provided;
} *tre_mem_t;

#define tre_mem_new_impl   __tre_mem_new_impl
#define tre_mem_alloc_impl __tre_mem_alloc_impl
#define tre_mem_destroy    __tre_mem_destroy

tre_mem_t tre_mem_new_impl(int provided, void *provided_block);
void *tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
			 int zero, size_t size);

/* Returns a new memory allocator or NULL if out of memory. */
#define tre_mem_new()  tre_mem_new_impl(0, NULL)

/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
   allocated block or NULL if an underlying malloc() failed. */
#define tre_mem_alloc(mem, size) tre_mem_alloc_impl((tre_mem_t)mem, 0, NULL, 0, size)

/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
   allocated block or NULL if an underlying malloc() failed.  The memory
   is set to zero. */
#define tre_mem_calloc(mem, size) tre_mem_alloc_impl((tre_mem_t)mem, 0, NULL, 1, size)

#ifdef TRE_USE_ALLOCA
/* alloca() versions.  Like above, but memory is allocated with alloca()
   instead of malloc(). */

#define tre_mem_newa() \
  tre_mem_new_impl(1, alloca(sizeof(struct tre_mem_struct)))

#define tre_mem_alloca(mem, size)					      \
  ((mem)->n >= (size)							      \
   ? tre_mem_alloc_impl((mem), 1, NULL, 0, (size))			      \
   : tre_mem_alloc_impl((mem), 1, alloca(TRE_MEM_BLOCK_SIZE), 0, (size)))
#endif /* TRE_USE_ALLOCA */


/* Frees the memory allocator and all memory allocated with it. */
void tre_mem_destroy(tre_mem_t mem);

#define xmalloc malloc
#define xcalloc calloc
#define xfree free
#define xrealloc realloc

/*
  regcomp.c - TRE POSIX compatible regex compilation functions.

  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdint.h>
#include <ctype.h>

#ifndef JSI_AMALGAMATION
#include <regex.h>
#include "tre.h"
#endif

#include <assert.h>

/***********************************************************************
 from tre-compile.h
***********************************************************************/

typedef struct {
  int position;
  int code_min;
  int code_max;
  int *tags;
  int assertions;
  tre_ctype_t rclass;
  tre_ctype_t *neg_classes;
  int backref;
} tre_pos_and_tags_t;


/***********************************************************************
 from tre-ast.c and tre-ast.h
***********************************************************************/

/* The different AST node types. */
typedef enum {
  LITERAL,
  CATENATION,
  ITERATION,
  UNION
} tre_ast_type_t;

/* Special subtypes of TRE_LITERAL. */
#define EMPTY     -1   /* Empty leaf (denotes empty string). */
#define ASSERTION -2   /* Assertion leaf. */
#define TAG   -3   /* Tag leaf. */
#define BACKREF   -4   /* Back reference leaf. */

#define IS_SPECIAL(x)   ((x)->code_min < 0)
#define IS_EMPTY(x) ((x)->code_min == EMPTY)
#define IS_ASSERTION(x) ((x)->code_min == ASSERTION)
#define IS_TAG(x)   ((x)->code_min == TAG)
#define IS_BACKREF(x)   ((x)->code_min == BACKREF)


/* A generic AST node.  All AST nodes consist of this node on the top
   level with `obj' pointing to the actual content. */
typedef struct {
  tre_ast_type_t type;   /* Type of the node. */
  void *obj;             /* Pointer to actual node. */
  int nullable;
  int submatch_id;
  int num_submatches;
  int num_tags;
  tre_pos_and_tags_t *firstpos;
  tre_pos_and_tags_t *lastpos;
} tre_ast_node_t;


/* A "literal" node.  These are created for assertions, back references,
   tags, matching parameter settings, and all expressions that match one
   character. */
typedef struct {
  long code_min;
  long code_max;
  int position;
  tre_ctype_t rclass;
  tre_ctype_t *neg_classes;
} tre_literal_t;

/* A "catenation" node.  These are created when two regexps are concatenated.
   If there are more than one subexpressions in sequence, the `left' part
   holds all but the last, and `right' part holds the last subexpression
   (catenation is left associative). */
typedef struct {
  tre_ast_node_t *left;
  tre_ast_node_t *right;
} tre_catenation_t;

/* An "iteration" node.  These are created for the "*", "+", "?", and "{m,n}"
   operators. */
typedef struct {
  /* Subexpression to match. */
  tre_ast_node_t *arg;
  /* Minimum number of consecutive matches. */
  int min;
  /* Maximum number of consecutive matches. */
  int max;
  /* If 0, match as many characters as possible, if 1 match as few as
     possible.  Note that this does not always mean the same thing as
     matching as many/few repetitions as possible. */
  unsigned int minimal:1;
} tre_iteration_t;

/* An "union" node.  These are created for the "|" operator. */
typedef struct {
  tre_ast_node_t *left;
  tre_ast_node_t *right;
} tre_union_t;


static tre_ast_node_t *
tre_ast_new_node(tre_mem_t mem, int type, void *obj)
{
    tre_ast_node_t *node = (tre_ast_node_t *)tre_mem_calloc(mem, sizeof *node);
    if (!node || !obj)
        return 0;
    node->obj = obj;
    node->type = (tre_ast_type_t)type;
    node->nullable = -1;
    node->submatch_id = -1;
    return node;
}

static tre_ast_node_t *
tre_ast_new_literal(tre_mem_t mem, int code_min, int code_max, int position)
{
    tre_ast_node_t *node;
    tre_literal_t *lit;

    lit = (tre_literal_t *)tre_mem_calloc(mem, sizeof *lit);
    node = tre_ast_new_node(mem, LITERAL, lit);
    if (!node)
        return 0;
    lit->code_min = code_min;
    lit->code_max = code_max;
    lit->position = position;
    return node;
}

static tre_ast_node_t *
tre_ast_new_iter(tre_mem_t mem, tre_ast_node_t *arg, int min, int max, int minimal)
{
    tre_ast_node_t *node;
    tre_iteration_t *iter;

    iter = (tre_iteration_t *)tre_mem_calloc(mem, sizeof *iter);
    node = tre_ast_new_node(mem, ITERATION, iter);
    if (!node)
        return 0;
    iter->arg = arg;
    iter->min = min;
    iter->max = max;
    iter->minimal = minimal;
    node->num_submatches = arg->num_submatches;
    return node;
}

static tre_ast_node_t *
tre_ast_new_union(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
{
    tre_ast_node_t *node;
    tre_union_t *un;

    if (!left)
        return right;
    un = (tre_union_t *)tre_mem_calloc(mem, sizeof *un);
    node = tre_ast_new_node(mem, UNION, un);
    if (!node || !right)
        return 0;
    un->left = left;
    un->right = right;
    node->num_submatches = left->num_submatches + right->num_submatches;
    return node;
}

static tre_ast_node_t *
tre_ast_new_catenation(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
{
    tre_ast_node_t *node;
    tre_catenation_t *cat;

    if (!left)
        return right;
    cat =(tre_catenation_t *) tre_mem_calloc(mem, sizeof *cat);
    node = tre_ast_new_node(mem, CATENATION, cat);
    if (!node)
        return 0;
    cat->left = left;
    cat->right = right;
    node->num_submatches = left->num_submatches + right->num_submatches;
    return node;
}


/***********************************************************************
 from tre-stack.c and tre-stack.h
***********************************************************************/

typedef struct tre_stack_rec tre_stack_t;

/* Creates a new stack object.  `size' is initial size in bytes, `max_size'
   is maximum size, and `increment' specifies how much more space will be
   allocated with realloc() if all space gets used up.  Returns the stack
   object or NULL if out of memory. */
static tre_stack_t *
tre_stack_new(int size, int max_size, int increment);

/* Frees the stack object. */
static void
tre_stack_destroy(tre_stack_t *s);

/* Returns the current number of objects in the stack. */
static int
tre_stack_num_objects(tre_stack_t *s);

/* Each tre_stack_push_*(tre_stack_t *s, <type> value) function pushes
   `value' on top of stack `s'.  Returns REG_ESPACE if out of memory.
   This tries to realloc() more space before failing if maximum size
   has not yet been reached.  Returns REG_OK if successful. */
#define declare_pushf(typetag, type)                          \
  static reg_errcode_t tre_stack_push_ ## typetag(tre_stack_t *s, type value)

declare_pushf(voidptr, void *);
declare_pushf(int, int);

/* Each tre_stack_pop_*(tre_stack_t *s) function pops the topmost
   element off of stack `s' and returns it.  The stack must not be
   empty. */
#define declare_popf(typetag, type)       \
  static type tre_stack_pop_ ## typetag(tre_stack_t *s)

declare_popf(voidptr, void *);
declare_popf(int, int);

/* Just to save some typing. */
#define STACK_PUSH(s, typetag, value)                         \
  do                                          \
    {                                         \
      status = tre_stack_push_ ## typetag(s, value);                  \
    }                                         \
  while (/*CONSTCOND*/0)

#define STACK_PUSHX(s, typetag, value)                        \
  {                                       \
    status = tre_stack_push_ ## typetag(s, value);                \
    if (status != REG_OK)                             \
      break;                                      \
  }

#define STACK_PUSHR(s, typetag, value)                        \
  {                                       \
    reg_errcode_t _status;                            \
    _status = tre_stack_push_ ## typetag(s, value);               \
    if (_status != REG_OK)                            \
      return _status;                                 \
  }

union tre_stack_item {
  void *voidptr_value;
  int int_value;
};

struct tre_stack_rec {
  int size;
  int max_size;
  int increment;
  int ptr;
  union tre_stack_item *stack;
};


static tre_stack_t *
tre_stack_new(int size, int max_size, int increment)
{
  tre_stack_t *s;

  s = (tre_stack_t *)xmalloc(sizeof(*s));
  if (s != NULL)
    {
      s->stack = (union tre_stack_item*)xmalloc(sizeof(*s->stack) * size);
      if (s->stack == NULL)
    {
      xfree(s);
      return NULL;
    }
      s->size = size;
      s->max_size = max_size;
      s->increment = increment;
      s->ptr = 0;
    }
  return s;
}

static void
tre_stack_destroy(tre_stack_t *s)
{
  xfree(s->stack);
  xfree(s);
}

static int
tre_stack_num_objects(tre_stack_t *s)
{
  return s->ptr;
}

static reg_errcode_t
tre_stack_push(tre_stack_t *s, union tre_stack_item value)
{
  if (s->ptr < s->size)
    {
      s->stack[s->ptr] = value;
      s->ptr++;
    }
  else
    {
      if (s->size >= s->max_size)
    {
      return REG_ESPACE;
    }
      else
    {
      union tre_stack_item *new_buffer;
      int new_size;
      new_size = s->size + s->increment;
      if (new_size > s->max_size)
        new_size = s->max_size;
      new_buffer = (union tre_stack_item *)xrealloc(s->stack, sizeof(*new_buffer) * new_size);
      if (new_buffer == NULL)
        {
          return REG_ESPACE;
        }
      assert(new_size > s->size);
      s->size = new_size;
      s->stack = new_buffer;
      tre_stack_push(s, value);
    }
    }
  return REG_OK;
}

#define define_pushf(typetag, type)  \
  declare_pushf(typetag, type) {     \
    union tre_stack_item item;       \
    item.typetag ## _value = value;  \
    return tre_stack_push(s, item);  \
}

define_pushf(int, int)
define_pushf(voidptr, void *)

#define define_popf(typetag, type)          \
  declare_popf(typetag, type) {             \
    return s->stack[--s->ptr].typetag ## _value;    \
  }

define_popf(int, int)
define_popf(voidptr, void *)


/***********************************************************************
 from tre-parse.c and tre-parse.h
***********************************************************************/

/* Parse context. */
typedef struct {
    /* Memory allocator. The AST is allocated using this. */
    tre_mem_t mem;
    /* Stack used for keeping track of regexp syntax. */
    tre_stack_t *stack;
    /* The parsed node after a parse function returns. */
    tre_ast_node_t *n;
    /* Position in the regexp pattern after a parse function returns. */
    const char *s;
    /* The first character of the regexp. */
    const char *re;
    /* Current submatch ID. */
    int submatch_id;
    /* Current position (number of literal). */
    int position;
    /* The highest back reference or -1 if none seen so far. */
    int max_backref;
    /* Compilation flags. */
    int cflags;
} tre_parse_ctx_t;

/* Some macros for expanding \w, \s, etc. */
static const struct {
    char c;
    const char *expansion;
} tre_macros[] = {
    {'t', "\t"}, {'n', "\n"}, {'r', "\r"},
    {'f', "\f"}, {'a', "\a"}, {'e', "\033"},
    {'w', "[[:alnum:]_]"}, {'W', "[^[:alnum:]_]"}, {'s', "[[:space:]]"},
    {'S', "[^[:space:]]"}, {'d', "[[:digit:]]"}, {'D', "[^[:digit:]]"},
    { 0, 0 }
};

/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
   must have at least `len' items.  Sets buf[0] to zero if the there
   is no match in `tre_macros'. */
static const char *tre_expand_macro(const char *s)
{
    int i;
    for (i = 0; tre_macros[i].c && tre_macros[i].c != *s; i++);
    return tre_macros[i].expansion;
}

static int
tre_compare_lit(const void *a, const void *b)
{
    const tre_literal_t *const *la = (const tre_literal_t *const *)a;
    const tre_literal_t *const *lb = (const tre_literal_t *const *)b;
    /* assumes the range of valid code_min is < INT_MAX */
    return la[0]->code_min - lb[0]->code_min;
}

struct literals {
    tre_mem_t mem;
    tre_literal_t **a;
    int len;
    int cap;
};

static tre_literal_t *tre_new_lit(struct literals *p)
{
    tre_literal_t **a;
    if (p->len >= p->cap) {
        if (p->cap >= 1<<15)
            return 0;
        p->cap *= 2;
        a = (tre_literal_t**)xrealloc(p->a, p->cap * sizeof *p->a);
        if (!a)
            return 0;
        p->a = a;
    }
    a = p->a + p->len++;
    *a = (tre_literal_t*)tre_mem_calloc((tre_literal_t*)p->mem, sizeof **a);
    return *a;
}

static int add_icase_literals(struct literals *ls, int min, int max)
{
    tre_literal_t *lit;
    int b, e, c;
    for (c=min; c<=max; ) {
        /* assumes islower(c) and isupper(c) are exclusive
           and toupper(c)!=c if islower(c).
           multiple opposite case characters are not supported */
        if (tre_islower(c)) {
            b = e = tre_toupper(c);
            for (c++, e++; c<=max; c++, e++)
                if ((int)tre_toupper(c) != e) break;
        } else if (tre_isupper(c)) {
            b = e = tre_tolower(c);
            for (c++, e++; c<=max; c++, e++)
                if ((int)tre_tolower(c) != e) break;
        } else {
            c++;
            continue;
        }
        lit = tre_new_lit(ls);
        if (!lit)
            return -1;
        lit->code_min = b;
        lit->code_max = e-1;
        lit->position = -1;
    }
    return 0;
}


/* Maximum number of character classes in a negated bracket expression. */
#define MAX_NEG_CLASSES 64

struct neg {
    int negate;
    int len;
    tre_ctype_t a[MAX_NEG_CLASSES];
};

// TODO: parse bracket into a set of non-overlapping [lo,hi] ranges

/*
bracket grammar:
Bracket  =  '[' List ']'  |  '[^' List ']'
List     =  Term  |  List Term
Term     =  Char  |  Range  |  Chclass  |  Eqclass
Range    =  Char '-' Char  |  Char '-' '-'
Char     =  Coll  |  coll_single
Meta     =  ']'  |  '-'
Coll     =  '[.' coll_single '.]'  |  '[.' coll_multi '.]'  |  '[.' Meta '.]'
Eqclass  =  '[=' coll_single '=]'  |  '[=' coll_multi '=]'
Chclass  =  '[:' rclass ':]'

coll_single is a single char collating element but it can be
 '-' only at the beginning or end of a List and
 ']' only at the beginning of a List and
 '^' anywhere except after the openning '['
*/

static reg_errcode_t parse_bracket_terms(tre_parse_ctx_t *ctx, const char *s, struct literals *ls, struct neg *neg)
{
    const char *start = s;
    tre_ctype_t rclass;
    int min, max;
    wchar_t wc;
    int len;

    for (;;) {
        rclass = 0;
        len = mbtowc(&wc, s, -1);
        if (len <= 0)
            return *s ? REG_BADPAT : REG_EBRACK;
        if (*s == ']' && s != start) {
            ctx->s = s+1;
            return REG_OK;
        }
        if (*s == '-' && s != start && s[1] != ']' &&
            /* extension: [a-z--@] is accepted as [a-z]|[--@] */
            (s[1] != '-' || s[2] == ']'))
            return REG_ERANGE;
        if (*s == '[' && (s[1] == '.' || s[1] == '='))
            /* collating symbols and equivalence classes are not supported */
            return REG_ECOLLATE;
        if (*s == '[' && s[1] == ':') {
            char tmp[CHARCLASS_NAME_MAX+1];
            s += 2;
            for (len=0; len < CHARCLASS_NAME_MAX && s[len]; len++) {
                if (s[len] == ':') {
                    memcpy(tmp, s, len);
                    tmp[len] = 0;
                    rclass = tre_ctype(tmp);
                    break;
                }
            }
            if (!rclass || s[len+1] != ']')
                return REG_ECTYPE;
            min = 0;
            max = TRE_CHAR_MAX;
            s += len+2;
        } else {
            min = max = wc;
            s += len;
            if (*s == '-' && s[1] != ']') {
                s++;
                len = mbtowc(&wc, s, -1);
                max = wc;
                /* XXX - Should use collation order instead of
                   encoding values in character ranges. */
                if (len <= 0 || min > max)
                    return REG_ERANGE;
                s += len;
            }
        }

        if (rclass && neg->negate) {
            if (neg->len >= MAX_NEG_CLASSES)
                return REG_ESPACE;
            neg->a[neg->len++] = rclass;
        } else  {
            tre_literal_t *lit = tre_new_lit(ls);
            if (!lit)
                return REG_ESPACE;
            lit->code_min = min;
            lit->code_max = max;
            lit->rclass = rclass;
            lit->position = -1;

            /* Add opposite-case codepoints if REG_ICASE is present.
               It seems that POSIX requires that bracket negation
               should happen before case-folding, but most practical
               implementations do it the other way around. Changing
               the order would need efficient representation of
               case-fold ranges and bracket range sets even with
               simple patterns so this is ok for now. */
            if (ctx->cflags & REG_ICASE && !rclass)
                if (add_icase_literals(ls, min, max))
                    return REG_ESPACE;
        }
    }
}

static reg_errcode_t parse_bracket(tre_parse_ctx_t *ctx, const char *s)
{
    int i, max, min, negmax, negmin;
    tre_ast_node_t *node = 0, *n;
    tre_ctype_t *nc = 0;
    tre_literal_t *lit;
    struct literals ls;
    struct neg neg;
    reg_errcode_t err;

    ls.mem = ctx->mem;
    ls.len = 0;
    ls.cap = 32;
    ls.a = (tre_literal_t**)xmalloc(ls.cap * sizeof *ls.a);
    if (!ls.a)
        return REG_ESPACE;
    neg.len = 0;
    neg.negate = *s == '^';
    if (neg.negate)
        s++;

    err = parse_bracket_terms(ctx, s, &ls, &neg);
    if (err != REG_OK)
        goto parse_bracket_done;

    if (neg.negate) {
        /* Sort the array if we need to negate it. */
        qsort(ls.a, ls.len, sizeof *ls.a, tre_compare_lit);
        /* extra lit for the last negated range */
        lit = tre_new_lit(&ls);
        if (!lit) {
            err = REG_ESPACE;
            goto parse_bracket_done;
        }
        lit->code_min = TRE_CHAR_MAX+1;
        lit->code_max = TRE_CHAR_MAX+1;
        lit->position = -1;
        /* negated classes */
        if (neg.len) {
            nc = (tre_ctype_t*)tre_mem_alloc(ctx->mem, (neg.len+1)*sizeof *neg.a);
            if (!nc) {
                err = REG_ESPACE;
                goto parse_bracket_done;
            }
            memcpy(nc, neg.a, neg.len*sizeof *neg.a);
            nc[neg.len] = 0;
        }
    }

    /* Build a union of the items in the array, negated if necessary. */
    negmax = negmin = 0;
    for (i = 0; i < ls.len; i++) {
        lit = ls.a[i];
        min = lit->code_min;
        max = lit->code_max;
        if (neg.negate) {
            if (min <= negmin) {
                /* Overlap. */
                negmin = MAX(max + 1, negmin);
                continue;
            }
            negmax = min - 1;
            lit->code_min = negmin;
            lit->code_max = negmax;
            negmin = max + 1;
        }
        lit->position = ctx->position;
        lit->neg_classes = nc;
        n = tre_ast_new_node(ctx->mem, LITERAL, lit);
        node = tre_ast_new_union(ctx->mem, node, n);
        if (!node) {
            err = REG_ESPACE;
            break;
        }
    }

parse_bracket_done:
    xfree(ls.a);
    ctx->position++;
    ctx->n = node;
    return err;
}

static const char *parse_dup_count(const char *s, int *n)
{
    *n = -1;
    if (!isdigit(*s))
        return s;
    *n = 0;
    for (;;) {
        *n = 10 * *n + (*s - '0');
        s++;
        if (!isdigit(*s) || *n > RE_DUP_MAX)
            break;
    }
    return s;
}

static reg_errcode_t parse_dup(tre_parse_ctx_t *ctx, const char *s)
{
    int min, max;

    s = parse_dup_count(s, &min);
    if (*s == ',')
        s = parse_dup_count(s+1, &max);
    else
        max = min;

    if (
        (max < min && max >= 0) ||
        max > RE_DUP_MAX ||
        min > RE_DUP_MAX ||
        min < 0 ||
        (!(ctx->cflags & REG_EXTENDED) && *s++ != '\\') ||
        *s++ != '}'
    )
        return REG_BADBR;

    if (min == 0 && max == 0)
        ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
    else
        ctx->n = tre_ast_new_iter(ctx->mem, ctx->n, min, max, 0);
    if (!ctx->n)
        return REG_ESPACE;
    ctx->s = s;
    return REG_OK;
}

static int hexval(unsigned c)
{
    if (c-'0'<10) return c-'0';
    c |= 32;
    if (c-'a'<6) return c-'a'+10;
    return -1;
}

static reg_errcode_t marksub(tre_parse_ctx_t *ctx, tre_ast_node_t *node, int subid)
{
    if (node->submatch_id >= 0) {
        tre_ast_node_t *n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
        if (!n)
            return REG_ESPACE;
        n = tre_ast_new_catenation(ctx->mem, n, node);
        if (!n)
            return REG_ESPACE;
        n->num_submatches = node->num_submatches;
        node = n;
    }
    node->submatch_id = subid;
    node->num_submatches++;
    ctx->n = node;
    return REG_OK;
}

/*
BRE grammar:
Regex  =  Branch  |  '^'  |  '$'  |  '^$'  |  '^' Branch  |  Branch '$'  |  '^' Branch '$'
Branch =  Atom  |  Branch Atom
Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '\(' Branch '\)'  |  back_ref
Dup    =  '*'  |  '\{' Count '\}'  |  '\{' Count ',\}'  |  '\{' Count ',' Count '\}'

(leading ^ and trailing $ in a sub expr may be an anchor or literal as well)

ERE grammar:
Regex  =  Branch  |  Regex '|' Branch
Branch =  Atom  |  Branch Atom
Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '(' Regex ')'  |  '^'  |  '$'
Dup    =  '*'  |  '+'  |  '?'  |  '{' Count '}'  |  '{' Count ',}'  |  '{' Count ',' Count '}'

(a*+?, ^*, $+, \X, {, (|a) are unspecified)
*/

static reg_errcode_t parse_atom(tre_parse_ctx_t *ctx, const char *s)
{
    int len, ere = ctx->cflags & REG_EXTENDED;
    const char *p;
    tre_ast_node_t *node;
    wchar_t wc;
    switch (*s) {
    case '[':
        return parse_bracket(ctx, s+1);
    case '\\':
        p = tre_expand_macro(s+1);
        if (p) {
            /* assume \X expansion is a single atom */
            reg_errcode_t err = parse_atom(ctx, p);
            ctx->s = s+2;
            return err;
        }
        /* extensions: \b, \B, \<, \>, \xHH \x{HHHH} */
        switch (*++s) {
        case 0:
            return REG_EESCAPE;
        case 'b':
            node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB, -1);
            break;
        case 'B':
            node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB_NEG, -1);
            break;
        case '<':
            node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOW, -1);
            break;
        case '>':
            node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOW, -1);
            break;
        case 'x': {
            s++;
            int i, v = 0, c;
            len = 2;
            if (*s == '{') {
                len = 8;
                s++;
            }
            for (i=0; i<len && v<0x110000; i++) {
                c = hexval(s[i]);
                if (c < 0) break;
                v = 16*v + c;
            }
            s += i;
            if (len == 8) {
                if (*s != '}')
                    return REG_EBRACE;
                s++;
            }
            node = tre_ast_new_literal(ctx->mem, v, v, ctx->position);
            ctx->position++;
            s--;
            break;
        }
        default:
            if (isdigit(*s)) {
                /* back reference */
                int val = *s - '0';
                node = tre_ast_new_literal(ctx->mem, BACKREF, val, ctx->position);
                ctx->max_backref = MAX(val, ctx->max_backref);
            } else {
                /* extension: accept unknown escaped char
                   as a literal */
                node = tre_ast_new_literal(ctx->mem, *s, *s, ctx->position);
            }
            ctx->position++;
        }
        s++;
        break;
    case '.':
        if (ctx->cflags & REG_NEWLINE) {
            tre_ast_node_t *tmp1, *tmp2;
            tmp1 = tre_ast_new_literal(ctx->mem, 0, '\n'-1, ctx->position++);
            tmp2 = tre_ast_new_literal(ctx->mem, '\n'+1, TRE_CHAR_MAX, ctx->position++);
            if (tmp1 && tmp2)
                node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
            else
                node = 0;
        } else {
            node = tre_ast_new_literal(ctx->mem, 0, TRE_CHAR_MAX, ctx->position++);
        }
        s++;
        break;
    case '^':
        /* '^' has a special meaning everywhere in EREs, and at beginning of BRE. */
        if (!ere && s != ctx->re)
            goto parse_literal;
        node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOL, -1);
        s++;
        break;
    case '$':
        /* '$' is special everywhere in EREs, and in the end of the string in BREs. */
        if (!ere && s[1])
            goto parse_literal;
        node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOL, -1);
        s++;
        break;
    case '*':
    case '|':
    case '{':
    case '+':
    case '?':
        if (!ere)
            goto parse_literal;
    case 0:
        node = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
        break;
    default:
parse_literal:
        len = mbtowc(&wc, s, -1);
        if (len < 0)
            return REG_BADPAT;
        if (ctx->cflags & REG_ICASE && (tre_isupper(wc) || tre_islower(wc))) {
            tre_ast_node_t *tmp1, *tmp2;
            /* multiple opposite case characters are not supported */
            tmp1 = tre_ast_new_literal(ctx->mem, tre_toupper(wc), tre_toupper(wc), ctx->position);
            tmp2 = tre_ast_new_literal(ctx->mem, tre_tolower(wc), tre_tolower(wc), ctx->position);
            if (tmp1 && tmp2)
                node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
            else
                node = 0;
        } else {
            node = tre_ast_new_literal(ctx->mem, wc, wc, ctx->position);
        }
        ctx->position++;
        s += len;
        break;
    }
    if (!node)
        return REG_ESPACE;
    ctx->n = node;
    ctx->s = s;
    return REG_OK;
}

#define PUSHPTR(err, s, v) do { \
    if ((err = tre_stack_push_voidptr(s, v)) != REG_OK) \
        return err; \
} while(0)

#define PUSHINT(err, s, v) do { \
    if ((err = tre_stack_push_int(s, v)) != REG_OK) \
        return err; \
} while(0)

static reg_errcode_t tre_parse(tre_parse_ctx_t *ctx)
{
    tre_ast_node_t *nbranch=0, *nunion=0;
    int ere = ctx->cflags & REG_EXTENDED;
    const char *s = ctx->re;
    int subid = 0;
    int depth = 0;
    reg_errcode_t err;
    tre_stack_t *stack = ctx->stack;

    PUSHINT(err, stack, subid++);
    for (;;) {
        if ((!ere && *s == '\\' && s[1] == '(') ||
            (ere && *s == '(')) {
            PUSHPTR(err, stack, nunion);
            PUSHPTR(err, stack, nbranch);
            PUSHINT(err, stack, subid++);
            s++;
            if (!ere)
                s++;
            depth++;
            nbranch = nunion = 0;
            continue;
        }
        if ((!ere && *s == '\\' && s[1] == ')') ||
            (ere && *s == ')' && depth)) {
            ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
            if (!ctx->n)
                return REG_ESPACE;
        } else {
            err = parse_atom(ctx, s);
            if (err != REG_OK)
                return err;
            s = ctx->s;
        }

    parse_iter:
        /* extension: repetitions are accepted after an empty node
           eg. (+), ^*, a$?, a|{2} */
        switch (*s) {
        case '+':
        case '?':
            if (!ere)
                break;
            /* fallthrough */
        case '*':; {
            int min=0, max=-1;
            if (*s == '+')
                min = 1;
            if (*s == '?')
                max = 1;
            s++;
            ctx->n = tre_ast_new_iter(ctx->mem, ctx->n, min, max, 0);
            if (!ctx->n)
                return REG_ESPACE;
            /* extension: multiple consecutive *+?{,} is unspecified,
               but (a+)+ has to be supported so accepting a++ makes
               sense, note however that the RE_DUP_MAX limit can be
               circumvented: (a{255}){255} uses a lot of memory.. */
            goto parse_iter;
        }
        case '\\':
            if (ere || s[1] != '{')
                break;
            s++;
            goto parse_brace;
        case '{':
            if (!ere)
                break;
        parse_brace:
            err = parse_dup(ctx, s+1);
            if (err != REG_OK)
                return err;
            s = ctx->s;
            goto parse_iter;
        }

        nbranch = tre_ast_new_catenation(ctx->mem, nbranch, ctx->n);
        if ((ere && *s == '|') ||
            (ere && *s == ')' && depth) ||
            (!ere && *s == '\\' && s[1] == ')') ||
            !*s) {
            /* extension: empty branch is unspecified (), (|a), (a|)
               here they are not rejected but match on empty string */
            int c = *s;
            nunion = tre_ast_new_union(ctx->mem, nunion, nbranch);
            nbranch = 0;
            if (c != '|') {
                if (c == '\\') {
                    if (!depth) return REG_EPAREN;
                    s+=2;
                } else if (c == ')')
                    s++;
                depth--;
                err = marksub(ctx, nunion, tre_stack_pop_int(stack));
                if (err != REG_OK)
                    return err;
                if (!c && depth<0) {
                    ctx->submatch_id = subid;
                    return REG_OK;
                }
                if (!c || depth<0)
                    return REG_EPAREN;
                nbranch = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
                nunion = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
                goto parse_iter;
            }
            s++;
        }
    }
}


/***********************************************************************
 from tre-compile.c
***********************************************************************/


/*
  TODO:
   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
     function calls.
*/

/*
  Algorithms to setup tags so that submatch addressing can be done.
*/


/* Inserts a catenation node to the root of the tree given in `node'.
   As the left child a new tag with number `tag_id' to `node' is added,
   and the right child is the old root. */
static reg_errcode_t
tre_add_tag_left(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
{
  tre_catenation_t *c;

  c = (tre_catenation_t*)tre_mem_alloc(mem, sizeof(*c));
  if (c == NULL)
    return REG_ESPACE;
  c->left = tre_ast_new_literal(mem, TAG, tag_id, -1);
  if (c->left == NULL)
    return REG_ESPACE;
  c->right = (tre_ast_node_t*)tre_mem_alloc(mem, sizeof(tre_ast_node_t));
  if (c->right == NULL)
    return REG_ESPACE;

  c->right->obj = node->obj;
  c->right->type = node->type;
  c->right->nullable = -1;
  c->right->submatch_id = -1;
  c->right->firstpos = NULL;
  c->right->lastpos = NULL;
  c->right->num_tags = 0;
  node->obj = c;
  node->type = CATENATION;
  return REG_OK;
}

/* Inserts a catenation node to the root of the tree given in `node'.
   As the right child a new tag with number `tag_id' to `node' is added,
   and the left child is the old root. */
static reg_errcode_t
tre_add_tag_right(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
{
  tre_catenation_t *c;

  c = (tre_catenation_t*)tre_mem_alloc(mem, sizeof(*c));
  if (c == NULL)
    return REG_ESPACE;
  c->right = tre_ast_new_literal(mem, TAG, tag_id, -1);
  if (c->right == NULL)
    return REG_ESPACE;
  c->left = (tre_ast_node_t*)tre_mem_alloc(mem, sizeof(tre_ast_node_t));
  if (c->left == NULL)
    return REG_ESPACE;

  c->left->obj = node->obj;
  c->left->type = node->type;
  c->left->nullable = -1;
  c->left->submatch_id = -1;
  c->left->firstpos = NULL;
  c->left->lastpos = NULL;
  c->left->num_tags = 0;
  node->obj = c;
  node->type = CATENATION;
  return REG_OK;
}

typedef enum {
  ADDTAGS_RECURSE,
  ADDTAGS_AFTER_ITERATION,
  ADDTAGS_AFTER_UNION_LEFT,
  ADDTAGS_AFTER_UNION_RIGHT,
  ADDTAGS_AFTER_CAT_LEFT,
  ADDTAGS_AFTER_CAT_RIGHT,
  ADDTAGS_SET_SUBMATCH_END
} tre_addtags_symbol_t;


typedef struct {
  int tag;
  int next_tag;
} tre_tag_states_t;


/* Go through `regset' and set submatch data for submatches that are
   using this tag. */
static void
tre_purge_regset(int *regset, tre_tnfa_t *tnfa, int tag)
{
  int i;

  for (i = 0; regset[i] >= 0; i++)
    {
      int id = regset[i] / 2;
      int start = !(regset[i] % 2);
      if (start)
    tnfa->submatch_data[id].so_tag = tag;
      else
    tnfa->submatch_data[id].eo_tag = tag;
    }
  regset[0] = -1;
}


/* Adds tags to appropriate locations in the parse tree in `tree', so that
   subexpressions marked for submatch addressing can be traced. */
static reg_errcode_t
tre_add_tags(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree,
         tre_tnfa_t *tnfa)
{
  reg_errcode_t status = REG_OK;
  tre_addtags_symbol_t symbol;
  tre_ast_node_t *node = tree; /* Tree node we are currently looking at. */
  int bottom = tre_stack_num_objects(stack);
  /* True for first pass (counting number of needed tags) */
  int first_pass = (mem == NULL || tnfa == NULL);
  int *regset, *orig_regset;
  int num_tags = 0; /* Total number of tags. */
  int num_minimals = 0;  /* Number of special minimal tags. */
  int tag = 0;      /* The tag that is to be added next. */
  int next_tag = 1; /* Next tag to use after this one. */
  int *parents;     /* Stack of submatches the current submatch is
               contained in. */
  int minimal_tag = -1; /* Tag that marks the beginning of a minimal match. */
  tre_tag_states_t *saved_states;

  tre_tag_direction_t direction = TRE_TAG_MINIMIZE;
  if (!first_pass)
    {
      tnfa->end_tag = 0;
      tnfa->minimal_tags[0] = -1;
    }

  regset = (int*)xmalloc(sizeof(*regset) * ((tnfa->num_submatches + 1) * 2));
  if (regset == NULL)
    return REG_ESPACE;
  regset[0] = -1;
  orig_regset = regset;

  parents = (int*)xmalloc(sizeof(*parents) * (tnfa->num_submatches + 1));
  if (parents == NULL)
    {
      xfree(regset);
      return REG_ESPACE;
    }
  parents[0] = -1;

  saved_states = (tre_tag_states_t*)xmalloc(sizeof(*saved_states) * (tnfa->num_submatches + 1));
  if (saved_states == NULL)
    {
      xfree(regset);
      xfree(parents);
      return REG_ESPACE;
    }
  else
    {
      unsigned int i;
      for (i = 0; i <= tnfa->num_submatches; i++)
    saved_states[i].tag = -1;
    }

  STACK_PUSH(stack, voidptr, node);
  STACK_PUSH(stack, int, ADDTAGS_RECURSE);

  while (tre_stack_num_objects(stack) > bottom)
    {
      if (status != REG_OK)
    break;

      symbol = (tre_addtags_symbol_t)tre_stack_pop_int(stack);
      switch (symbol)
    {

    case ADDTAGS_SET_SUBMATCH_END:
      {
        int id = tre_stack_pop_int(stack);
        int i;

        /* Add end of this submatch to regset. */
        for (i = 0; regset[i] >= 0; i++);
        regset[i] = id * 2 + 1;
        regset[i + 1] = -1;

        /* Pop this submatch from the parents stack. */
        for (i = 0; parents[i] >= 0; i++);
        parents[i - 1] = -1;
        break;
      }

    case ADDTAGS_RECURSE:
      node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);

      if (node->submatch_id >= 0)
        {
          int id = node->submatch_id;
          int i;


          /* Add start of this submatch to regset. */
          for (i = 0; regset[i] >= 0; i++);
          regset[i] = id * 2;
          regset[i + 1] = -1;

          if (!first_pass)
        {
          for (i = 0; parents[i] >= 0; i++);
          tnfa->submatch_data[id].parents = NULL;
          if (i > 0)
            {
              int *p = (int*)xmalloc(sizeof(*p) * (i + 1));
              if (p == NULL)
            {
              status = REG_ESPACE;
              break;
            }
              assert(tnfa->submatch_data[id].parents == NULL);
              tnfa->submatch_data[id].parents = p;
              for (i = 0; parents[i] >= 0; i++)
            p[i] = parents[i];
              p[i] = -1;
            }
        }

          /* Add end of this submatch to regset after processing this
         node. */
          STACK_PUSHX(stack, int, node->submatch_id);
          STACK_PUSHX(stack, int, ADDTAGS_SET_SUBMATCH_END);
        }

      switch (node->type)
        {
        case LITERAL:
          {
        tre_literal_t *lit = (tre_literal_t*)node->obj;

        if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
          {
            int i;
            if (regset[0] >= 0)
              {
            /* Regset is not empty, so add a tag before the
               literal or backref. */
            if (!first_pass)
              {
                status = tre_add_tag_left(mem, node, tag);
                tnfa->tag_directions[tag] = direction;
                if (minimal_tag >= 0)
                  {
                for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
                tnfa->minimal_tags[i] = tag;
                tnfa->minimal_tags[i + 1] = minimal_tag;
                tnfa->minimal_tags[i + 2] = -1;
                minimal_tag = -1;
                num_minimals++;
                  }
                tre_purge_regset(regset, tnfa, tag);
              }
            else
              {
                node->num_tags = 1;
              }

            regset[0] = -1;
            tag = next_tag;
            num_tags++;
            next_tag++;
              }
          }
        else
          {
            assert(!IS_TAG(lit));
          }
        break;
          }
        case CATENATION:
          {
        tre_catenation_t *cat = (tre_catenation_t*)node->obj;
        tre_ast_node_t *left = cat->left;
        tre_ast_node_t *right = cat->right;
        int reserved_tag = -1;


        /* After processing right child. */
        STACK_PUSHX(stack, voidptr, node);
        STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_RIGHT);

        /* Process right child. */
        STACK_PUSHX(stack, voidptr, right);
        STACK_PUSHX(stack, int, ADDTAGS_RECURSE);

        /* After processing left child. */
        STACK_PUSHX(stack, int, next_tag + left->num_tags);
        if (left->num_tags > 0 && right->num_tags > 0)
          {
            /* Reserve the next tag to the right child. */
            reserved_tag = next_tag;
            next_tag++;
          }
        STACK_PUSHX(stack, int, reserved_tag);
        STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_LEFT);

        /* Process left child. */
        STACK_PUSHX(stack, voidptr, left);
        STACK_PUSHX(stack, int, ADDTAGS_RECURSE);

        }
          break;
        case ITERATION:
          {
        tre_iteration_t *iter = (tre_iteration_t*)node->obj;

        if (first_pass)
          {
            STACK_PUSHX(stack, int, regset[0] >= 0 || iter->minimal);
          }
        else
          {
            STACK_PUSHX(stack, int, tag);
            STACK_PUSHX(stack, int, iter->minimal);
          }
        STACK_PUSHX(stack, voidptr, node);
        STACK_PUSHX(stack, int, ADDTAGS_AFTER_ITERATION);

        STACK_PUSHX(stack, voidptr, iter->arg);
        STACK_PUSHX(stack, int, ADDTAGS_RECURSE);

        /* Regset is not empty, so add a tag here. */
        if (regset[0] >= 0 || iter->minimal)
          {
            if (!first_pass)
              {
            int i;
            status = tre_add_tag_left(mem, node, tag);
            if (iter->minimal)
              tnfa->tag_directions[tag] = TRE_TAG_MAXIMIZE;
            else
              tnfa->tag_directions[tag] = direction;
            if (minimal_tag >= 0)
              {
                for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
                tnfa->minimal_tags[i] = tag;
                tnfa->minimal_tags[i + 1] = minimal_tag;
                tnfa->minimal_tags[i + 2] = -1;
                minimal_tag = -1;
                num_minimals++;
              }
            tre_purge_regset(regset, tnfa, tag);
              }

            regset[0] = -1;
            tag = next_tag;
            num_tags++;
            next_tag++;
          }
        direction = TRE_TAG_MINIMIZE;
          }
          break;
        case UNION:
          {
        tre_union_t *uni = (tre_union_t*)node->obj;
        tre_ast_node_t *left = uni->left;
        tre_ast_node_t *right = uni->right;
        int left_tag;
        int right_tag;

        if (regset[0] >= 0)
          {
            left_tag = next_tag;
            right_tag = next_tag + 1;
          }
        else
          {
            left_tag = tag;
            right_tag = next_tag;
          }

        /* After processing right child. */
        STACK_PUSHX(stack, int, right_tag);
        STACK_PUSHX(stack, int, left_tag);
        STACK_PUSHX(stack, voidptr, regset);
        STACK_PUSHX(stack, int, regset[0] >= 0);
        STACK_PUSHX(stack, voidptr, node);
        STACK_PUSHX(stack, voidptr, right);
        STACK_PUSHX(stack, voidptr, left);
        STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_RIGHT);

        /* Process right child. */
        STACK_PUSHX(stack, voidptr, right);
        STACK_PUSHX(stack, int, ADDTAGS_RECURSE);

        /* After processing left child. */
        STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_LEFT);

        /* Process left child. */
        STACK_PUSHX(stack, voidptr, left);
        STACK_PUSHX(stack, int, ADDTAGS_RECURSE);

        /* Regset is not empty, so add a tag here. */
        if (regset[0] >= 0)
          {
            if (!first_pass)
              {
            int i;
            status = tre_add_tag_left(mem, node, tag);
            tnfa->tag_directions[tag] = direction;
            if (minimal_tag >= 0)
              {
                for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
                tnfa->minimal_tags[i] = tag;
                tnfa->minimal_tags[i + 1] = minimal_tag;
                tnfa->minimal_tags[i + 2] = -1;
                minimal_tag = -1;
                num_minimals++;
              }
            tre_purge_regset(regset, tnfa, tag);
              }

            regset[0] = -1;
            tag = next_tag;
            num_tags++;
            next_tag++;
          }

        if (node->num_submatches > 0)
          {
            /* The next two tags are reserved for markers. */
            next_tag++;
            tag = next_tag;
            next_tag++;
          }

        break;
          }
        }

      if (node->submatch_id >= 0)
        {
          int i;
          /* Push this submatch on the parents stack. */
          for (i = 0; parents[i] >= 0; i++);
          parents[i] = node->submatch_id;
          parents[i + 1] = -1;
        }

      break; /* end case: ADDTAGS_RECURSE */

    case ADDTAGS_AFTER_ITERATION:
      {
        int minimal = 0;
        int enter_tag;
        node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
        if (first_pass)
          {
        node->num_tags = ((tre_iteration_t *)node->obj)->arg->num_tags
          + tre_stack_pop_int(stack);
        minimal_tag = -1;
          }
        else
          {
        minimal = tre_stack_pop_int(stack);
        enter_tag = tre_stack_pop_int(stack);
        if (minimal)
          minimal_tag = enter_tag;
          }

        if (!first_pass)
          {
        if (minimal)
          direction = TRE_TAG_MINIMIZE;
        else
          direction = TRE_TAG_MAXIMIZE;
          }
        break;
      }

    case ADDTAGS_AFTER_CAT_LEFT:
      {
        int new_tag = tre_stack_pop_int(stack);
        next_tag = tre_stack_pop_int(stack);
        if (new_tag >= 0)
          {
        tag = new_tag;
          }
        break;
      }

    case ADDTAGS_AFTER_CAT_RIGHT:
      node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
      if (first_pass)
        node->num_tags = ((tre_catenation_t *)node->obj)->left->num_tags
          + ((tre_catenation_t *)node->obj)->right->num_tags;
      break;

    case ADDTAGS_AFTER_UNION_LEFT:
      /* Lift the bottom of the `regset' array so that when processing
         the right operand the items currently in the array are
         invisible.  The original bottom was saved at ADDTAGS_UNION and
         will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
      while (*regset >= 0)
        regset++;
      break;

    case ADDTAGS_AFTER_UNION_RIGHT:
      {
        int added_tags, tag_left, tag_right;
        tre_ast_node_t *left = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
        tre_ast_node_t *right = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
        node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
        added_tags = tre_stack_pop_int(stack);
        if (first_pass)
          {
        node->num_tags = ((tre_union_t *)node->obj)->left->num_tags
          + ((tre_union_t *)node->obj)->right->num_tags + added_tags
          + ((node->num_submatches > 0) ? 2 : 0);
          }
        regset = (int*)tre_stack_pop_voidptr(stack);
        tag_left = tre_stack_pop_int(stack);
        tag_right = tre_stack_pop_int(stack);

        /* Add tags after both children, the left child gets a smaller
           tag than the right child.  This guarantees that we prefer
           the left child over the right child. */
        /* XXX - This is not always necessary (if the children have
           tags which must be seen for every match of that child). */
        /* XXX - Check if this is the only place where tre_add_tag_right
           is used.  If so, use tre_add_tag_left (putting the tag before
           the child as opposed after the child) and throw away
           tre_add_tag_right. */
        if (node->num_submatches > 0)
          {
        if (!first_pass)
          {
            status = tre_add_tag_right(mem, left, tag_left);
            tnfa->tag_directions[tag_left] = TRE_TAG_MAXIMIZE;
            status = tre_add_tag_right(mem, right, tag_right);
            tnfa->tag_directions[tag_right] = TRE_TAG_MAXIMIZE;
          }
        num_tags += 2;
          }
        direction = TRE_TAG_MAXIMIZE;
        break;
      }

    default:
      assert(0);
      break;

    } /* end switch(symbol) */
    } /* end while(tre_stack_num_objects(stack) > bottom) */

  if (!first_pass)
    tre_purge_regset(regset, tnfa, tag);

  if (!first_pass && minimal_tag >= 0)
    {
      int i;
      for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
      tnfa->minimal_tags[i] = tag;
      tnfa->minimal_tags[i + 1] = minimal_tag;
      tnfa->minimal_tags[i + 2] = -1;
      minimal_tag = -1;
      num_minimals++;
    }

  assert(tree->num_tags == num_tags);
  tnfa->end_tag = num_tags;
  tnfa->num_tags = num_tags;
  tnfa->num_minimals = num_minimals;
  xfree(orig_regset);
  xfree(parents);
  xfree(saved_states);
  return status;
}



/*
  AST to TNFA compilation routines.
*/

typedef enum {
  COPY_RECURSE,
  COPY_SET_RESULT_PTR
} tre_copyast_symbol_t;

/* Flags for tre_copy_ast(). */
#define COPY_REMOVE_TAGS     1
#define COPY_MAXIMIZE_FIRST_TAG  2

static reg_errcode_t
tre_copy_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
         int flags, int *pos_add, tre_tag_direction_t *tag_directions,
         tre_ast_node_t **copy, int *max_pos)
{
  reg_errcode_t status = REG_OK;
  int bottom = tre_stack_num_objects(stack);
  int num_copied = 0;
  int first_tag = 1;
  tre_ast_node_t **result = copy;
  tre_copyast_symbol_t symbol;

  STACK_PUSH(stack, voidptr, ast);
  STACK_PUSH(stack, int, COPY_RECURSE);

  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
    {
      tre_ast_node_t *node;
      if (status != REG_OK)
    break;

      symbol = (tre_copyast_symbol_t)tre_stack_pop_int(stack);
      switch (symbol)
    {
    case COPY_SET_RESULT_PTR:
      result = (tre_ast_node_t**)tre_stack_pop_voidptr(stack);
      break;
    case COPY_RECURSE:
      node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
      switch (node->type)
        {
        case LITERAL:
          {
        tre_literal_t *lit = (tre_literal_t *)node->obj;
        int pos = lit->position;
        int min = lit->code_min;
        int max = lit->code_max;
        if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
          {
            /* XXX - e.g. [ab] has only one position but two
               nodes, so we are creating holes in the state space
               here.  Not fatal, just wastes memory. */
            pos += *pos_add;
            num_copied++;
          }
        else if (IS_TAG(lit) && (flags & COPY_REMOVE_TAGS))
          {
            /* Change this tag to empty. */
            min = EMPTY;
            max = pos = -1;
          }
        else if (IS_TAG(lit) && (flags & COPY_MAXIMIZE_FIRST_TAG)
             && first_tag)
          {
            /* Maximize the first tag. */
            tag_directions[max] = TRE_TAG_MAXIMIZE;
            first_tag = 0;
          }
        *result = tre_ast_new_literal(mem, min, max, pos);
        if (*result == NULL)
          status = REG_ESPACE;

        if (pos > *max_pos)
          *max_pos = pos;
        break;
          }
        case UNION:
          {
        tre_union_t *uni = (tre_union_t *)node->obj;
        tre_union_t *tmp;
        *result = tre_ast_new_union(mem, uni->left, uni->right);
        if (*result == NULL)
          {
            status = REG_ESPACE;
            break;
          }
        tmp = (tre_union_t *)((*result)->obj);
        result = &tmp->left;
        STACK_PUSHX(stack, voidptr, uni->right);
        STACK_PUSHX(stack, int, COPY_RECURSE);
        STACK_PUSHX(stack, voidptr, &tmp->right);
        STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
        STACK_PUSHX(stack, voidptr, uni->left);
        STACK_PUSHX(stack, int, COPY_RECURSE);
        break;
          }
        case CATENATION:
          {
        tre_catenation_t *cat = (tre_catenation_t *)node->obj;
        tre_catenation_t *tmp;
        *result = tre_ast_new_catenation(mem, cat->left, cat->right);
        if (*result == NULL)
          {
            status = REG_ESPACE;
            break;
          }
        tmp = (tre_catenation_t *)((*result)->obj);
        tmp->left = NULL;
        tmp->right = NULL;
        result = &tmp->left;

        STACK_PUSHX(stack, voidptr, cat->right);
        STACK_PUSHX(stack, int, COPY_RECURSE);
        STACK_PUSHX(stack, voidptr, &tmp->right);
        STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
        STACK_PUSHX(stack, voidptr, cat->left);
        STACK_PUSHX(stack, int, COPY_RECURSE);
        break;
          }
        case ITERATION:
          {
        tre_iteration_t *iter = (tre_iteration_t *)node->obj;
        STACK_PUSHX(stack, voidptr, iter->arg);
        STACK_PUSHX(stack, int, COPY_RECURSE);
        *result = tre_ast_new_iter(mem, iter->arg, iter->min,
                       iter->max, iter->minimal);
        if (*result == NULL)
          {
            status = REG_ESPACE;
            break;
          }
        iter = (tre_iteration_t *)((*result)->obj);
        result = &iter->arg;
        break;
          }
        default:
          assert(0);
          break;
        }
      break;
    }
    }
  *pos_add += num_copied;
  return status;
}

typedef enum {
  EXPAND_RECURSE,
  EXPAND_AFTER_ITER
} tre_expand_ast_symbol_t;

/* Expands each iteration node that has a finite nonzero minimum or maximum
   iteration count to a catenated sequence of copies of the node. */
static reg_errcode_t
tre_expand_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
           int *position, tre_tag_direction_t *tag_directions)
{
  reg_errcode_t status = REG_OK;
  int bottom = tre_stack_num_objects(stack);
  int pos_add = 0;
  int pos_add_total = 0;
  int max_pos = 0;
  int iter_depth = 0;

  STACK_PUSHR(stack, voidptr, ast);
  STACK_PUSHR(stack, int, EXPAND_RECURSE);
  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
    {
      tre_ast_node_t *node;
      tre_expand_ast_symbol_t symbol;

      if (status != REG_OK)
    break;

      symbol = (tre_expand_ast_symbol_t)tre_stack_pop_int(stack);
      node = (tre_ast_node_t*)tre_stack_pop_voidptr(stack);
      switch (symbol)
    {
    case EXPAND_RECURSE:
      switch (node->type)
        {
        case LITERAL:
          {
        tre_literal_t *lit= (tre_literal_t *)node->obj;
        if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
          {
            lit->position += pos_add;
            if (lit->position > max_pos)
              max_pos = lit->position;
          }
        break;
          }
        case UNION:
          {
        tre_union_t *uni = (tre_union_t *)node->obj;
        STACK_PUSHX(stack, voidptr, uni->right);
        STACK_PUSHX(stack, int, EXPAND_RECURSE);
        STACK_PUSHX(stack, voidptr, uni->left);
        STACK_PUSHX(stack, int, EXPAND_RECURSE);
        break;
          }
        case CATENATION:
          {
        tre_catenation_t *cat = (tre_catenation_t *)node->obj;
        STACK_PUSHX(stack, voidptr, cat->right);
        STACK_PUSHX(stack, int, EXPAND_RECURSE);
        STACK_PUSHX(stack, voidptr, cat->left);
        STACK_PUSHX(stack, int, EXPAND_RECURSE);
        break;
          }
        case ITERATION:
          {
        tre_iteration_t *iter = (tre_iteration_t *)node->obj;
        STACK_PUSHX(stack, int, pos_add);
        STACK_PUSHX(stack, voidptr, node);
        STACK_PUSHX(stack, int, EXPAND_AFTER_ITER);
        STACK_PUSHX(stack, voidptr, iter->arg);
        STACK_PUSHX(stack, int, EXPAND_RECURSE);
        /* If we are going to expand this node at EXPAND_AFTER_ITER
           then don't increase the `pos' fields of the nodes now, it
           will get done when expanding. */
        if (iter->min > 1 || iter->max > 1)
          pos_add = 0;
        iter_depth++;
        break;
          }
        default:
          assert(0);
          break;
        }
      break;
    case EXPAND_AFTER_ITER:
      {
        tre_iteration_t *iter = (tre_iteration_t *)node->obj;
        int pos_add_last;
        pos_add = tre_stack_pop_int(stack);
        pos_add_last = pos_add;
        if (iter->min > 1 || iter->max > 1)
          {
        tre_ast_node_t *seq1 = NULL, *seq2 = NULL;
        int j;
        int pos_add_save = pos_add;

        /* Create a catenated sequence of copies of the node. */
        for (j = 0; j < iter->min; j++)
          {
            tre_ast_node_t *copy;
            /* Remove tags from all but the last copy. */
            int flags = ((j + 1 < iter->min)
                 ? COPY_REMOVE_TAGS
                 : COPY_MAXIMIZE_FIRST_TAG);
            pos_add_save = pos_add;
            status = tre_copy_ast(mem, stack, iter->arg, flags,
                      &pos_add, tag_directions, &copy,
                      &max_pos);
            if (status != REG_OK)
              return status;
            if (seq1 != NULL)
              seq1 = tre_ast_new_catenation(mem, seq1, copy);
            else
              seq1 = copy;
            if (seq1 == NULL)
              return REG_ESPACE;
          }

        if (iter->max == -1)
          {
            /* No upper limit. */
            pos_add_save = pos_add;
            status = tre_copy_ast(mem, stack, iter->arg, 0,
                      &pos_add, NULL, &seq2, &max_pos);
            if (status != REG_OK)
              return status;
            seq2 = tre_ast_new_iter(mem, seq2, 0, -1, 0);
            if (seq2 == NULL)
              return REG_ESPACE;
          }
        else
          {
            for (j = iter->min; j < iter->max; j++)
              {
            tre_ast_node_t *tmp, *copy;
            pos_add_save = pos_add;
            status = tre_copy_ast(mem, stack, iter->arg, 0,
                          &pos_add, NULL, &copy, &max_pos);
            if (status != REG_OK)
              return status;
            if (seq2 != NULL)
              seq2 = tre_ast_new_catenation(mem, copy, seq2);
            else
              seq2 = copy;
            if (seq2 == NULL)
              return REG_ESPACE;
            tmp = tre_ast_new_literal(mem, EMPTY, -1, -1);
            if (tmp == NULL)
              return REG_ESPACE;
            seq2 = tre_ast_new_union(mem, tmp, seq2);
            if (seq2 == NULL)
              return REG_ESPACE;
              }
          }

        pos_add = pos_add_save;
        if (seq1 == NULL)
          seq1 = seq2;
        else if (seq2 != NULL)
          seq1 = tre_ast_new_catenation(mem, seq1, seq2);
        if (seq1 == NULL)
          return REG_ESPACE;
        node->obj = seq1->obj;
        node->type = seq1->type;
          }

        iter_depth--;
        pos_add_total += pos_add - pos_add_last;
        if (iter_depth == 0)
          pos_add = pos_add_total;

        break;
      }
    default:
      assert(0);
      break;
    }
    }

  *position += pos_add_total;

  /* `max_pos' should never be larger than `*position' if the above
     code works, but just an extra safeguard let's make sure
     `*position' is set large enough so enough memory will be
     allocated for the transition table. */
  if (max_pos > *position)
    *position = max_pos;

  return status;
}

static tre_pos_and_tags_t *
tre_set_empty(tre_mem_t mem)
{
  tre_pos_and_tags_t *new_set;

  new_set = (tre_pos_and_tags_t *)tre_mem_calloc(mem, sizeof(*new_set));
  if (new_set == NULL)
    return NULL;

  new_set[0].position = -1;
  new_set[0].code_min = -1;
  new_set[0].code_max = -1;

  return new_set;
}

static tre_pos_and_tags_t *
tre_set_one(tre_mem_t mem, int position, int code_min, int code_max,
        tre_ctype_t rclass, tre_ctype_t *neg_classes, int backref)
{
  tre_pos_and_tags_t *new_set;

  new_set = (tre_pos_and_tags_t *)tre_mem_calloc(mem, sizeof(*new_set) * 2);
  if (new_set == NULL)
    return NULL;

  new_set[0].position = position;
  new_set[0].code_min = code_min;
  new_set[0].code_max = code_max;
  new_set[0].rclass = rclass;
  new_set[0].neg_classes = neg_classes;
  new_set[0].backref = backref;
  new_set[1].position = -1;
  new_set[1].code_min = -1;
  new_set[1].code_max = -1;

  return new_set;
}

static tre_pos_and_tags_t *
tre_set_union(tre_mem_t mem, tre_pos_and_tags_t *set1, tre_pos_and_tags_t *set2,
          int *tags, int assertions)
{
  int s1, s2, i, j;
  tre_pos_and_tags_t *new_set;
  int *new_tags;
  int num_tags;

  for (num_tags = 0; tags != NULL && tags[num_tags] >= 0; num_tags++);
  for (s1 = 0; set1[s1].position >= 0; s1++);
  for (s2 = 0; set2[s2].position >= 0; s2++);
  new_set = (tre_pos_and_tags_t *)tre_mem_calloc(mem, sizeof(*new_set) * (s1 + s2 + 1));
  if (!new_set )
    return NULL;

  for (s1 = 0; set1[s1].position >= 0; s1++)
    {
      new_set[s1].position = set1[s1].position;
      new_set[s1].code_min = set1[s1].code_min;
      new_set[s1].code_max = set1[s1].code_max;
      new_set[s1].assertions = set1[s1].assertions | assertions;
      new_set[s1].rclass = set1[s1].rclass;
      new_set[s1].neg_classes = set1[s1].neg_classes;
      new_set[s1].backref = set1[s1].backref;
      if (set1[s1].tags == NULL && tags == NULL)
    new_set[s1].tags = NULL;
      else
    {
      for (i = 0; set1[s1].tags != NULL && set1[s1].tags[i] >= 0; i++);
      new_tags = (int *)tre_mem_alloc(mem, (sizeof(*new_tags)
                     * (i + num_tags + 1)));
      if (new_tags == NULL)
        return NULL;
      for (j = 0; j < i; j++)
        new_tags[j] = set1[s1].tags[j];
      for (i = 0; i < num_tags; i++)
        new_tags[j + i] = tags[i];
      new_tags[j + i] = -1;
      new_set[s1].tags = new_tags;
    }
    }

  for (s2 = 0; set2[s2].position >= 0; s2++)
    {
      new_set[s1 + s2].position = set2[s2].position;
      new_set[s1 + s2].code_min = set2[s2].code_min;
      new_set[s1 + s2].code_max = set2[s2].code_max;
      /* XXX - why not | assertions here as well? */
      new_set[s1 + s2].assertions = set2[s2].assertions;
      new_set[s1 + s2].rclass = set2[s2].rclass;
      new_set[s1 + s2].neg_classes = set2[s2].neg_classes;
      new_set[s1 + s2].backref = set2[s2].backref;
      if (set2[s2].tags == NULL)
    new_set[s1 + s2].tags = NULL;
      else
    {
      for (i = 0; set2[s2].tags[i] >= 0; i++);
      new_tags = (int *)tre_mem_alloc(mem, sizeof(*new_tags) * (i + 1));
      if (new_tags == NULL)
        return NULL;
      for (j = 0; j < i; j++)
        new_tags[j] = set2[s2].tags[j];
      new_tags[j] = -1;
      new_set[s1 + s2].tags = new_tags;
    }
    }
  new_set[s1 + s2].position = -1;
  return new_set;
}

/* Finds the empty path through `node' which is the one that should be
   taken according to POSIX.2 rules, and adds the tags on that path to
   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
   set to the number of tags seen on the path. */
static reg_errcode_t
tre_match_empty(tre_stack_t *stack, tre_ast_node_t *node, int *tags,
        int *assertions, int *num_tags_seen)
{
  tre_literal_t *lit;
  tre_union_t *uni;
  tre_catenation_t *cat;
  tre_iteration_t *iter;
  int i;
  int bottom = tre_stack_num_objects(stack);
  reg_errcode_t status = REG_OK;
  if (num_tags_seen)
    *num_tags_seen = 0;

  status = tre_stack_push_voidptr(stack, node);

  /* Walk through the tree recursively. */
  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
    {
      node = (tre_ast_node_t *)tre_stack_pop_voidptr(stack);

      switch (node->type)
    {
    case LITERAL:
      lit = (tre_literal_t *)node->obj;
      switch (lit->code_min)
        {
        case TAG:
          if (lit->code_max >= 0)
        {
          if (tags != NULL)
            {
              /* Add the tag to `tags'. */
              for (i = 0; tags[i] >= 0; i++)
            if (tags[i] == lit->code_max)
              break;
              if (tags[i] < 0)
            {
              tags[i] = lit->code_max;
              tags[i + 1] = -1;
            }
            }
          if (num_tags_seen)
            (*num_tags_seen)++;
        }
          break;
        case ASSERTION:
          assert(lit->code_max >= 1
             || lit->code_max <= ASSERT_LAST);
          if (assertions != NULL)
        *assertions |= lit->code_max;
          break;
        case EMPTY:
          break;
        default:
          assert(0);
          break;
        }
      break;

    case UNION:
      /* Subexpressions starting earlier take priority over ones
         starting later, so we prefer the left subexpression over the
         right subexpression. */
      uni = (tre_union_t *)node->obj;
      if (uni->left->nullable)
        STACK_PUSHX(stack, voidptr, uni->left)
      else if (uni->right->nullable)
        STACK_PUSHX(stack, voidptr, uni->right)
      else
        assert(0);
      break;

    case CATENATION:
      /* The path must go through both children. */
      cat = (tre_catenation_t *)node->obj;
      assert(cat->left->nullable);
      assert(cat->right->nullable);
      STACK_PUSHX(stack, voidptr, cat->left);
      STACK_PUSHX(stack, voidptr, cat->right);
      break;

    case ITERATION:
      /* A match with an empty string is preferred over no match at
         all, so we go through the argument if possible. */
      iter = (tre_iteration_t *)node->obj;
      if (iter->arg->nullable)
        STACK_PUSHX(stack, voidptr, iter->arg);
      break;

    default:
      assert(0);
      break;
    }
    }

  return status;
}


typedef enum {
  NFL_RECURSE,
  NFL_POST_UNION,
  NFL_POST_CATENATION,
  NFL_POST_ITERATION
} tre_nfl_stack_symbol_t;


/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
   the nodes of the AST `tree'. */
static reg_errcode_t
tre_compute_nfl(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree)
{
  int bottom = tre_stack_num_objects(stack);

  STACK_PUSHR(stack, voidptr, tree);
  STACK_PUSHR(stack, int, NFL_RECURSE);

  while (tre_stack_num_objects(stack) > bottom)
    {
      tre_nfl_stack_symbol_t symbol;
      tre_ast_node_t *node;

      symbol = (tre_nfl_stack_symbol_t)tre_stack_pop_int(stack);
      node = (tre_ast_node_t *)tre_stack_pop_voidptr(stack);
      switch (symbol)
    {
    case NFL_RECURSE:
      switch (node->type)
        {
        case LITERAL:
          {
        tre_literal_t *lit = (tre_literal_t *)node->obj;
        if (IS_BACKREF(lit))
          {
            /* Back references: nullable = false, firstpos = {i},
               lastpos = {i}. */
            node->nullable = 0;
            node->firstpos = tre_set_one(mem, lit->position, 0,
                         TRE_CHAR_MAX, 0, NULL, -1);
            if (!node->firstpos)
              return REG_ESPACE;
            node->lastpos = tre_set_one(mem, lit->position, 0,
                        TRE_CHAR_MAX, 0, NULL,
                        (int)lit->code_max);
            if (!node->lastpos)
              return REG_ESPACE;
          }
        else if (lit->code_min < 0)
          {
            /* Tags, empty strings, params, and zero width assertions:
               nullable = true, firstpos = {}, and lastpos = {}. */
            node->nullable = 1;
            node->firstpos = tre_set_empty(mem);
            if (!node->firstpos)
              return REG_ESPACE;
            node->lastpos = tre_set_empty(mem);
            if (!node->lastpos)
              return REG_ESPACE;
          }
        else
          {
            /* Literal at position i: nullable = false, firstpos = {i},
               lastpos = {i}. */
            node->nullable = 0;
            node->firstpos =
              tre_set_one(mem, lit->position, (int)lit->code_min,
                  (int)lit->code_max, 0, NULL, -1);
            if (!node->firstpos)
              return REG_ESPACE;
            node->lastpos = tre_set_one(mem, lit->position,
                        (int)lit->code_min,
                        (int)lit->code_max,
                        lit->rclass, lit->neg_classes,
                        -1);
            if (!node->lastpos)
              return REG_ESPACE;
          }
        break;
          }

        case UNION:
          /* Compute the attributes for the two subtrees, and after that
         for this node. */
          STACK_PUSHR(stack, voidptr, node);
          STACK_PUSHR(stack, int, NFL_POST_UNION);
          STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->right);
          STACK_PUSHR(stack, int, NFL_RECURSE);
          STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->left);
          STACK_PUSHR(stack, int, NFL_RECURSE);
          break;

        case CATENATION:
          /* Compute the attributes for the two subtrees, and after that
         for this node. */
          STACK_PUSHR(stack, voidptr, node);
          STACK_PUSHR(stack, int, NFL_POST_CATENATION);
          STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->right);
          STACK_PUSHR(stack, int, NFL_RECURSE);
          STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->left);
          STACK_PUSHR(stack, int, NFL_RECURSE);
          break;

        case ITERATION:
          /* Compute the attributes for the subtree, and after that for
         this node. */
          STACK_PUSHR(stack, voidptr, node);
          STACK_PUSHR(stack, int, NFL_POST_ITERATION);
          STACK_PUSHR(stack, voidptr, ((tre_iteration_t *)node->obj)->arg);
          STACK_PUSHR(stack, int, NFL_RECURSE);
          break;
        }
      break; /* end case: NFL_RECURSE */

    case NFL_POST_UNION:
      {
        tre_union_t *uni = (tre_union_t *)node->obj;
        node->nullable = uni->left->nullable || uni->right->nullable;
        node->firstpos = tre_set_union(mem, uni->left->firstpos,
                       uni->right->firstpos, NULL, 0);
        if (!node->firstpos)
          return REG_ESPACE;
        node->lastpos = tre_set_union(mem, uni->left->lastpos,
                      uni->right->lastpos, NULL, 0);
        if (!node->lastpos)
          return REG_ESPACE;
        break;
      }

    case NFL_POST_ITERATION:
      {
        tre_iteration_t *iter = (tre_iteration_t *)node->obj;

        if (iter->min == 0 || iter->arg->nullable)
          node->nullable = 1;
        else
          node->nullable = 0;
        node->firstpos = iter->arg->firstpos;
        node->lastpos = iter->arg->lastpos;
        break;
      }

    case NFL_POST_CATENATION:
      {
        int num_tags, *tags, assertions;
        reg_errcode_t status;
        tre_catenation_t *cat = (tre_catenation_t *)node->obj;
        node->nullable = cat->left->nullable && cat->right->nullable;

        /* Compute firstpos. */
        if (cat->left->nullable)
          {
        /* The left side matches the empty string.  Make a first pass
           with tre_match_empty() to get the number of tags and
           parameters. */
        status = tre_match_empty(stack, cat->left,
                     NULL, NULL, &num_tags);
        if (status != REG_OK)
          return status;
        /* Allocate arrays for the tags and parameters. */
        tags = (int*)xmalloc(sizeof(*tags) * (num_tags + 1));
        if (!tags)
          return REG_ESPACE;
        tags[0] = -1;
        assertions = 0;
        /* Second pass with tre_mach_empty() to get the list of
           tags and parameters. */
        status = tre_match_empty(stack, cat->left, tags,
                     &assertions, NULL);
        if (status != REG_OK)
          {
            xfree(tags);
            return status;
          }
        node->firstpos =
          tre_set_union(mem, cat->right->firstpos, cat->left->firstpos,
                tags, assertions);
        xfree(tags);
        if (!node->firstpos)
          return REG_ESPACE;
          }
        else
          {
        node->firstpos = cat->left->firstpos;
          }

        /* Compute lastpos. */
        if (cat->right->nullable)
          {
        /* The right side matches the empty string.  Make a first pass
           with tre_match_empty() to get the number of tags and
           parameters. */
        status = tre_match_empty(stack, cat->right,
                     NULL, NULL, &num_tags);
        if (status != REG_OK)
          return status;
        /* Allocate arrays for the tags and parameters. */
        tags = (int*)xmalloc(sizeof(int) * (num_tags + 1));
        if (!tags)
          return REG_ESPACE;
        tags[0] = -1;
        assertions = 0;
        /* Second pass with tre_mach_empty() to get the list of
           tags and parameters. */
        status = tre_match_empty(stack, cat->right, tags,
                     &assertions, NULL);
        if (status != REG_OK)
          {
            xfree(tags);
            return status;
          }
        node->lastpos =
          tre_set_union(mem, cat->left->lastpos, cat->right->lastpos,
                tags, assertions);
        xfree(tags);
        if (!node->lastpos)
          return REG_ESPACE;
          }
        else
          {
        node->lastpos = cat->right->lastpos;
          }
        break;
      }

    default:
      assert(0);
      break;
    }
    }

  return REG_OK;
}


/* Adds a transition from each position in `p1' to each position in `p2'. */
static reg_errcode_t
tre_make_trans(tre_pos_and_tags_t *p1, tre_pos_and_tags_t *p2,
           tre_tnfa_transition_t *transitions,
           int *counts, int *offs)
{
  tre_pos_and_tags_t *orig_p2 = p2;
  tre_tnfa_transition_t *trans;
  int i, j, k, l, dup, prev_p2_pos;

  if (transitions != NULL)
    while (p1->position >= 0)
      {
    p2 = orig_p2;
    prev_p2_pos = -1;
    while (p2->position >= 0)
      {
        /* Optimization: if this position was already handled, skip it. */
        if (p2->position == prev_p2_pos)
          {
        p2++;
        continue;
          }
        prev_p2_pos = p2->position;
        /* Set `trans' to point to the next unused transition from
           position `p1->position'. */
        trans = transitions + offs[p1->position];
        while (trans->state != NULL)
          {
#if 0
        /* If we find a previous transition from `p1->position' to
           `p2->position', it is overwritten.  This can happen only
           if there are nested loops in the regexp, like in "((a)*)*".
           In POSIX.2 repetition using the outer loop is always
           preferred over using the inner loop.  Therefore the
           transition for the inner loop is useless and can be thrown
           away. */
        /* XXX - The same position is used for all nodes in a bracket
           expression, so this optimization cannot be used (it will
           break bracket expressions) unless I figure out a way to
           detect it here. */
        if (trans->state_id == p2->position)
          {
            break;
          }
#endif
        trans++;
          }

        if (trans->state == NULL)
          (trans + 1)->state = NULL;
        /* Use the character ranges, assertions, etc. from `p1' for
           the transition from `p1' to `p2'. */
        trans->code_min = p1->code_min;
        trans->code_max = p1->code_max;
        trans->state = transitions + offs[p2->position];
        trans->state_id = p2->position;
        trans->assertions = p1->assertions | p2->assertions
          | (p1->rclass ? ASSERT_CHAR_CLASS : 0)
          | (p1->neg_classes != NULL ? ASSERT_CHAR_CLASS_NEG : 0);
        if (p1->backref >= 0)
          {
        assert((trans->assertions & ASSERT_CHAR_CLASS) == 0);
        assert(p2->backref < 0);
        trans->u.backref = p1->backref;
        trans->assertions |= ASSERT_BACKREF;
          }
        else
          trans->u.rclass = p1->rclass;
        if (p1->neg_classes != NULL)
          {
        for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++);
        trans->neg_classes =
          (tre_ctype_t*)xmalloc(sizeof(*trans->neg_classes) * (i + 1));
        if (trans->neg_classes == NULL)
          return REG_ESPACE;
        for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++)
          trans->neg_classes[i] = p1->neg_classes[i];
        trans->neg_classes[i] = (tre_ctype_t)0;
          }
        else
          trans->neg_classes = NULL;

        /* Find out how many tags this transition has. */
        i = 0;
        if (p1->tags != NULL)
          while(p1->tags[i] >= 0)
        i++;
        j = 0;
        if (p2->tags != NULL)
          while(p2->tags[j] >= 0)
        j++;

        /* If we are overwriting a transition, free the old tag array. */
        if (trans->tags != NULL)
          xfree(trans->tags);
        trans->tags = NULL;

        /* If there were any tags, allocate an array and fill it. */
        if (i + j > 0)
          {
        trans->tags = (int*)xmalloc(sizeof(*trans->tags) * (i + j + 1));
        if (!trans->tags)
          return REG_ESPACE;
        i = 0;
        if (p1->tags != NULL)
          while(p1->tags[i] >= 0)
            {
              trans->tags[i] = p1->tags[i];
              i++;
            }
        l = i;
        j = 0;
        if (p2->tags != NULL)
          while (p2->tags[j] >= 0)
            {
              /* Don't add duplicates. */
              dup = 0;
              for (k = 0; k < i; k++)
            if (trans->tags[k] == p2->tags[j])
              {
                dup = 1;
                break;
              }
              if (!dup)
            trans->tags[l++] = p2->tags[j];
              j++;
            }
        trans->tags[l] = -1;
          }

        p2++;
      }
    p1++;
      }
  else
    /* Compute a maximum limit for the number of transitions leaving
       from each state. */
    while (p1->position >= 0)
      {
    p2 = orig_p2;
    while (p2->position >= 0)
      {
        counts[p1->position]++;
        p2++;
      }
    p1++;
      }
  return REG_OK;
}

/* Converts the syntax tree to a TNFA.  All the transitions in the TNFA are
   labelled with one character range (there are no transitions on empty
   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
   the regexp. */
static reg_errcode_t
tre_ast_to_tnfa(tre_ast_node_t *node, tre_tnfa_transition_t *transitions,
        int *counts, int *offs)
{
  tre_union_t *uni;
  tre_catenation_t *cat;
  tre_iteration_t *iter;
  reg_errcode_t errcode = REG_OK;

  /* XXX - recurse using a stack!. */
  switch (node->type)
    {
    case LITERAL:
      break;
    case UNION:
      uni = (tre_union_t *)node->obj;
      errcode = tre_ast_to_tnfa(uni->left, transitions, counts, offs);
      if (errcode != REG_OK)
    return errcode;
      errcode = tre_ast_to_tnfa(uni->right, transitions, counts, offs);
      break;

    case CATENATION:
      cat = (tre_catenation_t *)node->obj;
      /* Add a transition from each position in cat->left->lastpos
     to each position in cat->right->firstpos. */
      errcode = tre_make_trans(cat->left->lastpos, cat->right->firstpos,
                   transitions, counts, offs);
      if (errcode != REG_OK)
    return errcode;
      errcode = tre_ast_to_tnfa(cat->left, transitions, counts, offs);
      if (errcode != REG_OK)
    return errcode;
      errcode = tre_ast_to_tnfa(cat->right, transitions, counts, offs);
      break;

    case ITERATION:
      iter = (tre_iteration_t *)node->obj;
      assert(iter->max == -1 || iter->max == 1);

      if (iter->max == -1)
    {
      assert(iter->min == 0 || iter->min == 1);
      /* Add a transition from each last position in the iterated
         expression to each first position. */
      errcode = tre_make_trans(iter->arg->lastpos, iter->arg->firstpos,
                   transitions, counts, offs);
      if (errcode != REG_OK)
        return errcode;
    }
      errcode = tre_ast_to_tnfa(iter->arg, transitions, counts, offs);
      break;
    }
  return errcode;
}


#define ERROR_EXIT(err)       \
  do                  \
    {                 \
      errcode = err;          \
      if (/*CONSTCOND*/1)     \
        goto error_exit;      \
    }                 \
 while (/*CONSTCOND*/0)

#ifdef __cplusplus
#define restrict
#endif
int
regcomp(regex_t *restrict preg, const char *restrict regex, int cflags)
{
  tre_stack_t *stack;
  tre_ast_node_t *tree, *tmp_ast_l, *tmp_ast_r;
  tre_pos_and_tags_t *p;
  int *counts = NULL, *offs = NULL;
  int i, add = 0;
  tre_tnfa_transition_t *transitions, *initial;
  tre_tnfa_t *tnfa = NULL;
  tre_submatch_data_t *submatch_data;
  tre_tag_direction_t *tag_directions = NULL;
  reg_errcode_t errcode;
  tre_mem_t mem;

  /* Parse context. */
  tre_parse_ctx_t parse_ctx;

  /* Allocate a stack used throughout the compilation process for various
     purposes. */
  stack = tre_stack_new(512, 10240, 128);
  if (!stack)
    return REG_ESPACE;
  /* Allocate a fast memory allocator. */
  mem = tre_mem_new();
  if (!mem)
    {
      tre_stack_destroy(stack);
      return REG_ESPACE;
    }

  /* Parse the regexp. */
  memset(&parse_ctx, 0, sizeof(parse_ctx));
  parse_ctx.mem = mem;
  parse_ctx.stack = stack;
  parse_ctx.re = regex;
  parse_ctx.cflags = cflags;
  parse_ctx.max_backref = -1;
  errcode = tre_parse(&parse_ctx);
  if (errcode != REG_OK)
    ERROR_EXIT(errcode);
  preg->re_nsub = parse_ctx.submatch_id - 1;
  tree = parse_ctx.n;

#ifdef TRE_DEBUG
  tre_ast_print(tree);
#endif /* TRE_DEBUG */

  /* Referring to nonexistent subexpressions is illegal. */
  if (parse_ctx.max_backref > (int)preg->re_nsub)
    ERROR_EXIT(REG_ESUBREG);

  /* Allocate the TNFA struct. */
  tnfa = (tre_tnfa_t*)xcalloc(1, sizeof(tre_tnfa_t));
  if (tnfa == NULL)
    ERROR_EXIT(REG_ESPACE);
  tnfa->have_backrefs = parse_ctx.max_backref >= 0;
  tnfa->have_approx = 0;
  tnfa->num_submatches = parse_ctx.submatch_id;

  /* Set up tags for submatch addressing.  If REG_NOSUB is set and the
     regexp does not have back references, this can be skipped. */
  if (tnfa->have_backrefs || !(cflags & REG_NOSUB))
    {

      /* Figure out how many tags we will need. */
      errcode = tre_add_tags(NULL, stack, tree, tnfa);
      if (errcode != REG_OK)
    ERROR_EXIT(errcode);

      if (tnfa->num_tags > 0)
    {
      tag_directions = (tre_tag_direction_t*)xmalloc(sizeof(*tag_directions)
                   * (tnfa->num_tags + 1));
      if (tag_directions == NULL)
        ERROR_EXIT(REG_ESPACE);
      tnfa->tag_directions = tag_directions;
      memset(tag_directions, -1,
         sizeof(*tag_directions) * (tnfa->num_tags + 1));
    }
      tnfa->minimal_tags = (int*)xcalloc((unsigned)tnfa->num_tags * 2 + 1,
                   sizeof(*tnfa->minimal_tags));
      if (tnfa->minimal_tags == NULL)
    ERROR_EXIT(REG_ESPACE);

      submatch_data = (tre_submatch_data_t*)xcalloc((unsigned)parse_ctx.submatch_id,
                  sizeof(*submatch_data));
      if (submatch_data == NULL)
    ERROR_EXIT(REG_ESPACE);
      tnfa->submatch_data = submatch_data;

      errcode = tre_add_tags(mem, stack, tree, tnfa);
      if (errcode != REG_OK)
    ERROR_EXIT(errcode);

    }

  /* Expand iteration nodes. */
  errcode = tre_expand_ast(mem, stack, tree, &parse_ctx.position,
               tag_directions);
  if (errcode != REG_OK)
    ERROR_EXIT(errcode);

  /* Add a dummy node for the final state.
     XXX - For certain patterns this dummy node can be optimized away,
       for example "a*" or "ab*".   Figure out a simple way to detect
       this possibility. */
  tmp_ast_l = tree;
  tmp_ast_r = tre_ast_new_literal(mem, 0, 0, parse_ctx.position++);
  if (tmp_ast_r == NULL)
    ERROR_EXIT(REG_ESPACE);

  tree = tre_ast_new_catenation(mem, tmp_ast_l, tmp_ast_r);
  if (tree == NULL)
    ERROR_EXIT(REG_ESPACE);

  errcode = tre_compute_nfl(mem, stack, tree);
  if (errcode != REG_OK)
    ERROR_EXIT(errcode);

  counts = (int*)xmalloc(sizeof(int) * parse_ctx.position);
  if (counts == NULL)
    ERROR_EXIT(REG_ESPACE);

  offs = (int*)xmalloc(sizeof(int) * parse_ctx.position);
  if (offs == NULL)
    ERROR_EXIT(REG_ESPACE);

  for (i = 0; i < parse_ctx.position; i++)
    counts[i] = 0;
  tre_ast_to_tnfa(tree, NULL, counts, NULL);

  add = 0;
  for (i = 0; i < parse_ctx.position; i++)
    {
      offs[i] = add;
      add += counts[i] + 1;
      counts[i] = 0;
    }
  transitions = (tre_tnfa_transition_t*)xcalloc((unsigned)add + 1, sizeof(*transitions));
  if (transitions == NULL)
    ERROR_EXIT(REG_ESPACE);
  tnfa->transitions = transitions;
  tnfa->num_transitions = add;

  errcode = tre_ast_to_tnfa(tree, transitions, counts, offs);
  if (errcode != REG_OK)
    ERROR_EXIT(errcode);

  tnfa->firstpos_chars = NULL;

  p = tree->firstpos;
  i = 0;
  while (p->position >= 0)
    {
      i++;
      p++;
    }

  initial = (tre_tnfa_transition_t*)xcalloc((unsigned)i + 1, sizeof(tre_tnfa_transition_t));
  if (initial == NULL)
    ERROR_EXIT(REG_ESPACE);
  tnfa->initial = initial;

  i = 0;
  for (p = tree->firstpos; p->position >= 0; p++)
    {
      initial[i].state = transitions + offs[p->position];
      initial[i].state_id = p->position;
      initial[i].tags = NULL;
      /* Copy the arrays p->tags, and p->params, they are allocated
     from a tre_mem object. */
      if (p->tags)
    {
      int j;
      for (j = 0; p->tags[j] >= 0; j++);
      initial[i].tags = (int*)xmalloc(sizeof(*p->tags) * (j + 1));
      if (!initial[i].tags)
        ERROR_EXIT(REG_ESPACE);
      memcpy(initial[i].tags, p->tags, sizeof(*p->tags) * (j + 1));
    }
      initial[i].assertions = p->assertions;
      i++;
    }
  initial[i].state = NULL;

  tnfa->num_transitions = add;
  tnfa->final = transitions + offs[tree->lastpos[0].position];
  tnfa->num_states = parse_ctx.position;
  tnfa->cflags = cflags;

  tre_mem_destroy(mem);
  tre_stack_destroy(stack);
  xfree(counts);
  xfree(offs);

  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
  return REG_OK;

 error_exit:
  /* Free everything that was allocated and return the error code. */
  tre_mem_destroy(mem);
  if (stack != NULL)
    tre_stack_destroy(stack);
  if (counts != NULL)
    xfree(counts);
  if (offs != NULL)
    xfree(offs);
  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
  regfree(preg);
  return errcode;
}

#ifdef __cplusplus
#undef restrict
#endif


void
regfree(regex_t *preg)
{
  tre_tnfa_t *tnfa;
  unsigned int i;
  tre_tnfa_transition_t *trans;

  tnfa = (tre_tnfa_t*)preg->TRE_REGEX_T_FIELD;
  if (!tnfa)
    return;

  for (i = 0; i < tnfa->num_transitions; i++)
    if (tnfa->transitions[i].state)
      {
    if (tnfa->transitions[i].tags)
      xfree(tnfa->transitions[i].tags);
    if (tnfa->transitions[i].neg_classes)
      xfree(tnfa->transitions[i].neg_classes);
      }
  if (tnfa->transitions)
    xfree(tnfa->transitions);

  if (tnfa->initial)
    {
      for (trans = tnfa->initial; trans->state; trans++)
    {
      if (trans->tags)
        xfree(trans->tags);
    }
      xfree(tnfa->initial);
    }

  if (tnfa->submatch_data)
    {
      for (i = 0; i < tnfa->num_submatches; i++)
    if (tnfa->submatch_data[i].parents)
      xfree(tnfa->submatch_data[i].parents);
      xfree(tnfa->submatch_data);
    }

  if (tnfa->tag_directions)
    xfree(tnfa->tag_directions);
  if (tnfa->firstpos_chars)
    xfree(tnfa->firstpos_chars);
  if (tnfa->minimal_tags)
    xfree(tnfa->minimal_tags);
  xfree(tnfa);
}
#include <string.h>
#ifndef JSI_AMALGAMATION
#include <regex.h>
#endif
#include <stdio.h>
//#include "locale_impl.h"

/* Error message strings for error codes listed in `regex.h'.  This list
   needs to be in sync with the codes listed there, naturally. */

/* Converted to single string by Rich Felker to remove the need for
 * data relocations at runtime, 27 Feb 2006. */

static const char messages[] = {
  "No error\0"
  "No match\0"
  "Invalid regexp\0"
  "Unknown collating element\0"
  "Unknown character class name\0"
  "Trailing backslash\0"
  "Invalid back reference\0"
  "Missing ']'\0"
  "Missing ')'\0"
  "Missing '}'\0"
  "Invalid contents of {}\0"
  "Invalid character range\0"
  "Out of memory\0"
  "Repetition not preceded by valid expression\0"
  "\0Unknown error"
};

#ifdef __cplusplus
#define restrict
#endif
size_t regerror(int e, const regex_t *restrict preg, char *restrict buf, size_t size)
{
    const char *s;
    for (s=messages; e && *s; e--, s+=strlen(s)+1);
    if (!*s) s++;
    //s = LCTRANS_CUR(s);
    return 1+snprintf(buf, size, "%s", s);
}
#ifdef __cplusplus
#undef restrict
#endif
/*
  regexec.c - TRE POSIX compatible matching functions (and more).

  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <wctype.h>
#include <limits.h>

#ifndef JSI_AMALGAMATION
#include <regex.h>
#include "tre.h"
#endif

#include <assert.h>

static void
tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
		const tre_tnfa_t *tnfa, int *tags, int match_eo);

/***********************************************************************
 from tre-match-utils.h
***********************************************************************/

#define GET_NEXT_WCHAR() do {                                                 \
    prev_c = next_c; pos += pos_add_next;                                     \
    if ((pos_add_next = mbtowc(&next_c, str_byte, MB_LEN_MAX)) <= 0) {        \
        if (pos_add_next < 0) { ret = REG_NOMATCH; goto error_exit; }         \
        else pos_add_next++;                                                  \
    }                                                                         \
    str_byte += pos_add_next;                                                 \
  } while (0)

#define IS_WORD_CHAR(c)	 ((c) == L'_' || tre_isalnum(c))

#define CHECK_ASSERTIONS(assertions)					      \
  (((assertions & ASSERT_AT_BOL)					      \
    && (pos > 0 || reg_notbol)						      \
    && (prev_c != L'\n' || !reg_newline))				      \
   || ((assertions & ASSERT_AT_EOL)					      \
       && (next_c != L'\0' || reg_noteol)				      \
       && (next_c != L'\n' || !reg_newline))				      \
   || ((assertions & ASSERT_AT_BOW)					      \
       && (IS_WORD_CHAR(prev_c) || !IS_WORD_CHAR(next_c)))	              \
   || ((assertions & ASSERT_AT_EOW)					      \
       && (!IS_WORD_CHAR(prev_c) || IS_WORD_CHAR(next_c)))		      \
   || ((assertions & ASSERT_AT_WB)					      \
       && (pos != 0 && next_c != L'\0'					      \
	   && IS_WORD_CHAR(prev_c) == IS_WORD_CHAR(next_c)))		      \
   || ((assertions & ASSERT_AT_WB_NEG)					      \
       && (pos == 0 || next_c == L'\0'					      \
	   || IS_WORD_CHAR(prev_c) != IS_WORD_CHAR(next_c))))

#define CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)                             \
  (((trans_i->assertions & ASSERT_CHAR_CLASS)                                 \
       && !(tnfa->cflags & REG_ICASE)                                         \
       && !tre_isctype((tre_cint_t)prev_c, trans_i->u.rclass))                 \
    || ((trans_i->assertions & ASSERT_CHAR_CLASS)                             \
        && (tnfa->cflags & REG_ICASE)                                         \
        && !tre_isctype(tre_tolower((tre_cint_t)prev_c),trans_i->u.rclass)     \
	&& !tre_isctype(tre_toupper((tre_cint_t)prev_c),trans_i->u.rclass))    \
    || ((trans_i->assertions & ASSERT_CHAR_CLASS_NEG)                         \
        && tre_neg_char_classes_match(trans_i->neg_classes,(tre_cint_t)prev_c,\
                                      tnfa->cflags & REG_ICASE)))




/* Returns 1 if `t1' wins `t2', 0 otherwise. */
static int
tre_tag_order(int num_tags, tre_tag_direction_t *tag_directions,
	      int *t1, int *t2)
{
  int i;
  for (i = 0; i < num_tags; i++)
    {
      if (tag_directions[i] == TRE_TAG_MINIMIZE)
	{
	  if (t1[i] < t2[i])
	    return 1;
	  if (t1[i] > t2[i])
	    return 0;
	}
      else
	{
	  if (t1[i] > t2[i])
	    return 1;
	  if (t1[i] < t2[i])
	    return 0;
	}
    }
  /*  assert(0);*/
  return 0;
}

static int
tre_neg_char_classes_match(tre_ctype_t *classes, tre_cint_t wc, int icase)
{
  while (*classes != (tre_ctype_t)0)
    if ((!icase && tre_isctype(wc, *classes))
	|| (icase && (tre_isctype(tre_toupper(wc), *classes)
		      || tre_isctype(tre_tolower(wc), *classes))))
      return 1; /* Match. */
    else
      classes++;
  return 0; /* No match. */
}


/***********************************************************************
 from tre-match-parallel.c
***********************************************************************/

/*
  This algorithm searches for matches basically by reading characters
  in the searched strval one by one, starting at the beginning.	 All
  matching paths in the TNFA are traversed in parallel.	 When two or
  more paths reach the same state, exactly one is chosen according to
  tag ordering rules; if returning submatches is not required it does
  not matter which path is chosen.

  The worst case time required for finding the leftmost and longest
  match, or determining that there is no match, is always linearly
  dependent on the length of the text being searched.

  This algorithm cannot handle TNFAs with back referencing nodes.
  See `tre-match-backtrack.c'.
*/

typedef struct {
  tre_tnfa_transition_t *state;
  int *tags;
} tre_tnfa_reach_t;

typedef struct {
  int pos;
  int **tags;
} tre_reach_pos_t;


static reg_errcode_t
tre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *strval,
		      int *match_tags, int eflags,
		      int *match_end_ofs)
{
  /* State variables required by GET_NEXT_WCHAR. */
  tre_char_t prev_c = 0, next_c = 0;
  const char *str_byte = (char *)strval;
  int pos = -1;
  int pos_add_next = 1;
#ifdef TRE_MBSTATE
  mbstate_t mbstate;
#endif /* TRE_MBSTATE */
  int reg_notbol = eflags & REG_NOTBOL;
  int reg_noteol = eflags & REG_NOTEOL;
  int reg_newline = tnfa->cflags & REG_NEWLINE;
  reg_errcode_t ret;

  char *buf;
  tre_tnfa_transition_t *trans_i;
  tre_tnfa_reach_t *reach, *reach_next, *reach_i, *reach_next_i;
  tre_reach_pos_t *reach_pos;
  int *tag_i;
  int num_tags, i;

  int match_eo = -1;	   /* end offset of match (-1 if no match found yet) */
  int new_match = 0;
  int *tmp_tags = NULL;
  int *tmp_iptr;

#ifdef TRE_MBSTATE
  memset(&mbstate, '\0', sizeof(mbstate));
#endif /* TRE_MBSTATE */

  if (!match_tags)
    num_tags = 0;
  else
    num_tags = tnfa->num_tags;

  /* Allocate memory for temporary data required for matching.	This needs to
     be done for every matching operation to be thread safe.  This allocates
     everything in a single large block from the stack frame using alloca()
     or with malloc() if alloca is unavailable. */
  {
    int tbytes, rbytes, pbytes, xbytes, total_bytes;
    char *tmp_buf;
    /* Compute the length of the block we need. */
    tbytes = sizeof(*tmp_tags) * num_tags;
    rbytes = sizeof(*reach_next) * (tnfa->num_states + 1);
    pbytes = sizeof(*reach_pos) * tnfa->num_states;
    xbytes = sizeof(int) * num_tags;
    total_bytes =
      (sizeof(long) - 1) * 4 /* for alignment paddings */
      + (rbytes + xbytes * tnfa->num_states) * 2 + tbytes + pbytes;

    /* Allocate the memory. */
    buf = (char *)xmalloc((unsigned)total_bytes);
    if (buf == NULL)
      return REG_ESPACE;
    memset(buf, 0, (size_t)total_bytes);

    /* Get the various pointers within tmp_buf (properly aligned). */
    tmp_tags = (int *)buf;
    tmp_buf = buf + tbytes;
    tmp_buf += ALIGN(tmp_buf, long);
    reach_next = (tre_tnfa_reach_t *)tmp_buf;
    tmp_buf += rbytes;
    tmp_buf += ALIGN(tmp_buf, long);
    reach = (tre_tnfa_reach_t *)tmp_buf;
    tmp_buf += rbytes;
    tmp_buf += ALIGN(tmp_buf, long);
    reach_pos = (tre_reach_pos_t *)tmp_buf;
    tmp_buf += pbytes;
    tmp_buf += ALIGN(tmp_buf, long);
    for (i = 0; i < tnfa->num_states; i++)
      {
	reach[i].tags = (int *)tmp_buf;
	tmp_buf += xbytes;
	reach_next[i].tags = (int *)tmp_buf;
	tmp_buf += xbytes;
      }
  }

  for (i = 0; i < tnfa->num_states; i++)
    reach_pos[i].pos = -1;

  GET_NEXT_WCHAR();
  pos = 0;

  reach_next_i = reach_next;
  while (1)
    {
      /* If no match found yet, add the initial states to `reach_next'. */
      if (match_eo < 0)
	{
	  trans_i = tnfa->initial;
	  while (trans_i->state != NULL)
	    {
	      if (reach_pos[trans_i->state_id].pos < pos)
		{
		  if (trans_i->assertions
		      && CHECK_ASSERTIONS(trans_i->assertions))
		    {
		      trans_i++;
		      continue;
		    }

		  reach_next_i->state = trans_i->state;
		  for (i = 0; i < num_tags; i++)
		    reach_next_i->tags[i] = -1;
		  tag_i = trans_i->tags;
		  if (tag_i)
		    while (*tag_i >= 0)
		      {
			if (*tag_i < num_tags)
			  reach_next_i->tags[*tag_i] = pos;
			tag_i++;
		      }
		  if (reach_next_i->state == tnfa->final)
		    {
		      match_eo = pos;
		      new_match = 1;
		      for (i = 0; i < num_tags; i++)
			match_tags[i] = reach_next_i->tags[i];
		    }
		  reach_pos[trans_i->state_id].pos = pos;
		  reach_pos[trans_i->state_id].tags = &reach_next_i->tags;
		  reach_next_i++;
		}
	      trans_i++;
	    }
	  reach_next_i->state = NULL;
	}
      else
	{
	  if (num_tags == 0 || reach_next_i == reach_next)
	    /* We have found a match. */
	    break;
	}

      /* Check for end of strval. */
      if (!next_c) break;

      GET_NEXT_WCHAR();

      /* Swap `reach' and `reach_next'. */
      reach_i = reach;
      reach = reach_next;
      reach_next = reach_i;

      /* For each state in `reach', weed out states that don't fulfill the
	 minimal matching conditions. */
      if (tnfa->num_minimals && new_match)
	{
	  new_match = 0;
	  reach_next_i = reach_next;
	  for (reach_i = reach; reach_i->state; reach_i++)
	    {
	      int skip = 0;
	      for (i = 0; tnfa->minimal_tags[i] >= 0; i += 2)
		{
		  int end = tnfa->minimal_tags[i];
		  int start = tnfa->minimal_tags[i + 1];
		  if (end >= num_tags)
		    {
		      skip = 1;
		      break;
		    }
		  else if (reach_i->tags[start] == match_tags[start]
			   && reach_i->tags[end] < match_tags[end])
		    {
		      skip = 1;
		      break;
		    }
		}
	      if (!skip)
		{
		  reach_next_i->state = reach_i->state;
		  tmp_iptr = reach_next_i->tags;
		  reach_next_i->tags = reach_i->tags;
		  reach_i->tags = tmp_iptr;
		  reach_next_i++;
		}
	    }
	  reach_next_i->state = NULL;

	  /* Swap `reach' and `reach_next'. */
	  reach_i = reach;
	  reach = reach_next;
	  reach_next = reach_i;
	}

      /* For each state in `reach' see if there is a transition leaving with
	 the current input symbol to a state not yet in `reach_next', and
	 add the destination states to `reach_next'. */
      reach_next_i = reach_next;
      for (reach_i = reach; reach_i->state; reach_i++)
	{
	  for (trans_i = reach_i->state; trans_i->state; trans_i++)
	    {
	      /* Does this transition match the input symbol? */
	      if (trans_i->code_min <= (tre_cint_t)prev_c &&
		  trans_i->code_max >= (tre_cint_t)prev_c)
		{
		  if (trans_i->assertions
		      && (CHECK_ASSERTIONS(trans_i->assertions)
			  || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
		    {
		      continue;
		    }

		  /* Compute the tags after this transition. */
		  for (i = 0; i < num_tags; i++)
		    tmp_tags[i] = reach_i->tags[i];
		  tag_i = trans_i->tags;
		  if (tag_i != NULL)
		    while (*tag_i >= 0)
		      {
			if (*tag_i < num_tags)
			  tmp_tags[*tag_i] = pos;
			tag_i++;
		      }

		  if (reach_pos[trans_i->state_id].pos < pos)
		    {
		      /* Found an unvisited node. */
		      reach_next_i->state = trans_i->state;
		      tmp_iptr = reach_next_i->tags;
		      reach_next_i->tags = tmp_tags;
		      tmp_tags = tmp_iptr;
		      reach_pos[trans_i->state_id].pos = pos;
		      reach_pos[trans_i->state_id].tags = &reach_next_i->tags;

		      if (reach_next_i->state == tnfa->final
			  && (match_eo == -1
			      || (num_tags > 0
				  && reach_next_i->tags[0] <= match_tags[0])))
			{
			  match_eo = pos;
			  new_match = 1;
			  for (i = 0; i < num_tags; i++)
			    match_tags[i] = reach_next_i->tags[i];
			}
		      reach_next_i++;

		    }
		  else
		    {
		      assert(reach_pos[trans_i->state_id].pos == pos);
		      /* Another path has also reached this state.  We choose
			 the winner by examining the tag values for both
			 paths. */
		      if (tre_tag_order(num_tags, tnfa->tag_directions,
					tmp_tags,
					*reach_pos[trans_i->state_id].tags))
			{
			  /* The new path wins. */
			  tmp_iptr = *reach_pos[trans_i->state_id].tags;
			  *reach_pos[trans_i->state_id].tags = tmp_tags;
			  if (trans_i->state == tnfa->final)
			    {
			      match_eo = pos;
			      new_match = 1;
			      for (i = 0; i < num_tags; i++)
				match_tags[i] = tmp_tags[i];
			    }
			  tmp_tags = tmp_iptr;
			}
		    }
		}
	    }
	}
      reach_next_i->state = NULL;
    }

  *match_end_ofs = match_eo;
  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
error_exit:
  xfree(buf);
  return ret;
}



/***********************************************************************
 from tre-match-backtrack.c
***********************************************************************/

/*
  This matcher is for regexps that use back referencing.  Regexp matching
  with back referencing is an NP-complete problem on the number of back
  references.  The easiest way to match them is to use a backtracking
  routine which basically goes through all possible paths in the TNFA
  and chooses the one which results in the best (leftmost and longest)
  match.  This can be spectacularly expensive and may run out of stack
  space, but there really is no better known generic algorithm.	 Quoting
  Henry Spencer from comp.compilers:
  <URL: http://compilers.iecc.com/comparch/article/93-03-102>

    POSIX.2 REs require longest match, which is really exciting to
    implement since the obsolete ("basic") variant also includes
    \<digit>.  I haven't found a better way of tackling this than doing
    a preliminary match using a DFA (or simulation) on a modified RE
    that just replicates subREs for \<digit>, and then doing a
    backtracking match to determine whether the subRE matches were
    right.  This can be rather slow, but I console myself with the
    thought that people who use \<digit> deserve very slow execution.
    (Pun unintentional but very appropriate.)

*/

typedef struct {
  int pos;
  const char *str_byte;
  tre_tnfa_transition_t *state;
  int state_id;
  int next_c;
  int *tags;
#ifdef TRE_MBSTATE
  mbstate_t mbstate;
#endif /* TRE_MBSTATE */
} tre_backtrack_item_t;

typedef struct tre_backtrack_struct {
  tre_backtrack_item_t item;
  struct tre_backtrack_struct *prev;
  struct tre_backtrack_struct *next;
} *tre_backtrack_t;

#ifdef TRE_MBSTATE
#define BT_STACK_MBSTATE_IN  stack->item.mbstate = (mbstate)
#define BT_STACK_MBSTATE_OUT (mbstate) = stack->item.mbstate
#else /* !TRE_MBSTATE */
#define BT_STACK_MBSTATE_IN
#define BT_STACK_MBSTATE_OUT
#endif /* !TRE_MBSTATE */

#define tre_bt_mem_new		  tre_mem_new
#define tre_bt_mem_alloc	  tre_mem_alloc
#define tre_bt_mem_destroy	  tre_mem_destroy


#define BT_STACK_PUSH(_pos, _str_byte, _str_wide, _state, _state_id, _next_c, _tags, _mbstate) \
  do									      \
    {									      \
      int i;								      \
      if (!stack->next)							      \
	{								      \
	  tre_backtrack_t s;						      \
	  s = (tre_backtrack_t)tre_bt_mem_alloc(mem, sizeof(*s));			      \
	  if (!s)							      \
	    {								      \
	      tre_bt_mem_destroy(mem);					      \
	      if (tags)							      \
		xfree(tags);						      \
	      if (pmatch)						      \
		xfree(pmatch);						      \
	      if (states_seen)						      \
		xfree(states_seen);					      \
	      return REG_ESPACE;					      \
	    }								      \
	  s->prev = stack;						      \
	  s->next = NULL;						      \
	  s->item.tags = (int*)tre_bt_mem_alloc(mem,				      \
					  sizeof(*tags) * tnfa->num_tags);    \
	  if (!s->item.tags)						      \
	    {								      \
	      tre_bt_mem_destroy(mem);					      \
	      if (tags)							      \
		xfree(tags);						      \
	      if (pmatch)						      \
		xfree(pmatch);						      \
	      if (states_seen)						      \
		xfree(states_seen);					      \
	      return REG_ESPACE;					      \
	    }								      \
	  stack->next = s;						      \
	  stack = s;							      \
	}								      \
      else								      \
	stack = stack->next;						      \
      stack->item.pos = (_pos);						      \
      stack->item.str_byte = (_str_byte);				      \
      stack->item.state = (_state);					      \
      stack->item.state_id = (_state_id);				      \
      stack->item.next_c = (_next_c);					      \
      for (i = 0; i < tnfa->num_tags; i++)				      \
	stack->item.tags[i] = (_tags)[i];				      \
      BT_STACK_MBSTATE_IN;						      \
    }									      \
  while (0)

#define BT_STACK_POP()							      \
  do									      \
    {									      \
      int i;								      \
      assert(stack->prev);						      \
      pos = stack->item.pos;						      \
      str_byte = stack->item.str_byte;					      \
      state = stack->item.state;					      \
      next_c = stack->item.next_c;					      \
      for (i = 0; i < tnfa->num_tags; i++)				      \
	tags[i] = stack->item.tags[i];					      \
      BT_STACK_MBSTATE_OUT;						      \
      stack = stack->prev;						      \
    }									      \
  while (0)

#undef MIN
#define MIN(a, b) ((a) <= (b) ? (a) : (b))

static reg_errcode_t
tre_tnfa_run_backtrack(const tre_tnfa_t *tnfa, const void *strval,
		       int *match_tags, int eflags, int *match_end_ofs)
{
  /* State variables required by GET_NEXT_WCHAR. */
  tre_char_t prev_c = 0, next_c = 0;
  const char *str_byte = (char*)strval;
  int pos = 0;
  int pos_add_next = 1;
#ifdef TRE_MBSTATE
  mbstate_t mbstate;
#endif /* TRE_MBSTATE */
  int reg_notbol = eflags & REG_NOTBOL;
  int reg_noteol = eflags & REG_NOTEOL;
  int reg_newline = tnfa->cflags & REG_NEWLINE;

  /* These are used to remember the necessary values of the above
     variables to return to the position where the current search
     started from. */
  int next_c_start;
  const char *str_byte_start;
  int pos_start = -1;
#ifdef TRE_MBSTATE
  mbstate_t mbstate_start;
#endif /* TRE_MBSTATE */

  /* End offset of best match so far, or -1 if no match found yet. */
  int match_eo = -1;
  /* Tag arrays. */
  int *next_tags, *tags = NULL;
  /* Current TNFA state. */
  tre_tnfa_transition_t *state;
  int *states_seen = NULL;

  /* Memory allocator to for allocating the backtracking stack. */
  tre_mem_t mem = tre_bt_mem_new();

  /* The backtracking stack. */
  tre_backtrack_t stack;

  tre_tnfa_transition_t *trans_i;
  regmatch_t *pmatch = NULL;
  int ret;

#ifdef TRE_MBSTATE
  memset(&mbstate, '\0', sizeof(mbstate));
#endif /* TRE_MBSTATE */

  if (!mem)
    return REG_ESPACE;
  stack = (tre_backtrack_t)tre_bt_mem_alloc(mem, sizeof(*stack));
  if (!stack)
    {
      ret = REG_ESPACE;
      goto error_exit;
    }
  stack->prev = NULL;
  stack->next = NULL;

  if (tnfa->num_tags)
    {
      tags = (int*)xmalloc(sizeof(*tags) * tnfa->num_tags);
      if (!tags)
	{
	  ret = REG_ESPACE;
	  goto error_exit;
	}
    }
  if (tnfa->num_submatches)
    {
      pmatch = (regmatch_t*)xmalloc(sizeof(*pmatch) * tnfa->num_submatches);
      if (!pmatch)
	{
	  ret = REG_ESPACE;
	  goto error_exit;
	}
    }
  if (tnfa->num_states)
    {
      states_seen = (int*)xmalloc(sizeof(*states_seen) * tnfa->num_states);
      if (!states_seen)
	{
	  ret = REG_ESPACE;
	  goto error_exit;
	}
    }

 retry:
  {
    int i;
    for (i = 0; i < tnfa->num_tags; i++)
      {
	tags[i] = -1;
	if (match_tags)
	  match_tags[i] = -1;
      }
    for (i = 0; i < tnfa->num_states; i++)
      states_seen[i] = 0;
  }

  state = NULL;
  pos = pos_start;
  GET_NEXT_WCHAR();
  pos_start = pos;
  next_c_start = next_c;
  str_byte_start = str_byte;
#ifdef TRE_MBSTATE
  mbstate_start = mbstate;
#endif /* TRE_MBSTATE */

  /* Handle initial states. */
  next_tags = NULL;
  for (trans_i = tnfa->initial; trans_i->state; trans_i++)
    {
      if (trans_i->assertions && CHECK_ASSERTIONS(trans_i->assertions))
	{
	  continue;
	}
      if (state == NULL)
	{
	  /* Start from this state. */
	  state = trans_i->state;
	  next_tags = trans_i->tags;
	}
      else
	{
	  /* Backtrack to this state. */
	  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
			trans_i->state_id, next_c, tags, mbstate);
	  {
	    int *tmp = trans_i->tags;
	    if (tmp)
	      while (*tmp >= 0)
		stack->item.tags[*tmp++] = pos;
	  }
	}
    }

  if (next_tags)
    for (; *next_tags >= 0; next_tags++)
      tags[*next_tags] = pos;


  if (state == NULL)
    goto backtrack;

  while (1)
    {
      tre_tnfa_transition_t *next_state;
      int empty_br_match;

      if (state == tnfa->final)
	{
	  if (match_eo < pos
	      || (match_eo == pos
		  && match_tags
		  && tre_tag_order(tnfa->num_tags, tnfa->tag_directions,
				   tags, match_tags)))
	    {
	      int i;
	      /* This match wins the previous match. */
	      match_eo = pos;
	      if (match_tags)
		for (i = 0; i < tnfa->num_tags; i++)
		  match_tags[i] = tags[i];
	    }
	  /* Our TNFAs never have transitions leaving from the final state,
	     so we jump right to backtracking. */
	  goto backtrack;
	}

      /* Go to the next character in the input strval. */
      empty_br_match = 0;
      trans_i = state;
      if (trans_i->state && trans_i->assertions & ASSERT_BACKREF)
	{
	  /* This is a back reference state.  All transitions leaving from
	     this state have the same back reference "assertion".  Instead
	     of reading the next character, we match the back reference. */
	  int so, eo, bt = trans_i->u.backref;
	  int bt_len;
	  int result;

	  /* Get the substring we need to match against.  Remember to
	     turn off REG_NOSUB temporarily. */
	  tre_fill_pmatch(bt + 1, pmatch, tnfa->cflags & ~REG_NOSUB,
			  tnfa, tags, pos);
	  so = pmatch[bt].rm_so;
	  eo = pmatch[bt].rm_eo;
	  bt_len = eo - so;

	  result = strncmp((const char*)strval + so, str_byte - 1,
				 (size_t)bt_len);

	  if (result == 0)
	    {
	      /* Back reference matched.  Check for infinite loop. */
	      if (bt_len == 0)
		empty_br_match = 1;
	      if (empty_br_match && states_seen[trans_i->state_id])
		{
		  goto backtrack;
		}

	      states_seen[trans_i->state_id] = empty_br_match;

	      /* Advance in input strval and resync `prev_c', `next_c'
		 and pos. */
	      str_byte += bt_len - 1;
	      pos += bt_len - 1;
	      GET_NEXT_WCHAR();
	    }
	  else
	    {
	      goto backtrack;
	    }
	}
      else
	{
	  /* Check for end of strval. */
	  if (next_c == L'\0')
		goto backtrack;

	  /* Read the next character. */
	  GET_NEXT_WCHAR();
	}

      next_state = NULL;
      for (trans_i = state; trans_i->state; trans_i++)
	{
	  if (trans_i->code_min <= (tre_cint_t)prev_c
	      && trans_i->code_max >= (tre_cint_t)prev_c)
	    {
	      if (trans_i->assertions
		  && (CHECK_ASSERTIONS(trans_i->assertions)
		      || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
		{
		  continue;
		}

	      if (next_state == NULL)
		{
		  /* First matching transition. */
		  next_state = trans_i->state;
		  next_tags = trans_i->tags;
		}
	      else
		{
		  /* Second matching transition.  We may need to backtrack here
		     to take this transition instead of the first one, so we
		     push this transition in the backtracking stack so we can
		     jump back here if needed. */
		  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
				trans_i->state_id, next_c, tags, mbstate);
		  {
		    int *tmp;
		    for (tmp = trans_i->tags; tmp && *tmp >= 0; tmp++)
		      stack->item.tags[*tmp] = pos;
		  }
#if 0 /* XXX - it's important not to look at all transitions here to keep
	 the stack small! */
		  break;
#endif
		}
	    }
	}

      if (next_state != NULL)
	{
	  /* Matching transitions were found.  Take the first one. */
	  state = next_state;

	  /* Update the tag values. */
	  if (next_tags)
	    while (*next_tags >= 0)
	      tags[*next_tags++] = pos;
	}
      else
	{
	backtrack:
	  /* A matching transition was not found.  Try to backtrack. */
	  if (stack->prev)
	    {
	      if (stack->item.state->assertions & ASSERT_BACKREF)
		{
		  states_seen[stack->item.state_id] = 0;
		}

	      BT_STACK_POP();
	    }
	  else if (match_eo < 0)
	    {
	      /* Try starting from a later position in the input strval. */
	      /* Check for end of strval. */
	      if (next_c == L'\0')
		    {
		      break;
		    }
	      next_c = next_c_start;
#ifdef TRE_MBSTATE
	      mbstate = mbstate_start;
#endif /* TRE_MBSTATE */
	      str_byte = str_byte_start;
	      goto retry;
	    }
	  else
	    {
	      break;
	    }
	}
    }

  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
  *match_end_ofs = match_eo;

 error_exit:
  tre_bt_mem_destroy(mem);
#ifndef TRE_USE_ALLOCA
  if (tags)
    xfree(tags);
  if (pmatch)
    xfree(pmatch);
  if (states_seen)
    xfree(states_seen);
#endif /* !TRE_USE_ALLOCA */

  return ret;
}

/***********************************************************************
 from regexec.c
***********************************************************************/

/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
   endpoint values. */
static void
tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
		const tre_tnfa_t *tnfa, int *tags, int match_eo)
{
  tre_submatch_data_t *submatch_data;
  unsigned int i, j;
  int *parents;

  i = 0;
  if (match_eo >= 0 && !(cflags & REG_NOSUB))
    {
      /* Construct submatch offsets from the tags. */
      submatch_data = tnfa->submatch_data;
      while (i < tnfa->num_submatches && i < nmatch)
	{
	  if (submatch_data[i].so_tag == tnfa->end_tag)
	    pmatch[i].rm_so = match_eo;
	  else
	    pmatch[i].rm_so = tags[submatch_data[i].so_tag];

	  if (submatch_data[i].eo_tag == tnfa->end_tag)
	    pmatch[i].rm_eo = match_eo;
	  else
	    pmatch[i].rm_eo = tags[submatch_data[i].eo_tag];

	  /* If either of the endpoints were not used, this submatch
	     was not part of the match. */
	  if (pmatch[i].rm_so == -1 || pmatch[i].rm_eo == -1)
	    pmatch[i].rm_so = pmatch[i].rm_eo = -1;

	  i++;
	}
      /* Reset all submatches that are not within all of their parent
	 submatches. */
      i = 0;
      while (i < tnfa->num_submatches && i < nmatch)
	{
	  if (pmatch[i].rm_eo == -1)
	    assert(pmatch[i].rm_so == -1);
	  assert(pmatch[i].rm_so <= pmatch[i].rm_eo);

	  parents = submatch_data[i].parents;
	  if (parents != NULL)
	    for (j = 0; parents[j] >= 0; j++)
	      {
		if (pmatch[i].rm_so < pmatch[parents[j]].rm_so
		    || pmatch[i].rm_eo > pmatch[parents[j]].rm_eo)
		  pmatch[i].rm_so = pmatch[i].rm_eo = -1;
	      }
	  i++;
	}
    }

  while (i < nmatch)
    {
      pmatch[i].rm_so = -1;
      pmatch[i].rm_eo = -1;
      i++;
    }
}

#ifdef __cplusplus
#define restrict
#endif
/*
  Wrapper functions for POSIX compatible regexp matching.
*/

int
regexec(const regex_t *restrict preg, const char *restrict strval,
	  size_t nmatch, regmatch_t pmatch[restrict], int eflags)
{
  tre_tnfa_t *tnfa = (tre_tnfa_t *)preg->TRE_REGEX_T_FIELD;
  reg_errcode_t status;
  int *tags = NULL, eo;
  if (tnfa->cflags & REG_NOSUB) nmatch = 0;
  if (tnfa->num_tags > 0 && nmatch > 0)
    {
      tags = (int*)xmalloc(sizeof(*tags) * tnfa->num_tags);
      if (tags == NULL)
	return REG_ESPACE;
    }

  /* Dispatch to the appropriate matcher. */
  if (tnfa->have_backrefs)
    {
      /* The regex has back references, use the backtracking matcher. */
      status = tre_tnfa_run_backtrack(tnfa, strval, tags, eflags, &eo);
    }
  else
    {
      /* Exact matching, no back references, use the parallel matcher. */
      status = tre_tnfa_run_parallel(tnfa, strval, tags, eflags, &eo);
    }

  if (status == REG_OK)
    /* A match was found, so fill the submatch registers. */
    tre_fill_pmatch(nmatch, pmatch, tnfa->cflags, tnfa, tags, eo);
  if (tags)
    xfree(tags);
  return status;
}
#ifdef __cplusplus
#undef restrict
#endif
/*
  tre-mem.c - TRE memory allocator

  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
  This memory allocator is for allocating small memory blocks efficiently
  in terms of memory overhead and execution speed.  The allocated blocks
  cannot be freed individually, only all at once.  There can be multiple
  allocators, though.
*/

#include <stdlib.h>
#include <string.h>

#ifndef JSI_AMALGAMATION
#include "tre.h"
#endif

/*
  This memory allocator is for allocating small memory blocks efficiently
  in terms of memory overhead and execution speed.  The allocated blocks
  cannot be freed individually, only all at once.  There can be multiple
  allocators, though.
*/

/* Returns a new memory allocator or NULL if out of memory. */
tre_mem_t
tre_mem_new_impl(int provided, void *provided_block)
{
  tre_mem_t mem;
  if (provided)
    {
      mem = (tre_mem_t)provided_block;
      memset(mem, 0, sizeof(*mem));
    }
  else
    mem = (tre_mem_t)xcalloc(1, sizeof(*mem));
  if (mem == NULL)
    return NULL;
  return mem;
}


/* Frees the memory allocator and all memory allocated with it. */
void
tre_mem_destroy(tre_mem_t mem)
{
  tre_list_t *tmp, *l = mem->blocks;

  while (l != NULL)
    {
      xfree(l->data);
      tmp = l->next;
      xfree(l);
      l = tmp;
    }
  xfree(mem);
}


/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
   allocated block or NULL if an underlying malloc() failed. */
void *
tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
		   int zero, size_t size)
{
  void *ptr;

  if (mem->failed)
    {
      return NULL;
    }

  if (mem->n < size)
    {
      /* We need more memory than is available in the current block.
	 Allocate a new block. */
      tre_list_t *l;
      if (provided)
	{
	  if (provided_block == NULL)
	    {
	      mem->failed = 1;
	      return NULL;
	    }
	  mem->ptr = (char*)provided_block;
	  mem->n = TRE_MEM_BLOCK_SIZE;
	}
      else
	{
	  int block_size;
	  if (size * 8 > TRE_MEM_BLOCK_SIZE)
	    block_size = size * 8;
	  else
	    block_size = TRE_MEM_BLOCK_SIZE;
	  l = (tre_list_t*)xmalloc(sizeof(*l));
	  if (l == NULL)
	    {
	      mem->failed = 1;
	      return NULL;
	    }
	  l->data = xmalloc(block_size);
	  if (l->data == NULL)
	    {
	      xfree(l);
	      mem->failed = 1;
	      return NULL;
	    }
	  l->next = NULL;
	  if (mem->current != NULL)
	    mem->current->next = l;
	  if (mem->blocks == NULL)
	    mem->blocks = l;
	  mem->current = l;
	  mem->ptr = (char*)l->data;
	  mem->n = block_size;
	}
    }

  /* Make sure the next pointer will be aligned. */
  size += ALIGN(mem->ptr + size, long);

  /* Allocate from current block. */
  ptr = mem->ptr;
  mem->ptr += size;
  mem->n -= size;

  /* Set to zero if needed. */
  if (zero)
    memset(ptr, 0, size);

  return ptr;
}
/* A Bison parser, made by GNU Bison 3.0.4.  */

/* Bison interface for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

#ifndef YY_YY_PARSER_H_INCLUDED
# define YY_YY_PARSER_H_INCLUDED
/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif

/* Token type.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    STRING = 258,
    IDENTIFIER = 259,
    IF = 260,
    ELSE = 261,
    FOR = 262,
    IN = 263,
    WHILE = 264,
    DO = 265,
    CONTINUE = 266,
    SWITCH = 267,
    CASE = 268,
    DEFAULT = 269,
    BREAK = 270,
    FUNC = 271,
    RETURN = 272,
    LOCAL = 273,
    OF = 274,
    NEW = 275,
    DELETE = 276,
    TRY = 277,
    CATCH = 278,
    FINALLY = 279,
    THROW = 280,
    WITH = 281,
    UNDEF = 282,
    _TRUE = 283,
    _FALSE = 284,
    _THIS = 285,
    ARGUMENTS = 286,
    FNUMBER = 287,
    REGEXP = 288,
    TYPESTRING = 289,
    TYPENUMBER = 290,
    TYPENULL = 291,
    TYPEOBJECT = 292,
    TYPEBOOLEAN = 293,
    TYPEUSEROBJ = 294,
    TYPEITEROBJ = 295,
    TYPEREGEXP = 296,
    TYPEANY = 297,
    TYPEARRAY = 298,
    ELLIPSIS = 299,
    __DEBUG = 300,
    MIN_PRI = 301,
    ARGCOMMA = 302,
    ADDAS = 303,
    MNSAS = 304,
    MULAS = 305,
    MODAS = 306,
    LSHFAS = 307,
    RSHFAS = 308,
    URSHFAS = 309,
    BANDAS = 310,
    BORAS = 311,
    BXORAS = 312,
    DIVAS = 313,
    OR = 314,
    AND = 315,
    EQU = 316,
    NEQ = 317,
    EEQU = 318,
    NNEQ = 319,
    LEQ = 320,
    GEQ = 321,
    INSTANCEOF = 322,
    LSHF = 323,
    RSHF = 324,
    URSHF = 325,
    NEG = 326,
    INC = 327,
    DEC = 328,
    TYPEOF = 329,
    VOID = 330,
    MAX_PRI = 331
  };
#endif

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED

union YYSTYPE
{

    Jsi_OpCodes *opcodes;
    Jsi_Value *value;
    const char *str;
    Jsi_Regex* regex;
    Jsi_Number *num;
    Jsi_ScopeStrs *scopes;
    int inum;
    struct jsi_CaseExprStat* caseitem;
    struct jsi_CaseList* caselist;

};

typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif

/* Location type.  */
#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE YYLTYPE;
struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
};
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif



int yyparse (struct jsi_Pstate *pstate);

#endif /* !YY_YY_PARSER_H_INCLUDED  */
#ifndef __JSIINT_H__
#define __JSIINT_H__

#ifdef JSI_CONFIG_H_FILE
#include JSI_CONFIG_H_FILE
#endif

// Define the defaults
#ifndef JSI__EVENT
#define JSI__EVENT 1
#endif
#ifndef JSI__DEBUG
#define JSI__DEBUG 1
#endif
#ifndef JSI__LOAD
#define JSI__LOAD 1
#endif
#ifndef JSI__SIGNAL
#define JSI__SIGNAL 1
#endif
#ifndef JSI__FILESYS
#define JSI__FILESYS 1
#endif
#ifndef JSI__ZVFS
#define JSI__ZVFS 1
#endif
#ifndef JSI__STUBS
#define JSI__STUBS 1
#endif
#ifndef JSI__THREADS
#define JSI__THREADS 1
#endif
#ifndef JSI__INFO
#define JSI__INFO 1
#endif
#ifndef JSI__CDATA
#define JSI__CDATA 1
#endif
#ifndef JSI__MARKDOWN
#define JSI__MARKDOWN 1
#endif
#ifndef JSI__MATH
#define JSI__MATH 1
#endif
#ifndef JSI__UTF8
#define JSI__UTF8 1
#endif

#if (JSI__STUBS!=1)
#ifndef JSI_OMIT_STUBS
#define JSI_OMIT_STUBS
#endif
#endif
#if (JSI__THREADS!=1)
#define JSI_OMIT_THREADS
#endif
#if (JSI__SIGNAL!=1)
#define JSI_OMIT_SIGNAL
#endif

#if defined(JSI__MD5) && JSI__MD5==0
#define JSI_OMIT_MD5 1
#endif
#if defined(JSI__SHA1) && JSI__SHA1==0
#define JSI_OMIT_SHA1 1
#endif
#if defined(JSI__SHA256) && JSI__SHA256==0
#define JSI_OMIT_SHA256 1
#endif
#if defined(JSI__ENCRYPT) && JSI__ENCRYPT==0
#define JSI_OMIT_ENCRYPT 1
#endif
#if defined(JSI__BASE64) && JSI__BASE64==0
#define JSI_OMIT_BASE64 1
#endif
#if defined(JSI__LOAD) && JSI__LOAD==0
#define JSI_OMIT_LOAD 1
#endif
#if defined(JSI__EVENT) && JSI__EVENT==0
#define JSI_OMIT_EVENT 1
#endif
#if defined(JSI__DEBUG) && JSI__DEBUG==0
#define JSI_OMIT_DEBUG 1
#endif
#if defined(JSI__CDATA) && JSI__CDATA==0
#define JSI_OMIT_CDATA 1
#endif
#if defined(JSI__MARKDOWN) && JSI__MARKDOWN==0
#define JSI_OMIT_MARKDOWN 1
#endif
#if defined(JSI__MATH) && JSI__MATH==0
#define JSI_OMIT_MATH 1
#endif

//#define JSI__MEMDEBUG 1
#if JSI__MEMDEBUG
#define JSI_MEM_DEBUG
#define Assert(n) assert(n)
#else
#define Assert(n)
#endif
#ifndef JSI_OMIT_SIGNATURES
#define JSI_HAS_SIG
#endif
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#define __USE_GNU
#endif
#define VAL_REFCNT
#define VAL_REFCNT2

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <ctype.h>
#include <assert.h>
#include <inttypes.h>
#include <limits.h>

#ifdef __WIN32 /* TODO: support windows signal??? */
#define JSI__MINIZ 1
#define JSI_OMIT_SIGNAL
#endif

#ifndef JSI_AMALGAMATION

#if JSI__REGEX
#include "regex/regex.h"
#else
#include <regex.h>
#endif
#ifdef __WIN32
#include "win/compat.h"
//#include "win/regex.h"
//#include "regex/regex.h"
#else
#define JSI__REGCOMP
#include <sys/time.h>
#endif
#endif

#include <time.h>

#ifndef JSI_IS64BIT
#ifdef __GNUC__
#ifdef __X86_64__
#define JSI_IS64BIT 1
#endif
#else /* GCC */
#if _WIN64 || __amd64__
#define JSI_IS64BIT 1
#endif
#endif /* GCC */
#endif /* JSI_IS64BIT */

#ifndef JSI_IS64BIT
#define JSI_IS64BIT 0
#endif

#define JSMN_FREE(p) Jsi_Free(p)
#define JSMN_MALLOC(l) Jsi_Malloc(l)
#define JSMN_REALLOC(p,l) Jsi_Realloc(p,l)

#define JSI_HAS_SIG /* Signatures to help with debugging */
#ifdef JSI_HAS_SIG
#ifndef SIGASSERT
#define SIGASSERT(s,n) assert((s) && (s)->sig == (uint)JSI_SIG_##n);
#endif
#define SIGINIT(s,n) (s)->sig = JSI_SIG_##n;
#define __VALSIG__ .sig=JSI_SIG_VALUE,
#else
#define SIGASSERT(s,n)
#define SIGINIT(s,n)
#define __VALSIG__
#endif

#ifndef JSI_HAS___PROTO__
#define JSI_HAS___PROTO__ 1  // Enable setting and getting prototypes. 1=set/get funcs, 2=__proto__ assign.
#endif

#ifdef NDEBUG
#define JSI_NOWARN(v) v=v
#else
#define JSI_NOWARN(v)
#endif

#ifdef __FreeBSD__
#define _JSICASTINT(s) (int)(s)
#else
#define _JSICASTINT(s) (s)
#endif

#if 0
#ifndef uint
typedef unsigned int uint;
#endif
#ifndef uchar
typedef unsigned char uchar;
#endif
#endif

#ifndef JSI_AMALGAMATION
#include "jsi.h"
#else
#define JSI_OMIT_STUBS
#endif

#define ALLOC_MOD_SIZE 16      /* Increase allocs by increments of 16. */
#define MAX_ARRAY_LIST 100000  /* Default Max size of an array convertable to list form */
#define MAX_LOOP_COUNT 10000000 /* Limit infinite loops */
#define JSI_MAX_ALLOC_BUF  100000000 /* Limit for dynamic memory allocation hunk */
#define JSI_MAX_SCOPE (BUFSIZ/2)
typedef enum {
    JSI_SIG_ITEROBJ=0xdeadbee1, JSI_SIG_FUNCOBJ, JSI_SIG_SCOPE, JSI_SIG_VALUE,
    JSI_SIG_OBJ, JSI_SIG_USERDATA, JSI_SIG_INTERP, JSI_SIG_PARSER,
    JSI_SIG_FILEOBJ, JSI_SIG_INTERPOBJ, JSI_SIG_FUNC, JSI_SIG_CMDSPECITEM, JSI_SIG_HASH,
    JSI_SIG_HASHENTRY, JSI_SIG_TREE, JSI_SIG_TREEENTRY, JSI_SIG_LIST, JSI_SIG_LISTENTRY,
    JSI_SIG_USER_REG, JSI_SIG_EVENT, JSI_SIG_MAP, JSI_SIG_REGEXP,
    JSI_SIG_ARGTYPE, JSI_SIG_FORINVAR, JSI_SIG_CASELIST, JSI_SIG_CASESTAT,
    JSI_SIG_FASTVAR, JSI_SIG_INTERPSTREVENT, JSI_SIG_ALIASCMD, JSI_SIG_SOCKET, JSI_SIG_SOCKETPSS,
    JSI_SIG_NAMEDATA
} jsi_Sig;

#define Jsi_LogType(fmt,...) Jsi_LogMsg(interp, interp->typeCheck.error?JSI_LOG_ERROR:JSI_LOG_WARN, fmt, ##__VA_ARGS__)

struct jsi_OpCode;

#if  JSI__MEMDEBUG
extern void jsi_VALCHK(Jsi_Value *v);
extern void jsi_OBJCHK(Jsi_Obj *o);
#define VALCHK(val) jsi_VALCHK(val)
#define OBJCHK(val) jsi_OBJCHK(val)
#else
#define VALCHK(val)
#define OBJCHK(val)
#endif

enum {  jsi_callTraceFuncs = 1, jsi_callTraceCmds = 2, jsi_callTraceNew = 4,
        jsi_callTraceReturn = 8, jsi_callTraceArgs = 16, 
        jsi_callTraceNoTrunc = 32,  jsi_callTraceNoParent = 64,
        jsi_callTraceFullPath = 128, jsi_callTraceBefore = 256
};

/* Scope chain */
typedef struct jsi_ScopeChain_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Value **chains;  /* values(objects) */
    int chains_cnt;         /* count */
} jsi_ScopeChain;

/* Function obj */
/* a Jsi_FuncObj is a raw function with own scope chain */
struct Jsi_FuncObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Func *func;
    jsi_ScopeChain *scope;
    Jsi_Value *bindArgs;
    Jsi_Value *bindFunc;
};

typedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);

/* Jsi_IterObj, use only in for-in statement */
struct Jsi_IterObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    const char **keys;
    uint size; 
    uint count;
    uint iter;
    bool isArrayList;            /* If an array list do not store keys. */
    bool isof;
    Jsi_Obj *obj;
    uint cur;                    /* Current array cursor. */
    int depth;                  /* Used to create list of keys. */
    Jsi_IterProc *iterCmd;
};

typedef struct UserObjReg_ { /* Per interp userobj registration. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_UserObjReg *reg;
    Jsi_Hash* hashPtr;
    int idx;
} UserObjReg;

/* User defined object */
typedef struct Jsi_UserObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Hash *id;
    void *data;
    const char *prefix;
    Jsi_UserObjReg *reg;
    struct UserObjReg_ *ureg;
    uintptr_t idx;
    Jsi_HashEntry* hPtr;
} Jsi_UserObj;

typedef struct {
    int valueCnt;
    int objCnt;
    int valueAllocCnt;
    int objAllocCnt;
#ifdef JSI_MEM_DEBUG
    Jsi_Hash *valueDebugTbl;
    Jsi_Hash *objDebugTbl;
    uint memDebugCallIdx;
#endif
} Jsi_InterpDebug;


/* stack change */
/* 0  nothing change */
/* +1 push */
/* -1 pop */
typedef enum {      /* SC   type of data    comment                             */
    OP_NOP,         /* 0 */
    OP_PUSHNUM,     /* +1   *double         number                              */
    OP_PUSHSTR,     /* +1   *char        string                              */
    OP_PUSHVAR,     /* +1   *FastVar        variable name                       */
    OP_PUSHUND,     /* +1   -               undefined                           */
    OP_PUSHNULL,    /* +1   -               null                                */
    OP_PUSHBOO,     /* +1   int             bool                                */
    OP_PUSHFUN,     /* +1   *Jsi_Func           function                            */
    OP_PUSHREG,     /* +1   *regex_t        regex                               */
    OP_PUSHARG,     /* +1   -               push arguments(cur scope)           */
    OP_PUSHTHS,     /* +1   -               push this                           */
    OP_PUSHTOP,     /* +1   -               duplicate top                       */
    OP_PUSHTOP2,    /* +2   -               duplicate toq and top               */
    OP_UNREF,       /* 0    -               make top be right value             */
    OP_POP,         /* -n   int             pop n elements                      */
    OP_LOCAL,       /* 0    *char        add a var to current scope          */
    OP_NEG,         /* 0    -               make top = - top                    */
    OP_POS,         /* 0    -               make top = + top, (conv to number)  */
    OP_NOT,         /* 0    -               reserve top                         */
    OP_BNOT,        /* 0    -               bitwise not                         */
    OP_ADD,         /* -1   -               all math opr pop 2 elem from stack, */
    OP_SUB,         /* -1   -                calc and push back in to the stack */
    OP_MUL,         /* -1   -                                                   */
    OP_DIV,         /* -1   -                                                   */
    OP_MOD,         /* -1   -                                                   */
    OP_LESS,        /* -1   -               logical opr, same as math opr       */
    OP_GREATER,     /* -1   -                                                   */
    OP_LESSEQU,     /* -1   -                                                   */
    OP_GREATEREQU,  /* -1   -                                                   */
    OP_EQUAL,       /* -1   -                                                   */
    OP_NOTEQUAL,    /* -1   -                                                   */
    OP_STRICTEQU,   /* -1   -                                                   */
    OP_STRICTNEQ,   /* -1   -                                                   */
    OP_BAND,        /* -1   -               bitwise and                         */
    OP_BOR,         /* -1   -               bitwise or                          */
    OP_BXOR,        /* -1   -               bitwise xor                         */
    OP_SHF,         /* -1   int(right)      signed shift left or shift right    */
    OP_INSTANCEOF,  /* -1 */
    OP_ASSIGN,      /* -n   int             if n = 1, assign to lval,           */
                    /*                      n = 2, assign to object member      */
    OP_SUBSCRIPT,   /* -1   -               do subscript TOQ[TOP]               */
    OP_INC,         /* 0    int             data indicate prefix/postfix inc/dec                */
    OP_TYPEOF,      /* 0    obj                                                                 */
    OP_IN,          /* 0    obj                                                                 */
    OP_DEC,         /* 0    int                                                                 */
    OP_KEY,         /* +1   -               push an iter object that contain all key in top     */
    OP_NEXT,        /* -1   -               assign next key to top, make top be res of this opr */
    OP_JTRUE,       /* -1   int             jmp to offset if top is true,                       */
    OP_JFALSE,      /* -1   int             jmp to offset if top is false,                      */
    OP_JTRUE_NP,    /* 0    int             jtrue no pop version                                */
    OP_JFALSE_NP,   /* 0    int             jfalse no pop version                               */
    OP_JMP,         /* 0    int             jmp to offset                                       */
    OP_JMPPOP,      /* -n   *jsi_JmpPopInfo     jmp to offset with pop n                            */
    OP_FCALL,       /* -n+1 int             call func with n args, pop then, make ret to be top */
    OP_NEWFCALL,    /* -n+1 int             same as fcall, call as a constructor                */
    OP_RET,         /* -n   int             n = 0|1, return with arg                            */
    OP_DELETE,      /* -n   int             n = 1, delete var, n = 2, delete object member      */
    OP_CHTHIS,      /* 0,   -               make toq as new 'this'                              */
    OP_OBJECT,      /* -n*2+1   int         create object from stack, and push back in          */
    OP_ARRAY,       /* -n+1 int             create array object from stack, and push back in    */
    OP_EVAL,        /* -n+1 int             eval can not be assign to other var                 */
    OP_STRY,        /* 0    *jsi_TryInfo        push try statment poses Jsi_LogWarn to trylist             */
    OP_ETRY,        /* 0    -               end of try block, jmp to finally                    */
    OP_SCATCH,      /* 0    *char        create new scope, assign to current excption        */
    OP_ECATCH,      /* 0    -               jmp to finally                                      */
    OP_SFINAL,      /* 0    -               restore scope chain create by Scatch                */
    OP_EFINAL,      /* 0    -               end of finally, any unfinish code in catch, do it   */
    OP_THROW,       /* 0    -               make top be last exception, pop trylist till catched*/
    OP_WITH,        /* -1   -               make top be top of scopechain, add to trylist       */
    OP_EWITH,       /* 0    -               pop trylist                                         */
    OP_RESERVED,    /* 0    jsi_ReservedInfo*   reserved, be replaced by iterstat by jmp/jmppop     */
    OP_DEBUG,       /* 0    -               DEBUG OPCODE, output top                            */
    OP_LASTOP       /* 0    -               END OF OPCODE                                       */
} jsi_Eopcode;

typedef enum { jsi_Oplf_none=0, jsi_Oplf_assert=1, jsi_Oplf_debug=2, jsi_Oplf_trace=3, jsi_Oplf_test=4 } jsi_OpLogFlags;

typedef struct jsi_OpCode {
    jsi_Eopcode op;
    void *data;
    unsigned int Line:16;
    unsigned int Lofs:8;
    unsigned char alloc:1;
    unsigned char nodebug:1;
    unsigned char hit:1;
    unsigned char isof:1;
    unsigned char local:1;
    jsi_OpLogFlags logflag:3;
    const char *fname;
} jsi_OpCode;


typedef struct Jsi_OpCodes {
    jsi_OpCode *codes;
    int code_len;
    int code_size;          // Used by malloc.
    
    int expr_counter;           /* context related expr count */
    int lvalue_flag;            /* left value count/flag */
    const char *lvalue_name; /* left value name */
    int line;  // Used in Lemon
#ifdef JSI_MEM_DEBUG
    Jsi_HashEntry *hPtr;
    int id;
#endif
} Jsi_OpCodes;


typedef struct jsi_TryInfo {
    int trylen;
    int catchlen;
    int finallen;
} jsi_TryInfo;

typedef struct jsi_ReservedInfo {
    int type;
    const char *label;
    int topop;
} jsi_ReservedInfo;

typedef struct jsi_JmpPopInfo {
    int off;
    int topop;
} jsi_JmpPopInfo;

#define RES_CONTINUE    1
#define RES_BREAK       2
typedef struct YYLTYPE jsi_Pline;

//void jsi_codes_print(Jsi_OpCodes *ops);
void jsi_code_decode(jsi_OpCode *op, int currentip, char *buf, int bsiz);
const char* jsi_opcode_string(uint opCode);

#ifdef JSI_MEM_DEBUG
typedef struct 
{
    const char *fname;
    int line;
    const char *func;
    const char *label;
    const char *label2;
    const char *label3;
    uint Idx;
    uint flags;
    struct jsi_OpCode *ip;
    int ipLine;
    jsi_Eopcode ipOp;
    const char* ipFname;
    Jsi_HashEntry *hPtr;
    Jsi_Interp *interp;
} jsi_ValueDebug;
#endif

struct Jsi_Obj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int refcnt;                 /* reference count */
    Jsi_otype ot:8;             /* object type */
    uint isarrlist:1;           /* Array type. */
    uint isstrkey:1;            /* Key string registered in interp->strKeyTbl (do not free) */
    uint isJSONstr:1;
    uint clearProto:1;          /* Prototype changed, clean it up at exit. */
    uint isNoOp:1;
    uint unused1:1;
    uint unused2:16;
    union {                     /* switched on by value of "ot" */
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Regex *robj;
        Jsi_FuncObj *fobj;
        Jsi_IterObj *iobj;
        Jsi_UserObj *uobj;
    } d;
    uint arrMaxSize;                 /* Max allocated space for array. */
    uint arrCnt;                     /* Count of actually set keys. */
    Jsi_Value **arr;   /* Array values. */  
    Jsi_Tree *tree;                 /* Tree storage (should be union with array). */
    Jsi_Value *__proto__;           /* TODO: memory leaks when this is changed */
    struct Jsi_Obj *constructor;
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebug VD;
#endif
};

/*#pragma pack(1)*/


struct Jsi_Value {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int32_t refCnt;
    Jsi_vtype vt:8;             /* value type */
    union {
        uint flag:8;
        struct vflagbit {
            uint readonly:1;
            uint dontenum:1;  /* Dont enumerate. */
            uint dontdel:1;
            uint innershared:1; /* All above used only for objkeys. */
            uint isarrlist:1;
            uint isstrkey:1;    /* Key string registered in interp->strKeyTbl (do not free) */
            uint local:1;       // Used to detect a function creating a global var.
            uint lookupfailed:1;// Indicates failed lookup, string is stored in lookupFail below.
        } bits;
    } f;
    union {                     /* see above */
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Obj *obj;
        struct Jsi_Value *lval;
        const char *lookupFail;
    } d;
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebug VD;
#endif
};

#ifndef JSI_SMALL_HASH_TABLE
#define JSI_SMALL_HASH_TABLE 0x10
#endif

typedef uintptr_t jsi_Hash;

typedef union jsi_HashKey {
    char string[sizeof(jsi_Hash)];  // STRING, STRUCT
    void *oneWordValue;             // ONEWORD, STRINGKEY
} jsi_HashKey;

typedef struct Jsi_HashEntry {
    jsi_Sig sig;
    int typ; // JSI_MAP_HASH
    struct Jsi_HashEntry *nextPtr;
    Jsi_Hash *tablePtr;
    jsi_Hash hval;
    void* clientData;
    jsi_HashKey key;
} Jsi_HashEntry;


typedef struct Jsi_Hash {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_HASH
    Jsi_HashEntry **buckets;
    Jsi_HashEntry *staticBuckets[JSI_SMALL_HASH_TABLE];
    int numBuckets;
    int numEntries;
    int rebuildSize;
    jsi_Hash mask;
    unsigned int downShift;
    int keyType;
    Jsi_HashEntry *(*createProc) (Jsi_Hash *tablePtr, const void *key, bool *newPtr);
    Jsi_HashEntry *(*findProc) (Jsi_Hash *tablePtr, const void *key);
    Jsi_MapOpts opts;
} Jsi_Hash;

struct Jsi_Tree {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_TREE
    //Jsi_Interp *interp;
    Jsi_TreeEntry *root;
    uint numEntries, keyType, epoch;
    struct {
        uint 
            inserting:1, destroyed:1,
            nonredblack:1,  /* Disable red/black handling on insert/delete. */
            internstr:1,    /* STRINGPTR keys are stored in strHash */
            valuesonly:1,   /* Values must be of type JSI_VALUE */
            unused:28;
    } flags;
    Jsi_Hash* strHash;  /* String hash table to use if INTERNSTR; setup on first Create if not defined. */
    Jsi_TreeEntry* (*createProc)(Jsi_Tree *treePtr, const void *key, bool *newPtr);
    Jsi_MapOpts opts;
};

typedef struct Jsi_TreeEntry {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_TREE
    Jsi_Tree *treePtr;
    struct Jsi_TreeEntry* left;
    struct Jsi_TreeEntry* right;
    struct Jsi_TreeEntry* parent;
    union { /* FLAGS: bottom 16 bits for JSI, upper 16 bits for users. First 7 map to JSI_OM_ above. */
        struct { 
            unsigned int readonly:1, dontenum:1, dontdel:1, innershared:1, isarrlist:1, isstrkey:1, unused:1,
                color:1,
                reserve:8,
                user0:8,
                user1:1, user2:1, user3:1, user4:1, user5:1, user6:1, user7:1, user8:1;
        } bits;
        int flags;
    } f;
    void* value;
    jsi_HashKey key;
} Jsi_TreeEntry;

typedef struct Jsi_Map {  // Wrapped Tree/Hash/List.
    uint sig;
    Jsi_Map_Type typ;
    union {
        Jsi_Hash *hash;
        Jsi_Tree *tree;
        Jsi_List *list;
    } v;
} Jsi_Map;

typedef struct jsi_ArgValue_ {
    char *name;
    uint type;  // or'ed Jsi_otype
    Jsi_Value *defValue;
} jsi_ArgValue;

typedef struct Jsi_ScopeStrs {
    jsi_ArgValue *args;
    int count;
    int _size;  // Used in allocation only.
    int varargs;
    int typeCnt;
    int firstDef;
    int argCnt;
    int retType;
} Jsi_ScopeStrs;

// Eval stack-frame.
typedef struct jsi_Frame {
    int level;
    const char *fileName;
    const char *funcName;
    const char *dirName;
    int line;
    jsi_OpCode *ip;
    int Sp;
    int tryDepth;
    int withDepth;
    jsi_ScopeChain* ingsc;
    Jsi_Value *incsc;
    Jsi_Value *inthis;
    Jsi_OpCodes *opcodes;
    struct jsi_Pstate *ps;
    bool strict;
    int logflag;
    Jsi_Func *evalFuncPtr;
    struct jsi_Frame *parent, *child;
    Jsi_Value *arguments; // Set when arguments are accessed.
} jsi_Frame;

/* Program/parse state(context) */
typedef struct jsi_Pstate {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int err_count;              /* Jsi_LogError count after parse */
    int eval_flag;              /* 1 if currently executing in an eval function */
    int funcDefs;               /* Count of functions defined. 0 means we can delete this cache (eventually). */
    Jsi_OpCodes *opcodes;    /* Execution codes. */
    struct jsi_Lexer *lexer;        /* seq provider */

    int _context_id;            /* used in FastVar-locating */
    Jsi_Value *last_exception;
    Jsi_Interp *interp;
    Jsi_HashEntry *hPtr;
    Jsi_Hash *argsTbl;
    Jsi_Hash *strTbl;
    Jsi_Hash *fastVarTbl;
    int argType;                // Used during parsing to aggregate type.
    Jsi_ScopeStrs *args;        // Last push.
} jsi_Pstate;


Jsi_ScopeStrs *jsi_ScopeStrsNew(void);
void jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType);
void jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss);
const char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i);

void jsi_PstatePush(jsi_Pstate *ps);
void jsi_PstatePop(jsi_Pstate *ps);
void jsi_PstateAddVar(jsi_Pstate *ps, const char *str);
Jsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps);

void jsi_PstateFree(jsi_Pstate *ps);
jsi_Pstate *jsi_PstateNew(Jsi_Interp *interp);
void jsi_PstateClear(jsi_Pstate *ps);
const char * jsi_PstateGetFilename(jsi_Pstate *ps);
int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang);
int jsi_PstateSetString(jsi_Pstate *ps, const char *str);

extern int yyparse(jsi_Pstate *ps);

#ifndef JSI_AMALGAMATION
#include "parser.h"
#endif

typedef struct jsi_ForinVar {
    jsi_Sig sig;
    const char *varname;
    Jsi_OpCodes *local;
    Jsi_OpCodes *lval;
} jsi_ForinVar;


typedef struct jsi_CaseExprStat {
    jsi_Sig sig;
    Jsi_OpCodes *expr;
    Jsi_OpCodes *stat;
    int isdefault;
} jsi_CaseExprStat;


typedef struct jsi_CaseList {
    jsi_Sig sig;
    jsi_CaseExprStat *es;
    int off;
    struct jsi_CaseList *tail;
    struct jsi_CaseList *next;
} jsi_CaseList;


typedef enum {
    LT_NONE,
    LT_FILE,            /* read from file */
    LT_STRING           /* read from a string */
} Jsi_Lexer_Type;

/* jsi_Lexer, where input seq provided */
typedef struct jsi_Lexer {
    Jsi_Lexer_Type ltype;
    union {
        Jsi_Channel fp;           /* LT_FILE, where to read */
        char *str;          /* LT_STRING */
    } d;
    int last_token;         /* last token returned */
    int ungot, unch[100];
    int cur;                /* LT_STRING, current char */
    int cur_line;           /* current line no. */
    int cur_char;           /* current column no. */
    jsi_Pstate *pstate;
} jsi_Lexer;

int yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate);
void yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg);

typedef struct FastVar_ {
    jsi_Sig sig;
    int context_id:31;
    unsigned int local:1;
    jsi_Pstate *ps;
    struct {
        char *varname;
        struct Jsi_Value *lval;
    } var;
} FastVar;

typedef enum { FC_NORMAL, FC_BUILDIN } Jsi_Func_Type;

/* raw function data, with script function or system Jsi_CmdProc */
struct Jsi_Func {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Func_Type type;                         /* type */
    struct Jsi_OpCodes *opcodes;    /* FC_NORMAL, codes of this function */
    Jsi_CmdProc *callback;            /* FC_BUILDIN, callback */

    Jsi_ScopeStrs *argnames;                 /* FC_NORMAL, argument names */
    Jsi_ScopeStrs *localnames;               /* FC_NORMAL, local var names */
    union {
        uint flags;
        struct {
            uint res:8, hasattr:1, isobj:1 , iscons:1, res2:4;
        } bits;
    } f;
    union {
        uint i;
        struct {
            uint addargs:1 , iscons:1, isdiscard:1, res:5;
        } bits;
    } callflags;
    int refCnt;
    void *privData;                 /* context data given in create. */
    Jsi_CmdSpec *cmdSpec;
    const char *name, *parent;  /* Name for non-anonymous function. */
    uint retType;  /* Type name: or of Jsi_otype*/
    int callCnt;
    const char *script;  /* Script created in. */
    jsi_Pline bodyline; /* Body line info. */
    Jsi_HashEntry *hPtr;
    //bool strict;
    double subTime, allTime;
    Jsi_FuncObj *fobj;
};

typedef struct {
    char *origFile; /* Short file name. */
    char *fileName; /* Fully qualified name. */
    char *dirName;  /* Directory name. */
    int useCnt;
} jsi_FileInfo;

enum {
    STACK_INIT_SIZE=1024, STACK_INCR_SIZE=1024, STACK_MIN_PAD=100,
    JSI_MAX_CALLFRAME_DEPTH=1000, /* default max nesting depth for procs */
    JSI_MAX_EVAL_DEPTH=1000, /* default max nesting depth for eval */
    JSI_MAX_INCLUDE_DEPTH=50,  JSI_MAX_SUBINTERP_DEPTH=10,
    JSI_IS_UTF=1,
    JSI_UTF_CHECKED=2
    /*,JSI_ON_STACK=0x80*/
};

typedef struct InterpStrEvent_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int rc, isExec, tryDepth, errLine;
    const char *errFile;
    Jsi_Value *objData;
    Jsi_DString func;
    Jsi_DString data;
    struct InterpStrEvent_ *next;
    void *mutex;
} InterpStrEvent;

typedef void (*jsiCallTraceProc)(Jsi_Interp *interp, const char *funcName, const char *file, 
    int line, Jsi_CmdSpec* spec, Jsi_Value* _this, Jsi_Value* args, Jsi_Value *ret);

typedef struct {
    const char *file;
    const char *func;
    int line;
    int id;
    int hits;
    bool enabled;
    bool temp;
} jsi_BreakPoint;

typedef struct jsi_PkgInfo {
    Jsi_Number version;
    const char *loadFile;  // Full path of file name loaded.
    Jsi_InitProc *initProc; // For C-extensions.
    bool needInit;  // If a C-extension and _Init func needs calling in this interp.
} jsi_PkgInfo;

typedef struct {
    bool isDebugger; // Set to 1 if we are the debugger, debugging a sub-interp.
    bool noFilter;
    bool doContinue;
    bool forceBreak;
    bool bpLast; // Last break was a breakpoint.
    bool includeOnce;
    bool includeTrace;
    int bpOpCnt;
    int minLevel;
    const char *callback;
    const char *putsCallback;
    const char *msgCallback;
    const char *traceCallback;
    Jsi_Value *callbackFunc;
    int lastLine;
    int lastLevel;
    const char *lastFile;
    bool pkgTrace;
    int breakIdx;
    Jsi_RC (*hook)(struct Jsi_Interp* interp, const char *curFile, int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *msg);
} Jsi_DebugInterp;

typedef union jsi_numUnion {
    bool       BOOL;
    int            INT;
    uint           UINT;
    int8_t         INT8;
    uint8_t        UINT8;
    int16_t        INT16;
    uint16_t       UINT16;
    int32_t        INT32;
    uint32_t       UINT32;
    int64_t        INT64;
    uint64_t       UINT64;
    Jsi_Number     DOUBLE;
    time_t         TIME_T;
    time_w         TIME_W;
    time_d         TIME_D;
} jsi_numUnion;

typedef struct {
    uint parse:1;
    uint run:1;
    uint all:1;     
    uint error:1;
    uint strict:1;
    uint noundef:1;
    uint nowith:1;
    uint proto:1;
    uint unused:24;
} Jsi_TypeCheck;

typedef enum {
    jsi_AssertModeThrow,
    jsi_AssertModeLog,
    jsi_AssertModePuts
} jsi_AssertMode;

typedef struct {
    uint isSpecified:1; /* User set the option. */
    uint initOnly:1;    /* Allow set only at init, disallowing update/conf. */
    uint readOnly:1;    /* Value can not be set. */
    uint noDupValue:1;  /* Values are not to be duped. */
    uint noClear:1;     /* Values are not to be cleared: watch for memory leaks */
    uint dbDirty:1;     /* Used to limit DB updates. */
    uint dbIgnore:1;    /* Field is not to be used for DB. */
    uint dbRowid:1 ;    /* Field used by DB to store rowid. */
    uint custNoCase:1;  /* Ignore case (eg. for ENUM and BITSET). */
    uint forceInt:1;    /* Force int instead of text for enum/bitset. */
    uint bitsetBool:1;  /* Treat bitset custom field as bool instead of an int. */
    uint timeDateOnly:1;/* Time field is date only. */
    uint timeTimeOnly:1;/* Time field is time only. */
    uint isBits:1;      /* Is a C bit-field. */
    uint fmtString:1;   /* Format value (eg. time) as string. */
    uint fmtNumber:1;   /* Format value (eg. enum) as number. */
    uint fmtHext:1;     /* Format number in hex. */
    uint strict:1;      /* Strict mode. */
    uint fieldSetup:1;  /* Field has been setup. */
    uint coerce:1;      /* Coerce input value to required type. */
    uint noSig:1;       /* No signature. */
    uint enumSpec:1;    /* Enum has spec rather than a list of strings. */
    uint enumUnsigned:1;/* Enum value is unsigned. */
    uint enumExact:1;   /* Enum must be an exact match. */
    uint required:1;    /* Field must be specified (if not IS_UPDATE). */
    uint prefix:1;      /* Allow matching unique prefix of object members. */
    uint isUpdate:1;    /* This is an update/conf (do not reset the specified flags) */
    uint ignoreExtra:1; /* Ignore extra members not found in spec. */
    uint forceStrict:1; /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */
    uint verbose:1;     /* Dump verbose options */
    uint userBits:32;
} jsi_OptionFlags;

typedef struct {
    bool file;    // Ouput file:line information: default is at end.
    bool full;    // Show full file path.
    bool func;    // Ouput function at end.
    bool debug;
    bool trace;
    bool test;
    bool noinfo;
    bool nowarn;
    bool noerror;
    bool time;    // Prefix with time
    bool date;    // Prefix with date
    bool before;  // Print file:line before message instead of at end.
    bool isUTC;
    const char* timeFmt;
    Jsi_Value *chan;
} jsi_LogOptions;

extern Jsi_OptionSpec jsi_InterpLogOptions[];

struct Jsi_Interp {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    bool isSafe;
    Jsi_Value *safeReadDirs;
    Jsi_Value *safeWriteDirs;
    Jsi_DebugInterp debugOpts;
    bool deleting;
    bool destroying;
    bool hasEventHdl;
    uint autoLoaded;
    int exited;
    int exitCode;
    int refCount;
    int traceCall;
    int opTrace;
    int memDebug;
    int coverAll, coverHit;
    bool coverage;
    bool profile;
    bool asserts;
    jsi_AssertMode assertMode;
    uint unitTest;
    const char *jsppChars;
    Jsi_Value *jsppCallback;
    bool noStderr;
    bool tracePuts;
    bool isMain;
    bool compat;
    bool mutexUnlock;
    bool noInherit;
    bool noUndef;
    bool fileStrict;  /* Error out on file not found, etc. */
    bool hasCallee;
    bool noReadline;
    bool nocacheOpCodes;
    bool noSubInterps;
    bool privKeys;
    bool subthread;
    bool showColumns;
    bool msgAllowDups;
    bool strict;
    bool protoInit;
    bool isInteractive;
    const char *confArgs;
    Jsi_Value *stdinStr;
    Jsi_Value *stdoutStr;
    Jsi_TypeCheck typeCheck;
    jsi_LogOptions logOpts;
    int typeWarnMax;
    int typeMismatchCnt;
    Jsi_InterpOpts opts;
    Jsi_Value *inopts;
    int evalFlags;
    Jsi_InterpDebug dbStatic;
    Jsi_InterpDebug *dbPtr;
    jsiCallTraceProc traceHook;
    int opCnt;  /* Count of instructions eval'ed */
    int maxOpCnt;
    int maxUserObjs;
    int userObjCnt;
    int funcCnt;
    int level;  /* Nesting level of eval/func/cmd calls. */
    int maxDepth;/* Max allowed eval recursion. */
    int maxIncDepth;
    int includeDepth;
    int includeCnt;
    int maxInterpDepth;
    int interpDepth;
    int pkgReqDepth;
    int didReturn;
    uint codeCacheHit;
    uint funcCallCnt;
    uint cmdCallCnt;
    uintptr_t eventIdx;
#ifdef JSI_MEM_DEBUG
    uint valueDebugIdx;
    Jsi_Hash *codesTbl;
#endif
    jsi_ScopeChain *gsc;
    Jsi_Value *csc;
    struct Jsi_Interp *parent, *topInterp, *mainInterp;
    Jsi_Value *onComplete;
    Jsi_Value *onEval;
    Jsi_Value *onExit;
    Jsi_Value *execZip;
    void (*logHook)(char *buf, va_list va);
    bool istty;
    const char *name;
    Jsi_Value *pkgDirs;
    bool selfZvfs;
    int inParse;
    Jsi_Value *retPtr;       /* Return value from eval */
    jsi_Pstate *ps;
    Jsi_Value *argv0;
    Jsi_Value *args;
    Jsi_Value *console;
    Jsi_Value *scriptFile;  /* Start script returned by info.argv0(). */
    const char *scriptStr;
    const char *curFile;
    const char *curFunction;
    const char *homeDir;
    const char *historyFile;
    char *curDir;
    int maxStack;

    Jsi_Map *strKeyTbl;  /* Global strings table. */
    Jsi_Map *cmdSpecTbl; /* Jsi_CmdSpecs registered. */
    Jsi_Hash *onDeleteTbl;  /* Cleanup funcs to call on interp delete. */
    Jsi_Hash *assocTbl;
    Jsi_Hash *codeTbl; /* Scripts compiled table. */
    Jsi_Hash *eventTbl;
    Jsi_Hash *genValueTbl;
    Jsi_Hash *genObjTbl;
    Jsi_Hash *funcObjTbl;
    Jsi_Hash *funcsTbl;
    Jsi_Hash *bindTbl;
    Jsi_Hash *fileTbl;    // The "source"ed files.
    Jsi_Hash *lexkeyTbl;
    Jsi_Hash *protoTbl;
    Jsi_Hash *regexpTbl;    
    Jsi_Hash *thisTbl;
    Jsi_Hash *userdataTbl;
    Jsi_Hash *varTbl;
    Jsi_Hash *preserveTbl;
    Jsi_Hash *loadTbl;
    Jsi_Hash *staticFuncsTbl; // For debugOpts.typeProto
    Jsi_Hash *breakpointHash;
    Jsi_Hash *packageHash;
    Jsi_Hash *aliasHash;
#ifdef VAL_REFCNT
    Jsi_Value **Stack;
    Jsi_Value **Obj_this;
#else
    Jsi_Value *Stack;
    Jsi_Value *Obj_this;
#endif
            
    Jsi_Value *Object_prototype;
    Jsi_Value *Function_prototype_prototype;
    Jsi_Value *Function_prototype;
    Jsi_Value *String_prototype;
    Jsi_Value *Number_prototype;
    Jsi_Value *Boolean_prototype;
    Jsi_Value *Array_prototype;
    Jsi_Value *RegExp_prototype;
    Jsi_Value *Date_prototype;
    
    Jsi_Value *NaNValue;
    Jsi_Value *InfValue;
    Jsi_Value *NullValue;
    Jsi_Value *nullFuncArg; /* Efficient call of no-arg func */
    Jsi_Value *nullFuncRet;
    Jsi_Value *autoFiles;
    Jsi_Obj* cleanObjs[4];

    const char *busyCallback;
    int busyInterval;
    int isInCallback;
    int objId;
    Jsi_Value *Top_object;
        Jsi_ScopeStrs *scopes[JSI_MAX_SCOPE];
    int cur_scope;
    int maxArrayList;
    int delRBCnt;
    Jsi_Func *activeFunc;  // Currently active function call.
    Jsi_Func *prevActiveFunc;  // Prev active function call.
    jsi_OpCode *curIp;  /* Used for debug Log msgs. */
    
    char *lastPushStr;  // Used by error handling and Jsi_LogMsg.   TODO: cleanup/rationalize.
    Jsi_Value* lastSubscriptFail;
    const char* lastSubscriptFailStr;

    Jsi_Wide sigmask;
    char errMsgBuf[200];  /* Error message space for when in try. */
    int errLine;
    int errCol;
    const char *errFile;
    Jsi_Mutex* Mutex;
    Jsi_Mutex* QMutex; /* For threads queues */
    void* threadId;
    int threadCnt;
    int threadShrCnt;
    int lockTimeout; /* in milliseconds. */
    uint lockRefCnt;
    int psEpoch;
    int mountCnt;
    Jsi_DString interpEvalQ;
    Jsi_DString interpMsgQ;
    InterpStrEvent *interpStrEvents;

    bool typeInit;
    Jsi_CData_Static *statics;  
    Jsi_Hash *StructHash;
    Jsi_Hash *SigHash;
    Jsi_Hash *EnumHash;
    Jsi_Hash *EnumItemHash;
    Jsi_Hash *CTypeHash;
    Jsi_Hash *TYPEHash;

    const char *recvCallback;
    uint threadErrCnt;  /* Count of bad thread event return codes. */
    uint threadEvalCnt;
    uint threadMsgCnt;
    void *sleepData;
    jsi_PkgInfo *pkgRequiring, *pkgProviding;
    jsi_Pline *parseLine;
    jsi_Frame *framePtr;
    struct jsi_DbVfs **dbVfsPtrPtr;
    double subTime, startTime, funcSelfTime, cmdSelfTime;
};


enum { JSI_REG_GLOB=0x1, JSI_REG_NEWLINE=0x2, JSI_REG_DOT_NEWLINE=0x4, JSI_REG_STATIC=0x100 };

struct Jsi_Regex_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    regex_t reg;
    int eflags;
    int flags;
    char *pattern;
    int lastIndex;
};


/* Entries in interp->cmdSpecTbl. */
typedef struct Jsi_CmdSpecItem_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    const char *name;  /* Parent cmd. */
    Jsi_CmdSpec *spec;
    Jsi_Value *proto;
    int flags;
    void *privData;
    Jsi_MapEntry *hPtr;
    struct Jsi_CmdSpecItem_ *next; /* TODO: support user-added sub-commands. */
    const char *help;
    const char *info;
    int isCons;
} Jsi_CmdSpecItem;

//extern Jsi_OptionType jsi_OptTypeInfo[];
extern const char* jsi_OptionTypeStr(Jsi_OptionId typ, bool cname);
extern const Jsi_OptionType* Jsi_OptionsStr2Type(const char *str, bool cname);

typedef struct {
    const char *topLink;
    bool getTitle;
    bool returnStr;
    Jsi_DString titleStr;
} jsi_MarkdownOpts;

/* SCOPE */
//typedef struct jsi_ScopeChain jsi_ScopeChain;

extern jsi_ScopeChain* jsi_ScopeChainNew(Jsi_Interp *interp, int cnt); /*STUB = 176*/
extern Jsi_Value* jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key); /*STUB = 177*/
extern jsi_ScopeChain* jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next); /*STUB = 178*/
extern void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc); /*STUB = 179*/

extern Jsi_Interp *jsiMainInterp; /* The main interp */
extern Jsi_Interp *jsiDelInterp; /* Interp being delete: Used by cleanup callbacks. */
extern void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr);
extern void jsi_markdown_to_html(Jsi_DString *input_markdown,  Jsi_DString *output_body, jsi_MarkdownOpts *opts);

Jsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitLexer(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitLoad(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitCmds(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitInterp(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitFileCmds(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitString(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitValue(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitNumber(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitArray(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitBoolean(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitMath(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitProto(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitJSON(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release);
Jsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitTree(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitSocket(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitSignal(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitOptions(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitZvfs(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitCData(Jsi_Interp *interp, int release);
Jsi_RC jsi_execCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr, Jsi_DString *cStr, int *code);

void jsi_SignalClear(Jsi_Interp *interp, int sigNum);
bool jsi_SignalIsSet(Jsi_Interp *interp, int sigNum);
/* excute opcodes
 * 1. ps, program execution context
 * 2. opcodes, codes to be executed
 * 3. scope, current scopechain, not include current scope
 * 4. currentScope, current scope
 * 5. _this, where 'this' indicated
 * 6. vret, return value
 */
extern Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, 
        jsi_ScopeChain *scope, Jsi_Value *currentScope,
        Jsi_Value *_this,
        Jsi_Value **vret);
        
typedef Jsi_RC (*Jsi_Constructor)(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, int flags, void *privData);
extern Jsi_RC jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc);
extern void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall);
extern Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    
enum {StrKeyAny = 0, StrKeyFunc = 0x1, StrKeyCmd = 0x2, StrKeyVar = 0x2};

//char* jsi_KeyLookup(Jsi_Interp *interp, const char *str);
char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey);
void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who);
Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp);
void jsi_AddEventHandler(Jsi_Interp *interp);

extern const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp);
extern const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val);
extern const char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp);
extern Jsi_RC jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);

extern const char *jsi_GetHomeDir(Jsi_Interp *interp);
extern Jsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret);
extern void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec);
extern Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline *line, const char *name);
extern Jsi_Func *jsi_FuncNew(Jsi_Interp *interp);
extern void jsi_FreeOpcodes(Jsi_OpCodes *ops);
extern void jsi_DelAssocData(Jsi_Interp *interp, void *data);

extern void jsi_UserObjFree (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern bool jsi_UserObjIsTrue (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern Jsi_RC jsi_UserObjDump   (Jsi_Interp *interp, const char *argStr, Jsi_Obj *obj);
extern Jsi_RC jsi_UserObjDelete (Jsi_Interp *interp, void *data);
extern void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr);
extern Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name);

extern Jsi_RC Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret);
extern Jsi_Value* jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex);
extern void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey);
extern const char* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);
extern void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);
extern Jsi_Value* jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value *value, int flag);
extern void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof);
extern Jsi_Value* jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key);
extern void jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags);
extern Jsi_Value* jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name);
extern Jsi_Value* jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent);
extern Jsi_Value* jsi_ObjValueNew(Jsi_Interp *interp);
extern Jsi_Value* Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v);
extern int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v);
extern Jsi_RC jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *handle);
extern Jsi_Value* jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec);
extern Jsi_Value* jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData);
extern bool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr);
extern bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent);
extern Jsi_RC jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat);
extern Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr);
extern Jsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);
extern Jsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, char *str, int flags, int level);
extern Jsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags);
extern Jsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret);

extern Jsi_IterObj *jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc);
extern void jsi_IterObjFree(Jsi_IterObj *iobj);
extern Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func);
extern void jsi_FuncObjFree(Jsi_FuncObj *fobj);
extern Jsi_RC jsi_ArglistFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);
extern void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func);

#ifndef _JSI_MEMCLEAR
#ifndef JSI_MEM_DEBUG
#define _JSI_MEMCLEAR(ptr)
#else
#define _JSI_MEMCLEAR(ptr) memset(ptr, 0, sizeof(*ptr)) /* To aid debugging memory.*/
#endif
#endif

#define MAX_SUBREGEX    256
#define JSI__LONG_LONG
#define UCHAR(s) (unsigned char)(s)
#define StrnCpy(d,s) Jsi_Strncpy(d,s,sizeof(d)), d[sizeof(d)-1] = 0
extern char* jsi_SubstrDup(const char *a, int start, int len);
extern int jsi_typeGet(Jsi_Interp *interp , const char *tname);
extern const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr);
extern Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ, Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func, bool isdefault);
extern void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes);
extern Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes);
extern Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a);
extern Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr);
extern Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr);
extern Jsi_RC jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName);
extern Jsi_Value* jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode);
extern double jsi_GetTimestamp(void);
extern const char *jsi_GetCurFile(Jsi_Interp *interp);
extern void jsi_TypeMismatch(Jsi_Interp* interp);
extern void jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep);
extern const char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str);
extern Jsi_Value* jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec);
extern int jsi_GetDefaultType(const char *cp);
extern Jsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str);
extern Jsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc);
extern Jsi_RC jsi_SysMarkdownCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_CDataDataSetCmdSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr, int flags);
extern char jsi_toHexChar(char code);
extern char jsi_fromHexChar(char ch);

typedef enum {
    _JSI_CDATA_INFO=0,
    _JSI_CDATA_GET=1,
    _JSI_CDATA_SET=2,
    _JSI_CDATA_SIZE=3,
    _JSI_CDATA_SCHEMA=4,
    _JSI_CDATA_STRUCT=6
} jsi_cdatasub;

//extern Jsi_RC jsi_cdataMapsubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
//    Jsi_Value **ret, Jsi_Func *funcPtr, jsi_cdatasub sub);

#define jsi_ValueString(pv) (pv->vt == JSI_VT_STRING ? &pv->d.s : \
  ((pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING) ? &pv->d.obj->d.s : NULL))
                 
#define jsi_IsStrictMode(interp) (interp->strict || interp->framePtr->strict)

#ifdef JSI_MEM_DEBUG
#define jsi_ValueDebugUpdate(interp, v, tbl, file, line, func) jsi_ValueDebugUpdate_(interp, &v->VD, v, interp->dbPtr->tbl, file, line, func)
#define jsi_ValueDebugLabel(v,l1,l2) jsi_ValueDebugLabel_(&v->VD,l1,l2)

#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueDup(interp,v) jsi_ValueDup(interp, v,__FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)

extern Jsi_Value *jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func);
extern Jsi_Obj *jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2);
extern void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func);
extern void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp);
extern void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp);

#define jsi_DebugValueCallIdx() ++interp->dbPtr->memDebugCallIdx
#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}, .d={}, .VD={.fname=__FILE__, .line=__LINE__,.func=__PRETTY_FUNCTION__}  }
#else
#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}  }
#define jsi_ValueDebugUpdate(interp, vd, v, tbl, file, line, func)
#define jsi_ValueDebugLabel(v,l1,l2)
#define jsi_DebugValue(v,r,i,t)
#define jsi_DebugObj(o,r,i,t)
#define jsi_DebugValueCallIdx() 0
#define jsi_ValueDebugLabel_(v,l1,l2)
#endif

#define DECL_VALINIT(n) Jsi_Value n = VALINIT

void jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *func, jsi_OpCode *iPtr, 
    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret);

struct Jsi_Stubs;
extern struct Jsi_Stubs *jsiStubsTblPtr;
extern char *jsi_execName;
extern const char *jsi_AssertModeStrs[];
extern Jsi_Chan jsi_StdChans[3];
extern Jsi_CmdSpec cDataArrayCmds[];
#define jsi_Stdin jsi_StdChans
#define jsi_Stdout jsi_StdChans+1
#define jsi_Stderr jsi_StdChans+2

#if JSI__SANITIZE
#define Jsi_Malloc(sz) malloc(sz)
#define Jsi_Calloc(nm, sz) calloc(nm,sz)
#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)
#define Jsi_Free(ptr) free(ptr)
#endif

#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY
#define jsi_IIRO .flags=JSI_OPT_READ_ONLY

#endif /* __JSIINT_H__ */
/* linenoise.h -- VERSION 1.0
 *
 * Guerrilla line editing library against the idea that a line editing lib
 * needs to be 20,000 lines of C code.
 *
 * See linenoise.c for more information.
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
 * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __LINENOISE_H
#define __LINENOISE_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct linenoiseCompletions {
  size_t len;
  char **cvec;
} linenoiseCompletions;

typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);
typedef char*(linenoiseHintsCallback)(const char *, int *color, int *bold);
typedef void(linenoiseFreeHintsCallback)(void *);
void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);
void linenoiseSetHintsCallback(linenoiseHintsCallback *);
void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);
void linenoiseAddCompletion(linenoiseCompletions *, const char *);

char *linenoise(const char *prompt);
void linenoiseFree(void *ptr);
int linenoiseHistoryAdd(const char *line);
int linenoiseHistorySetMaxLen(int len);
int linenoiseHistorySave(const char *filename);
int linenoiseHistoryLoad(const char *filename);
void linenoiseClearScreen(void);
void linenoiseSetMultiLine(int ml);
void linenoisePrintKeyCodes(void);

#ifdef __cplusplus
}
#endif

#endif /* __LINENOISE_H */
#ifndef JSI_LITE_ONLY
#ifndef _JSI_CODE_C_
#define _JSI_CODE_C_
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* replace continue/break(coded as OP_RESERVED) jmp
 * |------------------| \
 * |                  | \\ where 'continue' jmp (jmp to step code)
 * |       ops        |  / 
 * |                  | / \
 * |------------------|    \ where 'break' jmp (jmp after step code)
 * |                  |    /
 * |       step       |   /
 * |                  |  /
 * |------------------| /
 * 1. break_only used only in switch
 * 2. desire_label, only replace if current iter statement has the same label with opcode
 * 3. topop, if not replace in current iter statment, make sure when jmp out of this loop/switch
 *    corrent stack elems poped(for in always has 2 elem, while switch has 1)
 */

static const char *jsi_op_names[OP_LASTOP] = {
    "NOP",
    "PUSHNUM",
    "PUSHSTR",
    "PUSHVAR",
    "PUSHUND",
    "PUSHNULL",
    "PUSHBOO",
    "PUSHFUN",
    "PUSHREG",
    "PUSHARG",
    "PUSHTHS",
    "PUSHTOP",
    "PUSHTOP2",
    "UNREF",
    "POP",
    "LOCAL",
    "NEG",
    "POS",
    "NOT",
    "BNOT",
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MOD",
    "LESS",
    "GREATER",
    "LESSEQU",
    "GREATEREQU",
    "EQUAL",
    "NOTEQUAL",
    "STRICTEQU",
    "STRICTNEQ",
    "BAND",
    "BOR",
    "BXOR",
    "SHF",
    "INSTANCEOF",
    "ASSIGN",
    "SUBSCRIPT",
    "INC",
    "TYPEOF",
    "IN",
    "DEC",
    "KEY",
    "NEXT",
    "JTRUE",
    "JFALSE",
    "JTRUE_NP",
    "JFALSE_NP",
    "JMP",
    "JMPPOP",
    "FCALL",
    "NEWFCALL",
    "RET",
    "DELETE",
    "CHTHIS",
    "OBJECT",
    "ARRAY",
    "EVAL",
    "STRY",
    "ETRY",
    "SCATCH",
    "ECATCH",
    "SFINAL",
    "EFINAL",
    "THROW",
    "WITH",
    "EWITH",
    "RESERVED",
    "DEBUG"
};

static int jsiOpCodesCnt[3] = {0,0,0};

void jsi_FreeOpcodes(Jsi_OpCodes *ops) {
    int i;
    if (!ops) return;
    for (i=0; i<ops->code_len; i++) {
        jsi_OpCode *op = ops->codes+i;
        if (op->data && op->alloc)
            Jsi_Free(op->data);
        _JSI_MEMCLEAR(op);
    }
    jsiOpCodesCnt[1]++;
    jsiOpCodesCnt[2]--;
#ifdef JSI_MEM_DEBUG
    if (ops->hPtr)
        Jsi_HashEntryDelete(ops->hPtr);
#endif
    Jsi_Free(ops->codes);
    Jsi_Free(ops);
}

static Jsi_OpCodes *codes_new(int size)
{
    Jsi_OpCodes *ops = (Jsi_OpCodes *)Jsi_Calloc(1, sizeof(*ops));
    jsiOpCodesCnt[0]++;
    jsiOpCodesCnt[2]++;
    ops->codes = (jsi_OpCode *)Jsi_Calloc(size, sizeof(jsi_OpCode));
    ops->code_size = size;
#ifdef JSI_MEM_DEBUG
    static int idNum = 0;
    ops->hPtr = Jsi_HashSet(jsiMainInterp->codesTbl, ops, ops);
    ops->id = idNum++;
#endif
    return ops;
}

static int codes_insert(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, int doalloc)
{
    if (c->code_size - c->code_len <= 0) {
        c->code_size += 100;
        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));
    }
    c->codes[c->code_len].op = code;
    c->codes[c->code_len].data = extra;
    c->codes[c->code_len].alloc = doalloc;
    c->code_len ++;
    return 0;
}

static int codes_insertln(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, jsi_Pstate *pstate, jsi_Pline *line, int doalloc)
{
    if (c->code_size - c->code_len <= 0) {
        c->code_size += 100;
        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));
    }
    c->codes[c->code_len].op = code;
    c->codes[c->code_len].data = extra;
    c->codes[c->code_len].Line = (code == OP_FCALL ? line->first_line:line->first_line);
    c->codes[c->code_len].Lofs = (code == OP_FCALL ? line->first_column:line->first_column);
    c->codes[c->code_len].fname = jsi_PstateGetFilename(pstate);
    c->codes[c->code_len].alloc = doalloc;
    c->code_len ++;
    return 0;
}


static Jsi_OpCodes *codes_join(Jsi_OpCodes *a, Jsi_OpCodes *b)
{
    Jsi_OpCodes *ret = codes_new(a->code_len + b->code_len);
    memcpy(ret->codes, a->codes, a->code_len * sizeof(jsi_OpCode));
    memcpy(&ret->codes[a->code_len], b->codes, b->code_len * sizeof(jsi_OpCode));
    ret->code_size = a->code_len + b->code_len;
    ret->code_len = ret->code_size;
    ret->expr_counter = a->expr_counter + b->expr_counter;
#if 0
    a->code_len=0;
    jsi_FreeOpcodes(a);
    b->code_len=0;
    jsi_FreeOpcodes(b);
#else
    Jsi_Free(a->codes);
    Jsi_Free(b->codes);
#ifdef JSI_MEM_DEBUG
    if (a->hPtr)
        Jsi_HashEntryDelete(a->hPtr);
    if (b->hPtr)
        Jsi_HashEntryDelete(b->hPtr);
#endif
    Jsi_Free(a);
    Jsi_Free(b);
#endif
    jsiOpCodesCnt[1]++;
    jsiOpCodesCnt[2]-=2;
    return ret;
}

static Jsi_OpCodes *codes_join3(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c)
{
    return codes_join(codes_join(a, b), c);
}

static Jsi_OpCodes *codes_join4(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c, Jsi_OpCodes *d)
{
    return codes_join(codes_join(a, b), codes_join(c, d));
}

#define JSI_NEW_CODES(doalloc,code, extra) do {                 \
        Jsi_OpCodes *r = codes_new(3);                  \
        codes_insert(r, (code), (void *)(uintptr_t)(extra), doalloc);   \
        return r;                                   \
    } while(0)

#define JSI_NEW_CODESLN(doalloc,code, extra) do {                 \
        Jsi_OpCodes *r = codes_new(3);                  \
        codes_insertln(r, (code), (void *)(uintptr_t)(extra), p, line, doalloc);   \
        return r;                                   \
    } while(0)

static Jsi_OpCodes *code_push_undef() { JSI_NEW_CODES(0,OP_PUSHUND, 0); }
static Jsi_OpCodes *code_push_null() { JSI_NEW_CODES(0,OP_PUSHNULL, 0); }
static Jsi_OpCodes *code_push_bool(int v) { JSI_NEW_CODES(0,OP_PUSHBOO, v); }
static Jsi_OpCodes *code_push_num(Jsi_Number *v) { JSI_NEW_CODES(1,OP_PUSHNUM, v); }
static Jsi_OpCodes *code_push_string(jsi_Pstate *p, jsi_Pline *line, const char *str) {
    if (*str == 'c' && !Jsi_Strcmp(str,"callee"))
        p->interp->hasCallee = 1;
    JSI_NEW_CODESLN(0,OP_PUSHSTR, str);
}

static Jsi_OpCodes *code_push_index(jsi_Pstate *p, jsi_Pline *line, const char *varname, int local)
{
    FastVar *n = (FastVar*)Jsi_Calloc(1,sizeof(*n)); /* TODO: free when opcodes are freed. */
    n->sig = JSI_SIG_FASTVAR;
    n->ps = p;
    n->context_id = -1;
    n->local = local;
    n->var.varname = (char*)Jsi_KeyAdd(p->interp, varname);
    Jsi_HashSet(p->fastVarTbl, n, n);
    JSI_NEW_CODESLN(1,OP_PUSHVAR, n);
}

static Jsi_OpCodes *code_push_this(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_PUSHTHS, 0); }
static Jsi_OpCodes *code_push_top() { JSI_NEW_CODES(0,OP_PUSHTOP, 0); }
static Jsi_OpCodes *code_push_top2() { JSI_NEW_CODES(0,OP_PUSHTOP2, 0); }
static Jsi_OpCodes *code_unref() { JSI_NEW_CODES(0,OP_UNREF, 0); }
static Jsi_OpCodes *code_push_args() { JSI_NEW_CODES(0,OP_PUSHARG, 0); }
static Jsi_OpCodes *code_push_func_sub(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) { p->funcDefs++; JSI_NEW_CODESLN(0,OP_PUSHFUN, fun); }
static Jsi_OpCodes *code_push_func(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) {
    Jsi_OpCodes* codes = code_push_func_sub(p, line, fun);
    if (codes && fun && fun->name)
        codes->codes[0].local = 1;
    return codes;
}
static Jsi_OpCodes *code_push_regex(jsi_Pstate *p, jsi_Pline *line, Jsi_Regex *reg) { JSI_NEW_CODESLN(0,OP_PUSHREG, reg); }

static Jsi_OpCodes *code_local(jsi_Pstate *p, jsi_Pline *line, const char *varname) { JSI_NEW_CODESLN(0,OP_LOCAL, varname); }

static Jsi_OpCodes *code_nop() { JSI_NEW_CODES(0,OP_NOP, 0); }
static Jsi_OpCodes *code_neg() { JSI_NEW_CODES(0,OP_NEG, 0); }
static Jsi_OpCodes *code_pos() { JSI_NEW_CODES(0,OP_POS, 0); }
static Jsi_OpCodes *code_bnot() { JSI_NEW_CODES(0,OP_BNOT, 0); }
static Jsi_OpCodes *code_not() { JSI_NEW_CODES(0,OP_NOT, 0); }
static Jsi_OpCodes *code_mul() { JSI_NEW_CODES(0,OP_MUL, 0); }
static Jsi_OpCodes *code_div() { JSI_NEW_CODES(0,OP_DIV, 0); }
static Jsi_OpCodes *code_mod() { JSI_NEW_CODES(0,OP_MOD, 0); }
static Jsi_OpCodes *code_add() { JSI_NEW_CODES(0,OP_ADD, 0); }
static Jsi_OpCodes *code_sub() { JSI_NEW_CODES(0,OP_SUB, 0); }
static Jsi_OpCodes *code_in() { JSI_NEW_CODES(0,OP_IN, 0); }
static Jsi_OpCodes *code_less() { JSI_NEW_CODES(0,OP_LESS, 0); }
static Jsi_OpCodes *code_greater() { JSI_NEW_CODES(0,OP_GREATER, 0); }
static Jsi_OpCodes *code_lessequ() { JSI_NEW_CODES(0,OP_LESSEQU, 0); }
static Jsi_OpCodes *code_greaterequ() { JSI_NEW_CODES(0,OP_GREATEREQU, 0); }
static Jsi_OpCodes *code_equal() { JSI_NEW_CODES(0,OP_EQUAL, 0); } 
static Jsi_OpCodes *code_notequal() { JSI_NEW_CODES(0,OP_NOTEQUAL, 0); }
static Jsi_OpCodes *code_eequ() { JSI_NEW_CODES(0,OP_STRICTEQU, 0); }
static Jsi_OpCodes *code_nneq() { JSI_NEW_CODES(0,OP_STRICTNEQ, 0); }
static Jsi_OpCodes *code_band() { JSI_NEW_CODES(0,OP_BAND, 0); }
static Jsi_OpCodes *code_bor() { JSI_NEW_CODES(0,OP_BOR, 0); }
static Jsi_OpCodes *code_bxor() { JSI_NEW_CODES(0,OP_BXOR, 0); }
static Jsi_OpCodes *code_shf(int right) { JSI_NEW_CODES(0,OP_SHF, right); }
static Jsi_OpCodes *code_instanceof() { JSI_NEW_CODES(0,OP_INSTANCEOF, 0); }
static Jsi_OpCodes *code_assign(jsi_Pstate *p, jsi_Pline *line, int h) { JSI_NEW_CODESLN(0,OP_ASSIGN, h); }
static Jsi_OpCodes *code_subscript(jsi_Pstate *p, jsi_Pline *line, int right_val) { JSI_NEW_CODESLN(0,OP_SUBSCRIPT, right_val); }
static Jsi_OpCodes *code_inc(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_INC, e); }
static Jsi_OpCodes *code_dec(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_DEC, e); }
static Jsi_OpCodes *code_typeof(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_TYPEOF, e); }

static Jsi_OpCodes *code__fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes) {
    jsi_FuncCallCheck(p,line,argc,1, name, namePre, argCodes);JSI_NEW_CODESLN(0,OP_FCALL, argc);
}
static Jsi_OpCodes *code_fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes, Jsi_OpCodes* pref) {
    Jsi_OpCodes *codes = code__fcall(p, line, argc, name, namePre, argCodes);
    int i;
    if (!name || !codes || !pref)
        return codes;
    jsi_OpLogFlags logflag = jsi_Oplf_none;
    if (name[0] == 'a' && !Jsi_Strcmp(name, "assert"))
        logflag = jsi_Oplf_assert;
    else if (name[0] == 'L' && name[1] == 'o') {
        if (!Jsi_Strcmp(name, "LogDebug"))
            logflag = jsi_Oplf_debug;
        else if (!Jsi_Strcmp(name, "LogTrace"))
            logflag = jsi_Oplf_trace;
        else if (!Jsi_Strcmp(name, "LogTest"))
            logflag = jsi_Oplf_test;
    }
    if (logflag) {
        codes->codes[0].logflag = logflag;
        if (argCodes)
            for (i=0; i<argCodes->code_len; i++)
                argCodes->codes[i].logflag = logflag;
        for (i=0; i<pref->code_len; i++)
            pref->codes[i].logflag = logflag;
    }
    return codes;
}
static Jsi_OpCodes *code_newfcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, Jsi_OpCodes *argCodes) {
    jsi_FuncCallCheck(p,line,argc,1, name, NULL, argCodes); JSI_NEW_CODESLN(0,OP_NEWFCALL, argc);
}
static Jsi_OpCodes *code_ret(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_RET, n); }
static Jsi_OpCodes *code_delete(int n) { JSI_NEW_CODES(0,OP_DELETE, n); }
static Jsi_OpCodes *code_chthis(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_CHTHIS, n); }
static Jsi_OpCodes *code_pop(int n) { JSI_NEW_CODES(0,OP_POP, n); }
static Jsi_OpCodes *code_jfalse(int off) { JSI_NEW_CODES(0,OP_JFALSE, off); }
static Jsi_OpCodes *code_jtrue(int off) { JSI_NEW_CODES(0,OP_JTRUE, off); }
static Jsi_OpCodes *code_jfalse_np(int off) { JSI_NEW_CODES(0,OP_JFALSE_NP, off); }
static Jsi_OpCodes *code_jtrue_np(int off) { JSI_NEW_CODES(0,OP_JTRUE_NP, off); }
static Jsi_OpCodes *code_jmp(int off) { JSI_NEW_CODES(0,OP_JMP, off); }
static Jsi_OpCodes *code_object(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_OBJECT, c); }
static Jsi_OpCodes *code_array(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_ARRAY, c); }
static Jsi_OpCodes *code_key() { JSI_NEW_CODES(0,OP_KEY, 0); }
static Jsi_OpCodes *code_next() { JSI_NEW_CODES(0,OP_NEXT, 0); }

static Jsi_OpCodes *code_eval(jsi_Pstate *p, jsi_Pline *line, int argc, Jsi_OpCodes *c) {
    jsi_FreeOpcodes(c); // Eliminate leak of unused opcodes.
    JSI_NEW_CODESLN(0,OP_EVAL, argc);
}

static Jsi_OpCodes *code_stry(jsi_Pstate *p, jsi_Pline *line, int trylen, int catchlen, int finlen)
{ 
    jsi_TryInfo *ti = (jsi_TryInfo *)Jsi_Calloc(1,sizeof(*ti));
    ti->trylen = trylen;
    ti->catchlen = catchlen;
    ti->finallen = finlen;
    JSI_NEW_CODESLN(1,OP_STRY, ti); 
}
static Jsi_OpCodes *code_etry(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ETRY, 0); }
static Jsi_OpCodes *code_scatch(jsi_Pstate *p, jsi_Pline *line, const char *var) { JSI_NEW_CODESLN(0,OP_SCATCH, var); }
static Jsi_OpCodes *code_ecatch(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ECATCH, 0); }
static Jsi_OpCodes *code_sfinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_SFINAL, 0); }
static Jsi_OpCodes *code_efinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EFINAL, 0); }
static Jsi_OpCodes *code_throw(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_THROW, 0); }
static Jsi_OpCodes *code_with(jsi_Pstate *p, jsi_Pline *line, int withlen) { JSI_NEW_CODESLN(0,OP_WITH, withlen); }
static Jsi_OpCodes *code_ewith(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EWITH, 0); }

static Jsi_OpCodes *code_debug(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_DEBUG, 0); }
static Jsi_OpCodes *code_reserved(jsi_Pstate *p, jsi_Pline *line, int type, const char *id)
{
    jsi_ReservedInfo *ri = (jsi_ReservedInfo*)Jsi_Calloc(1, sizeof(*ri));
    ri->type = type;
    ri->label = id;
    ri->topop = 0;
    JSI_NEW_CODESLN(1,OP_RESERVED, ri);
}

static jsi_JmpPopInfo *jpinfo_new(int off, int topop)
{
    jsi_JmpPopInfo *r = (jsi_JmpPopInfo *)Jsi_Calloc(1, sizeof(*r));
    r->off = off;
    r->topop = topop;
    return r;
}

static void code_reserved_replace(Jsi_OpCodes *ops, int step_len, int break_only,
                           const char *desire_label, int topop)
{
    int i;
    for (i = 0; i < ops->code_len; ++i) {
        if (ops->codes[i].op != OP_RESERVED) continue;
        jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ops->codes[i].data;

        if (ri->label) {
            if (!desire_label || Jsi_Strcmp(ri->label, desire_label) != 0) {
                ri->topop += topop;
                continue;
            }
        }
        
        if (ri->type == RES_CONTINUE) {
            if (break_only) {
                ri->topop += topop;
                continue;
            } else {
                int topop = ri->topop;
                Jsi_Free(ri);       /* kill reserved Warn, replace with other opcode */
 /*               if (ops->codes[i].data && ops->codes[i].alloc) //TODO: memory leak?
                    Jsi_Free(ops->codes[i].data);*/
                if (topop) {
                    ops->codes[i].data = jpinfo_new(ops->code_len - i, topop);
                    ops->codes[i].op = OP_JMPPOP;
                    ops->codes[i].alloc = 1;
                } else {
                    ops->codes[i].data = (void *)(uintptr_t)(ops->code_len - i);
                    ops->codes[i].op = OP_JMP;
                    ops->codes[i].alloc = 0;
                }
            }
        } else if (ri->type == RES_BREAK) {
            int topop = ri->topop;
            Jsi_Free(ri);
/*           if (ops->codes[i].data && ops->codes[i].alloc)
                Jsi_Free(ops->codes[i].data); */
            if (topop) {
                ops->codes[i].data = jpinfo_new(step_len + ops->code_len - i, topop);
                ops->codes[i].op = OP_JMPPOP;
                ops->codes[i].alloc = 1;
            } else {
                ops->codes[i].data = (void *)(uintptr_t)(step_len + ops->code_len - i);
                ops->codes[i].op = OP_JMP;
                ops->codes[i].alloc = 0;
            }
        }
    }
}

const char* jsi_opcode_string(uint opCode)
{
    if (opCode >= (sizeof(jsi_op_names)/sizeof(jsi_op_names[0])))
        return "NULL";
    return jsi_op_names[opCode];
}

void jsi_code_decode(jsi_OpCode *op, int currentip, char *buf, int bsiz)
{
    if (_JSICASTINT(op->op) < 0 || op->op >= OP_LASTOP) {
        snprintf(buf, bsiz, "Bad opcode[%d] at %d", op->op, currentip);
    }
    char nbuf[100];
    snprintf(nbuf, sizeof(nbuf), "%d#%d", currentip, op->Line);
    snprintf(buf, bsiz, "%-8s %s ", nbuf, jsi_op_names[op->op]);

    int sl = Jsi_Strlen(buf);
    char *bp = buf + sl;
    bsiz -= sl;
    if (op->op == OP_PUSHBOO || op->op == OP_FCALL || op->op == OP_EVAL ||
        op->op == OP_POP || op->op == OP_ASSIGN ||
        op->op == OP_RET || op->op == OP_NEWFCALL ||
        op->op == OP_DELETE || op->op == OP_CHTHIS ||
        op->op == OP_OBJECT || op->op == OP_ARRAY ||
        op->op == OP_SHF ||
        op->op == OP_INC || op->op == OP_DEC) snprintf(bp, bsiz, "%" PRId64, (Jsi_Wide)(uintptr_t)op->data);
    else if (op->op == OP_PUSHNUM) snprintf(bp, bsiz, "%" JSI_NUMGFMT "", *((Jsi_Number *)op->data));
    else if (op->op == OP_PUSHSTR || op->op == OP_LOCAL ||
             op->op == OP_SCATCH) snprintf(bp, bsiz, "\"%s\"", op->data ? (char*)op->data:"(NoCatch)");
    else if (op->op == OP_PUSHVAR) snprintf(bp, bsiz, "var: \"%s\"", ((FastVar *)op->data)->var.varname);
    else if (op->op == OP_PUSHFUN) snprintf(bp, bsiz, "func: 0x%" PRIx64, (Jsi_Wide)(uintptr_t)op->data);
    else if (op->op == OP_JTRUE || op->op == OP_JFALSE ||
             op->op == OP_JTRUE_NP || op->op == OP_JFALSE_NP ||
             op->op == OP_JMP) snprintf(bp, bsiz, "{%" PRIu64 "}\t#%" PRIu64 "", (Jsi_Wide)(uintptr_t)op->data, (Jsi_Wide)((uintptr_t)currentip + (uintptr_t)op->data));
    else if (op->op == OP_JMPPOP) {
        jsi_JmpPopInfo *jp = (jsi_JmpPopInfo*)op->data;
        snprintf(bp, bsiz, "{%d},%d\t#%d", jp->off, jp->topop, currentip + jp->off);
    }
    else if (op->op == OP_STRY) {
        jsi_TryInfo *t = (jsi_TryInfo *)op->data;
        snprintf(bp, bsiz, "{try:%d, catch:%d, final:%d}", t->trylen, t->catchlen, t->finallen);
    }
}

void jsi_mark_local(Jsi_OpCodes *ops) // Mark variables as declared with "var"
{
    return;
    int i = 0;
    if (ops == NULL || ops->codes == NULL)
        return;
    while (i < ops->code_len) {
        if (ops->codes[i].op == OP_PUSHVAR)
            ops->codes[i].local = 1;
        i++;
    }
}

/*
void jsi_codes_print(Jsi_OpCodes *ops)
{
    int i = 0;
    jsi_OpCode *opcodes = ops->codes;
    int opcodesi = ops->code_len;
    
    fprintf(stderr, "opcodes count = %d\n", opcodesi);
    
    while(i < opcodesi) {
        jsi_code_decode(&opcodes[i], i);
        i++;
    }
}*/



static jsi_ForinVar *forinvar_new(jsi_Pstate *pstate, const char *varname, Jsi_OpCodes *local, Jsi_OpCodes *lval)
{
    jsi_ForinVar *r = (jsi_ForinVar*)Jsi_Calloc(1,sizeof(*r));
    r->sig = JSI_SIG_FORINVAR;
    r->varname = varname;
    r->local = local;
    r->lval = lval;
    return r;
}

static Jsi_OpCodes *make_forin(Jsi_OpCodes *lval, jsi_Pline *line, Jsi_OpCodes *expr, Jsi_OpCodes *stat, const char *label, int isof)
{
    Jsi_OpCodes *keycode = code_key();
    keycode->codes[0].isof = isof;
    keycode->codes[0].Line = line->first_line;
    Jsi_OpCodes *init = codes_join(expr, keycode);
    Jsi_OpCodes *cond = codes_join3(lval, code_next(),
                                   code_jfalse(stat->code_len + 2));
    Jsi_OpCodes *stat_jmp = code_jmp(-(cond->code_len + stat->code_len));
    code_reserved_replace(stat, 1, 0, label, 2);
    return codes_join3(codes_join(init, cond), 
                          codes_join(stat, stat_jmp), code_pop(2));
}

static jsi_CaseExprStat *exprstat_new(jsi_Pstate *pstate, Jsi_OpCodes *expr, Jsi_OpCodes *stat, int isdef)
{
    jsi_CaseExprStat *r = (jsi_CaseExprStat*)Jsi_Calloc(1,sizeof(*r));
    r->sig = JSI_SIG_CASESTAT;
    r->expr = expr;
    r->stat = stat;
    r->isdefault = isdef;
    return r;
}

static jsi_CaseList *caselist_new(jsi_Pstate *pstate, jsi_CaseExprStat *es)
{
    jsi_CaseList *a = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*a));
    a->sig = JSI_SIG_CASELIST;
    a->es = es;
    a->tail = a;
    return a;
}

static jsi_CaseList *caselist_insert(jsi_Pstate *pstate, jsi_CaseList *a, jsi_CaseExprStat *es)
{
    jsi_CaseList *b = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*b));
    a->sig = JSI_SIG_CASELIST;
    b->es = es;
    a->tail->next = b;
    a->tail = b;
    return a;
}

static Jsi_OpCodes *opassign(jsi_Pstate *pstate, jsi_Pline *line, Jsi_OpCodes *lval, Jsi_OpCodes *oprand, Jsi_OpCodes *op)
{
    Jsi_OpCodes *ret;
    if ((lval)->lvalue_flag == 1) {
        ret = codes_join3(lval, 
                             codes_join3(code_push_top(), oprand, op),
                             code_assign(pstate, line, 1));
    } else {
        ret = codes_join3(lval,
                             codes_join4(code_push_top2(), code_subscript(pstate, line, 1), oprand, op),
                             code_assign(pstate, line, 2));
    }
    return ret;
}

#endif
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#define COMMENT (-128)

static int lexer_getchar(jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int c = 0;
    if (!lex) Jsi_LogBug("No lexer init");
    if (lex->ltype == LT_FILE) {
        c = Jsi_Getc(lex->d.fp);
        if (c == EOF) c = 0;
    } else {
        if (lex->ungot) {
            c = lex->unch[--lex->ungot];
        } else {
            c = lex->d.str[lex->cur];
            if (c != 0) lex->cur++;
        }
    }
    //printf("%c", c);
    if (c == '\n') {
        //printf("!!!!!!!!!!\n");
        lex->cur_line++;
        lex->cur_char = 0;
    }
    lex->cur_char++;
    //printf("<%2x\n",c);
    return c;
}

static void lexer_ungetc(int c, jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    if (!lex) Jsi_LogBug("No lexer init");
    if (!c) return;
    if (c == '\n') {
        lex->cur_line--;
    }

    //printf("^<%c>", c);
    if (lex->ltype == LT_FILE) {
        Jsi_Ungetc(lex->d.fp, c);
    } else if (lex->ungot<=0 && lex->cur>0 && c == lex->d.str[lex->cur-1]) {
        lex->cur--;
    } else if ((lex->ungot+2)<(int)sizeof(lex->unch)) {
        lex->unch[lex->ungot++] = c;
    }
    //printf(">%2x\n",c);
}

Jsi_RC jsi_InitLexer(Jsi_Interp *interp, int release)
{
    static struct st_kw {
        const char *name;
        uintptr_t value;
    } keywords[] = {
        { "if", IF },
        { "else", ELSE },
        { "for", FOR },
        { "in", IN },
        { "while", WHILE },
        { "do", DO },
        { "continue", CONTINUE },
        { "switch", SWITCH },
        { "case", CASE },
        { "default", DEFAULT },
        { "break", BREAK },
        { "function", FUNC },
        { "return", RETURN },
        { "var", LOCAL },
        { "of", OF },
        { "new", NEW },
        { "delete", DELETE },
        { "try", TRY },
        { "catch", CATCH },
        { "throw", THROW },
        { "finally", FINALLY },
        { "with", WITH },
        { "undefined", UNDEF },
        { "true", _TRUE },
        { "false", _FALSE },
        { "this", _THIS },
        { "arguments", ARGUMENTS },
        { "void", VOID },
        { "typeof", TYPEOF },
        { "instanceof", INSTANCEOF },
        { "string", TYPESTRING },
        { "number", TYPENUMBER },
        { "regexp", TYPEREGEXP },
        { "any", TYPEANY },
        { "userobj", TYPEUSEROBJ },
        { "iterobj", TYPEITEROBJ },
        { "object", TYPEOBJECT },
        { "boolean", TYPEBOOLEAN },
        { "array", TYPEARRAY },
        { "null", TYPENULL },
        { "...", ELLIPSIS },
        { "debugger", __DEBUG }
    };
    uint i;
    Jsi_HashEntry *hPtr;
    if (release) return JSI_OK;
    if (!interp->lexkeyTbl->numEntries) {
        bool isNew;
        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw); ++i) {
            hPtr = Jsi_HashEntryNew(interp->lexkeyTbl, keywords[i].name, &isNew);
            assert(hPtr);
            if (hPtr)
                Jsi_HashValueSet(hPtr, (void*)keywords[i].value);
        }
    }
    return JSI_OK;
}

static int jsi_iskey(const char *word, jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->lexkeyTbl, word);
    if (hPtr)
        return (uintptr_t)Jsi_HashValueGet(hPtr);
    return 0;
}

static char *jsi_do_string(jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int n, c = lexer_getchar(lex);
    int endchar = c;
    
    int bufi = 0, bsiz, done = 0;
    char unibuf[bsiz=BUFSIZ], *buf = unibuf, *ret;
    
    while (!done) {
        if (bufi >= (bsiz-5)) {
            int nsiz = bsiz+=BUFSIZ;
            if (buf!=unibuf) 
                buf = (char*)Jsi_Realloc(buf, nsiz);
            else {
                buf = (char*)Jsi_Malloc(nsiz);
                memcpy(buf, unibuf, sizeof(unibuf));
            }
            bsiz = nsiz;
        }
        c = lexer_getchar(lex);
        if (c == EOF || c == 0) {
            goto saw_eof;
        }
        if (c == '\\') {
            n = lexer_getchar(lex);
            switch(n) {
                case 'b': buf[bufi++] = '\b'; break;
                case 'f': buf[bufi++] = '\f'; break;
                case 'n': buf[bufi++] = '\n'; break;
                case 'r': buf[bufi++] = '\r'; break;
                case 't': buf[bufi++] = '\t'; break;
                case 'u': {
                    char ibuf[5];
                    int ui;
                    for (ui=0; ui<4; ui++)
                        ibuf[ui] = lexer_getchar(lex);
                    ibuf[4] = 0;
                    ui = Jsi_UtfDecode(ibuf, buf+bufi);
                    if (ui>0)
                        bufi+=ui;
                    else {
                        Jsi_LogError("Unexpected utf encoding.");
                        buf[bufi++] = 0;
                        done = 1;
                    }
                    break;
                }
                case EOF: 
                case 0:
saw_eof:
                    Jsi_LogError("Unexpected EOF parsing string.");
                    buf[bufi++] = 0;
                    done = 1;
                    break;
                default: buf[bufi++] = n;
            }
        } else {
            buf[bufi++] = c;
        }
        if (c == endchar) {
            bufi --;
            break;
        }
    }
    buf[bufi] = 0;
    Jsi_HashEntry *hPtr = Jsi_HashSet(lex->pstate->strTbl, buf, NULL);
    ret = (char*)Jsi_HashKeyGet(hPtr);
    if (buf != unibuf)
        Jsi_Free(buf);
    return ret;
}

static char *jsi_do_regex(jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;

    int n, bufi = 0, bsiz;
    char unibuf[bsiz=BUFSIZ], *buf = unibuf, *ret = NULL;
    
    buf[bufi++] = lexer_getchar(lex);     /* first '/'*/
    while (1) {
        if (bufi >= (bsiz-5)) {
            int nsiz = bsiz+=BUFSIZ;
            if (buf!=unibuf) 
                buf = (char*)Jsi_Realloc(buf, nsiz);
            else {
                buf = (char*)Jsi_Malloc(nsiz);
                memcpy(buf, unibuf, sizeof(unibuf));
            }
            bsiz = nsiz;
        }
        int c = lexer_getchar(lex);
        if (c == EOF || c == 0) {
            goto saw_eof;
        }
        if (c == '\\') {
            n = lexer_getchar(lex);
            if (n == EOF || c == 0) {
saw_eof:
                Jsi_LogError("Unexpected EOF parsing regular expression.");
                buf[bufi++] = 0;
                break;
            }
            
            buf[bufi++] = c;
            buf[bufi++] = n;
        } else if (c == '/') {
            buf[bufi++] = '/';
            while (1) {
                buf[bufi++] = c = lexer_getchar(lex);
                if (!isalnum(c)) break;
            }
            buf[bufi-1] = 0;
            lexer_ungetc(c, lex);
            break;
        } else {
            buf[bufi++] = c;
        }
    }
    Jsi_HashEntry *hPtr = Jsi_HashSet(lex->pstate->strTbl, buf, NULL);
    ret = (char*)Jsi_HashKeyGet(hPtr);
    ret = Jsi_Strdup(buf);
    if (buf != unibuf)
        Jsi_Free(buf);
    return ret;
}

static int jsi_do_sign(jsi_Lexer *lex)
{
    static struct st_sn {
        const char *name;
        int len;
        int value;
    } signs[] = {
        { ">>>=", 4, URSHFAS },
        { "<<=", 3, LSHFAS },
        { ">>=", 3, RSHFAS },
        { "===", 3, EEQU },
        { "!==", 3, NNEQ },
        { ">>>", 3, URSHF },
        { "==", 2, EQU },
        { "!=", 2, NEQ },
        { "<=", 2, LEQ },
        { ">=", 2, GEQ },
        { "++", 2, INC },
        { "--", 2, DEC },
        { "&&", 2, AND },
        { "||", 2, OR },
        { "+=", 2, ADDAS },
        { "-=", 2, MNSAS },
        { "*=", 2, MULAS },
        { "/=", 2, DIVAS },
        { "%=", 2, MODAS },
        { "&=", 2, BANDAS },
        { "|=", 2, BORAS },
        { "^=", 2, BXORAS },
        { "<<", 2, LSHF },
        { ">>", 2, RSHF }
    };

    int bufi;
    char buf[4];
    uint i;
    for (bufi = 0; bufi < 4; ++bufi) {
        int c = lexer_getchar(lex);
        if (c == 0 || c == '\n') break;
        buf[bufi] = c;
    }
    if (!bufi) return 0;
    
    for (i = 0; i < sizeof(signs)/sizeof(struct st_sn); ++i) {
        if (bufi < signs[i].len) continue;
        if (strncmp(buf, signs[i].name, signs[i].len) == 0) {
            int j;
            for (j = bufi - 1; j >= signs[i].len; --j)
                lexer_ungetc(buf[j], lex);

            return signs[i].value;
        }
    }
    
    for (i = bufi - 1; i >= 1; --i)
        lexer_ungetc(buf[i], lex);
    
    return buf[0];
}

#define LOCATION_START(loc, lex) do {       \
    (loc)->first_line = (lex)->cur_line;    \
    (loc)->first_column = (lex)->cur_char;  \
    } while(0)
#define LOCATION_END(loc, lex) do {         \
    (loc)->last_line = (lex)->cur_line;     \
    (loc)->last_column = (lex)->cur_char;   \
    } while(0)

static void jsi_eat_comment(jsi_Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int c;
    while((c = lexer_getchar(lex))) {
        if (c == '*') {
            c = lexer_getchar(lex);
            if (c == '/') return;
            lexer_ungetc(c, lex);
        }
    }
    Jsi_LogError("Comment reach end of file");
}

static int jsi_yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Lexer *lex)
{
    int c, c2;
    Jsi_Interp *interp = lex->pstate->interp;
    
    char word[BUFSIZ];
    int wi = 0;

    while ((c = lexer_getchar(lex)) == ' ' || c == '\t' || c == '\n' || c == '\r');
    LOCATION_START(yyllocp, lex);
    
    if (c=='.') {
        c2 = lexer_getchar(lex);
        if (!isdigit(c2)) {
            lexer_ungetc(c2, lex);
        } else {
            word[wi++] = c;
            c = c2;
        }
    }
            
    if (isdigit(c)) {
        int base = 10, digCnt = 1, isdig, cpre=0;
        Jsi_Number fval;
        char *eptr = NULL;
        word[wi++] = c;
        while (wi < 1020) {
            c = lexer_getchar(lex);
            isdig = isxdigit(c);
            if (isdig)
                digCnt++;
            if (isdig || c == '.' || toupper(c)=='P' || toupper(c)=='E'
                || (toupper(c)=='X' && wi==1 && word[0] == '0')
                || ((c == '-' || c == '+') && toupper(cpre)=='E')
                || (base == 16 && isxdigit(c))) {
                if (toupper(c)=='X')
                    base = 16;
                word[wi++] = c;
                cpre = c;
                continue;
            }
            lexer_ungetc(c, lex);
            break;
        }
        word[wi] = 0;

        if (word[0] == '0' && (digCnt+(base==16)) == wi)
            fval = (Jsi_Number)strtoll(word, &eptr, base);
        else
            fval = (Jsi_Number)strtod(word, &eptr);
        LOCATION_END(yyllocp, lex);
        if (eptr == NULL || *eptr)
            Jsi_LogError("invalid number: %s", word); 
        Jsi_Number *db = (Jsi_Number *)Jsi_Malloc(sizeof(Jsi_Number));
        *db = fval;
        yylvalp->num = db;
        return FNUMBER;
    } else if (c == '"' || c == '\'') {
        lexer_ungetc(c, lex);
        yylvalp->str = jsi_do_string(lex);
        LOCATION_END(yyllocp, lex);
        return STRING;
    } else if (isalpha(c) || c == '_' || c == '$') {
        lexer_ungetc(c, lex);
        while (wi < 1020) {
            c = lexer_getchar(lex);
            if (!isalnum(c) && c != '_' && c != '$') break;
            word[wi++] = c;
        }
        lexer_ungetc(c, lex);
        
        word[wi] = 0;
        int r = jsi_iskey(word, lex);
        if (r) return r;
        yylvalp->str = (char*)Jsi_KeyAdd(interp,word); /*Jsi_Strdup(word);*/
        LOCATION_END(yyllocp, lex);
        return IDENTIFIER;
    } else if (c == '/') {
        int d = lexer_getchar(lex);
        if (d == '/') {
            while ((d = lexer_getchar(lex)) != '\r' && d != '\n' && d != 0);
            return COMMENT;
        } else if (d == '*') {
            jsi_eat_comment(lex);
            return COMMENT;
        } else lexer_ungetc(d, lex);
        
        if (lex->last_token == '=' || lex->last_token == '(' || lex->last_token == ':'
            || lex->last_token == '?' || lex->last_token == ','
            || lex->last_token == '[' || lex->last_token == '{')
        {
            lexer_ungetc(c, lex);
            
            char *regtxt = jsi_do_regex(lex);
            Jsi_Regex *re = Jsi_RegExpNew(interp, regtxt, JSI_REG_STATIC);
            if (!(yylvalp->regex = re)) {
                 Jsi_Free(regtxt);
                 return -1;
            }
            Jsi_Free(regtxt);
            return REGEXP;
        }
    }
    
    lexer_ungetc(c, lex);
    
    int r = jsi_do_sign(lex);
    LOCATION_END(yyllocp, lex);
    return r;
}

int yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate)
{
    int ret;
    do {
        ret = jsi_yylex(yylvalp, yyllocp, pstate->lexer);
    } while (ret == COMMENT);
/*
    if (ret < 128 && ret > 0) printf("%c\n", ret);
    else printf("%d\n", ret);
*/
    pstate->lexer->last_token = ret;
    return ret;
}

void yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg)
{
    Jsi_Interp *interp = ps->interp;
    interp->errLine = yylloc->first_line;
    interp->errCol = yylloc->first_column;
    Jsi_LogParse("%s:%d.%d: error: %s", interp->curFile?interp->curFile:"@", yylloc->first_line, 
        yylloc->first_column, msg);
    /*if (interp->curFile)
        fprintf(stderr, "%s:%d.%d: %s\n",  interp->curFile, yylloc->first_line, yylloc->first_column, msg);
    else
        fprintf(stderr, "@%d.%d: %s\n", yylloc->first_line, yylloc->first_column, msg);*/
    ps->err_count++;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* Return value from call to function will is not used. */
bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr) {
    return funcPtr->callflags.bits.isdiscard;
}

bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr)
{
    return (funcPtr->f.bits.iscons);
}

Jsi_CmdSpec *Jsi_FunctionGetSpecs(Jsi_Func *funcPtr)
{
    return funcPtr->cmdSpec;
}

void *Jsi_FunctionPrivData(Jsi_Func *funcPtr)
{
    return funcPtr->privData;
}

const char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp)
{
    switch (otyp) {
        case JSI_TT_NUMBER:     return "number"; 
        case JSI_TT_STRING:     return "string"; 
        case JSI_TT_BOOLEAN:    return "boolean"; 
        case JSI_TT_ARRAY:      return "array"; 
        case JSI_TT_FUNCTION:   return "function"; 
        case JSI_TT_OBJECT:     return "object"; 
        case JSI_TT_REGEXP:     return "regexp"; 
        case JSI_TT_ANY:        return "any"; 
        case JSI_TT_USEROBJ:    return "userobj"; 
        case JSI_TT_ITEROBJ:    return "iterobj"; 
        case JSI_TT_UNDEFINED:      return "undefined";
        case JSI_TT_VOID:       return "void";
        case JSI_TT_NULL:       return "null"; 
    }
    return "undefined";
}
const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp)
{
    switch (otyp) {
        case JSI_OT_NUMBER:     return "number"; 
        case JSI_OT_STRING:     return "string"; 
        case JSI_OT_BOOL:       return "boolean"; 
        case JSI_OT_ARRAY:      return "array"; 
        case JSI_OT_FUNCTION:   return "function"; 
        case JSI_OT_OBJECT:     return "object"; 
        case JSI_OT_REGEXP:     return "regexp"; 
        case JSI_OT_ITER:       return "iter"; 
        case JSI_OT_USEROBJ:    return "userobj"; 
        case JSI_OT_UNDEF:      return "any";
    }
    return "undefined";
}

const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val)
{
    switch (val->vt) {
        case JSI_VT_NUMBER:     return "number"; 
        case JSI_VT_STRING:     return "string"; 
        case JSI_VT_BOOL:       return "boolean"; 
        case JSI_VT_OBJECT:     if (val->d.obj->ot == JSI_OT_OBJECT && val->d.obj->isarrlist) return "array"; return jsi_ObjectTypeName(interp, val->d.obj->ot); 
        case JSI_VT_VARIABLE:   return "variable"; 
        case JSI_VT_NULL:       return "null"; 
        case JSI_VT_UNDEF:      break;
    }
    return "undefined";
}

int jsi_typeGet(Jsi_Interp *interp, const char *tname) {
    if (!tname)
        return 0;
    if (Jsi_Strchr(tname, '|')) {
        int argc, i, rc, val = 0;
        char **argv;
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        Jsi_SplitStr(tname, &argc, &argv, "|", &dStr);
        for (i=0; i<argc; i++) {
            rc = jsi_typeGet(interp, argv[i]);
            if (rc < 0)
                break;
            val |= rc;
        }
        Jsi_DSFree(&dStr);
        if (i<argc)
            return -1;
        return val;
    }
    switch (tname[0]) {
        case 'b': if (Jsi_Strcmp(tname, "boolean")==0) return JSI_TT_BOOLEAN; break;
        case 's': if (Jsi_Strcmp(tname, "string")==0) return JSI_TT_STRING; break;
        case 'n': if (Jsi_Strcmp(tname, "null")==0) return JSI_TT_NULL;
                  if (Jsi_Strcmp(tname, "number")==0) return JSI_TT_NUMBER; break;
        case 'o': if (Jsi_Strcmp(tname, "object")==0) return JSI_TT_OBJECT; break;
        case 'r': if (Jsi_Strcmp(tname, "regexp")==0) return JSI_TT_REGEXP; break;
        case 'f': if (Jsi_Strcmp(tname, "function")==0) return JSI_TT_FUNCTION; break;
        case 'i': if (Jsi_Strcmp(tname, "iterobj")==0) return JSI_TT_ITEROBJ;
        case 'u': if (Jsi_Strcmp(tname, "userobj")==0) return JSI_TT_USEROBJ;
                  if (Jsi_Strcmp(tname, "undefined")==0) return JSI_TT_UNDEFINED; break;
        case 'a': if (Jsi_Strcmp(tname, "array")==0) return JSI_TT_ARRAY;
                  if (Jsi_Strcmp(tname, "any")==0) return JSI_TT_ANY; break;
        case 'v': if (Jsi_Strcmp(tname, "void")==0) return JSI_TT_VOID; break;
    }
    Jsi_LogWarn("Type \"%s\" is not one of boolean, string, number, function, array, object, regexp, userobj, null, undefined, void or any", tname);
    return 0;
}

const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr) {
    if (typ<=0 || (typ&JSI_TT_ANY)) {
        Jsi_DSAppend(dStr, "any", NULL);
        return Jsi_DSValue(dStr);
    }
    int i = 0;
    if (typ&JSI_TT_NUMBER) Jsi_DSAppend(dStr, (i++?"|":""), "number", NULL);
    if (typ&JSI_TT_STRING) Jsi_DSAppend(dStr, (i++?"|":""), "string", NULL);
    if (typ&JSI_TT_BOOLEAN)  Jsi_DSAppend(dStr, (i++?"|":""), "boolean", NULL);
    if (typ&JSI_TT_ARRAY)   Jsi_DSAppend(dStr, (i++?"|":""), "array", NULL);
    if (typ&JSI_TT_FUNCTION) Jsi_DSAppend(dStr, (i++?"|":""), "function", NULL);
    if (typ&JSI_TT_OBJECT) Jsi_DSAppend(dStr, (i++?"|":""), "object", NULL);
    if (typ&JSI_TT_REGEXP) Jsi_DSAppend(dStr, (i++?"|":""), "regexp", NULL);
    if (typ&JSI_TT_USEROBJ) Jsi_DSAppend(dStr, (i++?"|":""), "userobj", NULL);
    if (typ&JSI_TT_ITEROBJ) Jsi_DSAppend(dStr, (i++?"|":""), "iterobj", NULL);
    if (typ&JSI_TT_NULL) Jsi_DSAppend(dStr, (i++?"|":""), "null", NULL);
    if (typ&JSI_TT_UNDEFINED) Jsi_DSAppend(dStr, (i++?"|":""), "undefined", NULL);
    if (typ&JSI_TT_VOID) Jsi_DSAppend(dStr, (i++?"|":""), "void", NULL);
    return Jsi_DSValue(dStr);
}

const char *jsiFuncInfo(Jsi_Interp *interp, Jsi_DString *dStr, Jsi_Func* func, Jsi_Value *arg) {
    if (!func) return "";
    if (func->name)
        Jsi_DSPrintf(dStr, ", in call to '%s'", func->name);
    else
        Jsi_DSPrintf(dStr, ", in call to function");
    if (func->script) {
        const char *cp = Jsi_Strrchr(func->script, '/');
        if (cp)
            cp++;
        else
            cp = func->script;
        Jsi_DSPrintf(dStr, " declared at %s:%d.%d", cp, func->bodyline.first_line, func->bodyline.first_column);
    }
        if (arg) {
        Jsi_DSAppend(dStr, " <", NULL);
        Jsi_ValueGetDString(interp, arg, dStr, 0);
        Jsi_DSAppend(dStr, ">.", NULL);
    }
    return Jsi_DSValue(dStr);
}

// Check argument matches type.  If func is null, this is a parse. An index of 0 is the return value.
Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,
    const char *p2, int index, Jsi_Func *func, bool isdefault) {
    Jsi_RC rc = JSI_OK;
    char idxBuf[200];
    idxBuf[0] = 0;
    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {
        snprintf(idxBuf, sizeof(idxBuf), " arg %d", index);
        jsi_TypeMismatch(interp);
       
        Jsi_DString fStr = {};
        Jsi_LogType("call with undefined var %s%s '%s'%s", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));
        Jsi_DSFree(&fStr);
        if (interp->typeCheck.error)
            rc = JSI_ERROR;
        return rc;
    }
    if (typ <= 0)
        return JSI_OK;
    if (typ&JSI_TT_VOID)
        return JSI_OK;
    if (interp->typeCheck.all==0) {
        if (func ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))
            return JSI_OK;
    }
    if (index == 0 && func && func->type == FC_BUILDIN && 
        interp->typeCheck.all == 0) // Normally do not check return types for builtins.
        return JSI_OK; 
    if ((typ&JSI_TT_ANY)) return JSI_OK;
    if (index == 0 && (typ&JSI_TT_VOID)) {
        if (arg->vt != JSI_VT_UNDEF && !(typ&JSI_TT_UNDEFINED))
            goto done;
        return JSI_OK;
    }
    if (typ&JSI_TT_UNDEFINED && Jsi_ValueIsUndef(interp, arg)) return rc;
    if (typ&JSI_TT_NUMBER && Jsi_ValueIsNumber(interp, arg)) return rc;
    if (typ&JSI_TT_STRING && Jsi_ValueIsString(interp, arg)) return rc;
    if (typ&JSI_TT_BOOLEAN && Jsi_ValueIsBoolean(interp, arg))  return rc;
    if (typ&JSI_TT_ARRAY && Jsi_ValueIsArray(interp, arg))   return rc;
    if (typ&JSI_TT_FUNCTION && Jsi_ValueIsFunction(interp, arg)) return rc;
    if (typ&JSI_TT_REGEXP && Jsi_ValueIsObjType(interp, arg, JSI_OT_REGEXP)) return rc;
    if (typ&JSI_TT_USEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_USEROBJ)) return rc;
    if (typ&JSI_TT_ITEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_ITER)) return rc;
    if (typ&JSI_TT_OBJECT && (
        Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT) && Jsi_ValueIsArray(interp, arg)==0))
        return rc;
    if (typ&JSI_TT_NULL && Jsi_ValueIsNull(interp, arg)) return rc;
done:
    {
        Jsi_DString dStr = {};
        const char *exp = jsi_typeName(interp, typ, &dStr);
        const char *vtyp = jsi_ValueTypeName(interp, arg);
        if (index>0)
            snprintf(idxBuf, sizeof(idxBuf), " arg %d", index);
        if (interp->typeCheck.error)
            rc = JSI_ERROR;
        jsi_TypeMismatch(interp);
        Jsi_DString fStr = {};
        Jsi_LogType("type mismatch %s%s '%s': expected \"%s\" but got \"%s\"%s",
            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, arg));
        Jsi_DSFree(&fStr);
        Jsi_DSFree(&dStr);
    }
    return rc;
}

Jsi_RC jsi_StaticArgTypeCheck(Jsi_Interp *interp, int atyp, const char *p1, const char *p2, int index, Jsi_Func *func, jsi_Pline *line) {
    Assert(index>0);
    Jsi_RC rc;
    if (interp->typeCheck.parse==0 && interp->typeCheck.all==0)
        return JSI_OK;
    int ai = index-1+func->callflags.bits.addargs;
    if (func->argnames == NULL || ai>=func->argnames->count || ai<0)
        return JSI_OK;
    int typ = func->argnames->args[ai].type;
    if (typ <= 0)
        return JSI_OK;
    if (index == 0 && func && func->type == FC_BUILDIN && 
        interp->typeCheck.all==0) // Normally do not check return types for builtins.
        return JSI_OK; 
    if ((typ&JSI_TT_ANY)) return JSI_OK;
    if (index == 0 && (typ&JSI_TT_VOID)) {
        if (atyp != JSI_VT_UNDEF && !(typ&JSI_TT_UNDEFINED))
            goto done;
        return JSI_OK;
    }
    if (atyp == JSI_VT_UNDEF)
        return JSI_OK;
    rc = JSI_OK;
    if (typ&JSI_TT_UNDEFINED && atyp == JSI_TT_UNDEFINED) return rc;
    if (typ&JSI_TT_NUMBER && atyp==JSI_TT_NUMBER) return rc;
    if (typ&JSI_TT_STRING && atyp==JSI_TT_STRING) return rc;
    if (typ&JSI_TT_BOOLEAN && atyp==JSI_TT_BOOLEAN)  return rc;
    if (typ&JSI_TT_ARRAY && atyp==JSI_TT_ARRAY)   return rc;
    if (typ&JSI_TT_FUNCTION && atyp==JSI_TT_FUNCTION) return rc;
    if (typ&JSI_TT_REGEXP && atyp==JSI_TT_REGEXP) return rc;
    if (typ&JSI_TT_USEROBJ && atyp==JSI_TT_USEROBJ) return rc;
    if (typ&JSI_TT_ITEROBJ && atyp==JSI_TT_ITEROBJ) return rc;
    if (typ&JSI_TT_OBJECT && atyp==JSI_TT_OBJECT) return rc;
    if (typ&JSI_TT_NULL && atyp==JSI_TT_NULL) return rc;
done:
    {
        Jsi_DString dStr = {};
        const char *exp = jsi_typeName(interp, typ, &dStr);
        const char *vtyp = jsi_TypeName(interp, (Jsi_ttype)atyp);
        char idxBuf[200];
        idxBuf[0] = 0;
        if (index>0)
            snprintf(idxBuf, sizeof(idxBuf), " arg %d", index);
        if (line)
            interp->parseLine = line;
        if (interp->typeCheck.error)
            rc = JSI_ERROR;
        jsi_TypeMismatch(interp);
        Jsi_DString fStr = {};
        Jsi_LogType("type mismatch %s%s '%s': expected \"%s\" but got \"%s\"%s",
            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, NULL));
        Jsi_DSFree(&fStr);
        Jsi_DSFree(&dStr);
    }
    return rc;
}

int jsiPopArgs(Jsi_OpCodes *argCodes, int i)
{
    int m=i-1, n = (uintptr_t)argCodes->codes[i].data, cnt = 0;
    if (argCodes->codes[i].op == OP_OBJECT)
        n *= 2;
    for (; m>=0 && cnt<n; m--, cnt++) {
        int op = argCodes->codes[m].op;
        if (op == OP_ARRAY || op == OP_OBJECT)
            m = jsiPopArgs(argCodes, m);
    }
    return m+1;
}

Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes)
{
    Jsi_RC rc = JSI_OK;
    if (interp->typeCheck.all==0) {
        if (!argCodes ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))
            return JSI_OK;
    }

    Jsi_CmdSpec *spec = func->cmdSpec;
    Jsi_ScopeStrs *ss = func->argnames;
    if (ss==NULL && spec == NULL)
        return JSI_OK;
    int i, minArgs, maxArgs, mis = 0, varargs = 0;
    char nbuf[100];
    if (func->type == FC_BUILDIN) {
        varargs =  (spec->maxArgs<0);
        maxArgs = spec->maxArgs + func->callflags.bits.addargs;
        minArgs = spec->minArgs + func->callflags.bits.addargs;
    } else {
        varargs = ss->varargs;
        minArgs = (ss->firstDef>0 ? ss->firstDef-1 : ss->count);
        maxArgs = ss->count;
        mis = (argc != ss->count);
        if (func->retType == 0 && ss && ss->typeCnt == 0 && interp->typeCheck.all==0)
            return JSI_OK;
    }
    if (varargs) {
        if (argc >= minArgs)
            return JSI_OK;
        mis = (argc<minArgs);
    } else 
        mis = (argc<minArgs || argc>maxArgs);
    if (mis) {
        if (varargs)
            snprintf(nbuf, sizeof(nbuf), "%d or more", minArgs);
        else if (maxArgs > minArgs)
            snprintf(nbuf, sizeof(nbuf), "%d-%d", minArgs, maxArgs);
        else
            snprintf(nbuf, sizeof(nbuf), "%d", maxArgs);
        if (line)
            interp->parseLine = line;
        if (interp->typeCheck.error)
            rc = JSI_ERROR;
        Jsi_DString dStr = {};
        Jsi_FuncObjToString(interp, func, &dStr, 2);
        Jsi_LogType("got %d args, expected %s, calling %s",
            argc, nbuf, Jsi_DSValue(&dStr));
        jsi_TypeMismatch(interp);
        Jsi_DSFree(&dStr);
        if (line)
            interp->parseLine = NULL;
        return rc;
    }
    if (argCodes && argCodes->code_len>=argc) {
        int cl = argCodes->code_len;
        int aind=argc-1;
        for (i=cl-1; rc == JSI_OK && i>=0 && aind>=0; i--,aind--) {
            Jsi_ttype atyp = JSI_TT_ANY;
            switch (argCodes->codes[i].op) {
                case OP_PUSHSTR: atyp=JSI_TT_STRING; break;
                case OP_PUSHNUM: atyp=JSI_TT_NUMBER; break;
                case OP_PUSHBOO: atyp=JSI_TT_BOOLEAN; break;
                case OP_PUSHFUN: atyp=JSI_TT_FUNCTION; break;
                case OP_PUSHTHS: atyp=JSI_TT_OBJECT; break;
                case OP_PUSHREG: atyp=JSI_TT_REGEXP; break;
                case OP_PUSHUND: atyp=JSI_TT_VOID; break;
                case OP_PUSHNULL: atyp=JSI_TT_NULL; break;
                case OP_PUSHARG: atyp=JSI_TT_ARRAY; break;
                case OP_ARRAY: atyp=JSI_TT_ARRAY; i=jsiPopArgs(argCodes, i); break;
                case OP_OBJECT: atyp=JSI_TT_OBJECT; i=jsiPopArgs(argCodes, i); break;
                default: break;
            }
            if (atyp == JSI_TT_ANY) continue;
            rc = jsi_StaticArgTypeCheck(interp, atyp, "for argument", name, aind+1, func, line);  
        }
    }
    return rc;
}

int jsi_BuiltinCmd(Jsi_Interp *interp, const char *name)
{
    Jsi_Value *val = Jsi_NameLookup(interp, name);
    if (!name)
        return 0;
    if (!Jsi_ValueIsFunction(interp, val))
        return 0;
    Jsi_Func *f = val->d.obj->d.fobj->func;
    return (f->type == FC_BUILDIN);
}

// Parse time function call checker.
void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes)
{
    Jsi_Interp *interp = p->interp;
    if (name == NULL || !(interp->typeCheck.proto|interp->typeCheck.all|interp->typeCheck.parse))
        return;
    if (name && isdigit(name[0]))
        return;
    Jsi_Value *val;
    val = Jsi_NameLookup2(interp, name, namePre);
    Jsi_Func *f = NULL;
    if (val != NULL) {
        if (Jsi_ValueIsFunction(interp, val))
            f = val->d.obj->d.fobj->func;
    } else if (interp->staticFuncsTbl) {
        f = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);
    }
    if (f)
        jsi_RunFuncCallCheck(interp, f, argc, name, line, argCodes);
    else if (interp->typeCheck.proto && (namePre==NULL || jsi_BuiltinCmd(interp, namePre))) {
        if (line)
            interp->parseLine = line;
        Jsi_LogWarn("called function '%s' with no previous definition", name);
        jsi_TypeMismatch(interp);
        if (line)
            interp->parseLine = NULL;
    }
}

int jsi_FuncSigsMatch(jsi_Pstate *pstate, Jsi_Func *f1, Jsi_Func *f2)
{
    // Skip where both functions have no types.
    if (f1->retType==0 && f1->argnames->typeCnt==0 && f1->argnames->varargs==0 &&
        f2->retType==0 && f2->argnames->typeCnt==0 && f2->argnames->varargs==0 &&
        pstate->interp->typeCheck.all==0)
        return 1;
    if (f1->retType != f2->retType)
        return 0;
    if (f1->argnames->count != f2->argnames->count)
        return 0;
    if (f1->argnames->typeCnt != f2->argnames->typeCnt)
        return 0;
    if (f1->argnames->varargs != f2->argnames->varargs)
        return 0;
    int i;
    for (i=0; i<f1->argnames->count; i++) {
        Jsi_ScopeStrs *a1 = f1->argnames, *a2 = f2->argnames;
        if (a1->args[i].type != a2->args[i].type)
            return 0;
        Jsi_Value *v1, *v2;
        v1 = a1->args[i].defValue;
        v2 = a2->args[i].defValue;
        if (v1==NULL && v2 == NULL)
            continue;
        if (v1==NULL || v2 == NULL)
            return 0;
        if (v1->vt != v2->vt)
            return 0;
        if (Jsi_ValueCmp(pstate->interp, v1, v2, 0))
            return 0;
    }
    return 1;
}

// Return directive from first instruction.
const char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str) {
    if (!ops) return NULL;
    if (!ops->code_len) return NULL;
    if (ops->codes[0].op != OP_PUSHSTR || !ops->codes[0].data) return NULL;
    if (Jsi_Strncmp((char*)ops->codes[0].data, str, Jsi_Strlen(str))) return NULL;
    return (char*)ops->codes[0].data;
}

/* TODO: if not in a file (an eval) save copy of body string from pstate->lexer??? */
Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline* line, const char *name)
{
    Jsi_Interp *interp = pstate->interp;
    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);
    Jsi_Func *f = jsi_FuncNew(interp);
    f->type = FC_NORMAL;
    f->opcodes = ops;
    f->argnames = args;
    f->localnames = localvar;
    f->script = interp->curFile;
    f->bodyline = *line;
    f->retType = (Jsi_otype)args->retType;
    //f->strict = (jsi_GetDirective(interp, ops, "use strict") != NULL);
    pstate->argType = 0;
    if (localvar && args && (jsi_IsStrictMode(interp))) {
        int i, j;
        for (i=0; i<localvar->count; i++)
            for (j=0; j<args->count; j++)
                if (!Jsi_Strcmp(localvar->args[i].name, args->args[j].name)) {
                        if (line)
                            interp->parseLine = line;
                        Jsi_LogType("function %s():  parameter name conflicts with 'var %s'", name?name:"", localvar->args[i].name);
                        if (line)
                            interp->parseLine = NULL;
                        jsi_TypeMismatch(interp);
                        if (interp->typeCheck.error)
                            pstate->err_count++;
                }
    }
    if (name) {
        f->name = Jsi_KeyAdd(interp, name);
        if ((interp->typeCheck.run|interp->typeCheck.parse|interp->typeCheck.all|interp->typeCheck.proto)) {
            
            if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {
                if (line)
                    interp->parseLine = line;
                Jsi_LogWarn("missing return at end of function '%s'", name);
                if (line)
                    interp->parseLine = NULL;
                //if (interp->typeCheck.error)
                 //   pstate->err_count++;
            }
             
            if (interp->staticFuncsTbl) {
                Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);
                
                // Forward declaration signature compare (indicated by an empty body).
                if (interp->typeCheck.proto && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {
                    if (!jsi_FuncSigsMatch(pstate, f, fo)) {
                        if (line)
                            interp->parseLine = line;
                        Jsi_LogWarn("possible signature mismatch for function '%s' at %.120s:%d", name, fo->script, fo->bodyline.first_line);
                        if (line)
                            interp->parseLine = NULL;
                        jsi_TypeMismatch(interp);
                    }
                    //printf("OLD: %s\n", name);
                }
                Jsi_HashSet(interp->staticFuncsTbl, name, f);
            }
        }
    }
    return f;
}

Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr)
{
    Jsi_FuncObj *funcPtr;
    Jsi_Func *f;
    if (!Jsi_ValueIsFunction(interp, func))
        return JSI_ERROR;
    funcPtr = func->d.obj->d.fobj;
    f = funcPtr->func;
    SIGASSERT(f, FUNC);
    *argcPtr = f->argnames->count;
    return JSI_OK;
}

void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who)
{
    SIGASSERT(who, FUNC);
    if (who->localnames) {
        int i;
        for (i = 0; i < who->localnames->count; ++i) {
            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);
            if (argkey) {
                DECL_VALINIT(key);// = VALINIT;
                Jsi_Value *v __attribute__((unused));
                Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.
                Jsi_ValueMakeStringKey(interp, &kPtr, argkey);
                v = jsi_ValueObjKeyAssign(interp, arguments, kPtr, NULL, JSI_OM_DONTENUM);
                jsi_ValueDebugLabel(v, "locals", who->name);
            }
        }
    }
}

Jsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int withTypes)
{
    if (f->type == FC_NORMAL) {
        int i;
        for (i = 0; i < f->argnames->count; ++i) {
            jsi_ArgValue *av = f->argnames->args+i;
            if (i) Jsi_DSAppend(dStr, ", ", NULL);
            Jsi_DSAppend(dStr,  jsi_ScopeStrsGet(f->argnames, i), NULL);
            if (withTypes && av) {
                Jsi_DString tStr = {};
                int atyp = av->type;
                if (av->defValue)
                    atyp &= ~(av->defValue->vt==JSI_VT_NULL?JSI_TT_NULL:(1<<av->defValue->vt));
                if (atyp) {
                    Jsi_DSAppend(dStr, ":", jsi_typeName(interp, atyp, &tStr), NULL);
                }
                Jsi_DSSetLength(&tStr, 0);
                if (av->defValue)
                    Jsi_DSAppend(dStr, "=", Jsi_ValueGetDString(interp, av->defValue, &tStr, 1), NULL);
                Jsi_DSFree(&tStr);
            }
        }
    } else if (f->cmdSpec && f->cmdSpec->argStr)
        Jsi_DSAppend(dStr, f->cmdSpec->argStr, NULL);
    return JSI_OK;
}

Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags)
{
    int withBody = flags&1;
    int withTypes = flags&2;
    int withJSON = flags&4;
    Jsi_CmdSpec *spec = f->cmdSpec;
    if (withJSON)
        Jsi_DSAppend(dStr, "\"", NULL);
    if (f->type == FC_NORMAL) {
        Jsi_DSAppend(dStr, "function ", f->name?f->name:"", "(", NULL);
        jsi_FuncArgsToString(interp, f, dStr, withTypes);
        Jsi_DSAppend(dStr, ")", NULL);
        if (withTypes && f->retType) {
            Jsi_DString tStr;
            Jsi_DSInit(&tStr);
            Jsi_DSAppend(dStr, ":", jsi_typeName(interp, f->retType, &tStr), NULL);
            Jsi_DSFree(&tStr);
        }
        if (withBody)
            Jsi_DSAppend(dStr, " {...}", NULL);
    } else {
        Jsi_DSAppend(dStr, "function ", f->name?f->name:"", "(",
            (spec&&spec->argStr)?spec->argStr:"", ")", NULL);
        if (withBody)
            Jsi_DSAppend(dStr, " { [native code] }", NULL);
    }
    if (withJSON)
        Jsi_DSAppend(dStr, "\"", NULL);
    return JSI_OK;
}

Jsi_Value *jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec)
{
    Jsi_Obj *o = Jsi_ObjNew(interp);
    Jsi_Func *f = jsi_FuncNew(interp);
    Jsi_ObjIncrRefCount(interp, o);
    o->ot = JSI_OT_FUNCTION;
    f->type = FC_BUILDIN;
    f->callback = callback;
    f->privData = NULL;
    o->d.fobj = jsi_FuncObjNew(interp, f);
    f->cmdSpec = cspec;
    if (!cspec) {
        f->cmdSpec = (Jsi_CmdSpec*)Jsi_Calloc(2,sizeof(Jsi_CmdSpec));
        f->cmdSpec->reserved[3] = (void*)0x1;
        f->cmdSpec->maxArgs = -1;
        if (name)
            f->cmdSpec->name = (char*)Jsi_KeyAdd(interp, name);
    }
    f->script = interp->curFile;
    f->callback = callback;
    return Jsi_ValueMakeObject(interp, toVal, o);
}

Jsi_Value *jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData)
{
    Jsi_Obj *o = Jsi_ObjNew(interp);
    Jsi_Func *f = jsi_FuncNew(interp);
    o->ot = JSI_OT_FUNCTION;
    f->type = FC_BUILDIN;
    f->cmdSpec = cmdSpec;
    f->callback = cmdSpec->proc;
    f->privData = privData;
    f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);
    f->script = interp->curFile;
    o->d.fobj = jsi_FuncObjNew(interp, f);
    return Jsi_ValueMakeObject(interp, NULL, o);
}


/* Call a function with args: args and/or ret can be NULL. */
static Jsi_RC jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
{
    if (interp->deleting)
        return JSI_ERROR;
    if (!Jsi_ValueIsFunction(interp, func)) 
        return Jsi_LogError("can not execute expression, expression is not a function");
    if (!func->d.obj->d.fobj) {   /* empty function */
        return JSI_OK;
    }
    if (!ret) {
        if (!interp->nullFuncRet) {
            interp->nullFuncRet = Jsi_ValueNew(interp);
            Jsi_IncrRefCount(interp, interp->nullFuncRet);
        }
        ret = &interp->nullFuncRet;
        Jsi_ValueMakeUndef(interp, ret);
    }
    if (!args) {
        if (!interp->nullFuncArg) {
            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
            Jsi_IncrRefCount(interp, interp->nullFuncArg);
        }
        args = interp->nullFuncArg;
    }
    /* func to call */
    Jsi_Func *fstatic = func->d.obj->d.fobj->func;
    SIGASSERT(fstatic, FUNC);
    
    /* prepare args */
    if (args->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, args->d.obj)) 
        return Jsi_LogError("argument must be an array");
    /* new this */
    Jsi_Value *ntPtr = Jsi_ValueDup(interp, _this ? _this : func);
    Jsi_Func *prevActive = interp->activeFunc;
    Jsi_RC res = jsi_SharedArgs(interp, args, fstatic, 1);
    bool isalloc = 0;
    int calltrc = 0;
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, args, fstatic);
        jsi_SetCallee(interp, args, func);
        isalloc = 1;
        Jsi_IncrRefCount(interp, args);
        if (fstatic->type == FC_NORMAL) {
            if ((interp->traceCall&jsi_callTraceFuncs) && fstatic->name)
                calltrc = 1;
        } else {
            if ((interp->traceCall&jsi_callTraceCmds) && fstatic->name)
                calltrc = 1;
        }
        interp->activeFunc = fstatic;
        if (fstatic->type == FC_NORMAL) {
            if (calltrc)
                jsi_TraceFuncCall(interp, fstatic, NULL, ntPtr, args, NULL);
            res = jsi_evalcode(interp->ps, fstatic, fstatic->opcodes, func->d.obj->d.fobj->scope, 
                args, ntPtr, ret);
        } else {
            if (calltrc)
                jsi_TraceFuncCall(interp, fstatic, NULL, ntPtr, args, NULL);
            res = fstatic->callback(interp, args, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic, 0);
    if (calltrc && (interp->traceCall&jsi_callTraceReturn))
        jsi_TraceFuncCall(interp, fstatic, NULL, ntPtr, NULL, *ret);
    interp->activeFunc = prevActive;
    jsi_SharedArgs(interp, args, fstatic, 0);
    if (isalloc) 
        Jsi_DecrRefCount(interp, args);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}

Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
{
    // Arrange for error reporting to point to called function.
    Jsi_Func *fstatic = func->d.obj->d.fobj->func;
    jsi_OpCode *oldops = interp->curIp;
    if (fstatic->opcodes)
        interp->curIp = fstatic->opcodes->codes;
    Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);
    interp->curIp = oldops;
    return rc;
}

// Do typechecking for callback using argStr from .data in builtin Jsi_Options: may not use = or ...
bool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr)
{
    int i, atyp, ftyp, rc = 0;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    int argc = 0;
    char **argv, *sname, *stype, *cp;
    if (!argStr)
        goto done;
    if (f->type == FC_BUILDIN) {
        // Check builtin cmd
        jsi_CommandArgCheck(interp, f->cmdSpec, f, f->parent);
        goto done;
    }
    if ((cp=Jsi_Strchr(argStr, '='))) {
        Jsi_LogWarn("may not have default value in option, expected: %s", argStr);
        goto done;
    }
    if (Jsi_Strstr(argStr, "...")) {
        Jsi_LogWarn("may not have ... in args, expected: %s", argStr);
        goto done;
    }
    if (argStr[0]) {
        Jsi_SplitStr(argStr, &argc, &argv, ",", &dStr);
        if (argc<=0)
            goto done;
    }
    if (!f->argnames) {
        if (argStr[0])
            Jsi_LogWarn("function has no args, expected: %s", argStr);
        else
            rc = 1;
        goto done;
    } else {
        if (f->argnames->argCnt != argc) {
            if (argc)
                Jsi_LogWarn("argument mismatch, expected: %s", argStr);
            else
                Jsi_LogWarn("function should have no arguments");
            goto done;
        }
        if (f->argnames->varargs) { // TODO: could allow varargs...
            Jsi_LogWarn("may not use varargs function, expected: %s", argStr);
            goto done;
        }

    }
    for (i=0; i<argc; i++) {
        sname = argv[i];
        stype = NULL;
        while (sname && *sname && isspace(*sname)) { sname++; }
        if ((cp=Jsi_Strchr(sname, ':')))
        {
            stype = cp+1;
            *cp = 0;
            while (*stype && isspace(*stype)) { stype++; }
            if (*stype) {
                cp = stype+Jsi_Strlen(stype)-1;
                while (cp>=stype && isspace(*cp)) { *cp = 0; cp--; }
            }
        }
        if (sname && *sname) {
            cp = sname+Jsi_Strlen(sname)-1;
            while (cp>=sname && isspace(*cp)) { *cp = 0; cp--; }
        }
        ftyp = f->argnames->args[i].type;
        if (ftyp<=0 || (ftyp&JSI_TT_ANY))
            continue;
        atyp = jsi_typeGet(interp, stype);
        if (ftyp != atyp && atyp) {
            Jsi_LogWarn("argument %d of function \"%s\" does not match \"func(%s)\"" ,
                i+1, f->name, argStr);
            goto done;
        }
    }
    rc = 1;
done:
    Jsi_DSFree(&dStr);
    if (!rc)
        jsi_TypeMismatch(interp);
    return rc;
}

/* Call function that returns a bool with a single argument. Returns -1, else 0/1 for false/true,  */
int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg)
{
    if (interp->deleting)
        return JSI_ERROR;
    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);
    Jsi_RC rc;
    int bres = 0;
    if (!arg) {
        if (!interp->nullFuncArg) {
            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
            Jsi_IncrRefCount(interp, interp->nullFuncArg);
        }
        vpargs = interp->nullFuncArg;
    } else {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));
    }
    Jsi_IncrRefCount(interp, vpargs);
    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (rc == JSI_OK)
        bres = Jsi_ValueIsTrue(interp, frPtr);
    else {
        bres = 2;
        Jsi_LogError("function call failed");
    }
    Jsi_DecrRefCount(interp, frPtr);
    return bres;
}

// Invoke function with one string argument.
Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr)
{
    if (interp->deleting)
        return JSI_ERROR;
    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);
    Jsi_RC rc;
    if (!arg) {
        if (!interp->nullFuncArg) {
            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
            Jsi_IncrRefCount(interp, interp->nullFuncArg);
        }
        vpargs = interp->nullFuncArg;
    } else {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));
    }
    Jsi_IncrRefCount(interp, vpargs);
    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (rc != JSI_OK)
        Jsi_LogError("function call failed");
    else
        Jsi_ValueGetDString(interp, frPtr, dStr, 0);
    Jsi_DecrRefCount(interp, frPtr);
    return rc;
}
       

Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func)
{
    Jsi_FuncObj *f = (Jsi_FuncObj*)Jsi_Calloc(1,sizeof(Jsi_FuncObj));
    f->interp = interp;
    SIGINIT(f,FUNCOBJ);
    f->func = func;
    func->refCnt++;
    return f;
}

void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func)
{
    if (--func->refCnt > 0)
        return;
    if (interp->profile || interp->coverage) {
        const char *file = func->script;
        if (!file)
            file = "";
        int line = func->bodyline.last_line;
        if (interp->coverage || interp->profile) {
            if (!func->callCnt) {
                if (interp->coverage && func->type == FC_NORMAL && func->name)
                    fprintf(stderr, "COVERAGE: func=%s  file=%s:%d  cover=0%%\n", func->name, file, line );
            } else {
                char buf[BUFSIZ];
                if (func->type == FC_BUILDIN) {
                    snprintf(buf, sizeof(buf), "cmd=%s%s%s", func->parent, func->parent[0]?".":"", func->name);
                    interp->cmdSelfTime += (func->allTime-func->subTime);
                } else {
                    
                    double coverage = 0; // Calculate hits/all.
                    if (func->opcodes && func->opcodes->code_len>0) {
                        int i, cchit=0, ccall=0, ccline=0, cchitline=0;
                        Jsi_OpCodes *oc = func->opcodes;
                        for (i=0; i<oc->code_len; i++) {
                            if (oc->codes[i].Line<=0) continue;
                            if (ccline != oc->codes[i].Line) {
                                ccline = oc->codes[i].Line;
                                ccall++;
                                interp->coverAll++;
                            }
                            if (cchitline != oc->codes[i].Line && oc->codes[i].hit) {
                                cchitline = oc->codes[i].Line;
                                cchit++;
                                interp->coverHit++;
                            }
                        }
                        if (ccall)
                            coverage = (int)(100.0*cchit/ccall);
                            
                        if (interp->coverage && cchit<ccall) { // Generate the misses list.
                            char cbuf[BUFSIZ];
                            int lastout = 0, lastpos=0, dupcnt=0, cccnt=0;
                            cbuf[0] = 0;
                            ccline=cchitline=0;
                            for (i=0; i<=oc->code_len; i++) {
                                int ismiss = 0;
                                if (i==oc->code_len) {
                                    ismiss = (ccline>0 && cchitline != ccline);
                                } else {
                                    if (oc->codes[i].Line<=0) continue;
                                    ismiss = (ccline>0 && ccline != oc->codes[i].Line && cchitline != ccline);
                                }
                                if (ismiss) {
                                    cccnt++;
                                    const char *sep = (cccnt>1?",":"");
                                    if (lastout && (lastout+1)==ccline) {
                                        sep = "-";
                                        dupcnt++;
                                        if (dupcnt>1)
                                            cbuf[lastpos]=0; // Inefficient, but reliable.
                                        else
                                            lastpos = Jsi_Strlen(cbuf);
                                    } else 
                                        dupcnt = 0;
                                    int cbl = Jsi_Strlen(cbuf);
                                    snprintf(cbuf+cbl, sizeof(cbuf)-cbl, "%s%d", sep, ccline);
                                    lastout = ccline;
                                }
                                ccline = oc->codes[i].Line;
                                if (oc->codes[i].hit)
                                    cchitline = ccline;
                            }
                            fprintf(stderr, "COVERAGE: func=%s  file=%s:%d  cover=%2.1f%%  hits=%d,  all=%d,  misses=%s\n", 
                                func->name, file, line, coverage, cchit, ccall, cbuf);
                        }
                    }
                    snprintf(buf, sizeof(buf), "cover=%#5.1f%%  func=%s file=%s:%d", coverage, func->name, file, line);
                    interp->funcSelfTime += (func->allTime-func->subTime);
                }
                if (interp->profile)
                    fprintf(stderr, "PROFILE:  self=%6.6f  all=%6.6f  #calls=%-8d  self/call=%6.6f  all/call=%6.6f  %s %s%s\n",
                        (func->allTime-func->subTime), (double)(func->allTime), func->callCnt, 
                        (double)(func->allTime-func->subTime)/func->callCnt,  (double)(func->allTime)/func->callCnt, 
                        buf, interp->parent?" ::":"", (interp->parent&&interp->name?interp->name:""));
            }
        }
    }

    if (func->opcodes)
        jsi_FreeOpcodes(func->opcodes);
    if (func->hPtr)
        Jsi_HashEntryDelete(func->hPtr);
    if (func->localnames)
        jsi_ScopeStrsFree(interp, func->localnames);
    if (func->argnames)
        jsi_ScopeStrsFree(interp, func->argnames);
    if (func->cmdSpec && (intptr_t)func->cmdSpec->reserved[3]& 0x1)
        Jsi_Free(func->cmdSpec);
    _JSI_MEMCLEAR(func);
    Jsi_Free(func);
    interp->funcCnt--;
}

Jsi_Func *jsi_FuncNew(Jsi_Interp *interp)
{
     Jsi_Func *func = (Jsi_Func*)Jsi_Calloc(1, sizeof(Jsi_Func));
     SIGINIT(func, FUNC);
     func->hPtr = Jsi_HashSet(interp->funcsTbl, func, func);
     func->refCnt = 1;
     interp->funcCnt++;
     return func;
}

void jsi_FuncObjFree(Jsi_FuncObj *fobj)
{
    if (fobj->scope)
        jsi_ScopeChainFree(fobj->interp, fobj->scope);
    if (fobj->bindArgs)
        Jsi_DecrRefCount(fobj->interp, fobj->bindArgs);
    if (fobj->bindFunc)
        Jsi_DecrRefCount(fobj->interp, fobj->bindFunc);
    if (fobj->func)
        jsi_FuncFree(fobj->interp, fobj->func);
    _JSI_MEMCLEAR(fobj);
    Jsi_Free(fobj);
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define bits_set(who, mask)     ((who) |= (mask))
#define bits_unset(who, mask)   ((who) &= (~(mask)))
#define bits_get(who, mask)     ((who) & (mask))

static void IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth);

#if  JSI__MEMDEBUG
void jsi_VALCHK(Jsi_Value *val) {
    SIGASSERT(val,VALUE);
    assert(val->vt <= JSI_VT__MAX);
    if (val->vt == JSI_VT_OBJECT)
        OBJCHK(val->d.obj);
}

void jsi_OBJCHK(Jsi_Obj *obj) {
    SIGASSERT(obj,OBJ);
    assert(obj->ot <= JSI_OT__MAX);
}
#endif

/*********************************************/

bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)
{
    SIGASSERT(v,VALUE);
    return (v->refCnt > 1);
}

int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)
{
    SIGASSERT(v,VALUE);
    assert(v->refCnt>=0);
    jsi_DebugValue(v,"Incr", jsi_DebugValueCallIdx(), interp);
    return ++(v->refCnt);
}

int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {
    SIGASSERT(v,VALUE);
    if (v->refCnt<0)
        return -2;
    int ref;
    jsi_DebugValue(v,"Decr", jsi_DebugValueCallIdx(), interp);
    if ((ref = --(v->refCnt)) <= 0) {
        v->refCnt = -1;
        Jsi_ValueFree(interp, v);
    }
    return ref;
}

static Jsi_Value *ValueNew(Jsi_Interp *interp)
{
    interp->dbPtr->valueCnt++;
    interp->dbPtr->valueAllocCnt++;
    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));
    SIGINIT(v,VALUE)
    v->vt = JSI_VT_UNDEF;
    jsi_DebugValue(v,"New", jsi_DebugValueCallIdx(), interp);
    return v;
}

static Jsi_Value *ValueNew1(Jsi_Interp *interp)
{
    Jsi_Value *v = ValueNew(interp);
    Jsi_IncrRefCount(interp, v);
    return v;
}

static Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_Value *r = ValueNew1(interp);
    Jsi_ValueCopy(interp,r, v);
#ifdef JSI_MEM_DEBUG
    r->VD.label2 = "ValueDup";
#endif
    return r;
}
#ifndef JSI_MEM_DEBUG
Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {
    return ValueNew(interp);
}
Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {
    return ValueNew1(interp);
}
Jsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {
    return ValueDup(interp, v);
}
#else
// Debugging functions: set breakpoint with "cond B v == 0xNNN"
void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp)
{
    return;
}
void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp)
{
    return;
}

static uint jsi_memDebugBreakIdx = 0;  // Debug memory by setting this, and adding BP on following func.
void jsi_memDebugBreak() {
}

void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)
{
    vd->fname = fname;
    vd->line = line;
    vd->func = func;
    if (!vd->Idx)
        vd->Idx = interp->dbPtr->memDebugCallIdx;
    vd->hPtr = Jsi_HashSet(tbl, v, 0);
    vd->ip = interp->curIp;
    if (vd->ip) {
        vd->ipLine = vd->ip->Line;
        vd->ipOp = vd->ip->op;
        vd->ipFname = vd->ip->fname;
    }
    vd->interp = interp;
    if (jsi_memDebugBreakIdx == vd->Idx)
        jsi_memDebugBreak();
}

void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)
{
    if (l1)
        vd->label = l1;
    if (l2)
        vd->label2 = l2;
}


Jsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueNew(interp);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}

Jsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueNew1(interp);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}
Jsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueDup(interp, ov);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}

#ifndef JSI_OMIT_STUBS
#undef Jsi_ValueNew
#undef Jsi_ValueNew1
Jsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }
Jsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return NULL; ValueNew1(interp); }
#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#endif

#endif

Jsi_Hash *strDebug = NULL;

static void ValueFree(Jsi_Interp *interp, Jsi_Value* v)
{
    SIGASSERT(v,VALUE);
    //printf("FREE: %d\n", interp->valueCnt);
    switch (v->vt) {
        case JSI_VT_OBJECT:
            Jsi_ObjDecrRefCount(interp, v->d.obj);
            break;
        case JSI_VT_VARIABLE:
            assert(v->d.lval != v);
            Jsi_DecrRefCount(interp, v->d.lval);
            break;
        case JSI_VT_STRING:
            if (v->d.s.str && !v->f.bits.isstrkey) {
                Jsi_Free(v->d.s.str);
                /*Jsi_HashEntry *hPtr;
                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))
                    Jsi_HashEntryDelete(hPtr);*/
            }
            break;
        default:
            break;
    }
    v->vt = JSI_VT_UNDEF;
}

void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)
{
    interp->dbPtr->valueCnt--;
    jsi_DebugValue(v, "Free", jsi_DebugValueCallIdx(), interp);
    ValueFree(interp, v);
#ifdef JSI_MEM_DEBUG
    //if (v->VD.interp != interp)  //TODO: InterpAliasCmd leaking Values.
     //   fprintf(stderr, "cross interp delete: %p\n", v);
    if (v->VD.hPtr) {
        if (!Jsi_HashEntryDelete(v->VD.hPtr))
            fprintf(stderr, "Value not in hash\n");
    }
#endif
    _JSI_MEMCLEAR(v);
    Jsi_Free(v);
}

/* Reset a value back to undefined, releasing string/obj if necessary. */
void Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = *vPtr;
    SIGASSERT(v,VALUE);
    Assert(v->vt <= JSI_VT__MAX);
    jsi_DebugValue(v, "Reset", jsi_DebugValueCallIdx(), interp);
    Assert(v->refCnt>=0);
    if (v->vt == JSI_VT_UNDEF)
        return;
    ValueFree(interp, v);
    v->f.flag = 0;
}

// Assign value ptrs (to=from). Decr old to, and Incr from ref count.
void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {
    VALCHK(from);
    if( *to == from) return;
    if (*to)
        Jsi_DecrRefCount(interp, *to);
    *to = from;
    if (from)
        Jsi_IncrRefCount(interp, from);
}


static void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {
    if (!from) {
        Jsi_ValueMakeUndef(interp, &to);
        return;
    }
    VALCHK(from);
    if( to == from) return;
    int ocnt = to->refCnt;
    Jsi_Value *ovt = NULL;
    assert(ocnt>0);
    int toVt = to->vt;
    if (toVt == JSI_VT_VARIABLE) {
        ovt = to->d.lval;
        Jsi_IncrRefCount(interp, ovt);
    }
    Jsi_ValueMakeUndef(interp, &to);
#ifdef JSI_MEM_DEBUG
    memcpy(to, from, sizeof(*to)-sizeof(to->VD));
    to->VD.label3 = from->VD.func;
#else
    *to = *from;
#endif
    if (isCopy) {
        if (to->refCnt) {
            switch (to->vt) {
                case JSI_VT_STRING:
                    if (!to->f.bits.isstrkey) {
                        to->d.s.str = Jsi_Strdup(to->d.s.str);
                        to->d.s.len = Jsi_Strlen(to->d.s.str);
                    }
                    break;
                case JSI_VT_OBJECT:
                    Jsi_ObjIncrRefCount(interp,to->d.obj);
                    break;
                case JSI_VT_VARIABLE:
                    Jsi_IncrRefCount(interp,to->d.lval);
                    break;
                default:
                    break;
            }
        }
        to->refCnt = ocnt;
        if (ovt)
            Jsi_DecrRefCount(interp, ovt);
    } else {
        to->refCnt = ocnt;
        if (ovt)
            Jsi_DecrRefCount(interp, ovt);
        ocnt = from->refCnt;
#ifdef JSI_MEM_DEBUG
        memset(from, 0, sizeof(*to)-sizeof(to->VD));
#else
        memset(from, 0, sizeof(*to));
#endif
        SIGINIT(from, VALUE);
        from->refCnt = ocnt;
    }
}

void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {
    return jsi_ValueCopyMove(interp, to, from, 0);
}

void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {
    return jsi_ValueCopyMove(interp, to, from, 1);
}

void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )
{
    if (!*to)
        *to = Jsi_ValueNew1(interp);
#ifdef JSI_MEM_DEBUG
    (*to)->VD.label3 = "ValueDup2";
#endif
    Jsi_ValueCopy(interp, *to, from);
    (*to)->f.bits.readonly = 0;
}

Jsi_Value *Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val)
{
    Jsi_DString pStr;
    Jsi_DSInit(&pStr);
    Jsi_ValueGetDString(interp, val, &pStr, JSI_OUTPUT_JSON);
    Jsi_Value *valPtr = NULL;
    if (Jsi_JSONParse(interp, Jsi_DSValue(&pStr), &valPtr, 0) != JSI_OK)
        Jsi_LogBug("bad json parse");
    Jsi_DSFree(&pStr);
    return valPtr;
}

Jsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)
{
    Jsi_Obj *obj;
    Jsi_Value *v = NULL;
    if (interp->noInherit && key) {
        if (key[0] == 'p' && Jsi_Strcmp(key, "prototype")==0) {
            Jsi_LogError("inheritance is disabled in interp");
            return NULL;
        }
    }
    if (target->vt != JSI_VT_OBJECT) {
        if (jsi_IsStrictMode(interp))
            Jsi_LogWarn("Target is not object: %d", target->vt);
        return NULL;
    }
    obj = target->d.obj;
    
#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)
    if (*key == '_' && Jsi_Strcmp(key, "__proto__")==0 && interp->noInherit==0)
        return obj->__proto__;
#endif

    if (*key == 't' && Jsi_Strcmp(key, "this")==0)
        return interp->framePtr->inthis;
    if (obj->arr)
        v = jsi_ObjArrayLookup(interp, obj, key);
    if (!v)
        v= Jsi_TreeObjGetValue(obj, key, isstrkey);
    return v;  /* TODO: redo with copy */
}

Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)
{
    char unibuf[12];
    Jsi_Obj *obj = args->d.obj;
    Jsi_Value *v;
    assert(args->vt == JSI_VT_OBJECT);
    if (obj->isarrlist && obj->arr) {
        if (index < 0 || (uint)index >= obj->arrCnt) {
            return NULL;
        }
        v = obj->arr[index];
        assert(v != args);
        return v;
    } else {
        Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));
        v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);
    } /* TODO: redo with copy */
    return v;
}

/**************************************************/

Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val)
{
    if (!pv) return JSI_ERROR;
    if (pv->vt == JSI_VT_BOOL)
        *val = pv->d.val;
    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)
        *val = pv->d.obj->d.val;
    else 
        return JSI_ERROR;
    return JSI_OK;
}

bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {
    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);
}

bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));
}

bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_NULL);
}

bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_UNDEF);
}

Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)
{
    if (!pv) return JSI_ERROR;
    if (pv->vt == JSI_VT_NUMBER)
        *val = pv->d.num;
    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)
        *val = pv->d.obj->d.num;
    else 
        return JSI_ERROR;
    return JSI_OK;
}
bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));
}

bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)
{
    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)
        return 1;
    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)
        return 1;
    return 0;
}

bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));
}

bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)
{
    int rc = (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION);
    if (!rc) return rc;
    if (interp == v->d.obj->d.fobj->interp)
        return 1;
    fprintf(stderr, "OOPS: function in wrong interp %s: %s\n", 
        interp->parent?"(string came in from parent interp?)":"",
        v->d.obj->d.fobj->func->name);
    return 0;
}

bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {
    if (!pv) return 0;
    return pv->vt == vtype;
}

Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }


bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)
{
    if (v == NULL || v->vt != JSI_VT_OBJECT)
        return 0;
    if (otype != JSI_OT_ARRAY)
        return (v->d.obj->ot == otype);
    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)
        return 0;
    return 1;
}

char* Jsi_NumberToString(Jsi_Number d, char *buf, int bsiz)
{
     if (Jsi_NumberIsInteger(d)) {
        Jsi_NumberItoA10((int)d, buf, bsiz);
    } else if (Jsi_NumberIsNormal(d)) {
        Jsi_NumberDtoA(d, buf, bsiz, 10);
    } else if (Jsi_NumberIsNaN(d)) {
        Jsi_Strcpy(buf, "NaN");
    } else {
        int s = Jsi_NumberIsInfinity(d);
        if (s > 0) Jsi_Strcpy(buf,  "Infinity");
        else if (s < 0) Jsi_Strcpy(buf, "-Infinity");
        else {
            buf[0] = 0;
        }
    }
    return buf;
}

/* Return the string value.  Coerce value to a string type. */
const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)
{
    Jsi_Number d;
    const char *ntxt = "undefined";
    int kflag = 1;
    int isKey = 0;
    char *key = NULL;
    if (!v)
        goto done;
    if (lenPtr) *lenPtr = 0;
    char unibuf[200];
    switch(v->vt) {
        case JSI_VT_STRING:
            ntxt = v->d.s.str;
            goto done;
        case JSI_VT_UNDEF:
            break;
        case JSI_VT_BOOL:
            ntxt = v->d.val ? "true":"false";
            break;
        case JSI_VT_NULL:
            ntxt = "null";
            break;
        case JSI_VT_NUMBER: {
            d = v->d.num;
fmtnum:
            if (Jsi_NumberIsInteger(d)) {
                Jsi_NumberItoA10((int)d, unibuf, sizeof(unibuf));
                kflag = 0;
                ntxt = unibuf;
            } else if (Jsi_NumberIsNormal(d)) {
                Jsi_NumberDtoA(d, unibuf, sizeof(unibuf), 10);
                kflag = 0;
                ntxt = unibuf;
            } else if (Jsi_NumberIsNaN(v->d.num)) {
                ntxt = "NaN";
            } else {
                int s = Jsi_NumberIsInfinity(d);
                if (s > 0) ntxt = "Infinity";
                else if (s < 0) ntxt = "-Infinity";
                else Jsi_LogBug("Ieee function got problem");
            }
            break;
        }
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_STRING:
                    ntxt = obj->d.s.str;
                    goto done;
                case JSI_OT_BOOL:
                    ntxt = obj->d.val ? "true":"false";
                    break;
                case JSI_OT_NUMBER:
                    d = obj->d.num;
                    goto fmtnum;
                    break;
                default:
                    ntxt = "[object Object]";
                    break;
            }
            break;
        }
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to string", v->vt);
            break;
    }
    Jsi_ValueReset(interp, &v);
    if (!kflag) {
        Jsi_ValueMakeStringDup(interp, &v, ntxt);
        return Jsi_ValueString(interp, v, lenPtr);
    }
    
    key = jsi_KeyFind(interp, ntxt, 0, &isKey);
    if (key)
        Jsi_ValueMakeStringKey(interp, &v, key);
    else
        Jsi_ValueMakeString(interp, &v, ntxt);
    ntxt = v->d.s.str;
    
done:
    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);
    return ntxt;
}

Jsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)
{
    char *endPtr = NULL;
    Jsi_Number a = 0;
    switch(v->vt) {
        case JSI_VT_BOOL:
            a = (Jsi_Number)(v->d.val ? 1.0: 0);
            break;
        case JSI_VT_NULL:
            a = 0;
            break;
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_BOOL:
                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);
                    break;
                case JSI_OT_NUMBER:
                    a = obj->d.num;
                    break;
                case JSI_OT_STRING:
                    if (!isInt)
                        a = strtod(obj->d.s.str, &endPtr);
                    else
                        a = (Jsi_Number)strtol(obj->d.s.str, &endPtr, 0);
                    if (endPtr && *endPtr) {
                        a = interp->NaNValue->d.num;
                    }
                    break;
                default:
                    a = 0;
                break;
            }
            break;
        }
        case JSI_VT_UNDEF:
            a = Jsi_NumberNaN();
            break;
        case JSI_VT_NUMBER:
            a = v->d.num;
            break;
        case JSI_VT_STRING:
            if (!isInt) {
                a = strtod(v->d.s.str, &endPtr);
                if (endPtr && *endPtr) {
                    a = interp->NaNValue->d.num;
                }
            } else {
                a = (Jsi_Number)strtol(v->d.s.str, &endPtr, 0);
                if (!isdigit(v->d.s.str[0]))
                    a = interp->NaNValue->d.num;
            }
            break;
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to number", v->vt);
            break;
    }
    return a;
}

Jsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt == JSI_VT_NUMBER) return JSI_OK;
    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);
    Jsi_ValueReset(interp, &v);
    Jsi_ValueMakeNumber(interp, &v, a);
    return JSI_OK;
}

Jsi_RC Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_RC rc = JSI_OK;
    bool a = 0;
    switch(v->vt) {
        case JSI_VT_BOOL:
            a = v->d.val;
            break;
        case JSI_VT_NULL:
            break;
        case JSI_VT_UNDEF:
            break;
        case JSI_VT_NUMBER:
            a = (v->d.num ? 1: 0);
            break;
        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */
            a = atoi(v->d.s.str);
            a = (a ? 1 : 0);
            break;
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_BOOL:
                    a = (obj->d.val ? 1.0: 0);
                    break;
                case JSI_OT_NUMBER:
                    a = obj->d.num;
                    a = (a ? 1 : 0);
                    break;
                case JSI_OT_STRING:
                    a = atoi(obj->d.s.str);
                    a = (a ? 1 : 0);
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to number", v->vt);
            return JSI_ERROR;
    }
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeBool(interp, &v, a);
    return rc;
}

int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeNumber(interp, &v, a);
    return (int)a;
}

Jsi_RC Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_RC rc = JSI_OK;
    if (v->vt == JSI_VT_OBJECT) return rc;
    Jsi_Obj *o = Jsi_ObjNew(interp);
    switch(v->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_NULL:
            if (jsi_IsStrictMode(interp)) {
                Jsi_LogError("converting a undefined/null value to object");
                rc = JSI_ERROR;
            }
            o->d.num = 0;
            o->ot = JSI_OT_NUMBER;
            o->__proto__ = interp->Number_prototype;
            break;
        case JSI_VT_BOOL: {
            o->d.val = v->d.val;
            o->ot = JSI_OT_BOOL;
            o->__proto__ = interp->Boolean_prototype;
            break;
        }
        case JSI_VT_NUMBER: {
            o->d.num = v->d.num;
            o->ot = JSI_OT_NUMBER;
            o->__proto__ = interp->Number_prototype;
            break;
        }
        case JSI_VT_STRING: {
            o->d.s = v->d.s;
            if (!v->f.bits.isstrkey)
                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);
            o->isstrkey = 1;
            o->ot = JSI_OT_STRING;
            o->__proto__ = interp->String_prototype;
            break;
        }
        default:
            Jsi_LogBug("toobject, not suppose to reach here");
    }
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeObject(interp, &v, o);
    return rc;
}

/* also toBoolean here, in ecma */
bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)
{
    switch(v->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_NULL:   return 0;
        case JSI_VT_BOOL:   return v->d.val ? 1:0;
        case JSI_VT_NUMBER: 
            if (v->d.num == 0.0 || Jsi_NumberIsNaN(v->d.num)) return 0;
            return 1;
        case JSI_VT_STRING: return Jsi_ValueStrlen(v) ? 1 : 0;
        case JSI_VT_OBJECT: {
            Jsi_Obj *o = v->d.obj;
            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {
                return jsi_UserObjIsTrue(interp, o->d.uobj);
            }
            return 1;
        }
        default: Jsi_LogBug("TOP is type incorrect: %d", v->vt);
    }
    return 0;
}

bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;
    return 0;
}

bool Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)
{
    int eq = 0;
    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)
        eq = 1;
    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))
        eq = 1;
    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))
        eq = 1;
    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {
        bool b1, b2;
        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK
            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK
            && b1 == b2);
    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {
        Jsi_Number n1, n2;
        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK
            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK
            && n1 == n2);
    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {
        const char *s1, *s2;
        int l1, l2;
        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))
            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));
    }
    return eq;
}

void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)
{
    Jsi_Value *v = *vPtr;
    if (v->vt != JSI_VT_OBJECT)
        return;
    DECL_VALINIT(res);
    Jsi_Value *rPtr = &res;
    Jsi_Obj *obj = v->d.obj;
    //rPtr = v;
    switch(obj->ot) {
        case JSI_OT_BOOL:
            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);
            break;
        case JSI_OT_NUMBER:
            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);
            break;
        case JSI_OT_STRING:
            if (obj->isstrkey) {
                res.d.s = obj->d.s;
                res.f.bits.isstrkey = 1;
                obj->d.s.str = NULL;
            } else {
                if (obj->refcnt==1) {
                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);
                    res.d.s = obj->d.s;
                    obj->d.s.str = NULL;
                } else if (obj->d.s.len >= 0) 
                {
                    Assert(obj->refcnt>=1);
                    obj->refcnt--;
                    int bytes = obj->d.s.len;
                    unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);
                    memcpy(uptr, obj->d.s.str, bytes);
                    uptr[bytes] = 0;
                    Jsi_ValueMakeBlob(interp, &rPtr, uptr, bytes);
                } else
                    Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(obj->d.s.str));
            }
            break;
        case JSI_OT_FUNCTION: {
            Jsi_DString dStr;
            Jsi_DSInit(&dStr);
            Jsi_FuncObjToString(interp, obj->d.fobj->func, &dStr, 3);
            Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(Jsi_DSValue(&dStr)));
            Jsi_DSFree(&dStr);
            break;
        }
        case JSI_OT_USEROBJ: {
            Jsi_DString dStr;
            Jsi_DSInit(&dStr);
            jsi_UserObjToName(interp, obj->d.uobj, &dStr);
            Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(Jsi_DSValue(&dStr)));
            Jsi_DSFree(&dStr);
            break;
        }
        default:
            Jsi_ValueMakeStringKey(interp,&rPtr, "[object Object]");
            break;
    }
    Jsi_ValueReset(interp, vPtr);
    res.refCnt = v->refCnt;
#ifdef JSI_MEM_DEBUG
    memcpy(v, &res, sizeof(res)-sizeof(res.VD));
#else
    *v = res;
#endif
}

static void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)
{
    if (v->vt != JSI_VT_OBJECT) {
#ifdef JSI_MEM_DEBUG
    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));
#else
    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?
#endif
        return;
    }
    Jsi_Obj *obj = v->d.obj;
    switch(obj->ot) {
        case JSI_OT_BOOL:
            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);
            break;
        case JSI_OT_NUMBER:
            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);
            break;
        case JSI_OT_STRING:
            rPtr->vt = JSI_VT_STRING;
            rPtr->d.s = obj->d.s;
            rPtr->f.bits.isstrkey = 1;
            break;
        default:
            break;
    }
}

int Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)
{
    DECL_VALINIT(res1);
    DECL_VALINIT(res2);
    int r = 1;
    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_DICT));
    if (v1 == v2)
        return 1;
    if (v1->vt != v2->vt) {
        jsi_ValueToPrimitiveRes(interp, v1, &res1);
        jsi_ValueToPrimitiveRes(interp, v2, &res2);
        v1 = &res1;
        v2 = &res2;
    }
    if (v1->vt != v2->vt) {
        if ((flags&JSI_CMP_EXACT))
            return 1;
        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && 
            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {
            r = 0;
        } else {
            Jsi_Number n1, n2;
            n1 = Jsi_ValueToNumberInt(interp, v1, 0);
            n2 = Jsi_ValueToNumberInt(interp, v2, 0);
            r = (n2 - n1);
        }
    } else {
        switch (v1->vt) {
            case JSI_VT_NUMBER:
                r = (v2->d.num - v1->d.num);
                break;
            case JSI_VT_BOOL:
                r = (v2->d.val - v1->d.val);
                break;
            case JSI_VT_STRING:
                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));
                break;
            case JSI_VT_OBJECT:
                /* TODO: refer to objects joined to each other */
                if (v1->d.obj->ot == JSI_OT_STRING)
                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));
                else
                    r = (v2->d.obj - v1->d.obj);
                break;
            case JSI_VT_UNDEF:
            case JSI_VT_NULL:
                r = 0;
                break;
            default:
                Jsi_LogBug("Unexpected value type");
        }
    }
    return r;
}

/**
 * @brief Split a string.
 * @param interp 
 * @param str - input string to split
 * @param split - to split on
 * @returns an array of string values
 * 
 * 
 */
Jsi_Value *Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton)
{
    char **argv; int argc;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);
    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);
    Jsi_Obj *obj = nret->d.obj;
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);
    }
    Jsi_ObjSetLength(interp, obj, argc);
    Jsi_ValueMakeArrayObject(interp, &nret, obj);
    Jsi_DSFree(&dStr);
    return nret;
}

void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)
{
    Jsi_TreeEntry *hPtr;
    if (target->vt != JSI_VT_OBJECT) {
        if (jsi_IsStrictMode(interp))
            Jsi_LogWarn("Target is not object: %d", target->vt);
        return;
    }
    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));
    if (!hPtr)
        return;
    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);
}

Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)
{
    int arrayindex = -1;

    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {
        arrayindex = (int)keyval->d.num;
    }
    /* TODO: array["1"] also extern the length of array */
    
    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&
        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {
        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);
    }
    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);
    
#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)
    if (Jsi_Strcmp(kstr, "__proto__")==0) {
        Jsi_Obj *obj = target->d.obj;
        obj->__proto__ = Jsi_ValueDup(interp, value);
        //obj->clearProto = 1;
        return obj->__proto__;
    }
#endif
    if (value && Jsi_ValueIsFunction(interp, value) && kstr[0] == 'L' && kstr[1] == 'o') {
        // Special case where Jsi_Opts() is setting local binds.
        const char *cp = interp->framePtr->funcName;
        if (cp && !strcmp(cp, "Jsi_Opts")) {
            jsi_Frame *fptr = interp->framePtr->parent;
            if (!strcmp(kstr, "LogDebug"))
                fptr->logflag |= (1<<jsi_Oplf_debug);
            else if (!strcmp(kstr, "LogTrace"))
                fptr->logflag |= (1<<jsi_Oplf_trace);
            else if (!strcmp(kstr, "LogTest"))
                fptr->logflag |= (1<<jsi_Oplf_test);
        }
    }

    Jsi_Value *v;
    if (value)
        Jsi_ValueCopy(interp,v = Jsi_ValueNew1(interp), value);
    else
        value = (v = Jsi_ValueNew1(interp));

    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));
    Jsi_DecrRefCount(interp, v);
    return v;
}

const char *jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret,
    int right_val)
{
    const char *keyStr = Jsi_ValueToString(interp, key, NULL);
    if (!target) {
        Jsi_ValueMakeUndef(interp, ret);
        return keyStr;
    }
    
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogError("subscript operand is not object");
        return keyStr;
    }

    Jsi_Value *r = Jsi_ValueObjLookup(interp, target, (char*)keyStr,
        ((key->vt == JSI_VT_STRING && key->f.bits.isstrkey)? 1 : 0));
    if (!r) {
        /* query from prototype, always no right_val */
        if (target->d.obj->__proto__) {
            jsi_ValueSubscript(interp, target->d.obj->__proto__, key, ret, 1);
        }
        if (right_val == 0) {       /* need a lvalue */
            Jsi_Value *n = Jsi_ValueNew1(interp);
            Jsi_ValueCopy(interp,n, *ret);   /* copy from prototype */
            
            jsi_ValueObjKeyAssign(interp, target, key, n, 0);
            jsi_ValueDebugLabel(n, "subscript", keyStr);
            //Jsi_DecrRefCount(interp, n);
            Jsi_ValueReset(interp, ret);
           (*ret)->vt = JSI_VT_VARIABLE;
            (*ret)->d.lval = n;
            SIGASSERT(n, VALUE);
        }
    } else {
        if (right_val || r->f.bits.readonly) {
            Jsi_ValueCopy(interp, *ret, r);
        } else {
            (*ret)->vt = JSI_VT_VARIABLE;
            (*ret)->d.lval = r;
            SIGASSERT(r, VALUE);
        }
    }
    return keyStr;
}

/* Like above, but handle "length", "constructor", "String", etc specially. */
void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key,
                           Jsi_Value **ret, int right_val)
{
    int len;
    Jsi_ValueReset(interp, ret);
    const char *keyStr = jsi_ValueSubscript(interp, target, key, ret, right_val);
    if ((*ret)->vt != JSI_VT_UNDEF || key->vt != JSI_VT_STRING)
        return;

    if (Jsi_Strcmp(keyStr,"length")==0) {
        if (Jsi_ValueIsString(interp, target)) {
            len = Jsi_ValueStrlen(target);
        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist /*&& target->d.obj->arr*/) {
            /* && target->d.obj->ot == JSI_OT_ARRAY   ??? */
            len = target->d.obj->arrCnt;
        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {
            if (target->d.obj->d.fobj->func->type == FC_NORMAL)
                len = target->d.obj->d.fobj->func->argnames->count;
            else
                len = target->d.obj->d.fobj->func->cmdSpec->maxArgs;
        } else {
            return;
        }
        (*ret)->vt = JSI_VT_NUMBER;
        (*ret)->d.num = (Jsi_Number)len;
        return;
    }

    if (target->vt == JSI_VT_OBJECT && (interp->noInherit==0 && Jsi_Strcmp(keyStr,"constructor")==0)) {
        const char *cp;
        Jsi_Obj *o = target->d.obj->constructor;
        if (o) {
            if (o->ot == JSI_OT_FUNCTION) {
                Jsi_Value *proto = Jsi_TreeObjGetValue(o, "prototype", 0);
                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {
                    o = proto->d.obj->constructor;
                }
            }
        } else {
            switch(target->d.obj->ot) {
                case JSI_OT_NUMBER:
                    cp = "Number";
                    break;
                case JSI_OT_BOOL:
                    cp = "Boolean";
                    break;
                case JSI_OT_STRING:
                    cp = "String";
                    break;
                default:
                    Jsi_ValueMakeUndef(interp, ret);
                    return;
            }
            Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);
            if (v==NULL || v->vt != JSI_VT_OBJECT)
                return;
            o = target->d.obj->constructor = v->d.obj;
        }
        Jsi_ValueMakeObject(interp, ret, o);
        return;
    }

    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {
        /* Looking up something like "String.substr('abc',1)" */
        Jsi_Func* func = target->d.obj->d.fobj->func;
        if (func->type == FC_BUILDIN) {
            if (func->f.bits.iscons && func->name) {
                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);
                if (v && ((v = Jsi_ValueObjLookup(interp, v, "prototype", 0)))
                        && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {
                    if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,"Interp")) {
                        Jsi_Func* sfunc = v->d.obj->d.fobj->func;
                        sfunc->callflags.bits.addargs = 1;
                    }
                    Jsi_ValueCopy(interp, *ret, v);
                    return;
                }
            }
            if (Jsi_ValueIsString(interp, key)) {
                char *kstr = Jsi_ValueString(interp, key, NULL);
                if (0==Jsi_Strcmp(kstr,"call") || 0==Jsi_Strcmp(kstr,"apply") || 0==Jsi_Strcmp(kstr,"bind")) {
                    char fbuf[100];
                    snprintf(fbuf, sizeof(fbuf), "Function.%s", kstr);
                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);
                    if (vv) {
                        Jsi_ValueCopy(interp, *ret, vv);
                        Jsi_ValueInsert(interp, target, kstr, vv, 0);
                        Jsi_DecrRefCount(interp, vv);
                        return;
                    }
                }
            }
        }
        return;
    }

}

bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)
{
    SIGASSERT(interp,INTERP);
    //SIGASSERT(target,VALUE);
    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))
        return 1;
    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)
        return 0;
    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);
}

void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof)
{
    Jsi_IterObj *io = jsi_IterObjNew(interp, NULL);
    Jsi_Obj *to = target->d.obj;
    
    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {

        if (target->vt == JSI_VT_OBJECT && to->arr) {
            io->isArrayList = 1;
            io->count = to->arrCnt;
        } else {
            if (isof &&jsi_IsStrictMode(interp))
                Jsi_LogWarn("non-array in 'for...of'");
            IterGetKeys(interp, target, io, 0);
        }
    }
    io->obj = to;
    io->isof = isof;
    Jsi_Obj *r = Jsi_ObjNew(interp);
    r->ot = JSI_OT_ITER;
    r->d.iobj = io;
    Jsi_ValueMakeObject(interp, &ret, r);
}

Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)
{
    uint i, n = 0;
    Jsi_IterObj *io;
    if (target->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    Jsi_Obj *to = target->d.obj;
    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ValueMakeArrayObject(interp, &ret, r);
    if (to->arr) {
        for (i=0; i<to->arrCnt; i++)
            if (to->arr[i]) n++;
        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {
            Jsi_LogError("too long");
            Jsi_ValueMakeUndef(interp, &ret);
            return JSI_ERROR;
        }
        for (i=0, n=0; i<to->arrCnt; i++) {
            if (to->arr[i]) {
                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);
                Jsi_IncrRefCount(interp, r->arr[n]);
                n++;
            }
        }
        r->arrCnt = n;
        return JSI_OK;
    }
    io = jsi_IterObjNew(interp, NULL);
    IterGetKeys(interp, target, io, 0);
    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {
        Jsi_LogError("too long");
        Jsi_ValueMakeUndef(interp, &ret);
        return JSI_ERROR;
    }
    for (i=0; i<io->count; i++) {
        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);
        Jsi_IncrRefCount(interp, r->arr[i]);
    }
    io->count = 0;
    r->arrCnt = i;
    jsi_IterObjFree(io);
    return JSI_OK;
}

jsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)
{
    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));
    r->interp = interp;
    SIGINIT(r,SCOPE);
    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));
    r->chains_cnt = cnt;
    return r;
}

Jsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)
{
    int i;
    Jsi_Value *ret;
    for (i = sc->chains_cnt - 1; i >= 0; --i) {
        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {
            return ret;
        }
    }
    return NULL;
}

jsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)
{
    if (!sc) {
        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);
        nr->chains[0] = next;
        Jsi_IncrRefCount(interp, next);
        nr->chains_cnt = 1;
        return nr;
    }
    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);
    int i;
    for (i = 0; i < sc->chains_cnt; ++i) {
        r->chains[i] = sc->chains[i];
        Jsi_IncrRefCount(interp, sc->chains[i]);
    }
    r->chains[i] =  next;
    Jsi_IncrRefCount(interp, next);
    r->chains_cnt = i + 1;
    return r;
}

void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)
{
    int i;
    for (i = 0; i < sc->chains_cnt; ++i) {
        Jsi_DecrRefCount(interp, sc->chains[i]);
    }
    Jsi_Free(sc->chains);
    _JSI_MEMCLEAR(sc);
    Jsi_Free(sc);
}


int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v)
{
    if (!v) return JSI_ERROR;
    if (v->vt != JSI_VT_OBJECT)
        return 0;
    
    return Jsi_ObjGetLength(interp, v->d.obj);
}

char *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);
    if (!arg)
        return NULL;
    char *res = Jsi_ValueString(interp, arg, lenPtr);
    if (res)
        return res;
    res = (char*)Jsi_ValueToString(interp, arg, NULL);
    if (res && lenPtr)
        *lenPtr = Jsi_Strlen(res);
    return res;
}

void Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)
{
    if (target == NULL)
        target = interp->csc;
    if (target->vt != JSI_VT_OBJECT) {
        if (jsi_IsStrictMode(interp))
            Jsi_LogWarn("Target is not object");
        return ;
    }
    target->f.flag |= flags;
    Jsi_ObjInsert(interp, target->d.obj, key, val, flags);
}

void jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)
{
    if (target->vt != JSI_VT_OBJECT) {
        if (jsi_IsStrictMode(interp))
            Jsi_LogWarn("Target is not object");
        return;
    }
    Jsi_Obj *obj = target->d.obj;
    
    if (obj->isarrlist) {
        if (key >= 0 && key < interp->maxArrayList) {
            Jsi_ObjArraySet(interp, obj, val, key);
            return;
        }
    }
    char unibuf[100];
    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));
    Jsi_ObjInsert(interp, obj, unibuf, val, flags);
}

/* OBJ INTERFACE TO BTREE */

static void IterObjInsertKey(Jsi_IterObj *io, const char *key)
{
    assert(!io->isArrayList);
    if (io->depth) {
        uint i;
        for (i=0; i<io->count; i++) {
            if (!Jsi_Strcmp(key, io->keys[i]))
                return;
        }
    }

    if (io->count >= io->size) {
        io->size += 10;
        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));
    }
    io->keys[io->count] = key;
    io->count++;
}
static void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)
{
    IterObjInsertKey(io, (const char*)Jsi_TreeKeyGet(hPtr));
}

Jsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)
{
    Jsi_TreeEntry *hPtr;
    SIGASSERT(val, VALUE);
    /*if (val)
        Jsi_IncrRefCount(interp, val);*/
    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));
    if ((flags&JSI_OM_DONTDEL))
        val->f.bits.dontdel = hPtr->f.bits.dontdel = 1;
    if ((flags&JSI_OM_READONLY))
        val->f.bits.readonly =hPtr->f.bits.readonly = 1;
    if ((flags&JSI_OM_DONTENUM))
        val->f.bits.dontenum =hPtr->f.bits.dontenum = 1;
    return hPtr;
}

static Jsi_RC IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_IterObj *io = (Jsi_IterObj *)data;
    if (!hPtr->f.bits.dontenum) {
        IterObjInsert(io, hPtr);
    }
    return JSI_OK;
}

static void IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)
{
    if (!target) return;
    if (target->vt != JSI_VT_OBJECT) {
        if (jsi_IsStrictMode(interp))
            Jsi_LogWarn("operand is not a object");
        return;
    }
    Jsi_Obj *to = target->d.obj;
    Jsi_CmdSpec *cs = NULL;
    if (to->ot == JSI_OT_USEROBJ) {
        Jsi_UserObj *uobj = to->d.uobj;
        cs = uobj->reg->spec;
    } else if (to->ot == JSI_OT_FUNCTION) {
        Jsi_FuncObj *fobj = to->d.fobj;
        if (fobj->func->type == FC_BUILDIN)
            cs = fobj->func->cmdSpec;
    }
    if (cs) {
        while (cs->name) {
            IterObjInsertKey(iterobj, cs->name);
            cs++;
        }
        return;
    }
    iterobj->depth = depth;
    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);
    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)
        IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);
    iterobj->depth = depth;
}

Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    Jsi_Obj *obj;
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
        assert(v->vt <= JSI_VT__MAX);
        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING
            && v->d.obj->refcnt == 1
        ) {
            Jsi_ObjFromDS(dsPtr, v->d.obj);
            return v;
        }
        Jsi_ValueReset(interp, &v);
    }
    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ObjFromDS(dsPtr, obj);
    Jsi_ValueMakeObject(interp, &v, obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)
        return v;
    if (v)
        Jsi_ValueReset(interp, vPtr);
    else
        v = Jsi_ValueNew(interp);
    //Jsi_IncrRefCount(interp, v);
    if (!o)
        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    v->vt = JSI_VT_OBJECT;
    v->d.obj = o;
    Jsi_ObjIncrRefCount(interp,v->d.obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!o)
        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {
            if (!o->isarrlist) {
                if (o->tree)
                    Jsi_TreeDelete( o->tree);
                o->tree = NULL;
                o->__proto__ = interp->Array_prototype;
                o->isarrlist = 1;
            }
            return v;
        }
        Jsi_ValueReset(interp, vPtr);
    }
    v->vt = JSI_VT_OBJECT;
    v->d.obj = o;
    o->ot = JSI_OT_OBJECT;
    o->__proto__ = interp->Array_prototype;
    o->isarrlist = 1;
    Jsi_ObjArraySizer(interp, o, 0);
    Jsi_ObjIncrRefCount(interp,v->d.obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_NUMBER;
    v->d.num = n;
    return v;
}

Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_BOOL;
    v->d.val = b;
    return v;
}

Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ValueMakeObject(interp, &v, obj);
    obj->d.s.str = (char*)s;
    obj->d.s.len = len;
    return v;
}


Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {
    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));
}

Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);
    v->d.s.len = Jsi_Strlen(s);
    v->f.bits.isstrkey = 1;
    return v;
}

Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_NULL;
    return v;
}

Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
        if (v->vt == JSI_VT_UNDEF) return v;
        Jsi_ValueReset(interp, vPtr);
    }
    return v;
}

Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_NUMBER;
    v->d.num = n;
    return v;
}

Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    Jsi_ValueMakeObject(interp, &v, o);
    return v;
}

Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {
    assert(s);
    Jsi_Value *v = Jsi_ValueNew(interp);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ValueMakeObject(interp, &v, obj);
    obj->d.s.str = (char*)s;
    obj->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);
    return v;
}

Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {
    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);
}

Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);
    v->d.s.len = Jsi_Strlen(s);
    v->f.bits.isstrkey = 1;
    return v;
}

Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, uint len) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_Malloc(len+1);
    memcpy(v->d.s.str, (char*)s, len);
    v->d.s.str[len] = 0;
    v->d.s.len = len;
    return v;
}

Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_BOOL;
    v->d.val = bval;
    return v;
}

Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_NULL;
    return v;
}

Jsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    int i = 0;
    if (count<0) {
        count = 0;
        while (items[count])
            count++;
    }
    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {
        Jsi_ObjFree(interp, obj);
        return NULL;
    }
    for (i = 0; i < count; ++i) {
        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);
        Jsi_IncrRefCount(interp, obj->arr[i]);
    }
    obj->arrCnt = count;
    assert(obj->arrCnt<=obj->arrMaxSize);
    return Jsi_ValueMakeArrayObject(interp, NULL, obj);
}

Jsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)
{
    if (v->vt == JSI_VT_OBJECT) {
        return v->d.obj;
    }
    return NULL;
}

int Jsi_ValueStrlen(Jsi_Value* v) {
    Jsi_String *s = jsi_ValueString(v);
    if (s == 0 || s->str == 0)
        return 0;
#if JSI__UTF8
    return (int)Jsi_NumUtfChars(s->str, -1);
#else
    if (s->len>=0) return s->len;
    return (int)Jsi_NumUtfChars(s->str, -1);
#endif
}

char *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)
{
    if (!v) return NULL;
    Jsi_String *s = jsi_ValueString(v);
    if (s) {
        if (lenPtr)
            *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);
        return s->str;
    }
    if (lenPtr)
        *lenPtr = 0;
    return NULL;
}

unsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)
{
    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);
}

char* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)
{
    if (!pv)
        return NULL;
    Jsi_String *s = jsi_ValueString(pv);
    if (!s)
        return NULL;
    if (lenPtr)
        *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);
    return s->str;
}

int Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)
{
    Jsi_Value *proto, *sproto;
    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)
        return 0;
    proto = Jsi_ValueObjLookup(interp, v2, "prototype", 0);
    if (!proto)
        return 0;
    sproto = v1->d.obj->__proto__ ;
    while (sproto) {
        if (sproto == proto)
            return 1;
        if (sproto->vt != JSI_VT_OBJECT)
            return 0;
        sproto = sproto->d.obj->__proto__;
    }
    return 0;
}


Jsi_RC jsi_InitValue(Jsi_Interp *interp, int release)
{
    return JSI_OK;
}

void  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)
{
    char *cp = NULL;
    int len = Jsi_DSLength(dsPtr);
    if (len && !(cp=(char*)dsPtr->strA))
        cp = Jsi_Strdup(dsPtr->Str);
    dsPtr->strA = NULL;
    dsPtr->Str[0] = 0;
    dsPtr->len = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
    Jsi_ValueMakeString(interp, ret, cp?cp:Jsi_Strdup(""));
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
/* TODO: handle delete */

#define ChkRegexp(_this, funcPtr, dest) \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->RegExp_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndex(interp, args, 0); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_REGEXP) { \
        return Jsi_LogError("apply Regexp.%s to a non-regex object", funcPtr->cmdSpec->name); \
    } else  { \
        dest = _this; \
    }

void Jsi_RegExpFree(Jsi_Regex* re) {
    regfree(&re->reg);
    _JSI_MEMCLEAR(re);
    Jsi_Free(re);
}

Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int eflag)
{
    bool isNew;
    Jsi_HashEntry *hPtr;
    int flag = REG_EXTENDED;
    char c, *cm, *ce;
    const char *cp;
    Jsi_Regex *re;
    eflag |= JSI_REG_STATIC;
    if (!regtxt[0])
        return NULL;
    hPtr = Jsi_HashEntryFind(interp->regexpTbl, regtxt);
    if (hPtr) {
        re = (Jsi_Regex*)Jsi_HashValueGet(hPtr);
        if (JSI_REG_STATIC & eflag)
            re->eflags |= JSI_REG_STATIC;
        return re;
    }
    cp = regtxt+1;
    if (regtxt[0] != '/')
        return NULL;
    ce = (char*)Jsi_Strrchr(cp, '/');
    if (ce == cp || !ce)
        return NULL;
    cm = ce + 1;    
    while (*cm) {
        c = *cm++;
        if (c == 'i') flag |= REG_ICASE;
        else if (c == 'g') eflag |= JSI_REG_GLOB;
        else if (c == 'm') { /* PERL NON-STANDARD */
            eflag |= JSI_REG_NEWLINE;
            flag |= REG_NEWLINE;
        }
#ifdef RE_DOT_NEWLINE
        else if (c == 's') { /* PERL NON-STANDARD */
            eflag |= JSI_REG_DOT_NEWLINE;
            flag |= RE_DOT_NEWLINE;
        }
#endif
    }
    *ce = 0;
    regex_t reg;
    if (regcomp(&reg, cp, flag)) {
        *ce++ = '/';
        Jsi_LogError("Invalid regex string '%s'", cp);
        return NULL;
    }
    *ce++ = '/';
    re = (Jsi_Regex*)Jsi_Calloc(1, sizeof(Jsi_Regex));
    SIGINIT(re, REGEXP);
    assert (re);
    re->reg = reg;
    re->eflags = eflag;
    re->flags = flag;
    hPtr = Jsi_HashEntryNew(interp->regexpTbl, regtxt, &isNew);
    assert(hPtr);
    Jsi_HashValueSet(hPtr, re);
    re->pattern = (char*)Jsi_HashKeyGet(hPtr);
    return re;

}

Jsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret)
{
    
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, "/", regtxt, "/", NULL);
    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);
    Jsi_DSFree(&dStr);
    if (re == NULL)
        return JSI_ERROR;
    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
    Jsi_ValueMakeObject(interp, &ret, o);
    ret->d.obj->d.robj = re;
    ret->d.obj->ot = JSI_OT_REGEXP;
    return JSI_OK;
}


static Jsi_RC RegExp_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *target;
    
    if (Jsi_FunctionIsConstructor(funcPtr))
        target = _this;
    else {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
        Jsi_ValueMakeObject(interp, ret, o);
        target = *ret;
    }
    
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *regtxt = "";
    const char *mods = NULL;
    if (v) {
        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_REGEXP) {
            Jsi_ValueCopy(interp,target, v);
            return JSI_OK;
        } else if (!(regtxt = Jsi_ValueString(interp, v, NULL))) {
            return JSI_ERROR;
        }
    }
    Jsi_Value *f = Jsi_ValueArrayIndex(interp, args, 1);
    if (f)
        mods = Jsi_ValueString(interp, f, NULL);
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, "/", regtxt, "/", mods, NULL);
    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);
    Jsi_DSFree(&dStr);
    if (re == NULL)
        return JSI_ERROR;
    target->d.obj->d.robj = re;
    target->d.obj->ot = JSI_OT_REGEXP;
    return JSI_OK;
}

// Preform regexc setting *rc to 1 if match occurs.  If dStr != NULL, it is used to return matching strings.
Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)
{
    Jsi_Regex *re;
    int regexec_flags = 0;
    if (rc)
        *rc = 0;
    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) 
        return Jsi_LogError("expected pattern");
    re = pattern->d.obj->d.robj;
    regex_t *reg = &re->reg;
    
    regmatch_t pos = {};
    if (dStr)
        Jsi_DSInit(dStr);
        
    int r  = regexec(reg, v, 1, &pos, regexec_flags);

    if (r >= REG_BADPAT) {
        char buf[100];

        regerror(r, reg, buf, sizeof(buf));
        return Jsi_LogError("error while matching pattern: %s", buf);
    }
    if (r != REG_NOMATCH) {
        if (rc) *rc = 1;
        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)
            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);
    }
    
    return JSI_OK;
}



static Jsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, Jsi_Value *ret, int *ofs)
{
    Jsi_Regex *re;
    int regexec_flags = 0;
    Jsi_Value *seq = pattern;

    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNull(interp, &ret);
        return JSI_OK;
    }
    re = seq->d.obj->d.robj;
    regex_t *reg = &re->reg;
    
    regmatch_t pos[MAX_SUBREGEX] = {};
    int num_matches = 0, r, n = Jsi_Strlen(str);
    Jsi_Obj *obj;
    
    do {
        r = regexec(reg, str, MAX_SUBREGEX, pos, regexec_flags);

        if (r >= REG_BADPAT) {
            char buf[BUFSIZ];

            regerror(r, reg, buf, sizeof(buf));
            return Jsi_LogError("error while matching pattern: %s", buf);
        }
        if (r == REG_NOMATCH) {
            if (num_matches == 0) {
                Jsi_ValueMakeNull(interp, &ret);
                return JSI_OK;
            }
            break;
        }

        if (num_matches == 0) {
            obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
            obj->__proto__ = interp->Array_prototype;
            Jsi_ValueMakeObject(interp, &ret, obj);
            Jsi_ObjSetLength(interp, ret->d.obj, 0);
        }
    
        int i;
        for (i = 0; i < MAX_SUBREGEX; ++i) {
            if (pos[i].rm_so <= 0 && pos[i].rm_eo <= 0)
                break;
            if (i && pos[i].rm_so == pos[i-1].rm_so && pos[i].rm_eo == pos[i-1].rm_eo)
                continue;
    
            Jsi_Value *val = Jsi_ValueMakeString(interp, NULL, 
                jsi_SubstrDup(str, pos[i].rm_so, pos[i].rm_eo - pos[i].rm_so));
            if (ofs)
                *ofs = pos[i].rm_eo;
            jsi_ValueInsertArray(interp, ret, num_matches, val, 0);
            num_matches++;
        }
        if (num_matches == 1 && (ofs || (!(re->eflags&JSI_REG_GLOB))))
            break;
        
        str += pos[0].rm_eo;
        n -= pos[0].rm_eo;

        regexec_flags |= REG_NOTBOL;
    } while (n && pos[0].rm_eo>0);
    
    return JSI_OK;
}

Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, Jsi_Value *ret)
{
    return jsi_RegExpMatches(interp, pattern, str, ret, NULL);
}


#define FN_regexec JSI_INFO("\
Perform regexp match checking.  Returns the array of matches.\
With the global flag g, sets lastIndex and returns next match.")
static Jsi_RC RegexpExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    Jsi_Value *v;
    ChkRegexp(_this, funcPtr, v);
    /* TODO: add lastIndex support. */
    int slen;
    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), &slen);
    if (!str) 
        return Jsi_LogError("expected string");
    if (v == NULL || v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_REGEXP) 
        return Jsi_LogError("expected pattern");
    Jsi_Regex *re = v->d.obj->d.robj;
    int isglob = (re->eflags&JSI_REG_GLOB);
    Jsi_Value *l = NULL;
    Jsi_Number lv = 0;
    if (isglob) {
        l = Jsi_ValueObjLookup(interp, v, "lastIndex", 0);
        if (l && Jsi_ValueGetNumber(interp, l, &lv) != JSI_OK) 
            return Jsi_LogError("lastIndex not a number");
        if (l)
            re->lastIndex = (int)lv;
    }
    int ofs = 0;
    Jsi_RC rc = jsi_RegExpMatches(interp, v, re->lastIndex<slen?str+re->lastIndex:"", *ret, isglob?&ofs:NULL);
    if (isglob) {
        if (rc != JSI_OK)
            return rc;
        re->lastIndex += ofs;
        if (Jsi_ValueIsNull(interp, *ret))
            re->lastIndex = 0;
        lv = (Jsi_Number)re->lastIndex;
        if (!l)
            Jsi_ValueInsert(interp, v, "lastIndex", Jsi_ValueNewNumber(interp, lv), JSI_OM_DONTDEL);
        else if (l->vt == JSI_VT_NUMBER)
            l->d.num = lv;
        else if (l->vt == JSI_VT_OBJECT && l->d.obj->ot == JSI_OT_NUMBER)
            l->d.obj->d.num = lv;
    }
    return rc;
}

static Jsi_RC RegexpTestCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0, rc = 0;
    Jsi_Value *v;
    ChkRegexp(_this, funcPtr, v);
    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), NULL);
    if (!str) 
        return Jsi_LogError("expected string");
    if (Jsi_RegExpMatch(interp, v, str, &rc, NULL) != JSI_OK)
        return JSI_ERROR;    
    Jsi_ValueMakeBool(interp, ret, rc != 0);
    return JSI_OK;
}

static Jsi_CmdSpec regexpCmds[] = {
    { "RegExp",  RegExp_constructor,    1, 1, "val:regexp|string", .help="Create a regexp object", .retType=(uint)JSI_TT_REGEXP, .flags=JSI_CMD_IS_CONSTRUCTOR  },
    { "exec",    RegexpExecCmd,         1, 1, "val:string", .help="return matching string", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NULL, 0, .info=FN_regexec  },
    { "test",    RegexpTestCmd,         1, 1, "val:string", .help="test if a string matches", .retType=(uint)JSI_TT_BOOLEAN },
    { NULL, 0,0,0,0,.help="Commands for managing reqular expression objects" }
};

Jsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release)
{
    if (!release)
        interp->RegExp_prototype = Jsi_CommandCreateSpecs(interp, "RegExp", regexpCmds, NULL, JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

// SCOPESTRS

Jsi_ScopeStrs *jsi_ScopeStrsNew()
{
    Jsi_ScopeStrs *ret = (Jsi_ScopeStrs *)Jsi_Calloc(1, sizeof(*ret));
    return ret;
}

void jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss)
{
    if (!ss) return;
    int i;
    for (i=0; i<ss->count; i++)
        if (ss->args[i].defValue)
            Jsi_DecrRefCount(interp, ss->args[i].defValue);
    if (ss->args)
        Jsi_Free(ss->args);
    Jsi_Free(ss);
}

void jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType)
{
    if (ss->count >= ss->_size) {
        int osz = ss->_size, isold = (ss->args!=NULL);
        ss->_size += ALLOC_MOD_SIZE;
        if (!isold)
            ss->args = (jsi_ArgValue*)Jsi_Calloc(ss->_size,  sizeof(ss->args[0]));
        else {
            ss->args = (jsi_ArgValue*)Jsi_Realloc(ss->args, (ss->_size) * sizeof(ss->args[0]));
            memset(ss->args+osz, 0, (ss->_size-osz)* sizeof(ss->args[0]));
        }
    }
    ss->args[ss->count].name = (char*)Jsi_KeyAdd(interp, string);
    ss->args[ss->count].type = argType;
    if (argType)
        ss->typeCnt++;
    ss->count++;
}

static Jsi_ScopeStrs *jsi_ScopeStrsDup(jsi_Pstate *ps, Jsi_ScopeStrs *ss)
{
    Jsi_ScopeStrs *n = jsi_ScopeStrsNew();
    int i;
    if (!ss) return n;
    *n = *ss;
    if (!ss->args) return n;
    n->args = (jsi_ArgValue*)Jsi_Calloc(n->count, sizeof(ss->args[0]));
    n->_size = n->count;
    memcpy(n->args, ss->args, (n->count *  sizeof(ss->args[0])));
    for (i = 0; i < ss->count; ++i) {
        if (ss->args[i].defValue)
            Jsi_IncrRefCount(ps->interp, ss->args[i].defValue);
    }
    return n;
}

const char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i)
{
    if (i < 0 || i >= ss->count)
        return NULL;
    return ss->args[i].name;
}

Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a)
{
    jsi_PstatePush(pstate);
    return a;
}

Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr)
{
    Jsi_Interp *interp = pstate->interp;
    if (!a)
        a = jsi_ScopeStrsNew();
    pstate->args = a;
    int atyp = pstate->argType;
    if (defValue) {
        int vt = defValue->vt;
        if (vt == JSI_VT_NULL)
            vt = JSI_TT_NULL;
        else if (vt == JSI_VT_UNDEF && defValue->d.num==1)
            vt = JSI_TT_VOID;
        else
            vt = (1<<defValue->vt);
        atyp |= vt;
    }
    jsi_ScopeStrsPush(interp, a, name, atyp);
    pstate->argType = 0;
    a->args[a->count-1].defValue = defValue;
    a->argCnt++;
    jsi_Pline *opl = interp->parseLine;
    interp->parseLine = lPtr;
    if (defValue) {
        Jsi_IncrRefCount(interp, defValue);
        if (a->firstDef==0)
            a->firstDef = a->argCnt;
            if (atyp)
                jsi_ArgTypeCheck(interp, atyp, defValue, "default value", name, a->argCnt, NULL, 0);
    } else {
        if (a->firstDef && (interp->typeCheck.run || interp->typeCheck.all) )
            Jsi_LogWarn("expected default value in argument list: \"%s\"", name);
    }
    interp->parseLine = opl;
    return a;
}


// PSTATE 

void jsi_PstatePush(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    if (interp->cur_scope >= JSI_MAX_SCOPE - 1) {
        Jsi_LogBug("Scope chain too short");
        return;
    }
    interp->cur_scope++;
}

void jsi_PstatePop(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    if (interp->cur_scope <= 0) {
        Jsi_LogBug("No more scope to pop");
        return;
    }
    jsi_ScopeStrsFree(interp, interp->scopes[interp->cur_scope]);
    interp->scopes[interp->cur_scope] = NULL;
    interp->cur_scope--;
}

void jsi_PstateAddVar(jsi_Pstate *ps, const char *str)
{
    Jsi_Interp *interp = ps->interp;
    int i;
    if (interp->scopes[interp->cur_scope] == NULL)
        interp->scopes[interp->cur_scope] = (Jsi_ScopeStrs *)jsi_ScopeStrsNew();
    
    for (i = 0; i < interp->scopes[interp->cur_scope]->count; ++i) {
        if (Jsi_Strcmp(str, interp->scopes[interp->cur_scope]->args[i].name) == 0) return;
    }
    jsi_ScopeStrsPush(ps->interp, interp->scopes[interp->cur_scope], str, JSI_VT_UNDEF);
}

Jsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    return jsi_ScopeStrsDup(ps, interp->scopes[interp->cur_scope]);
}

#if 0
static int fastVarFree(Jsi_Interp *interp, void *ptr) {
    FastVar *fv = ptr;
    Jsi_Value *v = fv->var.lval;
    if (v) {
        //printf("FV FREE: %p (%d/%d)\n", fv, v->refCnt, v->vt == JSI_VT_OBJECT?v->d.obj->refcnt:-99);
        //Jsi_DecrRefCount(interp, v);
    }
    return JSI_OK;
}
#endif

jsi_Pstate *jsi_PstateNew(Jsi_Interp *interp)
{
    jsi_Pstate *ps = (jsi_Pstate *)Jsi_Calloc(1,sizeof(*ps));
    SIGINIT(ps,PARSER);
    ps->lexer = (jsi_Lexer*)Jsi_Calloc(1,sizeof(*ps->lexer));
    ps->lexer->pstate = ps;
    ps->interp = interp;
   // ps->argsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_ArglistFree);
    ps->fastVarTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL /*fastVarFree*/);
    ps->strTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    return ps;
}

const char *jsi_PstateGetFilename(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    return interp->curFile;
}

void jsi_PstateClear(jsi_Pstate *ps)
{
    jsi_Lexer* l = ps->lexer;
    if (l->ltype == LT_FILE)
    {
        if (l->d.fp)
            Jsi_Close(l->d.fp);
        l->d.fp = NULL;
    }
    if (l->ltype == LT_STRING)
    {
        l->d.str = NULL;
    }
    l->ltype = LT_NONE;
    l->last_token = 0;
    l->cur_line = 1;
    l->cur_char = 0;
    l->cur = 0;
    ps->err_count = 0;
}

int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)
{
    jsi_Lexer *l = ps->lexer;
    jsi_PstateClear(ps);
    l->ltype = LT_FILE;
    l->d.fp = fp;
    Jsi_Rewind(fp);
    if (skipbang) {
        char buf[1000];
        if (Jsi_Gets(fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {
            Jsi_Rewind(fp);
        }
    }
            
    return JSI_OK;
}


int jsi_PstateSetString(jsi_Pstate *ps, const char *str)
{
    Jsi_Interp *interp = ps->interp;
    jsi_Lexer *l = ps->lexer;
    jsi_PstateClear(ps);
    l->ltype = LT_STRING;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)str, NULL);
    assert(hPtr);
    l->d.str = (char*)Jsi_HashKeyGet(hPtr);
    return JSI_OK;
}

void jsi_PstateFree(jsi_Pstate *ps)
{
    /* TODO: when do we free opcodes */
    jsi_PstateClear(ps);
    Jsi_Free(ps->lexer);
    if (ps->opcodes)
        jsi_FreeOpcodes(ps->opcodes);
    if (ps->hPtr)
        Jsi_HashEntryDelete(ps->hPtr);
    Jsi_HashDelete(ps->argsTbl);
    Jsi_HashDelete(ps->strTbl);
    Jsi_HashDelete(ps->fastVarTbl);
    if (ps->last_exception)
        Jsi_DecrRefCount(ps->interp, ps->last_exception);
    _JSI_MEMCLEAR(ps);
    Jsi_Free(ps);
}

#endif
#ifndef JSI_LITE_ONLY
#define __JSIINT_C__
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

#ifdef __WIN32
#include <windows.h>
#include <shlwapi.h>
#ifndef JSI_OMIT_THREADS
#include <process.h>
#endif
#else
#ifndef JSI_OMIT_THREADS
#include <pthread.h>
#endif
#endif

static int jsi_is_init = 0;
Jsi_Interp *jsiMainInterp = NULL;
Jsi_Interp *jsiDelInterp = NULL;
static Jsi_Hash *interpsTbl;

static Jsi_OptionSpec InterpDebugOptions[] = {
    JSI_OPT(STRKEY,Jsi_DebugInterp, callback,   .help="Command in parent interp for handling debugging. Call func(file:string, line:number, level:number, func:string, opstr:string, bpId:number, emsg:string)" ),
    JSI_OPT(BOOL,  Jsi_DebugInterp, doContinue, .help="Continue execution until breakpoint" ),
    JSI_OPT(BOOL,  Jsi_DebugInterp, forceBreak, .help="Force debugger to break" ),
    JSI_OPT(BOOL,  Jsi_DebugInterp, includeOnce, .help="Source the file only if not already sourced" ),
    JSI_OPT(BOOL,  Jsi_DebugInterp, includeTrace,.help="Trace includes" ),
    JSI_OPT(INT,   Jsi_DebugInterp, minLevel,   .help="Disable eval callback for level higher than this" ),
    JSI_OPT(STRKEY,Jsi_DebugInterp, msgCallback,.help="Comand in parent interp to handle log msgs. Call func(msg:string, type:string, file:string, line:number, col:number)" ),
    JSI_OPT(BOOL,  Jsi_DebugInterp, pkgTrace,   .help="Trace package loads" ),
    JSI_OPT(STRKEY,Jsi_DebugInterp, putsCallback,.help="Comand in parent interp to handle puts output. Call func(msg:string, isStderr:number)" ),
    JSI_OPT(STRKEY,Jsi_DebugInterp, traceCallback,.help="Comand in parent interp to handle traceCall. Call func(cmd:string, args:string, ret:string, file:string, line:number, col:number)" ),
    JSI_OPT_END(Jsi_DebugInterp, .help="Interp options for debugging")
};

Jsi_OptionSpec jsi_InterpLogOptions[] = {
    JSI_OPT(BOOL,   jsi_LogOptions, test,    .help="Enable LogTest messages" ),
    JSI_OPT(BOOL,   jsi_LogOptions, debug,   .help="Enable LogDebug messages" ),
    JSI_OPT(BOOL,   jsi_LogOptions, trace,   .help="Enable LogTrace messages" ),
    JSI_OPT(BOOL,   jsi_LogOptions, time,    .help="Prefix with time" ),
    JSI_OPT(BOOL,   jsi_LogOptions, date,    .help="Prefix with date" ),
    JSI_OPT(BOOL,   jsi_LogOptions, file,    .help="Ouptut contains file:line" ),
    JSI_OPT(BOOL,   jsi_LogOptions, func,    .help="Output function" ),
    JSI_OPT(BOOL,   jsi_LogOptions, full,    .help="Show full file path" ),
    JSI_OPT(BOOL,   jsi_LogOptions, before,  .help="Output file:line before message string" ),
    JSI_OPT(BOOL,   jsi_LogOptions, isUTC,   .help="Time is to be UTC" ),
    JSI_OPT(STRKEY, jsi_LogOptions, timeFmt, .help="A format string to use with strftime" ),
    JSI_OPT(USEROBJ,jsi_LogOptions, chan,    .help="Channel to send output to", .flags=0, .custom=0, .data=(void*)"Channel" ),
    JSI_OPT_END(jsi_LogOptions, .help="Interp options for logging")
};
static const char *jsi_TypeChkStrs[] = { "parse", "run", "all", "error", "strict", "noundef", "nowith", "proto", NULL };
static const char *jsi_callTraceStrs[] = { "funcs", "cmds", "new", "return", "args", "notrunc", "noparent", "full", "before", NULL};
const char *jsi_AssertModeStrs[] = { "throw", "log", "puts", NULL};

static Jsi_OptionSpec InterpOptions[] = {
    JSI_OPT(ARRAY, Jsi_Interp, args,        .help="The console.arguments for interp", jsi_IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, asserts,     .help="Enable assert" ),
    JSI_OPT(CUSTOM,Jsi_Interp, assertMode,  .help="Action upon assert failure", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),
    JSI_OPT(VALUE, Jsi_Interp, autoFiles,   .help="File(s) to source for loading Jsi_Auto to handle unknown commands"),
    JSI_OPT(STRKEY,Jsi_Interp, busyCallback,.help="Command in parent interp (or 'event') to periodically call. Call func(interpName:string, opCnt:number)"),
    JSI_OPT(INT   ,Jsi_Interp, busyInterval,.help="Call busyCallback command after this many op-code evals (100000)", jsi_IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, compat,      .help="Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser" ),
    JSI_OPT(BOOL,  Jsi_Interp, coverage,    .help="On exit generate detailed code coverage for function calls (with profile)"),
    JSI_OPT(CUSTOM,Jsi_Interp, debugOpts,   .help="Options for debugging", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpDebugOptions),
    JSI_OPT(STRKEY,Jsi_Interp, historyFile, .help="In interactive mode, file to use for history (~/.jsish_history)", jsi_IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help="Is this a safe interp (ie. with limited or no file access)", jsi_IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, istty,       .help="Indicates interp is in interactive mode", jsi_IIRO),
    JSI_OPT(STRKEY,Jsi_Interp, jsppChars,    .help="Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string"),
    JSI_OPT(FUNC,  Jsi_Interp, jsppCallback, .help="Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number)"),
    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help="Thread time-out for mutex lock acquires (milliseconds)" ),
    JSI_OPT(CUSTOM,Jsi_Interp, logOpts,     .help="Options for log output to add file/line/time", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=jsi_InterpLogOptions),
    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help="Depth limit of recursive function calls (1000)"),
    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help="Maximum allowed source/require nesting depth (50)" ),
    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help="Maximum nested subinterp create depth (10)" ),
    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help="Maximum number of 'new' object calls, eg. File, RegExp, etc" ),
    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help="Execution limit for op-code evaluation" ),
    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help="Memory debugging level: 1=summary, 2=detail", .flags=JSI_OPT_NO_CLEAR),
    JSI_OPT(BOOL,  Jsi_Interp, msgAllowDups,.help="Disable log duplicate filtering"),
    JSI_OPT(BOOL,  Jsi_Interp, mutexUnlock, .help="Unlock own mutex when evaling in other interps (true)", jsi_IIOF),
    JSI_OPT(STRKEY,Jsi_Interp, name,        .help="Optional text name for this interp"),
    JSI_OPT(BOOL,  Jsi_Interp, noInherit,   .help="Disable OOP features such as __proto__, prototype, constructor, etc"),
    JSI_OPT(BOOL,  Jsi_Interp, noReadline,  .help="Disable use of readline in interactive mode" ),
    JSI_OPT(BOOL,  Jsi_Interp, noUndef,     .help="Suppress printing undefined value result when in interactive mode"),
    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help="Function to return commands completions for interactive mode.  Default uses Info.completions ", .flags=0, .custom=0, .data=(void*)"prefix:string, start:number, end:number" ),
    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help="Function to get control for interactive evals", .flags=0, .custom=0, .data=(void*)"cmd:string" ),
    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help="Command to call in parent on exit, returns true to continue", jsi_IIOF , .custom=0, .data=(void*)""),
    JSI_OPT(INT,   Jsi_Interp, opTrace,     .help="Set debugging level for OPCODE execution"),
    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help="Disallow sub-interp creation", jsi_IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, noStderr,    .help="Make puts, log, assert, etc use stdout" ),
    JSI_OPT(ARRAY, Jsi_Interp, pkgDirs,     .help="list of library directories for require() to search" ),
    JSI_OPT(BOOL,  Jsi_Interp, profile,     .help="On exit generate profile of function calls"),
    JSI_OPT(BOOL,  Jsi_Interp, noInherit,   .help="Disable access to __proto__, prototype, constructor, etc"),
    JSI_OPT(STRKEY,Jsi_Interp, recvCallback,.help="Command to recv 'send' msgs from parent interp. Call func(msg:string)"),
    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help="In safe mode, directories to allow reads from", jsi_IIOF),
    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help="In safe mode, directories to allow writes to", jsi_IIOF),
    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help="Interp init script string", jsi_IIOF),
    JSI_OPT(STRING,Jsi_Interp, scriptFile,  .help="Interp init script file"),
    JSI_OPT(BOOL,  Jsi_Interp, showColumns, .help="Display column numbers in error messages"),
    JSI_OPT(STRING,Jsi_Interp, stdinStr,    .help="String to use as stdin for console.input()"),
    JSI_OPT(STRING,Jsi_Interp, stdoutStr,   .help="String to collect stdout for puts()"),
    JSI_OPT(BOOL,  Jsi_Interp, strict,      .help="Globally enable strict: same as 'use strict' in main program"),
    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help="Create a threaded Interp", jsi_IIOF),
    JSI_OPT(CUSTOM,Jsi_Interp, traceCall,   .help="Trace commands", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),
    JSI_OPT(BOOL,  Jsi_Interp, tracePuts,   .help="Trace puts by making it use logOpts" ),
    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help="Type-check control options", .flags=0, .custom=Jsi_Opt_SwitchBitset, .data=jsi_TypeChkStrs),
    JSI_OPT(INT,   Jsi_Interp, typeWarnMax, .help="Type checking is silently disabled after this many warnings (50)" ),
    JSI_OPT(UINT,  Jsi_Interp, unitTest,    .help="Unit test control bits: 1=subst ;;, 2=Puts with file:line prefix" ),
    JSI_OPT_END(Jsi_Interp, .help="Options for the Jsi interpreter")
};

/* Object for each interp created. */
typedef struct InterpObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *subinterp;
    Jsi_Interp *parent;
    //char *interpname;
    char *mode;
    Jsi_Obj *fobj;
    int objId;
    int deleting;
} InterpObj;

/* Global state of interps. */

typedef struct {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int refCount;
    const char *cmdName;
    Jsi_Value *args;
    Jsi_Value *func;
    Jsi_Value *cmdVal;
    InterpObj *intobj;
    Jsi_Interp *dinterp; // Dest interp.
    Jsi_Interp *subinterp;
} AliasCmd;


static void interpObjErase(InterpObj *fo);
static Jsi_RC interpObjFree(Jsi_Interp *interp, void *data);
static bool interpObjIsTrue(void *data);
static bool interpObjEqual(void *data1, void *data2);

static void ConvertReturn(Jsi_Interp *tointerp, Jsi_Value **toret, Jsi_Interp *frominterp, Jsi_Value **fromret)
{
    Jsi_DString dStr = {};

    switch ((*fromret)->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_BOOL:
        case JSI_VT_NUMBER:
        case JSI_VT_NULL:
            Jsi_ValueCopy(tointerp, *toret, *fromret);
            break;
        default:
            Jsi_DSInit(&dStr);
            char *cp = (char*)Jsi_ValueGetDString(frominterp, *fromret, &dStr, JSI_OUTPUT_JSON);
            Jsi_JSONParse(tointerp, cp, toret, 0);
            Jsi_DSFree(&dStr);
    }
}

/* Call a command with JSON args.  Returned string by using Jsi_ValueGetDString(..., flags). */
Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags)
{
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return JSI_ERROR;
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    Jsi_RC rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);
    Jsi_DSInit(dStr);
    Jsi_ValueGetDString(interp, nrPtr, dStr, flags /*JSI_OUTPUT_JSON*/);
    Jsi_DecrRefCount(interp, nrPtr);
    Jsi_MutexUnlock(interp, interp->Mutex);
    return rc;
}

/* Call a function with JSON args.  Return a primative. */
Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)
{
    if (!Jsi_ValueIsFunction(interp, func))
        return JSI_ERROR;
    Jsi_Value *aPtr = Jsi_ValueNew1(interp);
    Jsi_RC rc = Jsi_JSONParse(interp, json, &aPtr, 0);
    if (rc == JSI_OK) 
        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);
    Jsi_DecrRefCount(interp, aPtr);
    return rc;
}
/* Lookup cmd from cmdstr and invoke with JSON args. */
/*
 *   Jsi_CommandInvokeJSON(interp, "info.cmds", "[\"*\",true]", ret);
 */
Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)
{
    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);
    if (func)
        return Jsi_FunctionInvokeJSON(interp, func, json, ret);
    return Jsi_LogError("can not find cmd: %s", cmdstr);
}

/* Clean-copy value to interp: convert to JSON and back if required. */
static Jsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret)
{
    Jsi_RC rc = JSI_OK;
    const char *cp;
    unsigned char *dp;
    int len, iskey;
    Jsi_Obj *obj;
    switch (val->vt) {
        case JSI_VT_UNDEF: Jsi_ValueMakeUndef(interp, ret); return rc;
        case JSI_VT_NULL: Jsi_ValueMakeNull(tointerp, ret); return rc;
        case JSI_VT_BOOL: Jsi_ValueMakeBool(tointerp, ret, val->d.val); return rc;
        case JSI_VT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, val->d.num); return rc;
        case JSI_VT_STRING:
            iskey = val->f.bits.isstrkey;
            cp = val->d.s.str;
            len = val->d.s.len;
makestr:
            if (iskey) {
                Jsi_ValueMakeStringKey(interp, ret, cp);
                return rc;
            }
            if (len<0) len = Jsi_Strlen(cp);
            dp = (unsigned char*)Jsi_Malloc(len+1);
            memcpy(dp, cp, len);
            dp[len] = 0;
            Jsi_ValueMakeBlob(tointerp, ret, dp, len);
            return rc;
        case JSI_VT_OBJECT:
            obj = val->d.obj;
            switch (obj->ot) {
                case JSI_OT_BOOL: Jsi_ValueMakeBool(tointerp, ret, obj->d.val); return rc;
                case JSI_OT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, obj->d.num); return rc;
                case JSI_OT_STRING:
                    cp = obj->d.s.str;
                    len = obj->d.s.len;
                    iskey = obj->isstrkey;
                    goto makestr;
                default: break;
            }
            break;
        default:
            break;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    cp = Jsi_ValueGetDString(interp, val, &dStr, JSI_OUTPUT_JSON);
    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {
        Jsi_DSFree(&dStr);
        return Jsi_LogError("bad subinterp parse");
    }
    Jsi_DSFree(&dStr);
    return rc;
}

/* Invoke command in target interp. */
static Jsi_RC AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->reserved[2];
    Jsi_Interp *dinterp = ac->dinterp;
    Jsi_Value *nargs = NULL;
    int argc = Jsi_ValueGetLength(interp, args);
    if (!ac) {
        Jsi_LogBug("BAD ALIAS INVOKE OF DELETED");
        return JSI_ERROR;
    }
    SIGASSERT(ac,ALIASCMD);
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    if (argc == 0 && ac->args)
        nargs = ac->args;
    else if (argc) {
        if (dinterp == interp)
            Jsi_ValueCopy(interp, nrPtr, args);
        else if (Jsi_CleanValue(interp, dinterp, args, &nrPtr) != JSI_OK)
            return JSI_ERROR;
        if (ac->args) {
            nargs = Jsi_ValueArrayConcat(dinterp, ac->args, nrPtr);
        } else {
            nargs = nrPtr;
        }
    }
    if (dinterp != interp) {
        if (interp->mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
        if (Jsi_MutexLock(interp, dinterp->Mutex) != JSI_OK) {
            if (interp->mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);
            return JSI_ERROR;
        }
    }
    ac->refCount++;
    //int oref = 0;
    if (nargs && nargs != nrPtr) {
        Jsi_IncrRefCount(interp, nargs);
        //oref = nargs->d.obj->refcnt;
    }
    Jsi_Value *srPtr, **srpPtr = ret;
    if (dinterp != interp) {
        srPtr = Jsi_ValueNew1(interp);
        srpPtr = &srPtr;
    }
    Jsi_RC rc = Jsi_FunctionInvoke(dinterp, ac->func, nargs, srpPtr, NULL);
    //if (0 && nargs && oref != nargs->d.obj->refcnt && Jsi_Strcmp(ac->func->d.obj->d.fobj->func->name,"source") == 0) {
        // TODO: hack to reduce a mem-leak, probably due to use of "arguments[n]" in JS.
        //fprintf(stderr, "REF CHG: %d\n", oref - nargs->d.obj->refcnt);
        //Jsi_ObjDecrRefCount(interp, nargs->d.obj); 
    //}
    ac->refCount--;
    if (dinterp != interp) {
        Jsi_MutexUnlock(interp, dinterp->Mutex);
        if (interp->mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
            return JSI_ERROR;
        }
    }
    Jsi_DecrRefCount(interp, nrPtr);
    if (nargs && nargs != nrPtr)
        Jsi_DecrRefCount(interp, nargs);
    if (dinterp != interp) {
        ConvertReturn(dinterp, ret, interp, srpPtr);
        Jsi_DecrRefCount(interp, srPtr);
        if (rc != JSI_OK && dinterp->errMsgBuf[0]) {
            Jsi_Strcpy(interp->errMsgBuf, dinterp->errMsgBuf);
            interp->errLine = dinterp->errLine;
            interp->errFile = dinterp->errFile;
            dinterp->errMsgBuf[0] = 0;
        }
    }
    return rc;
}


static Jsi_RC AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {
    /* TODO: deal with other copies of func may be floating around (refCount). */
    AliasCmd *ac = (AliasCmd *)data;
    if (!ac) return JSI_ERROR;
    SIGASSERT(ac,ALIASCMD);
    if (ac->func)
        Jsi_DecrRefCount(ac->dinterp, ac->func);
    if (ac->args)
        Jsi_DecrRefCount(ac->dinterp, ac->args);
    if (!ac->cmdVal)
        return JSI_OK;
    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;
    fobj->cmdSpec->reserved[2] = NULL;
    fobj->cmdSpec->proc = NULL;
    if (ac->intobj && ac->intobj->subinterp) {
        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);
        if (Jsi_Strchr(ac->cmdName, '.'))
            Jsi_LogBug("alias free with X.Y dot name leaks memory: %s", ac->cmdName);
    } else
        Jsi_DecrRefCount(ac->subinterp, ac->cmdVal);
    _JSI_MEMCLEAR(ac);
    Jsi_Free(ac);
    return JSI_OK;
}

#define FN_intalias JSI_INFO("With 0 args, returns list of all aliases in interp. \
With 1 arg returns func for given alias name. \
With 2 args, returns args for given alias name (args must be null). \
With 3 args, create/update an alias for func and args. Delete an alias by creating it with null for both func and args.")
static Jsi_RC InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *sinterp = (udf ? udf->subinterp : interp );
    Jsi_Hash *aliases = sinterp->aliasHash;
    if (!aliases) 
        return Jsi_LogError("Sub-interp gone");
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0)
        return Jsi_HashKeysDump(interp, aliases, ret, 0);
    Jsi_HashEntry *hPtr;
    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!key) 
        return Jsi_LogError("expected string");
    AliasCmd* ac;
    if (argc == 1) {
        hPtr = Jsi_HashEntryFind(aliases, (void*)key);
        if (!hPtr)
            return JSI_OK;
        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
        if (!ac) return JSI_ERROR;
        SIGASSERT(ac,ALIASCMD);
        Jsi_ValueDup2(interp, ret, ac->func);
        return JSI_OK;
    }
    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);
    if (argc == 2) {
        hPtr = Jsi_HashEntryFind(aliases, (void*)key);
        if (!hPtr)
            return JSI_OK;
        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
        if (!Jsi_ValueIsNull(interp, afunc)) 
            return Jsi_LogError("arg 2: expected null to query args");
        if (!ac) return JSI_ERROR;
        SIGASSERT(ac,ALIASCMD);
        Jsi_ValueDup2(interp, ret, ac->args); //TODO: JSON??
        return JSI_OK;
    }
    if (interp->threadId != sinterp->threadId)
        return Jsi_LogError("alias not supported with threads");
    if (argc == 3) {
        bool isNew;
        Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);
        if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {
            hPtr = Jsi_HashEntryFind(aliases, (void*)key);
            if (hPtr == NULL)
                return JSI_OK;
            ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
            if (!ac) return JSI_ERROR;
            if (0 && ac->cmdVal)
                Jsi_DecrRefCount(interp, ac->cmdVal);
            AliasFree(interp, NULL, ac);
            Jsi_HashValueSet(hPtr, NULL);
            Jsi_HashEntryDelete(hPtr);
            return JSI_OK;
        }
        hPtr = Jsi_HashEntryNew(aliases, (void*)key, &isNew);
        if (!hPtr) 
            return Jsi_LogError("create failed: %s", key);
        if (!Jsi_ValueIsFunction(interp, afunc)) 
            return Jsi_LogError("arg 2: expected function");
        if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0) 
            return Jsi_LogError("arg 3: expected array or null");
        if (!isNew) {
            AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));
        }
        ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));
        SIGINIT(ac, ALIASCMD);
        ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);
        ac->func = afunc;
        Jsi_IncrRefCount(interp, afunc);
        if (!Jsi_ValueIsNull(interp, aargs)) {
            ac->args = aargs;
            Jsi_IncrRefCount(interp, aargs);
        }
        ac->intobj = udf;
        ac->dinterp = interp;
        ac->subinterp = sinterp;
        Jsi_HashValueSet(hPtr, ac);
        Jsi_Value *cmd = jsi_CommandCreate(sinterp, key, AliasInvoke, NULL, 0, 0);
        if (!cmd)
            return Jsi_LogBug("command create failure");
        ac->cmdVal = cmd;
        Jsi_Func *fobj = cmd->d.obj->d.fobj->func;
        fobj->cmdSpec->reserved[2] = ac;
        cmd->d.obj->isNoOp = (afunc->d.obj->d.fobj->func->callback == jsi_NoOpCmd);
    }
    return JSI_OK;
}

static Jsi_RC freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    jsi_Pstate *ps = (jsi_Pstate *)ptr;
    if (!ps) return JSI_OK;
    ps->hPtr = NULL;
    jsi_PstateFree(ps);
    return JSI_OK;
}

static Jsi_RC freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;
    proc(interp, NULL);
    return JSI_OK;
}

static Jsi_RC freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    jsi_DelAssocData(interp, ptr);
    return JSI_OK;
}

static Jsi_RC freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Event *event = (Jsi_Event *)ptr;
    SIGASSERT(event,EVENT);
    if (!ptr) return JSI_OK;
    Jsi_HashValueSet(event->hPtr, NULL);
    event->hPtr = NULL;
    Jsi_EventFree(interp, event);
    return JSI_OK;
}
Jsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Free(ptr);
    return JSI_OK;
}

static Jsi_RC regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_RegExpFree((Jsi_Regex*)ptr);
    return JSI_OK;
}

static Jsi_RC freeCmdSpecTbl(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    jsi_CmdSpecDelete(interp, ptr);
    return JSI_OK;
}

static Jsi_RC freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *obj = (Jsi_Obj *)ptr;
    SIGASSERT(obj,OBJ);
    if (!obj) return JSI_OK;
    Jsi_ObjDecrRefCount(interp, obj);
    return JSI_OK;
}


static Jsi_RC freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Func *func = (Jsi_Func *)ptr;
    if (!func) return JSI_OK;
    SIGASSERT(func,FUNC);
    func->hPtr = NULL;
    jsi_FuncFree(interp, func);
    return JSI_OK;
}

static Jsi_RC freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *v = (Jsi_Obj *)ptr;
    if (!v) return JSI_OK;
    SIGASSERT(v,OBJ);
    if (v->d.fobj) {
        if (v->d.fobj->scope) {
            jsi_ScopeChain *scope = v->d.fobj->scope;
            v->d.fobj->scope = NULL;
            jsi_ScopeChainFree(interp, scope);
        }
    }
    Jsi_ObjDecrRefCount(interp, v);
    return JSI_OK;
}

static Jsi_RC freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *v = (Jsi_Obj *)ptr;
    if (!v) return JSI_OK;
    SIGASSERT(v,OBJ);
    if (v->d.fobj && v->d.fobj->scope) {
        v->d.fobj->scope = NULL;
    }
    Jsi_ObjDecrRefCount(interp, v);
    return JSI_OK;
}

/* TODO: incr ref before add then just decr till done. */
static Jsi_RC freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Value *val = (Jsi_Value *)ptr;
    SIGASSERT(val,VALUE);
    if (!val) return JSI_OK;
    //printf("GEN: %p\n", val);
   /* if (val->refCnt>1)
        Jsi_DecrRefCount(interp, val);*/
    Jsi_DecrRefCount(interp, val);
    return JSI_OK;
}

static Jsi_RC freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (ptr) 
        jsi_UserObjDelete(interp, ptr);
    return JSI_OK;
}

void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v) {
    if (!v)
        v = interp->args;
    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)
        return;
    Jsi_Obj *obj = v->d.obj;
    int n = v->d.obj->arrCnt;
    n--;
    v = obj->arr[0];
    if (v)
        Jsi_DecrRefCount(interp, v);
    if (n>0)
        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));
    obj->arr[n] = NULL;
    Jsi_ObjSetLength(interp, obj, n);    
}

char *jsi_execName = NULL;
static Jsi_Value *jsi_execValue = NULL;

Jsi_Value *Jsi_Executable(Jsi_Interp *interp)
{
    return jsi_execValue;
}

static Jsi_RC KeyLocker(Jsi_Hash* tbl, int lock)
{
    if (!lock)
        Jsi_MutexUnlock(jsiMainInterp, jsiMainInterp->Mutex);
    else
        return Jsi_MutexLock(jsiMainInterp, jsiMainInterp->Mutex);
    return JSI_OK;
}

#ifdef JSI_USE_MANY_STRKEY
static Jsi_RC KeyLockerTree(Jsi_Tree* tree, int lock) { return KeyLocker((Jsi_Hash*)tree, lock); }
#endif

static int jsi_deleted = 0, jsi_exitCode = 0;
static Jsi_Value *jsi_vf = NULL;

static Jsi_RC jsi_InterpDelete(Jsi_Interp *interp, void *ptr) {
    if (jsi_vf)
        Jsi_DecrRefCount(interp, jsi_vf);
    jsi_vf = NULL;
    jsi_exitCode = interp->exitCode;
    jsi_deleted = 1;
    return JSI_OK;
}

Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)
{
    int rc = 0;
    Jsi_Interp* interp = NULL;
    int argc = 0;
    char **argv = NULL;
    if (opts) {
        interp = opts->interp;
        argc = opts->argc;
        argv = opts->argv;
    }
    if (!interp)
        interp = Jsi_InterpNew(opts);
    if (!interp)
        return NULL;
    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, NULL);

#ifndef NO_JAZ
    /* Mount zip at end of executable */
    Jsi_Value *v = Jsi_Executable(interp);
    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);
    int jsFound = 0;
    if (v && (argc != 2 || Jsi_Strcmp(argv[1], "--nozvfs"))) {
        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);
        if (rc == JSI_OK) {
            interp->selfZvfs = 1;
            if (!jsFound) {
#if (JSI__FILESYS && JSI__ZVFS)
                fprintf(stderr, "warning: no main.jsi or autoload.jsi\n");
#endif
            }
            if (jsi_deleted)
                return jsi_DoExit(interp, jsi_exitCode);
            else if (rc != 0) {
                fprintf(stderr, "Error\n");
                return jsi_DoExit(interp, 1);
            }
        }
    }
#endif

    Jsi_ShiftArgs(interp, NULL);
    if (argc == 1) {
iact:
        if (interp->opts.no_interactive)
            return interp;
        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);
    } else {
        if (argc == 2 && !Jsi_Strcmp(argv[1], "-h" )) {
            puts("usage: jsish -h/--help | -v/--version | -d/--debug | -D/--debugui | -u/--unittest | -U/-UU\n\t"
            "| -s/--safe | -Z/--zip | -S/--sqliteui | -W/--websrv | -H/--htmli | -J/--jsi\n\t"
            "| -C/--cssi | -c/--cdata | -M/--module | -m/--make | -e/--eval | -t/--tracecall\n\t"
            "| -T/--typecheck OPT | -IOPT VAL | FILE arg arg ...\nUse --help for long help");
            return jsi_DoExit(interp, 1);
        }
        if (argc == 2 && !Jsi_Strcmp(argv[1], "--help")) {
            puts("jsish arguments:\n"
              "  -h/--help\t\tPrint short/long help\n"
              "  -v/--version\t\tPrint short/long version info and exit\n"
              "  -e/--eval STRING\tEvaluate a javascript string and exit\n"
              "  -d/--debug SCRIPT\tRun console debugger on script\n"
              "  -D/--debugui SCRIPT\tRun web-gui debugger on script\n"
              "  -t/--tracecall\tTrace all function calls\n"
              "  -T/--typecheck OPT\tEnable typechecking\n"
              "  -u/--unittest FILEDIR\tRun unit-tests on scripts or dir of .js/.jsi files\n"
              "  -U/-UU SCRIPT\t\tShow output from unit-test mode, omitting pass/fail compare\n"
              "  -Z/--zip\t\tRun builtin zip sub-commmand\n"
              "  -s/--safe SCRIPT\tRun script in safe sub-interp\n"
              "  -S/--sqliteui DBFILE\tRun Sqlite web-gui\n"
              "  -W/--websrv FILE\tServe out file in web server, with preprocessing\n"
              "  -H/--htmli FILE\tPreprocess embedded jsi in .htmli file\n"
              "  -J/--jsi FILE\t\tPreprocess a .jsi file to typecheck in standard javascript\n"
              "  -C/--cssi FILE\tPreprocess embedded CSS in .css file\n"
              "  -c/--cdata FILE\tGenerate .c or JSON output from a .jsc description\n"
              "  -M/--module NAME\tInvoke module using Jsi_Main(NAME) (eg. from the /zvfs directory)\n"
              "  -m/--make FILE\tPreprocess script as a Jsi Makefile\n"
              "  -IOPT VAL\t\tSet an internal interp option value\n"
              "\nInterp options may also be set via the environment var JSI_INTERP_OPTS\n"
               );
            return jsi_DoExit(interp, 1);
        }
        if (argc == 2 && !Jsi_Strcmp(argv[1], "--version")) {
            char str[200] = "\n";
            Jsi_Channel chan = Jsi_Open(interp, Jsi_ValueNewStringKey(interp, "/zvfs/lib/sourceid.txt"), "r");
            if (chan)
                Jsi_Read(chan, str, sizeof(str));
            printf("%d.%d.%d %" JSI_NUMGFMT " %s", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);
            return jsi_DoExit(interp, 1);
        }
        if (argc == 2 && !Jsi_Strcmp(argv[1], "-v" )) {
            printf("%d.%d.%d\n", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);
            return jsi_DoExit(interp, 1);
        }
        if (argc > 2 && (Jsi_Strcmp(argv[1], "--module")==0 || Jsi_Strcmp(argv[1], "-M" )==0)) {
            Jsi_DString dStr = {};
            Jsi_DSAppend(&dStr, "Jsi_Main(\"", argv[2], "\",console.args.slice(1));", NULL);
            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);
            Jsi_DSFree(&dStr);
        }
        else if (argc == 3 && (Jsi_Strcmp(argv[1], "--eval")==0 || Jsi_Strcmp(argv[1], "-e" )==0))
            rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_NOSKIPBANG);
        
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--debug")==0 || Jsi_Strcmp(argv[1], "-d" )==0)) {
            interp->debugOpts.isDebugger = 1;
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_Debug');", 0);
        } else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--safe")==0 || Jsi_Strcmp(argv[1], "-s" )==0))
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_Safe');", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--debugui")==0 || Jsi_Strcmp(argv[1], "-D" )==0)) {
            interp->debugOpts.isDebugger = 1;
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_DebugUI');", 0);
        } else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--websrv")==0 || Jsi_Strcmp(argv[1], "-W" )==0))
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_Websrv');", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--sqliteui")==0 || Jsi_Strcmp(argv[1], "-S" )==0))
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_SqliteUI');", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--cdata")==0 || Jsi_Strcmp(argv[1], "-c" )==0))
            rc = Jsi_EvalString(interp, "puts(Jsi_Main('Jsi_CData'));", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--zip")==0 || Jsi_Strcmp(argv[1], "-Z" )==0))
            rc = Jsi_EvalString(interp, "Jsi_Main('Jsi_Zip');", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--cssi")==0 || Jsi_Strcmp(argv[1], "-C" )==0))
            rc = Jsi_EvalString(interp, "puts(Jsi_Main('Jsi_Csspp'));", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--jsi")==0 || Jsi_Strcmp(argv[1], "-J" )==0))
            rc = Jsi_EvalString(interp, "puts(Jsi_Main('Jsi_Jspp'));", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--htmli")==0 || Jsi_Strcmp(argv[1], "-H" )==0))
            rc = Jsi_EvalString(interp, "puts(Jsi_Main('Jsi_Htmlpp'));", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--unittest")==0 || Jsi_Strcmp(argv[1], "-u" )==0))
            rc = Jsi_EvalString(interp, "exit(Jsi_Main('Jsi_UnitTest'));", 0);
        else if (interp->selfZvfs && argc > 1 && (Jsi_Strcmp(argv[1], "--make")==0 || Jsi_Strcmp(argv[1], "-m" )==0))
            rc = Jsi_EvalString(interp, "exit(Jsi_Main('Jsi_Make'));", 0);
        else {
            int iocnt;
            for (iocnt = 1; (iocnt+1)<argc; iocnt+=2) {
                if (Jsi_Strcmp(argv[iocnt], "-t") == 0 || Jsi_Strcmp(argv[iocnt], "--tracecall") == 0) {iocnt--; continue; }
                if (Jsi_Strcmp(argv[iocnt], "-T") == 0 || Jsi_Strcmp(argv[iocnt], "--typecheck") == 0) {continue; }
                if (Jsi_Strcmp(argv[iocnt], "-U") == 0) {iocnt--; continue; }
                if (Jsi_Strcmp(argv[iocnt], "-UU") == 0) {iocnt--; continue; }
                if (Jsi_Strncmp(argv[iocnt], "-I", 2) == 0) continue;
                break;
            }
            argc -= (iocnt-1);
            argv += (iocnt-1);
            if (argc<2)
                goto iact;
            const char *ext = Jsi_Strrchr(argv[1], '.');

            /* Support running "main.jsi" from a zip file. */
            if (ext && (Jsi_Strcmp(ext,".zip")==0 ||Jsi_Strcmp(ext,".jsz")==0 ) ) {
                rc = Jsi_EvalZip(interp, argv[1], NULL, &jsFound);
                if (rc<0) {
                    fprintf(stderr, "zip mount failed\n");
                    return jsi_DoExit(interp, 1);
                }
                if (!(jsFound&JSI_ZIP_MAIN)) {
                    fprintf(stderr, "main.jsi not found\n");
                    return jsi_DoExit(interp, 1);
                }
            } else {
                if (argc>1) {
                    jsi_vf = Jsi_ValueNewStringKey(interp, argv[1]);
                    Jsi_IncrRefCount(interp, jsi_vf);
                }
                rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);
                if (jsi_vf) {
                    Jsi_DecrRefCount(interp, jsi_vf);
                    jsi_vf = NULL;
                }
                
            }
        }
        if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc
            return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);
        if (rc == 0) {
            /* Skip output from an ending semicolon which evaluates to undefined */
            Jsi_Value *ret = Jsi_ReturnValue(interp);
            if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {
                Jsi_DString dStr = {};
                fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);
                Jsi_DSFree(&dStr);
                fputs("\n", stdout);
            }
        } else {
            if (!interp->parent)
                fputs("ERROR\n", stderr);
            return jsi_DoExit(interp, 1);
        }

    }
    if (rc == JSI_EXIT) {
        if (opts)
            opts->exitCode = jsi_exitCode;
        return NULL;
    }
    if (jsi_deleted == 0 && interp->opts.auto_delete) {
        Jsi_InterpDelete(interp);
        return NULL;
    }
    return interp;
}

// Get control during script evaluation to support debugging.
static Jsi_RC jsi_InterpDebugHook(struct Jsi_Interp* interp, const char *curFile,
    int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *emsg)
{
    // TODO: when code is run in debugger, parser.y should attribute op for case stmt to skip str compares, etc.
    int isfun=0;
    if (interp->isInCallback || curLine<=0)
        return JSI_OK;
    if (op && op->nodebug)
        return JSI_OK;
    int isbp = 0, bpId = 0, cont = interp->debugOpts.doContinue,
        stop = (interp->debugOpts.noFilter || interp->debugOpts.forceBreak);
    if (!curFunc)
        curFunc = "";
        
    if (interp->parent && interp->parent->sigmask) {
        interp->parent->sigmask = 0;
        opCode = "SIGINT";
        
    } else if (Jsi_Strcmp(opCode, "DEBUG") || !interp->parent) {
    
        // Avoid overhead of multiple ops on same line of code.
        int sameLine = (interp->debugOpts.lastLine == curLine && interp->debugOpts.lastLevel == curLevel
            && interp->debugOpts.lastFile == curFile);
            
        if (sameLine && stop==0 && (interp->debugOpts.bpLast==0
            || (interp->debugOpts.bpOpCnt+10) >= interp->opCnt)) //TODO: need better way to detect bp dups.
            goto done;
        
        if (!interp->debugOpts.callback || !interp->parent) {
            fprintf(stderr, "FILE %s:%d (%d) %s %s\n", curFile, curLine, curLevel, curFunc, opCode);
            return JSI_OK;
        }
        
        // Check for breakpoints.
        if (interp->breakpointHash) {
            Jsi_HashEntry *hPtr;
            Jsi_HashSearch search;
            for (hPtr = Jsi_HashSearchFirst(interp->breakpointHash, &search);
                hPtr != NULL && stop == 0; hPtr = Jsi_HashSearchNext(&search)) {
                jsi_BreakPoint* bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);
                if (bptr == NULL || bptr->enabled == 0) continue;
                if (bptr->func)
                    stop = (!Jsi_Strcmp(bptr->func, curFunc));
                else
                    stop = (bptr->line == curLine && !Jsi_Strcmp(bptr->file, curFile));
                if (stop) {
                    isbp = 1;
                    bpId = bptr->id;
                    bptr->hits++;
                    if (bptr->temp)
                        bptr->enabled = 0;
                }
            }
        }
    
        if (stop == 0) { // No breakpoint.
            if (cont  // Cmd is "continue"
                // Handle "next" by skipping calls into functions.
                || (interp->debugOpts.minLevel>0 && curLevel>interp->debugOpts.minLevel)
                || (isfun=(Jsi_Strcmp(opCode, "PUSHVAR")==0 && op[1].op == OP_PUSHFUN)))
            {
                if (isfun) {
                    interp->debugOpts.lastLine = curLine;
                    interp->debugOpts.lastLevel = curLevel;
                    interp->debugOpts.lastFile = curFile;
                }
done:
                return JSI_OK;
            }
        }
    }
    interp->debugOpts.bpLast = isbp;
    interp->debugOpts.bpOpCnt = interp->opCnt;
    interp->debugOpts.lastLine = curLine;
    interp->debugOpts.lastLevel = curLevel;
    interp->debugOpts.lastFile = curFile;
    interp->debugOpts.forceBreak = 0;
        
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    if (emsg && Jsi_Strchr(emsg,'\"'))
        emsg = 0;
    Jsi_DSPrintf(&dStr, "[\"%s\", %d, %d, \"%s\", \"%s\", %d, \"%s\"]", curFile?curFile:"", curLine, curLevel, curFunc, opCode, bpId, emsg?emsg:"");
    interp->isInCallback = 1;
    if (!interp->debugOpts.callbackFunc)
        interp->debugOpts.callbackFunc = Jsi_NameLookup(interp, interp->debugOpts.callback);
    Jsi_RC rc;
    if (interp->debugOpts.callbackFunc)
        rc = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.callbackFunc, Jsi_DSValue(&dStr), &interp->retPtr);
    else
        rc = Jsi_CommandInvokeJSON(interp->parent, interp->debugOpts.callback, Jsi_DSValue(&dStr), &interp->retPtr);
    interp->isInCallback = 0;
    if (interp->parent->exited == 0 && rc != JSI_OK)
        Jsi_LogError("debugger failure");
    return rc;
}

Jsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str) {
    uint *iptr = (uint*)&interp->typeCheck;
    const char *wcp = str, *wcn = wcp;
    while (wcn && wcp) {
        int isnot = 0;
        if (*wcp == '!') { isnot = 1; wcp++; }
        wcn = Jsi_Strchr(wcp, ',');
        int ti, wlen = (wcn?(wcn-wcp):(int)Jsi_Strlen(wcp));
#define _JSIPARSETYPES(nam) \
        if (wlen == (sizeof(#nam)-1) && !Jsi_Strncmp(#nam, wcp, (sizeof(#nam)-1))) { \
            interp->logOpts.nam = (1-isnot); \
            wcp = (wcn?wcn+1:NULL); \
            continue; \
        }
        _JSIPARSETYPES(debug)
        _JSIPARSETYPES(trace)
        _JSIPARSETYPES(test)
        _JSIPARSETYPES(noinfo)
        _JSIPARSETYPES(nowarn)
        _JSIPARSETYPES(noerror)
        if (wlen == (sizeof("asserts")-1) && !Jsi_Strncmp("asserts", wcp, (sizeof("asserts")-1))) {
            interp->asserts = (isnot ? 0 : 1);
            wcp = (wcn?wcn+1:NULL);
            continue;
        }
        const char **tstrs = jsi_TypeChkStrs;
        for (ti=0; tstrs[ti]; ti++) {
            wlen = Jsi_Strlen(tstrs[ti]);
            if (!Jsi_Strncmp(tstrs[ti], wcp, wlen) && (!tstrs[ti][wlen] || tstrs[ti][wlen] == ',')) break;
        }
        if (tstrs[ti]) {
            if (isnot)
                *iptr &= ~(1<<ti);
            else {
                *iptr |= (1<<ti);
                if (!Jsi_Strcmp(tstrs[ti], "all"))
                    interp->typeCheck.parse = interp->typeCheck.run = 1;
                if (!Jsi_Strcmp(tstrs[ti], "strict")) {
                    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.error = interp->typeCheck.all =
                        interp->framePtr->strict = 1;
                    if (interp->framePtr->level<=0 || interp->isMain)
                        interp->strict = 1;
                }
            }
        } else {
            Jsi_DString wStr = {};
            int i;
            tstrs = jsi_TypeChkStrs;
            for (i=0; tstrs[i]; i++) Jsi_DSAppend(&wStr, i?", ":"", tstrs[i], NULL);
            Jsi_LogWarn("unknown typeCheck warn option(s) \"%s\" not in: debug, trace, test, asserts, %s", str, Jsi_DSValue(&wStr));
            Jsi_DSFree(&wStr);
            return JSI_ERROR;
        }
        wcp = (wcn?wcn+1:NULL);
    }
    return JSI_OK;
}

static Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)
{
    Jsi_Interp* interp;
    if (parent && parent->noSubInterps) {
        interp = parent;
        Jsi_LogError("subinterps disallowed");
        return NULL;
    }
    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||
        Jsi_TreeSize(opts->d.obj->tree)<=0))
        opts = NULL;
    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));
    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));
    if (!parent)
        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;
    else {
        interp->maxInterpDepth = parent->maxInterpDepth;
        interp->interpDepth = parent->interpDepth+1;
        if (interp->interpDepth > interp->maxInterpDepth) {
            Jsi_Free(interp);
            interp = parent;
            Jsi_LogError("exceeded max subinterp depth");
            return NULL;
        }
    }

    int iocnt;
    if (iopts) {
        iopts->interp = interp;
        interp->opts = *iopts;
    }
    interp->logOpts.file = 1;
    interp->logOpts.func = 1;
    int argc = interp->opts.argc;
    char **argv = interp->opts.argv;
    interp->parent = parent;
    interp->topInterp = (parent == NULL ? interp: parent->topInterp);
    if (jsiMainInterp == NULL)
        jsiMainInterp = interp->topInterp;
    interp->mainInterp = jsiMainInterp; // The first interps handles exit.
    interp->memDebug = interp->opts.mem_debug;
    if (parent) {
        interp->dbPtr = parent->dbPtr;
    } else {
        interp->dbPtr = &interp->dbStatic;
    }
#ifdef JSI_MEM_DEBUG
    if (!interp->dbPtr->valueDebugTbl) {
        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
    }
#endif    
    if (parent) {
        if (parent->pkgDirs)
            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);
    } else {
#ifdef JSI_PKG_DIRS
        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, ",");
        Jsi_IncrRefCount(interp, interp->pkgDirs);
#endif
    }
#ifdef JSI_USE_COMPAT
    interp->compat = JSI_USE_COMPAT;
#endif
    const char *ocp = NULL;
#ifndef JSI_CONF_ARGS
#define JSI_CONF_ARGS ""
#endif
    interp->confArgs = JSI_CONF_ARGS;
#ifndef JSI_OMIT_INTERP_ENV
    ocp = getenv("JSI_INTERP_OPTS");
#endif
    const char *ocp2;
    if (ocp && ((ocp2=Jsi_Strstr(ocp,"memDebug:"))))
        interp->memDebug=strtol(ocp+sizeof("memDebug:"), NULL, 0);
    if (ocp && ((ocp2=Jsi_Strstr(ocp,"compat:"))))
        interp->compat=(ocp[sizeof("compat:")]=='t');
    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)
    {
        if (Jsi_Strcmp(argv[iocnt], "-T") == 0 || Jsi_Strcmp(argv[iocnt], "--typecheck") == 0) {
            continue;
        }
        if (Jsi_Strcmp(argv[iocnt], "-t") == 0 || Jsi_Strcmp(argv[iocnt], "--tracecall") == 0
            || Jsi_Strcmp(argv[iocnt], "-U") == 0 || Jsi_Strcmp(argv[iocnt], "-UU") == 0) {
            iocnt--;
            continue;
        }
        if (Jsi_Strncmp(argv[iocnt], "-I", 2)) break;
        if (!Jsi_Strcmp("memDebug", argv[iocnt]+2))
            interp->memDebug=strtol(argv[iocnt+1], NULL, 0);
        else if (!Jsi_Strcmp("compat", argv[iocnt]+2))
            interp->compat=strtol(argv[iocnt+1], NULL, 0);
    }
    interp->maxDepth = JSI_MAX_EVAL_DEPTH;
    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;
    interp->typeWarnMax = 50;
    SIGINIT(interp,INTERP);
    interp->NullValue = Jsi_ValueNewNull(interp);
    Jsi_IncrRefCount(interp, interp->NullValue);
#ifdef __WIN32
    Jsi_DString cwdStr;
    Jsi_DSInit(&cwdStr);
    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));
    Jsi_DSFree(&cwdStr);    
#else
    char buf[BUFSIZ];
    interp->curDir = Jsi_Strdup(getcwd(buf, sizeof(buf)));
#endif
    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);
    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);
    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);
    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);
    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);
    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);
    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);
    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);
    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);
    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);
    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);
    interp->loadTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle);
    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);
    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, AliasFree);

    interp->lockTimeout = -1;
#ifdef JSI_LOCK_TIMEOUT
    interp->lockTimeout JSI_LOCK_TIMEOUT;
#endif
#ifndef JSI_DO_UNLOCK
#define JSI_DO_UNLOCK 1
#endif
    interp->mutexUnlock = JSI_DO_UNLOCK;
    Jsi_Map_Type mapType = JSI_MAP_HASH;
#ifdef JSI_USE_MANY_STRKEY
    mapType = JSI_MAP_TREE;
#endif

    if (interp == jsiMainInterp || interp->threadId != jsiMainInterp->threadId) {
        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);
        interp->privKeys = 1;
    }
    // Handle interp options: -T|--typecheck value and -Ixxx value
    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)
    {
        if (Jsi_Strcmp(argv[iocnt], "-t") == 0 || Jsi_Strcmp(argv[iocnt], "--tracecall") == 0) {
            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);
            iocnt--;
            continue;
        }
        if (Jsi_Strcmp(argv[iocnt], "-U") == 0) {
            interp->asserts = 1;
            interp->unitTest = 1;
            iocnt--;
            continue;
        }
        if (Jsi_Strcmp(argv[iocnt], "-UU") == 0) {
            interp->asserts = 1;
            interp->unitTest = 1;
            interp->tracePuts = 1;
            iocnt--;
            continue;
        }
        if (Jsi_Strcmp(argv[iocnt], "-T") == 0 || Jsi_Strcmp(argv[iocnt], "--typecheck") == 0) {
            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {
                Jsi_InterpDelete(interp);
                return NULL;
            }
            continue;
        }
        if (Jsi_Strncmp(argv[iocnt], "-I", 2)) break;
        const char *argStr = argv[iocnt+1];
        DECL_VALINIT(argV);
        Jsi_Value *argValue = &argV;
        Jsi_Number dv;
        bool bv;
        if (Jsi_GetBool(interp, argStr, &bv) == JSI_OK) {
            Jsi_ValueMakeBool(interp, &argValue, bv);
        } else if (Jsi_GetDouble(interp, argStr, &dv) == JSI_OK) {
            Jsi_ValueMakeNumber(interp, &argValue, dv);
        } else if (!Jsi_Strcmp("null", argStr)) {
            Jsi_ValueMakeNull(interp, &argValue);
        } else {
            Jsi_ValueMakeStringKey(interp, &argValue, argStr);
        }
        if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argv[iocnt]+2, argValue, 0)) {
            Jsi_InterpDelete(interp);
            return NULL;
        }
    }
    if (!interp->strKeyTbl)
        interp->strKeyTbl = jsiMainInterp->strKeyTbl;
    if (opts) {
        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);
        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {
            Jsi_DecrRefCount(interp, opts);
            interp->inopts = NULL;
            Jsi_InterpDelete(interp);
            return NULL;
        }
    }
    if (interp == jsiMainInterp) {
        interp->subthread = 0;
    } else if (opts) {
        if (interp->privKeys && interp->strKeyTbl == jsiMainInterp->strKeyTbl) {
            //Jsi_HashDelete(interp->strKeyTbl);
            Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */
            interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);
            if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);
        } else if (interp->privKeys == 0 && interp->strKeyTbl != jsiMainInterp->strKeyTbl) {
            Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */
            Jsi_MapDelete(interp->strKeyTbl);
            interp->strKeyTbl = jsiMainInterp->strKeyTbl;
            if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);
        }
        if (interp->subthread)
            jsiMainInterp->threadCnt++;
        if (interp->subthread && interp->strKeyTbl == jsiMainInterp->strKeyTbl)
            jsiMainInterp->threadShrCnt++;
        if (jsiMainInterp->threadShrCnt)
#ifdef JSI_USE_MANY_STRKEY
            jsiMainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;
#else
            jsiMainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;
#endif
    }
    if (parent && parent->isSafe)
        interp->isSafe = 1;
    Jsi_DString oStr = {};
#ifdef JSI_INTERP_OPTS  /* Omits curley braces: eg. "nonStrict: true, maxOpCnt:1000000" */
    if (ocp && *ocp)
        Jsi_DSAppend(&oStr, "{", JSI_INTERP_OPTS, ", ", ocp+1, NULL);
    else
        Jsi_DSAppend(&oStr, "{", JSI_INTERP_OPTS, "}", NULL);
#else
    Jsi_DSAppend(&oStr, ocp, NULL);
#endif
    ocp = Jsi_DSValue(&oStr);
    if (
#ifdef JSI_ENV_OPTS_MAINONLY
        interp == jsiMainInterp  &&
#endif
     *ocp) {
        Jsi_Value *popts = Jsi_ValueNew1(interp);
        if (Jsi_JSONParse(interp, ocp, &popts, 0) != JSI_OK ||
            Jsi_OptionsProcess(interp, InterpOptions, interp, popts, JSI_OPTS_IS_UPDATE) < 0) {
            Jsi_InterpDelete(interp);
            Jsi_DSFree(&oStr);
            return NULL;
        }
        Jsi_DecrRefCount(interp, popts);
    }
    Jsi_DSFree(&oStr);
#ifndef JSI_MEM_DEBUG
    static int warnNoDebug = 0;
    if (interp->memDebug && warnNoDebug == 0) {
        Jsi_LogWarn("ignoring memDebug as jsi was compiled without memory debugging");
        warnNoDebug = 1;
    }
#endif
    interp->threadId = Jsi_CurrentThread();
    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {
        interp->threadId = interp->parent->threadId;
#ifndef JSI_MEM_DEBUG
        Jsi_LogWarn("non-threaded sub-interp created by different thread than parent");
#endif
    }
    if (!interp->parent) {
        if (interp->debugOpts.msgCallback)
            Jsi_LogWarn("ignoring msgCallback");
        if (interp->debugOpts.putsCallback)
            Jsi_LogWarn("ignoring putsCallback");
        if (interp->busyCallback)
            Jsi_LogWarn("ignoring busyCallback");
        if (interp->recvCallback)
            Jsi_LogWarn("ignoring recvCallback");
        if (interp->debugOpts.traceCallback)
            Jsi_LogWarn("ignoring traceCallback");
    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {
        Jsi_LogWarn("disabling busyCallback due to threads");
        interp->busyCallback = NULL;
    }
    if (interp == jsiMainInterp)
        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    else
        interp->lexkeyTbl = jsiMainInterp->lexkeyTbl;
    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);
    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);
    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);
    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);
    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);
#ifdef JSI_MEM_DEBUG
    interp->codesTbl = (interp == jsiMainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiMainInterp->codesTbl);
#endif
    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.proto)
        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->maxArrayList = MAX_ARRAY_LIST;
    if (!jsi_is_init) {
        jsi_is_init = 1;
        jsi_InitValue(interp, 0);
        interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);
    }
    
    /* current scope, also global */
    interp->csc = Jsi_ValueNew1(interp);
    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));
    interp->framePtr->incsc = interp->csc;

#define JSIDOINIT(nam) if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug("Init failure in %s", #nam); }
#define JSIDOINIT2(nam) if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug("Init failure in %s", #nam); }

    JSIDOINIT(Proto);

    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.
        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;
    
    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));
    Jsi_ValueInsert(interp, interp->csc, "Jsi_Auto", modObj, JSI_OM_DONTDEL);
    
    /* initial scope chain, nothing */
    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);
    
    interp->ps = jsi_PstateNew(interp); /* Default parser. */
    if (interp->unitTest&2) {
        interp->logOpts.before = 1;
        interp->logOpts.full = 1;
        interp->tracePuts = 1;
        interp->noStderr = 1;
    }
    if (interp->args && argc) {
        Jsi_LogBug("args may not be specified both as options and parameter");
        Jsi_InterpDelete(interp);
        return NULL;
    }
    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)
        interp->maxDepth = JSI_MAX_EVAL_DEPTH;

    // Create the args array.
    if (argc >= 0 && !interp->args) {
        Jsi_Value *iargs = Jsi_ValueNew1(interp);
        iargs->f.bits.dontdel = 1;
        iargs->f.bits.readonly = 1;
        Jsi_Obj *iobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);
        int i = 1, ii = (iocnt>1 ? iocnt : 1);
        int msiz = (argc?argc-iocnt:0);
        Jsi_ObjArraySizer(interp, iobj, msiz);
        iobj->arrMaxSize = msiz;
        iocnt--;
        iobj->arrCnt = argc-iocnt;
        for (i = 1; ii < argc; ++ii, i++) {
            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);
            Jsi_IncrRefCount(interp, iobj->arr[i-1]);
            jsi_ValueDebugLabel(iobj->arr[i-1], "InterpCreate", "args");
        }
        Jsi_ObjSetLength(interp, iobj, msiz);
        interp->args = iargs;
    } else if (interp->parent && interp->args) {
        // Avoid strings from sneeking in with options from parent...
        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);
        Jsi_DecrRefCount(interp, interp->args);
        interp->args = nar;
    }
    JSIDOINIT(Options);
    JSIDOINIT(Cmds);
    JSIDOINIT(Interp);
    JSIDOINIT(JSON);

    interp->retPtr = Jsi_ValueNew1(interp);
    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
    if (1 || interp->subthread) {
        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
        Jsi_DSInit(&interp->interpEvalQ);
        Jsi_DSInit(&interp->interpMsgQ);
    }
    JSIDOINIT(Lexer);
    if (interp != jsiMainInterp && !parent)
        Jsi_HashSet(interpsTbl, interp, NULL);
        
    if (!interp->isSafe) {
        JSIDOINIT(Load);
#if JSI__SIGNAL==1
        JSIDOINIT(Signal);
#endif
    }
    if (interp->isSafe == 0 || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {
#if JSI__FILESYS==1
        JSIDOINIT(FileCmds);
        JSIDOINIT(Filesys);
#endif
#if JSI__SOCKET==1
    JSIDOINIT2(Socket);
#endif
#if JSI__SQLITE==1
    JSIDOINIT2(Sqlite);
#else
    Jsi_initSqlite(interp, 0);
#endif
#if JSI__MYSQL==1
    JSIDOINIT2(MySql);
#endif
    }
#if JSI__WEBSOCKET==1
    JSIDOINIT2(WebSocket);
#endif

#if JSI__CDATA==1
    JSIDOINIT(CData);
#endif

#ifdef JSI_USER_EXTENSION
    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);
    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {
        fprintf(stderr, "extension load failed");
        return jsi_DoExit(interp, 1);
    }
#endif

    if (argc > 0) {
        char *ss = argv[0];
        char epath[PATH_MAX] = ""; // Path of executable
#ifdef __WIN32
  
        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)
            ss = epath;
#else
#ifndef PROC_SELF_DIR
#define PROC_SELF_DIR "/proc/self/exe"
#endif
        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])
            ss = epath;
#endif
        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);
        Jsi_IncrRefCount(interp, src);
        jsi_execName = Jsi_Realpath(interp, src, NULL);
        Jsi_DecrRefCount(interp, src);
        if (!jsi_execName) jsi_execName = Jsi_Strdup("");
        jsi_execValue = Jsi_ValueNewString(interp, jsi_execName, -1);
        Jsi_IncrRefCount(interp, jsi_execValue);
        Jsi_HashSet(interp->genValueTbl, jsi_execValue, jsi_execValue);
    }
    
    //interp->nocacheOpCodes = 1;
    if (interp->debugOpts.callback && !interp->debugOpts.hook) {
        interp->debugOpts.hook = jsi_InterpDebugHook;
        jsi_StdChans[0].interp =  jsi_StdChans[1].interp = interp =
            jsi_StdChans[2].interp = interp;
    }
    if (interp->profile || interp->coverage)
        interp->startTime = jsi_GetTimestamp();    
#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c
    JSI_INTERP_EXTENSION_CODE
#endif
    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)
        Jsi_LogBug("Init failure in initProc");

    return interp;
}

Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts)
{
    return jsi_InterpNew(NULL, NULL, opts);
}

bool Jsi_InterpGone( Jsi_Interp* interp)
{
    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);
}

static void DeleteAllInterps() { /* Delete toplevel interps. */
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    if (!interpsTbl)
        return;
    for (hPtr = Jsi_HashSearchFirst(interpsTbl, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {
        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);
        Jsi_HashEntryDelete(hPtr);
        interp->destroying = 1;
        Jsi_InterpDelete(interp);
    }
    Jsi_HashDelete(interpsTbl);
    interpsTbl = NULL;
    jsi_is_init = 0;
}

#ifdef JSI_MEM_DEBUG

typedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;

void jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)
{
    Jsi_Value *v;
    int oflags;
    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)
        return;
    if (obj->tree) {
        Jsi_TreeEntry *hPtr;
        Jsi_TreeSearch srch;
        for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr;
            hPtr=Jsi_TreeSearchNext(&srch)) {
            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;
            oflags = v->VD.flags;
            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);
            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)
                continue;
            jsiFlagDebugValues(interp, v->d.obj);
        }
    }
    if (obj->arr) {
        uint i;
        for (i=0; i<obj->arrCnt; i++) {
            v = obj->arr[i];
            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;
            oflags = v->VD.flags;
            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);
            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)
                continue;
            jsiFlagDebugValues(interp, v->d.obj);
        }
    }
}

void jsi_DebugDumpValues(Jsi_Interp *interp)
{
    if (jsiMainInterp != interp) return;
    int vdLev = interp->memDebug;
    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);
    if ((have && vdLev>0) || vdLev>=3) {
        // First traverse all Object trees/arrays and mark all values contained therein.
        Jsi_HashSearch search;
        Jsi_HashEntry *hPtr;
        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);
            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {
                jsiFlagDebugValues(interp, vp);
            }
        }
        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)
            fprintf(stderr, "\n\nValues table/alloc mismatch: table=%d, alloc=%d\n",
                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);
        // Dump unfreed values and objs.
        int refSum=0, refsum=0;
        int bcnt[4] = {};
        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)
            fprintf(stderr, "\n\nUNFREED VALUES \"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\"\n");
        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->valueDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);
            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {
                bcnt[0]++;
                if (vdLev>1)
                    fprintf(stderr, "BAD VALUE: %p\n", vp);
            } else {
                bcnt[1]++;
                refSum += vp->refCnt;
                if (vdLev>1) {
                    char ebuf[BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];
                    ebuf[0] = 0;
                    if (vp->vt==JSI_VT_OBJECT)
                        snprintf(ebuf, sizeof(ebuf), " {obj=%p, otype=%s}", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));
                    else if (vp->vt==JSI_VT_NUMBER)
                        snprintf(ebuf, sizeof(ebuf), " {num=%s}", Jsi_NumberToString(vp->d.num, ebuf2, sizeof(ebuf2)));
                    else if (vp->vt==JSI_VT_BOOL)
                        snprintf(ebuf, sizeof(ebuf), " {bool=%s}", vp->d.val?"true":"false");
                    else if (vp->vt==JSI_VT_STRING) {
                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?"...":"");
                        snprintf(ebuf, sizeof(ebuf), " {string=\"%.40s%s\"}", (vp->d.s.str?vp->d.s.str:""), sbuf);
                    }
                    const char *pfx = "";
                    if (!(vp->VD.flags&MDB_INOBJ))
                        pfx = "!"; // Value is not contained in an object.
                    fprintf(stderr, "[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\n", pfx,
                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,
                        (vp->VD.label?vp->VD.label:""), (vp->VD.label2?":":""),
                        (vp->VD.label2?vp->VD.label2:""), vp->VD.interp==jsiMainInterp?"":"!",
                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);
                }
            }
        }
        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)
            fprintf(stderr, "\n\nObject table/alloc mismatch: table=%d, alloc=%d\n",
                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);
        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)
            fprintf(stderr, "\n\nUNFREED OBJECTS \"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\"\n");
        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);
            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {
                bcnt[2]++;
                fprintf(stderr, "BAD OBJ: %p\n", vp);
            } else {
                bcnt[3]++;
                refsum += vp->refcnt;
                if (vdLev>1) {
                    char ebuf[BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];
                    ebuf[0] = 0;
                    if (vp->ot==JSI_OT_OBJECT) {
                        if (vp->isarrlist)
                            snprintf(ebuf, sizeof(ebuf), "tree#%d, array#%d", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);
                        else
                            snprintf(ebuf, sizeof(ebuf), "tree#%d", (vp->tree?vp->tree->numEntries:0));
                    } else if (vp->ot==JSI_OT_NUMBER)
                        snprintf(ebuf, sizeof(ebuf), "num=%s", Jsi_NumberToString(vp->d.num, ebuf2, sizeof(ebuf2)));
                    else if (vp->ot==JSI_OT_BOOL)
                        snprintf(ebuf, sizeof(ebuf), "bool=%s", vp->d.val?"true":"false");
                    else if (vp->ot==JSI_OT_STRING) {
                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?"...":"");
                        snprintf(ebuf, sizeof(ebuf), "string=\"%.40s%s\"", (vp->d.s.str?vp->d.s.str:""), sbuf);
                    }
                    fprintf(stderr, "[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\n",
                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:"",
                        vp->VD.label2?":":"",vp->VD.label2?vp->VD.label2:"", vp->VD.interp==jsiMainInterp?"":"!",
                        vp->VD.fname, vp->VD.line,
                        vp->VD.func, ebuf);
                }
            }
        }
        fprintf(stderr, "\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d\n",
            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum);

        if (interp->codesTbl)
            for (hPtr = Jsi_HashSearchFirst(interp->codesTbl, &search);
                hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
                Jsi_OpCodes *vp = (Jsi_OpCodes *)Jsi_HashKeyGet(hPtr);
                fprintf(stderr, "unfreed opcodes: %d\n", vp->id);
            }
    }
    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);
    Jsi_HashDelete(interp->dbPtr->objDebugTbl);
    Jsi_HashDelete(interp->codesTbl);
}
#endif

static Jsi_RC jsiInterpDelete(Jsi_Interp* interp, void *unused)
{
    SIGASSERT(interp,INTERP);
    bool isMainInt = (interp == jsiMainInterp);
    int mainFlag = (isMainInt ? 2 : 1);
    if (isMainInt)
        DeleteAllInterps();
    if (interp->opts.initProc)
        (*interp->opts.initProc)(interp, mainFlag);
    jsiDelInterp = interp;
    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);
    //if (interp->csc->d.obj->refcnt>1) /* TODO: This is a hack to release global. */
       // Jsi_ObjDecrRefCount(interp, interp->csc->d.obj);
    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);
    if (interp->ps) jsi_PstateFree(interp->ps);
    int i;
    for (i=0; i<interp->maxStack; i++) {
        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);
        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);
    }
    Jsi_Free(interp->Stack);
    Jsi_Free(interp->Obj_this);

    if (interp->argv0)
        Jsi_DecrRefCount(interp, interp->argv0);
    if (interp->console)
        Jsi_DecrRefCount(interp, interp->console);
    if (interp->lastSubscriptFail)
        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);
    Jsi_HashDelete(interp->assocTbl);
    Jsi_HashDelete(interp->codeTbl);
    Jsi_MapDelete(interp->cmdSpecTbl);
    Jsi_HashDelete(interp->fileTbl);
    Jsi_HashDelete(interp->funcObjTbl);
    Jsi_HashDelete(interp->funcsTbl);
    if (isMainInt)
        Jsi_HashDelete(interp->lexkeyTbl);
    Jsi_HashDelete(interp->protoTbl);
    if (interp->subthread)
        jsiMainInterp->threadCnt--;
    if (interp->subthread && interp->strKeyTbl == jsiMainInterp->strKeyTbl)
        jsiMainInterp->threadShrCnt--;
    if (!jsiMainInterp->threadShrCnt)
#ifdef JSI_USE_MANY_STRKEY
        jsiMainInterp->strKeyTbl->v.tree->opts.lockTreeProc = NULL;
#else
        jsiMainInterp->strKeyTbl->v.hash->opts.lockHashProc = NULL;
#endif
    //Jsi_ValueMakeUndef(interp, &interp->ret);
    Jsi_HashDelete(interp->thisTbl);
    Jsi_HashDelete(interp->eventTbl);
    Jsi_HashDelete(interp->varTbl);
    Jsi_HashDelete(interp->genValueTbl);
    Jsi_HashDelete(interp->genObjTbl);
    Jsi_HashDelete(interp->aliasHash);
    Jsi_HashDelete(interp->regexpTbl);
    if (interp->staticFuncsTbl)
        Jsi_HashDelete(interp->staticFuncsTbl);
    if (interp->breakpointHash)
        Jsi_HashDelete(interp->breakpointHash);
    if (interp->preserveTbl->numEntries!=0)
        Jsi_LogBug("Preserves unbalanced");
    Jsi_HashDelete(interp->preserveTbl);
    if (interp->curDir)
        Jsi_Free(interp->curDir);
    if (isMainInt) {
        jsi_InitFilesys(interp, mainFlag);
    }
#ifndef JSI_OMIT_CDATA
        jsi_InitCData(interp, mainFlag);
#endif
#if JSI__MYSQL==1
        Jsi_InitMySql(interp, mainFlag);
#endif
    if (interp->Mutex)
        Jsi_MutexDelete(interp, interp->Mutex);
    if (interp->QMutex) {
        Jsi_MutexDelete(interp, interp->QMutex);
        Jsi_DSFree(&interp->interpEvalQ);
        Jsi_DSFree(&interp->interpMsgQ);
    }
    if (interp->nullFuncArg)
        Jsi_DecrRefCount(interp, interp->nullFuncArg);
    if (interp->NullValue)
        Jsi_DecrRefCount(interp, interp->NullValue);
    if (interp->Function_prototype_prototype) {
        if (interp->Function_prototype_prototype->refCnt>1)
            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);
        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);
    }
    if (interp->Object_prototype) {
        Jsi_DecrRefCount(interp, interp->Object_prototype);
    }
    if (interp->retPtr)
        Jsi_DecrRefCount(interp, interp->retPtr);
    int profile = interp->profile;
    Jsi_OptionsFree(interp, InterpOptions, interp, 0);
    Jsi_HashDelete(interp->userdataTbl);
    if (interp->inopts)
        Jsi_DecrRefCount(interp, interp->inopts);
    if (interp->safeWriteDirs)
        Jsi_DecrRefCount(interp, interp->safeWriteDirs);
    if (interp->safeReadDirs)
        Jsi_DecrRefCount(interp, interp->safeReadDirs);
    if (interp->pkgDirs)
        Jsi_DecrRefCount(interp, interp->pkgDirs);
    for (i=0; interp->cleanObjs[i]; i++) {
        interp->cleanObjs[i]->tree->opts.freeHashProc = 0;
        Jsi_ObjFree(interp, interp->cleanObjs[i]);
    }
    Jsi_HashDelete(interp->bindTbl);
    for (i = 0; i <= interp->cur_scope; i++)
        jsi_ScopeStrsFree(interp, interp->scopes[i]);
#if JSI__ZVFS==1
    Jsi_InitZvfs(interp, mainFlag);
#endif
    Jsi_HashDelete(interp->loadTbl);
    if (interp->packageHash)
        Jsi_HashDelete(interp->packageHash);
#ifdef JSI_MEM_DEBUG
    jsi_DebugDumpValues(interp);
#endif
    if (profile) { // TODO: resolve some values from dbPtr, others not.
        double endTime = jsi_GetTimestamp();
        double coverage = (int)(100.0*interp->coverHit/interp->coverAll);
        fprintf(stderr, "PROFILE: TOTAL: time=%.6f, func=%.6f, cmd=%.6f, #funcs=%d, #cmds=%d, cover=%2.1f%%, #values=%d, #objs=%d %s%s\n",
            endTime-interp->startTime, interp->funcSelfTime, interp->cmdSelfTime, interp->funcCallCnt, interp->cmdCallCnt,
            coverage, interp->dbPtr->valueAllocCnt,  interp->dbPtr->objAllocCnt,
            interp->parent?" ::":"", (interp->parent&&interp->name?interp->name:""));
    }
    if (isMainInt || interp->strKeyTbl != jsiMainInterp->strKeyTbl)
        Jsi_MapDelete(interp->strKeyTbl);
    if (isMainInt)
        jsiMainInterp = NULL;

    SIGASSERT(interp,INTERP);
    _JSI_MEMCLEAR(interp);
    jsiDelInterp = NULL;
    Jsi_Free(interp);
    return JSI_OK;
}

void Jsi_InterpDelete(Jsi_Interp* interp)
{
    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)
        return;
    interp->deleting = 1;
    Jsi_HashDelete(interp->onDeleteTbl);
    interp->onDeleteTbl = NULL;
    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);
}

typedef struct {
    void *data;
    Jsi_Interp *interp;
    int refCnt;
    Jsi_DeleteProc* proc;
} PreserveData;

void Jsi_Preserve(Jsi_Interp* interp, void *data) {
    bool isNew;
    PreserveData *ptr;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);
    assert(hPtr);
    if (!isNew) {
        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
        if (ptr) {
            assert(interp == ptr->interp);
            ptr->refCnt++;
        }
    } else {
        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));
        Jsi_HashValueSet(hPtr, ptr);
        ptr->interp = interp;
        ptr->data = data;
        ptr->refCnt = 1;
    }
}

void Jsi_Release(Jsi_Interp* interp, void *data) {
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);
    if (!hPtr) return;
    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
    if (!ptr) return;
    assert(ptr->interp == interp);
    if (--ptr->refCnt > 0) return;
    if (ptr->proc)
        (*ptr->proc)(interp, data);
    Jsi_Free(ptr);
    Jsi_HashEntryDelete(hPtr);
}

void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);
    if (!hPtr) {
        (*proc)(interp, data);
        return;
    }
    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
    assert(ptr && ptr->interp == interp);
    JSI_NOWARN(ptr);
    Jsi_HashEntryDelete(hPtr);
}

void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)
{
    Jsi_HashSet(interp->onDeleteTbl, ptr?ptr:(void*)freeProc, (void*)freeProc);
}

static void interpObjErase(InterpObj *fo)
{
    SIGASSERT(fo,INTERPOBJ);
    if (fo->subinterp) {
        Jsi_Interp *interp = fo->subinterp;        
        fo->subinterp = NULL;
        Jsi_InterpDelete(interp);
        /*fclose(fo->fp);
        Jsi_Free(fo->interpname);
        Jsi_Free(fo->mode);*/
    }
    fo->subinterp = NULL;
}

static Jsi_RC interpObjFree(Jsi_Interp *interp, void *data)
{
    InterpObj *fo = (InterpObj *)data;
    SIGASSERT(fo,INTERPOBJ);
    if (fo->deleting) return JSI_OK;
    fo->deleting = 1;
    interpObjErase(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static bool interpObjIsTrue(void *data)
{
    InterpObj *fo = (InterpObj *)data;
    SIGASSERT(fo,INTERPOBJ);
    if (!fo->subinterp) return 0;
    else return 1;
}

static bool interpObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

/* TODO: possibly support async func-callback.  Also for call/send. */
static Jsi_RC InterpEvalCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int flags)
{
    int isFile = flags&2;
    int isUplevel = flags&1;
    int lev = 0;
    bool async = 0;
    Jsi_RC rc = JSI_OK;
    int isthrd;
    Jsi_Interp *sinterp = interp;
    Jsi_ValueMakeUndef(interp, ret);
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (udf)
        sinterp = udf->subinterp;
    if (Jsi_InterpGone(interp) || Jsi_InterpGone(sinterp)) 
        return Jsi_LogError("Sub-interp gone");
    isthrd = (interp->threadId != sinterp->threadId);
    jsi_Frame *f = sinterp->framePtr;
    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);
    if (!isUplevel) {
        if (nw && Jsi_GetBoolFromValue(interp, nw, &async))
            return JSI_ERROR;
    } else {
        if (isthrd) 
            return Jsi_LogError("can not use uplevel() with threaded interp");
        Jsi_Number nlev = sinterp->framePtr->level;
        if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev)!=JSI_OK) 
            return Jsi_LogError("expected number");
        lev = (int)nlev;
        if (lev <= 0)
            lev = f->level+lev;
        if (lev <= 0 || lev > f->level) 
            return Jsi_LogError("level %d not between 1 and %d", (int)nlev, f->level);
    }

    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (cp==NULL || *cp == 0)
        return JSI_OK;
    if (async && isthrd) {
        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */
        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
            return JSI_ERROR;
        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?";":"", cp, NULL);
        Jsi_MutexUnlock(interp, sinterp->QMutex);
        return JSI_OK;
    }
    if (interp->mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
    if (!isthrd) {
        int ostrict = sinterp->strict;
        sinterp->strict = 0;
        sinterp->level++;
        if (interp->framePtr->tryDepth)
            sinterp->framePtr->tryDepth++;
        if (isFile) {
            int sflags = 0;
            if (!sinterp->includeCnt) {
                sflags = JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX;
                sinterp->isMain = 1;
            }
            if (sinterp->debugOpts.callback && !sinterp->includeCnt)  // TODO: safe debugging can't use "source"
                // TODO: we do this in debugger, even though it is illegal for interps to share objects.
                sinterp->autoFiles = Jsi_ValueDup(sinterp, interp->autoFiles);
            sinterp->includeCnt++;
            rc = Jsi_EvalFile(sinterp, Jsi_ValueArrayIndex(interp, args, 0), sflags);
        } else if (isUplevel == 0 || lev <= 1)
            rc = (Jsi_EvalString(sinterp, cp, 0) == 0 ? JSI_OK : JSI_ERROR);
        else {
            rc = (jsi_evalStrFile(sinterp, NULL, cp, 0, lev) == 0 ? JSI_OK : JSI_ERROR);
        }
        sinterp->strict = ostrict;
        if (interp->framePtr->tryDepth) {
            sinterp->framePtr->tryDepth--;
            if (rc != JSI_OK) {
                Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);
                interp->errLine = sinterp->errLine;
                interp->errFile = sinterp->errFile;
                sinterp->errMsgBuf[0] = 0;
            }
        }
        sinterp->level--;
    } else {
        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
            return JSI_ERROR;
        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));
        SIGINIT(s,INTERPSTREVENT);
        s->isExec = 1;
        s->tryDepth = interp->framePtr->tryDepth;
        Jsi_DSInit(&s->data);
        Jsi_DSAppend(&s->data, cp, NULL);
        Jsi_DSInit(&s->func);
        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
        //Jsi_MutexLock(s->mutex);
        se = sinterp->interpStrEvents;
        if (!se)
            sinterp->interpStrEvents = s;
        else {
            while (se->next)
                se = se->next;
            se->next = s;
        }
    
        Jsi_MutexUnlock(interp, sinterp->QMutex);
        while (s->isExec)      /* Wait until done. TODO: timeout??? */
            Jsi_Sleep(interp, 1);
        rc = (s->rc == 0 ? JSI_OK : JSI_ERROR);
        if (rc != JSI_OK)
            Jsi_LogError("eval failed: %s", Jsi_DSValue(&s->data));
        Jsi_DSFree(&s->func);
        Jsi_DSFree(&s->data);
        Jsi_Free(s);
    }

    if (interp->mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        return JSI_ERROR;
    }

    if (Jsi_InterpGone(sinterp))
    {
        /* TODO: perhaps exit() be able to delete. */
        //Jsi_InterpDelete(sinterp);
        return JSI_OK;
    }
    /*if (rc != JSI_OK && !async)
        return rc;*/
    if (sinterp->retPtr->vt != JSI_VT_UNDEF) {
        if (sinterp == interp)
            Jsi_ValueCopy(interp, *ret, sinterp->retPtr);
        else
            Jsi_CleanValue(sinterp, interp, sinterp->retPtr, ret);
    }
    return rc;
}

Jsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc)
{
    if (rc<0 || rc>127) rc = 127;
    if (!interp || !interp->opts.no_exit) {
        if (rc) {
            Jsi_Flush(jsi_Stdout);
            Jsi_Flush(jsi_Stderr);
        }
        exit(rc);
    }
    fprintf(stderr, "ignoring attempted exit: may cause a crash\n");
    if (interp) interp->deleting = 1;
    return NULL;
}

#define FN_interpeval JSI_INFO("\
When the 'async' option is used on a threaded interp, the script is queued as an Event.")

static Jsi_RC InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 0);
}


#define FN_interpuplevel JSI_INFO("\
The level argument is as returned by Info.level().  Not supported with threads.")
static Jsi_RC InterpUplevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 1);
}

static Jsi_RC InterpSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 2);
}

static Jsi_RC InterpValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *sinterp = interp;
    if (udf) {
        if (!udf->subinterp) 
        return Jsi_LogError("Sub-interp gone");
        sinterp = udf->subinterp;
        if (interp->threadId != udf->subinterp->threadId)
            return Jsi_LogError("value not supported with threads");
    }
    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);
    jsi_Frame *f = sinterp->framePtr;
    Jsi_Number nlev = sinterp->framePtr->level;
    if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev))
        return JSI_ERROR;
    int lev = (int)nlev;
    if (lev <= 0)
        lev = f->level+lev;
    if (lev <= 0 || lev > f->level) 
        return Jsi_LogError("level %d not between 1 and %d", (int)nlev, f->level);
    while (f->level != lev  && f->parent)
        f = f->parent;

    const char* arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *val = NULL;
    if (arg) {
        if (f == sinterp->framePtr)
            val = Jsi_NameLookup(sinterp, arg);
        else {
            jsi_Frame *of = sinterp->framePtr;
            sinterp->framePtr = f;
            val = Jsi_NameLookup(sinterp, arg);
            sinterp->framePtr = of;
        }
    }
    if (!val) 
        return Jsi_LogError("unknown var: %s", arg);
    if (sinterp == interp) {
        Jsi_ValueCopy(interp, *ret, val);
        return JSI_OK;
    }
    Jsi_CleanValue(sinterp, interp, val, ret);
    return JSI_OK;
}

static Jsi_RC InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *subinterp = interp;
    if (udf) {
        if (!udf->subinterp) 
            return Jsi_LogError("Sub-interp gone");
        subinterp = udf->subinterp;
    }
    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);
}

Jsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Interp *sinterp = interp;
    Jsi_DString dStr = {}, cStr = {};
    char tbuf[1024];
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    tbuf[0] = 0;
    if (v) {
        InterpObj *udf = NULL;
        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)
            udf = (InterpObj *)v->d.obj->d.uobj->data;
        if (udf && udf->subinterp) {
            SIGASSERT(udf, INTERPOBJ);
            sinterp = udf->subinterp;
        } else 
            return Jsi_LogError("unknown interp");
    }
    if (sinterp->subthread)
        snprintf(tbuf, sizeof(tbuf), ", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }",
            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );
    const char *funcstr = sinterp->framePtr->funcName;
    if (!funcstr)
        funcstr = "";
    int curLine = (sinterp->curIp?sinterp->curIp->Line:0);
    Jsi_DSPrintf(&dStr, "{curLevel:%d, curLine:%d, curFile:\"%s\", curFunc:\"%s\", hasExited:%d, "
        "opCnt:%d, isSafe:%s, depth:%d, codeCacheHits: %d, typeMismatchCnt:%d, "
        "funcCallCnt:%d, cmdCallCnt:%d, includeCnt:%d, includeDepth:%d, pkgReqDepth:%d, "
        "cwd:\"%s\", lockTimeout: %d, name, \"%s\" %s%s};",
        sinterp->level, curLine, jsi_GetCurFile(sinterp), funcstr?funcstr:"", 
        sinterp->exited, sinterp->opCnt, sinterp->isSafe?"true":"false", 
        sinterp->interpDepth, sinterp->codeCacheHit, sinterp->typeMismatchCnt,
        sinterp->funcCallCnt, sinterp->cmdCallCnt, sinterp->includeCnt, sinterp->includeDepth, sinterp->pkgReqDepth,
        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),
        sinterp->lockTimeout, sinterp->name?sinterp->name:"", tbuf[0]?",":"", tbuf);
    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    if (rc != JSI_OK)
        puts(Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&cStr);
    return rc;
}

static Jsi_RC SubInterpEvalCallback(Jsi_Interp *interp, void* data)
{
    Jsi_RC rc = JSI_OK;
    Jsi_DString dStr = {};
    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
        return JSI_ERROR;
    char *cp = Jsi_DSValue(&interp->interpEvalQ);
    if (*cp) {
        Jsi_DSAppend(&dStr, cp, NULL);
        Jsi_DSSetLength(&interp->interpEvalQ, 0);
        interp->threadEvalCnt++;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)
            rc = JSI_ERROR;
        Jsi_DSSetLength(&dStr, 0);
        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
            return JSI_ERROR;
    }
    cp = Jsi_DSValue(&interp->interpMsgQ);
    if (*cp) {
        Jsi_DSAppend(&dStr, cp, NULL);
        Jsi_DSSetLength(&interp->interpEvalQ, 0);
        interp->threadMsgCnt++;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (Jsi_CommandInvokeJSON(interp, interp->recvCallback, Jsi_DSValue(&dStr), NULL) != JSI_OK)
            rc = JSI_ERROR;
        Jsi_DSSetLength(&interp->interpMsgQ, 0);
    } else
        Jsi_MutexUnlock(interp, interp->QMutex);
    Jsi_DSFree(&dStr);
    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    /* Process subevents. */
    InterpStrEvent *oldse, *se = interp->interpStrEvents;
    Jsi_MutexUnlock(interp, interp->QMutex);
    while (se) {
        oldse = se;
        int isExec = se->isExec;
        if (isExec) {
            if (se->tryDepth)
                interp->framePtr->tryDepth++;
            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);
            Jsi_DSSetLength(&se->data, 0);
            if (se->rc != JSI_OK && se->tryDepth) {
                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);
                se->errLine = interp->errLine;
                se->errFile = interp->errFile;
            } else {
                Jsi_ValueGetDString(interp, interp->retPtr, &se->data, JSI_OUTPUT_JSON);
            }
            if (se->tryDepth)
                interp->framePtr->tryDepth--;
                
        /* Otherwise, async calls. */
        } else if (se->objData) {
            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))
                rc = JSI_ERROR;
        } else {
            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), Jsi_DSValue(&se->data), NULL))
                rc = JSI_ERROR;
        }
        if (!isExec) {
            Jsi_DSFree(&se->func);
            Jsi_DSFree(&se->data);
        }
        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
            return JSI_ERROR;
        interp->interpStrEvents = se->next;
        if (!isExec) Jsi_Free(se);
        se = interp->interpStrEvents;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (isExec)
            oldse->isExec = 0;
    }

    return rc;
}


static Jsi_RC ThreadEvalCallback(Jsi_Interp *interp, void* data) {
    Jsi_RC rc;

    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)
        interp->threadErrCnt++;
    return rc;
}

/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */
void jsi_AddEventHandler(Jsi_Interp *interp)
{
    Jsi_Event *ev;
    while (!interp->hasEventHdl) { /* Find an empty event slot. */
        bool isNew;
        uintptr_t id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->handler = ThreadEvalCallback;
        ev->hPtr = hPtr;
        ev->evType = JSI_EVENT_ALWAYS;
        Jsi_HashValueSet(hPtr, ev);
        interp->hasEventHdl = 1;
    }
}

#define FN_call JSI_INFO("\
Invoke function in sub-interp with arguments.  Since interps are not allowed to share objects, \
data is automatically cleansed by encoding/decoding \
to/from JSON if required.  Unless an 'async' parameter of true is given, we wait until the sub-interp is idle, \
make the call, and return the result.  Otherwise the call is acyncronous.")

static Jsi_RC InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    int isthrd;
    Jsi_Interp *sinterp;
    if (udf)
        sinterp = udf->subinterp;
    else 
        return Jsi_LogError("Apply Interp.call in a non-subinterp");
    if (Jsi_InterpGone(sinterp)) 
        return Jsi_LogError("Sub-interp gone");
    isthrd = (interp->threadId != sinterp->threadId);
    
    Jsi_Value *func = NULL;
    char *fname = NULL; 
    func = Jsi_ValueArrayIndex(interp, args, 0);   
    fname = Jsi_ValueString(interp, func, NULL);
    if (!fname) 
        return Jsi_LogError("function name must be a string");
    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)
        return JSI_ERROR;
    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);
    Jsi_MutexUnlock(interp, sinterp->Mutex);
    if (namLU == NULL) 
        return Jsi_LogError("unknown function: %s", fname);
    
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    char *cp = Jsi_ValueString(interp, arg, NULL);

    if (cp == NULL && !Jsi_ValueIsArray(interp, arg)) 
        return Jsi_LogError("expected string or array");

    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 2);
    Jsi_RC rc = JSI_OK;
    bool async = 0;
    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))
        return JSI_ERROR;
    
    if (!async) {
        Jsi_DString dStr = {};
        if (cp == NULL)
            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);
        if (interp->mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {
            if (interp->mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);
            return JSI_ERROR;
        }
        Jsi_Value *srPtr = Jsi_ValueNew1(interp);
        /* TODO: call from this interp may not be safe if threaded. 
         * Could instead use async code below then wait for unlock on se->mutex. */
        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);
        Jsi_DSSetLength(&dStr, 0);
        ConvertReturn(interp, ret, sinterp, &srPtr);
        //Jsi_ValueCopy(interp, *ret, srPtr);
        Jsi_DecrRefCount(interp, srPtr);
        Jsi_DSFree(&dStr);
        Jsi_MutexUnlock(interp, sinterp->Mutex);
        if (interp->mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
            Jsi_LogBug("mutex re-get failed");
            return JSI_ERROR;
        }
        return rc;
    }
    
    /* Post to thread event in sub-interps queue. */
    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    /* Is an async call. */
    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));
    // TODO: is s->data inited?
    Jsi_DSInit(&s->data);
    if (!cp) {
        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);
    }
    Jsi_DSSetLength(&s->data, 0);
    Jsi_DSAppend(&s->data, cp, NULL);
    Jsi_DSInit(&s->func);
    Jsi_DSAppend(&s->func, fname, NULL);
    se = sinterp->interpStrEvents;
    if (!se)
        sinterp->interpStrEvents = s;
    else {
        while (se->next)
            se = se->next;
        se->next = s;
    }

    Jsi_MutexUnlock(interp, sinterp->QMutex);
    if (!isthrd) {
        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)
            sinterp->threadErrCnt++;
    }
    return JSI_OK;
}

Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)
{
#if JSI__ZVFS==1
    return Zvfs_Mount(interp, archive, mount, ret);
#else
    return JSI_ERROR;
#endif
}

/* Looks in dir for autoload.jsi or lib/autoload.jsi to add to autoFiles list. */
int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir) {
    Jsi_DString dStr = {};
    Jsi_StatBuf stat;
    int i, cnt = 0;
    for (i=0; i<2; i++) {
        Jsi_DSAppend(&dStr, dir, (i==0?"/lib":""),"/autoload.jsi", NULL);
        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));
        if (Jsi_Stat(interp, v, &stat) != 0)
            Jsi_ValueFree(interp, v);
        else {
            if (!interp->autoFiles) {
                interp->autoFiles = Jsi_ValueNewArray(interp, 0, 0);
                Jsi_IncrRefCount(interp, interp->autoFiles);
            }
            Jsi_ObjArrayAdd(interp, interp->autoFiles->d.obj, v);
            cnt++;
            interp->autoLoaded = 0;
        }
        Jsi_DSSetLength(&dStr, 0);
    }
    Jsi_DSFree(&dStr);
    return cnt;
}

Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)
{
#if JSI__ZVFS==1
    Jsi_StatBuf stat;
    Jsi_Value *vinit, *vmnt = NULL;
    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);
    Jsi_Value *ret = NULL;
    Jsi_RC rc;
    const char *omntDir = mntDir;
    Jsi_IncrRefCount(interp, vexe);
    Jsi_HashSet(interp->genValueTbl, vexe, vexe);
    if (jsFound)
        *jsFound = 0;
    if (!mntDir)
        ret = Jsi_ValueNew(interp);
    else {
        vmnt = Jsi_ValueNewStringKey(interp, mntDir);
        Jsi_IncrRefCount(interp, vmnt);
        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);
    }
    rc =Jsi_Mount(interp, vexe, vmnt, &ret);
    if (rc != JSI_OK)
        return rc;
    Jsi_DString dStr = {};
    if (!mntDir)
        mntDir = Jsi_ValueString(interp, ret, NULL);
    Jsi_DSAppend(&dStr, mntDir, "/main.jsi", NULL);
    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));
    Jsi_IncrRefCount(interp, vinit);
    Jsi_HashSet(interp->genValueTbl, vinit, vinit);
    Jsi_DSFree(&dStr);
    Jsi_DSAppend(&dStr, mntDir, "/lib", NULL);
    const char *str = Jsi_DSValue(&dStr);
    if (!interp->pkgDirs) {
        interp->pkgDirs = Jsi_ValueNewArray(interp, &str, 1);
        Jsi_IncrRefCount(interp, interp->pkgDirs);
    }
    else
        Jsi_ValueArrayPush(interp, interp->pkgDirs, Jsi_ValueNewStringKey(interp, str));
    Jsi_DSFree(&dStr);
    if (Jsi_Stat(interp, vinit, &stat) == 0) {
        if (jsFound)
            *jsFound |= JSI_ZIP_MAIN;
        interp->execZip = vexe;
        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);
    } else {
        if (Jsi_AddAutoFiles(interp, mntDir) && omntDir)
            *jsFound = JSI_ZIP_INDEX;
    }
#endif
    return JSI_OK;
}

#define FN_send JSI_INFO("\
Add messages to queue to be processed by the 'recvCallback' interp option.")

static Jsi_RC InterpSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    //return SendCmd(interp, args, _this, ret, funcPtr, 1);
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *sinterp = NULL;
    int isthrd;
    if (udf) {
        sinterp = udf->subinterp;
    } else {
        sinterp = interp->parent;
        if (!sinterp) 
            return Jsi_LogError("Apply Interp.send in a non-subinterp");
    }

    if (Jsi_InterpGone(sinterp)) 
        return Jsi_LogError("Sub-interp gone");
    isthrd = (interp->threadId != sinterp->threadId);
    if (!sinterp->recvCallback) 
        return Jsi_LogError("interp was not created with 'recvCallback' option");

    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char *cp = Jsi_ValueString(interp, arg, NULL);

    /* Post to thread event in sub-interps queue. */
    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    int slen = Jsi_Strlen(Jsi_DSValue(&sinterp->interpMsgQ));
    Jsi_DString eStr = {};
    if (!cp) {
        cp = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);
    }
    if (!slen)
        Jsi_DSAppend(&sinterp->interpMsgQ, "[", cp, "]", NULL);
    else {
        Jsi_DSSetLength(&sinterp->interpMsgQ, slen-1);
        Jsi_DSAppend(&sinterp->interpMsgQ, ", ", cp, "]", NULL);
    }
    // if (interp->parent) printf("SENDING: %s\n", Jsi_DSValue(&sinterp->interpMsgQ));
    Jsi_DSFree(&eStr);

    Jsi_MutexUnlock(interp, sinterp->QMutex);
    if (!isthrd) {
        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)
            sinterp->threadErrCnt++;
    }
    return JSI_OK;

}

#ifndef JSI_OMIT_THREADS

#ifdef __WIN32
#define JSITHREADRET void
#else
#define JSITHREADRET void*
#endif

static JSITHREADRET NewInterpThread(void* iPtr)
{
    int rc = JSI_OK;
    InterpObj *udf = (InterpObj *)iPtr;
    Jsi_Interp *interp = udf->subinterp;
    interp->threadId = Jsi_CurrentThread();
    if (interp->scriptStr)
        rc = Jsi_EvalString(interp, interp->scriptStr, 0);
    else if (interp->scriptFile) {
        if (interp->debugOpts.callback == 0) // Debug will use Interp.source() instead.
            Jsi_EvalFile(interp, interp->scriptFile, 0); 
    } else {
        jsi_AddEventHandler(interp); 
        int mrc = Jsi_MutexLock(interp, interp->Mutex);      
        while (mrc == JSI_OK) {
            if (Jsi_EventProcess(interp, -1)<0)
                break;
            Jsi_Sleep(interp, 1);
        }
    }
    if (rc != JSI_OK) {
        Jsi_LogError("eval failure");
        interp->threadErrCnt++;
    }
    interpObjErase(udf);
#ifndef __WIN32
    /* TODO: should we wait/notify parent??? */
    pthread_detach(pthread_self());
    return NULL;
#endif
}
#endif

static Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
static Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    
static Jsi_CmdSpec interpCmds[] = {
    { "Interp", InterpConstructor,0,  1, "options:object=void", .help="Create a new interp", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=InterpOptions},
    { "alias",  InterpAliasCmd,   0,  3, "name:string=void, func:function|null=void, args:array|null=void",.help="Set/get global alias bindings for command in an interp", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_intalias },
    { "call",   InterpCallCmd,    2,  3, "funcName:string, args:string|array, async:boolean=false", .help="Call named function in subinterp", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_call },
    { "conf",   InterpConfCmd,    0,  1, "options:string|object=void",.help="Configure option(s)" , .retType=(uint)JSI_TT_ANY,.flags=0,.info=0,.opts=InterpOptions},
    { "eval",   InterpEvalCmd,    1,  2, "js:string, async:boolean=false", .help="Interpret script within sub-interp", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },
    { "info",   InterpInfoCmd,    0,  0, "", .help="Returns internal statistics about interp", .retType=(uint)JSI_TT_OBJECT },
    { "send",   InterpSendCmd,    1,  1, "msg:any", .help="Enqueue message onto a sub-interps recvCallback handler", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_send },
    { "source", InterpSourceCmd,  1,  2, "file:string, async:boolean=false", .help="Interpret file within sub-interp", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },
    { "uplevel",InterpUplevelCmd, 2,  2, "js:string, level:number=0", .help="Interpret code at the given stack level: see Info.level()", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpuplevel },
    { "value",  InterpValueCmd,   1,  2, "var:string, level:number=0", .help="Lookup value of variable at stack level: see Info.level()", .retType=(uint)JSI_TT_ANY },
    { NULL,     0,0,0,0, .help="Commands for accessing interps" }
};

static Jsi_UserObjReg interpobject = {
    "Interp",
    interpCmds,
    interpObjFree,
    interpObjIsTrue,
    interpObjEqual
};


static Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *fobj;
    Jsi_Value *toacc;
    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));
    int rc = JSI_OK;
    SIGINIT(cmdPtr,INTERPOBJ);
    cmdPtr->parent = interp;

    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);

    if (!(cmdPtr->subinterp = jsi_InterpNew(interp, arg, NULL))) {
        Jsi_Free(cmdPtr);
        return JSI_ERROR;
    }
    Jsi_Interp *sinterp = cmdPtr->subinterp;
    sinterp->opts.no_exit = interp->opts.no_exit;
    toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Interp", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)
        goto bail;
    sinterp->objId = cmdPtr->objId;
    cmdPtr->fobj = fobj;
#ifndef JSI_OMIT_THREADS
    if (sinterp->subthread) {
#ifdef __WIN32
        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {
            Jsi_LogError("thread create failed");
            goto bail;
        }
#else
        pthread_t nthread;
        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {
            Jsi_LogError("thread create failed");
            goto bail;
        }
#endif //__WIN32
#else
    if (0) {
#endif //JSI_OMIT_THREADS
    } else {
        //sinterp->framePtr->tryDepth++;
        if (sinterp->scriptStr != 0) {
            if (sinterp->scriptFile && !interp->curFile)
                sinterp->curFile = Jsi_ValueString(sinterp, sinterp->scriptFile, NULL);
            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, 0);
        } else if (sinterp->scriptFile != 0 && sinterp->debugOpts.callback == NULL) {
            int len;
            if (Jsi_ValueString(interp, sinterp->scriptFile, &len) && len==0)
                Jsi_Interactive(sinterp, 0);
            else
                rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, 0);        
        }
        //sinterp->framePtr->tryDepth--;
        if (rc == JSI_EXIT)
            return JSI_OK;
        if (rc != JSI_OK) {
            /*Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);
            interp->errLine = sinterp->errLine;
            interp->errFile = sinterp->errFile;
            sinterp->errMsgBuf[0] = 0;*/
            goto bail;
        }
    }
    return JSI_OK;
    
bail:
    interpObjErase(cmdPtr);
    Jsi_ValueMakeUndef(interp, ret);
    return JSI_ERROR;
}

static Jsi_RC Jsi_DoneInterp(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &interpobject);
    return JSI_OK;
}

static Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_RC rc;
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Interp *sinterp = interp;
    bool ostrict;
    if (!udf || udf->subinterp == interp) {
        ostrict = interp->strict;
        rc = Jsi_OptionsConf(interp, InterpOptions, interp, opts, ret, 0);
    } else {
        sinterp = udf->subinterp;
        ostrict = sinterp->strict;
        Jsi_Value *popts = opts;
        if (opts && opts->vt != JSI_VT_NULL && !Jsi_ValueString(interp, opts, NULL) && opts->vt == JSI_VT_OBJECT) {
            popts = Jsi_ValueNew1(sinterp);
            Jsi_CleanValue(interp, sinterp, opts, &popts);
        }
        rc = Jsi_OptionsConf(sinterp, InterpOptions, sinterp, popts, ret, 0);
        if (popts && popts != opts)
            Jsi_DecrRefCount(sinterp, popts);
        Jsi_CleanValue(sinterp, interp, *ret, ret);
    }
    if (ostrict != sinterp->strict)
        sinterp->framePtr->strict = sinterp->strict;
    return rc;
}

Jsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {
    return interp->retPtr;
}

Jsi_RC jsi_InitInterp(Jsi_Interp *interp, int release)
{
    if (release) return Jsi_DoneInterp(interp);
    Jsi_Hash *isys;
    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))
        Jsi_LogBug("Can not init interp");

    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

bool Jsi_InterpSafe(Jsi_Interp *interp)
{
    return interp->isSafe;
}

Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* file, int toWrite)
{
    Jsi_Value *v, *dirs = (toWrite ? interp->safeWriteDirs : interp->safeReadDirs);
    if (!interp->isSafe)
        return JSI_OK;
    if (!dirs)
        return JSI_ERROR;
    int i, n, m, argc = Jsi_ValueGetLength(interp, dirs);
    char *str, *dstr = Jsi_ValueString(interp, file, &n); /* TODO: normalize? */
    if (!dstr)
        return JSI_ERROR;
    char *scp = Jsi_Strrchr(dstr, '/');
    if (scp)
        n -= Jsi_Strlen(scp);
    for (i=0; i<argc; i++) {
        v = Jsi_ValueArrayIndex(interp, dirs, i);
        str = Jsi_ValueString(interp, v, &m);
        if (!str) continue;
        if (Jsi_Strncmp(str, dstr, m) == 0 && (n==m || dstr[m] == '/'))
            return JSI_OK;
        else if (Jsi_Strcmp(str,".") == 0 && !scp)
            return JSI_OK;
    }
    return JSI_ERROR;
}

Jsi_Value *Jsi_InterpResult(Jsi_Interp *interp)
{
    return interp->retPtr;
}

const char *Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr)
{
    if (errFilePtr)
        *errFilePtr = interp->errFile;
    if (errLinePtr)
        *errLinePtr = interp->errLine;
    return interp->errMsgBuf;
}

#ifdef __WIN32
void bzero(void *s, size_t n) {
    memset(s, 0, n);
}
#endif
#endif
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <errno.h>
#include <sys/time.h>


#if (defined(JSI__READLINE) && JSI__READLINE==1)
#define JSI_HAS_READLINE 1
//#define USE_GNU_READLINE
#ifdef USE_GNU_READLINE
# include <readline/readline.h>
# include <readline/history.h>

# define jsi_sh_add_history(X) add_history(X)
# define jsi_sh_read_history(X) read_history(X)
# define jsi_sh_write_history(X) write_history(X)
# define jsi_sh_stifle_history(X) stifle_history(X)
# define jsi_sh_readline(X) readline(X)
#else
#ifndef JSI_AMALGAMATION
#include "linenoise.h"
#endif
# define jsi_sh_add_history(X) linenoiseHistoryAdd(X)
# define jsi_sh_read_history(X) linenoiseHistoryLoad(X)
# define jsi_sh_write_history(X) linenoiseHistorySave(X)
# define jsi_sh_stifle_history(X) linenoiseHistorySetMaxLen(X)
# define jsi_sh_readline(X) linenoise(X)
#endif
#else

# define jsi_sh_read_history(X)
# define jsi_sh_write_history(X)
# define jsi_sh_stifle_history(X)

# define JSI_SH_USE_LOCAL_GETLINE 1
#endif
#include <math.h>

#ifdef Jsi_Free
#undef Jsi_Free
#undef Jsi_Malloc
#undef Jsi_Calloc
#undef Jsi_Realloc
#endif
void* Jsi_Realloc(void *m,unsigned int size) {
    void *v = realloc(m,size);
    return v;
}
void* Jsi_Malloc(unsigned int size) {
    void *v = malloc(size);
    return v;
}
void* Jsi_Calloc(unsigned int n,unsigned int size) {
    void *v = calloc(n,size);
    return v;
}
void  Jsi_Free(void *n) { free(n); }

#if JSI__SANITIZE
#define Jsi_Malloc(sz) malloc(sz)
#define Jsi_Calloc(nm, sz) calloc(nm,sz)
#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)
#define Jsi_Free(ptr) free(ptr)
#endif

static const char *jsi_LogCodes[] = { "bug", "error", "warn", "info", "debug", "parse", 0 };

#ifdef JSI_LITE_ONLY
Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {
    va_list va;
    va_start (va, format);
    const char *mt = (code <= JSI_LOG_PARSE ? jsi_LogCodes[code] : "");
    fputs(mt, stderr);
    vfprintf(stderr, format, va);
    fputs("\n", stderr);
    va_end(va);
    return JSI_ERROR;
}

#else // JSI_LITE_ONLY

int jsi_fatalexit = JSI_LOG_BUG;
const char *jsi_GetCurFile(Jsi_Interp *interp)
{
    const char *curFile = NULL;
    if (!interp)
        return NULL;
    if (interp->inParse)
        curFile = interp->curFile;
    else
        curFile = (interp->curIp && interp->curIp->fname? interp->curIp->fname:interp->curFile);
    if (!curFile) curFile = interp->framePtr->fileName;
    if (!curFile) curFile = "";
    return curFile;
}
extern void jsi_TypeMismatch(Jsi_Interp* interp)
{
    interp->typeMismatchCnt++;
    if (interp->typeWarnMax<=0)
        return;
    if (interp->typeMismatchCnt>=interp->typeWarnMax) {
        memset(&interp->typeCheck, 0, sizeof(interp->typeCheck));
        Jsi_LogWarn("Max warnings exceeded %d: typeCheck disabled", interp->typeWarnMax);
    }
}

static void (*logHook)(const char *buf, va_list va) = NULL;

// Format message: always returns JSI_ERROR.
Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {
    va_list va;
    va_start (va, format);
    char pbuf[BUFSIZ/8] = "";
    char buf[BUFSIZ/2];
    const char *term = "", *pterm=pbuf;
    static char lastMsg[BUFSIZ/2] = "";
    static int lastCnt = 0;
    const char *emsg = buf, *mt;
    int islog, line = 0, lofs = 0;

    if (interp==NULL)
        interp = jsiMainInterp;

    const char *curFile = jsi_GetCurFile(interp);
    /* Filter out try/catch (TODO: and non-syntax errors??). */
    if (code == JSI_LOG_PARSE || interp == NULL) {
        if (logHook)
            (*logHook)(format, va);
        else {
            vfprintf(stderr, format, va);
            fputc('\n', stderr);
        }
        va_end(va);
        return JSI_ERROR;
    }
        
    if (code == JSI_LOG_ERROR && (interp->framePtr->tryDepth - interp->framePtr->withDepth)>0 && interp->inParse<=0 ) { 
        /* Should only do the first or traceback? */
        if (!interp->errMsgBuf[0]) {
            vsnprintf(interp->errMsgBuf, sizeof(interp->errMsgBuf), format, va);
            //interp->errMsgBuf[sizeof(interp->errMsgBuf)-1] = 0;
            interp->errFile = curFile;
            interp->errLine = (interp->curIp?interp->curIp->Line:0);
            emsg = interp->errMsgBuf;
        }
        goto done;
    }
    mt = (code <= JSI_LOG_PARSE ? jsi_LogCodes[code] : "");
    assert((JSI_LOG_PARSE+2) == (sizeof(jsi_LogCodes)/sizeof(jsi_LogCodes[0])));
    if (!Jsi_Strchr(format,'\n')) term = "\n";
    if (code != JSI_LOG_INFO && interp && interp->lastPushStr && interp->lastPushStr[0]) {
        char *ss = interp->lastPushStr;
        char psbuf[BUFSIZ/6];
        if (Jsi_Strchr(ss,'%')) {
            char *s = ss, *sd = psbuf;
            int plen=0, llen = sizeof(psbuf)-2;
            while (*s && plen<llen) {
                if (*s == '%')
                    sd[plen++] = '%';
                sd[plen++] = *s;
                s++;
            }
            sd[plen] = 0;
            ss = psbuf;
        }
        while (*ss && isspace(*ss))
            ss++;
        if (*ss)
            snprintf(pbuf, sizeof(pbuf), "    (at or near \"%s\")\n", ss);
    }
    pbuf[sizeof(pbuf)-1] = 0;
    if (interp->inParse && interp->parseLine) {
        line = interp->parseLine->first_line;
        lofs = interp->parseLine->first_column;
    } else if (interp->curIp) {
        line = interp->curIp->Line;
        lofs = interp->curIp->Lofs;
        if (line<=0)
            line = interp->framePtr->line;
    }
    islog = (interp->parent && interp->debugOpts.msgCallback && code != JSI_LOG_BUG);
    if (interp && curFile && curFile[0] && Jsi_Strchr(curFile,'%')==0 && !islog) {
        if (!interp->showColumns)
            snprintf(buf, sizeof(buf), "%s:%d: %s: %s%s%s",  curFile, line, mt,format, pterm, term);
        else
            snprintf(buf, sizeof(buf), "%s:%d.%d: %s: %s%s%s",  curFile, line, lofs, mt,format, pterm, term);
    } else {
        snprintf(buf, sizeof(buf), "%s: %s%s%s", mt, format, pterm, term);
    }
    buf[sizeof(buf)-1]=0;

    if (logHook)
        (*logHook)(buf, va);
    else if (interp->msgAllowDups)
        vfprintf(stderr, buf, va);
    else {
        char buf1[BUFSIZ/2];
        vsnprintf(buf1, sizeof(buf1), buf, va);
        if (buf1[0] && lastCnt && Jsi_Strcmp(buf1, lastMsg)==0) {
            lastCnt++;
            goto done;
        } else if (lastMsg[0] && lastCnt>1 ) {
            fprintf(stderr, "REPEAT: Last msg repeated %d times...\"\n" ,lastCnt);
        }
        if (buf1[0] == 0 || (buf1[0] == '.' && buf1[1] == 0))
            goto done;
        lastCnt = 1;
        Jsi_Strcpy(lastMsg, buf1);
        if (!islog)
            fputs(buf1, stderr);
        else {
            Jsi_DString jStr={}, kStr={};
            Jsi_DSPrintf(&kStr, "[%s, \"%s\", \"%s\", %d, %d ]",
                Jsi_JSONQuote(interp, buf1, -1, &jStr), mt, curFile, line, lofs);
            if (Jsi_CommandInvokeJSON(interp->parent, interp->debugOpts.msgCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)
                code = 1;
            Jsi_DSFree(&jStr);
            Jsi_DSFree(&kStr);
        }
    }
done:
    va_end(va);
    if (interp->debugOpts.hook) {
        static int inhook = 0;
        if (!inhook) {
            inhook = 1;
            (*interp->debugOpts.hook)(interp, curFile, interp->curIp?interp->curIp->Line:0, interp->level, interp->curFunction, "DEBUG", NULL, emsg);
        }
        inhook = 0;
    }
    if ((code & jsi_fatalexit) && !interp->opts.no_exit)
        jsi_DoExit(interp, 1);
    return JSI_ERROR;
}

const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str)
{
    Jsi_MapEntry *hPtr;
    bool isNew;
    hPtr = Jsi_MapEntryNew(interp->strKeyTbl, str, &isNew);
    assert(hPtr) ;
    return (const char*)Jsi_MapKeyGet(hPtr, 0);
}

const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str)
{
    Jsi_MapEntry *hPtr;
    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);
    if (!hPtr) {
        return NULL;
    }
    return (const char*)Jsi_MapKeyGet(hPtr, 0);
}


Jsi_Value *Jsi_VarLookup(Jsi_Interp *interp, const char *varname)
{
    Jsi_Value *v;
    v = Jsi_ValueObjLookup(interp, interp->framePtr->incsc, (char*)varname, 0);
    if (!v)
        v = jsi_ScopeChainObjLookupUni(interp->framePtr->ingsc, (char*)varname);
    return v;
}

static char *FindEndB(char *cp) {
    
    if (*cp == '\"'||*cp == '\'') {
        char endc = *cp;
        cp++;
        while (*cp && *cp != endc) {
            if (*cp == '\\' && cp[1]) cp++;
            cp++;
        }
        if (*cp == endc)
            cp++;
        if (*cp != ']')
            return NULL;
        return cp;
    } else
        return Jsi_Strchr(cp, ']');
}


/* Lookup "name" within object "inObj", ie.  "inObj.name"  */
Jsi_Value *Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj)
{
    Jsi_Value *v;
    if (!name)
        return NULL;
    if (!inObj)
        return Jsi_VarLookup(interp, name);
    v = Jsi_VarLookup(interp, inObj);
    if (!v)
        return NULL;
    if (Jsi_ValueIsArray(interp, v)) {
        int n;
        if (!isdigit(name[0]))
            return NULL;
        if (Jsi_GetInt(interp, name, &n, 0) != JSI_OK)
            return NULL;
        if (n>=0 && n<(int)v->d.obj->arrCnt)
            return v->d.obj->arr[n];
        return NULL;
    }
    if (v->vt != JSI_VT_OBJECT || (v->d.obj->ot != JSI_OT_OBJECT && v->d.obj->ot != JSI_OT_FUNCTION))
        return NULL;
    return Jsi_ValueObjLookup(interp, v, name, 0);
}

/* Lookup a name, eg.  "a[b].c  a.b.c  a[b][c]  a.b[c]  a["b"].c  a[1].c  */
Jsi_Value *Jsi_NameLookup(Jsi_Interp *interp, const char *name)
{
    uint cnt = 0, len, isq;
    char *nam = (char*)name, *cp, *cp2, *ocp, *kstr;
    DECL_VALINIT(tv);
    DECL_VALINIT(nv);
    DECL_VALINIT(key);
    Jsi_Value *v = NULL, *nvPtr = &nv;
    Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.
    Jsi_DString dStr = {};
    cp2 = Jsi_Strchr(nam,'[');
    cp = Jsi_Strchr(nam, '.');
    if (cp2 && (cp==0 || cp2<cp))
        cp = cp2;
    if (!cp)
        return Jsi_VarLookup(interp, nam);
    Jsi_DSSetLength(&dStr, 0);
    Jsi_DSAppendLen(&dStr, nam, cp-nam);
    v = Jsi_VarLookup(interp, Jsi_DSValue(&dStr));
    if (!v)
        goto bail;
    while (cnt++ < 1000) {
        ocp = cp;
        nam = cp+1;
        isq = 0;
        if (*cp == '[') {
            cp = FindEndB(cp+1); /* handle [] in strings. */
            if (!cp) goto bail;
            len = cp-nam;
            cp++;
            if (len>=2 && ((nam[0] == '\"' && nam[len-1] == '\"') || (nam[0] == '\'' && nam[len-1] == '\''))) {
                nam += 1;
                len -= 2;
                isq = 1;
            }
        } else if (*cp == '.') {
            cp2 = Jsi_Strchr(nam,'[');
            cp = Jsi_Strchr(nam, '.');
            if (cp2 && (cp==0 || cp2<cp))
                cp = cp2;
            len = (cp ? (uint)(cp-nam) : Jsi_Strlen(nam));
        } else {
            goto bail;
        }
        Jsi_DSSetLength(&dStr, 0);
        Jsi_DSAppendLen(&dStr, nam, len);
        kstr = Jsi_DSValue(&dStr);
        if (*ocp == '[' && isq == 0 && isdigit(kstr[0]) && Jsi_ValueIsArray(interp, v)) {
            int nn;
            if (Jsi_GetInt(interp, kstr, &nn, 0) != JSI_OK)
                goto bail;
            v = Jsi_ValueArrayIndex(interp, v, nn);
            if (!v)
                goto bail;
        } else if (*ocp == '[' && isq == 0) {
            Jsi_Value *kv = Jsi_VarLookup(interp, kstr);
            if (!kv)
                goto bail;
            jsi_ValueSubscriptLen(interp, v, kv, &nvPtr, 1);
            goto keyon;
        } else {
            Jsi_ValueMakeStringKey(interp, &kPtr, kstr);
            jsi_ValueSubscriptLen(interp, v, kPtr, &nvPtr, 1);
keyon:
            if (nv.vt == JSI_VT_UNDEF)
                goto bail;
            else {
                tv = nv;
                v = &tv;
            }
        }
        if (cp == 0 || *cp == 0) break;
    }
    //Jsi_ValueReset(interp, &ret);
    Jsi_DSFree(&dStr);
    if (v && v == &tv) {
        v = Jsi_ValueNew(interp);
        //Jsi_ValueMove(interp, v, &tv);
#ifdef JSI_MEM_DEBUG
        memcpy(v, &tv, sizeof(tv)-sizeof(tv.VD));
        v->VD.label3 = tv.VD.func;
        if (interp->memDebug>1)
            v->VD.label2 = Jsi_KeyAdd(interp, name);
#else
        *v = tv;
#endif
    }
    return v;
bail:
    Jsi_DSFree(&dStr);
    return NULL;
}

Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp)
{
    return interp->csc;
}

typedef struct {
    Jsi_DString *dStr;
    int quote; /* Set to JSI_OUTPUT_JSON, etc*/
    int depth;
} objwalker;

static int IsAlnumStr(const char *cp)
{
    while (*cp)
        if (isalnum(*cp) || *cp == '_')
            cp++;
        else
            return 0;
    return 1;
}

static void jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr);

static Jsi_RC _object_get_callback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_Value *v;
    objwalker *ow = (objwalker *)data;
    Jsi_DString *dStr = ow->dStr;
    int len;
    char *str;
    if ((hPtr->f.bits.dontenum))
        return JSI_OK;
    v =(Jsi_Value*) Jsi_TreeValueGet(hPtr);
    if ((ow->quote&JSI_OUTPUT_JSON) && v && v->vt == JSI_VT_UNDEF)
        return JSI_OK;
    str = (char*)Jsi_TreeKeyGet(hPtr);
    char *cp = Jsi_DSValue(dStr);
    len = Jsi_DSLength(dStr);
    if (len>=2 && (cp[len-2] != '{' || cp[len-1] == '}'))
        Jsi_DSAppend(dStr, ", ", NULL);
    if (((ow->quote&JSI_OUTPUT_JSON) == 0 || (ow->quote&JSI_JSON_STRICT) == 0) && IsAlnumStr(str)
        && !Jsi_HashEntryFind(tree->opts.interp->lexkeyTbl, str))
        Jsi_DSAppend(dStr, str, NULL);
    else
        /* JSON/spaces, etc requires quoting the name. */
        Jsi_DSAppend(dStr, "\"", str, "\"", NULL);
    Jsi_DSAppend(dStr, ":", NULL);
    ow->depth++;
    jsiValueGetString(tree->opts.interp, v, dStr, ow);
    ow->depth--;
    return JSI_OK;
}

/* Format value into dStr.  Toplevel caller does init/free. */
static void jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr)
{
    char buf[100], *str;
    Jsi_DString eStr;
    Jsi_DSInit(&eStr);
    if (owPtr->depth > interp->maxDepth) {
        Jsi_LogError("recursive ToString");
        return;
    }
    int quote = owPtr->quote;
    int isjson = owPtr->quote&JSI_OUTPUT_JSON;
    Jsi_Number num;
    switch(v->vt) {
        case JSI_VT_UNDEF:
            Jsi_DSAppend(dStr, "undefined", NULL);
            return;
        case JSI_VT_NULL:
            Jsi_DSAppend(dStr, "null", NULL);
            return;
        case JSI_VT_VARIABLE:
            Jsi_DSAppend(dStr, "variable", NULL);
            return;
        case JSI_VT_BOOL:
            Jsi_DSAppend(dStr, (v->d.val ? "true":"false"), NULL);
            return;
        case JSI_VT_NUMBER:
            num = v->d.num;
outnum:
            if (isjson && !Jsi_NumberIsNormal(num)) {
                Jsi_DSAppend(dStr, "null", NULL);
            } else if (Jsi_NumberIsInteger(num)) {
                snprintf(buf, sizeof(buf), "%d", (int)num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (Jsi_NumberIsWide(num)) {
                snprintf(buf, sizeof(buf), "%" PRId64, (Jsi_Wide)num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (Jsi_NumberIsNormal(num) || Jsi_NumberIsSubnormal(num)) {
                snprintf(buf, sizeof(buf), "%" JSI_NUMGFMT, num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (Jsi_NumberIsNaN(num)) {
                Jsi_DSAppend(dStr, "NaN", NULL);
            } else {
                int s = Jsi_NumberIsInfinity(num);
                if (s > 0) Jsi_DSAppend(dStr, "+Infinity", NULL);
                else if (s < 0) Jsi_DSAppend(dStr, "-Infinity", NULL);
                else Jsi_LogBug("Ieee function problem: %d", fpclassify(num));
            }
            return;
        case JSI_VT_STRING:
            str = v->d.s.str;
outstr:
            if (!quote) {
                Jsi_DSAppend(dStr, str, NULL);
                return;
            }
            Jsi_DSAppend(dStr,"\"", NULL);
            while (*str) {
                if ((*str == '\'' && (!isjson)) || *str == '\\'|| *str == '\"'|| (*str == '\n'
                    && (!(owPtr->quote&JSI_OUTPUT_NEWLINES)))
                    || *str == '\r' || *str == '\t' || *str == '\f' || *str == '\b'  ) {
                    char pcp[2];
                    *pcp = *str;
                    pcp[1] = 0;
                    Jsi_DSAppendLen(dStr,"\\", 1);
                    switch (*str) {
                        case '\r': *pcp = 'r'; break;
                        case '\n': *pcp = 'n'; break;
                        case '\t': *pcp = 't'; break;
                        case '\f': *pcp = 'f'; break;
                        case '\b': *pcp = 'b'; break;
                    }
                    Jsi_DSAppendLen(dStr,pcp, 1);
                } else if (isprint(*str) || !isjson)
                    Jsi_DSAppendLen(dStr,str, 1);
                else {
                    char ubuf[10];
                    int l = Jsi_UtfEncode(str, ubuf);
                    Jsi_DSAppend(dStr,ubuf, NULL);
                    str += l-1;
                }
                str++;
            }
            Jsi_DSAppend(dStr,"\"", NULL);
            Jsi_DSFree(&eStr);
            return;
        case JSI_VT_OBJECT: {
            Jsi_Obj *o = v->d.obj;
            switch(o->ot) {
                case JSI_OT_BOOL:
                    Jsi_DSAppend(dStr, (o->d.val ? "true":"false"), NULL);
                    return;
                case JSI_OT_NUMBER:
                    num = o->d.num;
                    goto outnum;
                    return;
                case JSI_OT_STRING:
                    str = o->d.s.str;
                    goto outstr;
                case JSI_OT_FUNCTION:
                    Jsi_FuncObjToString(interp, o->d.fobj->func, &eStr, 3);
                    str = Jsi_DSValue(&eStr);
                    goto outstr;
                case JSI_OT_REGEXP:
                    str = o->d.robj->pattern;
                    goto outstr;
                case JSI_OT_USEROBJ:
                    jsi_UserObjToName(interp, o->d.uobj, &eStr);
                    str = Jsi_DSValue(&eStr);
                    goto outstr;
                case JSI_OT_ITER:
                    Jsi_DSAppend(dStr, (isjson?"null":"*ITER*"), NULL);
                    return;
                default:
                    break;
            }
                        
            if (o->isarrlist)
            {
                Jsi_Value *nv;
                int i, len = o->arrCnt;
                
                if (!o->arr)
                    len = Jsi_ValueGetLength(interp, v);
                Jsi_DSAppend(dStr,"[",len?" ":"", NULL);
                for (i = 0; i < len; ++i) {
                    nv = Jsi_ValueArrayIndex(interp, v, i);
                    if (i) Jsi_DSAppend(dStr,", ", NULL);
                    if (nv) jsiValueGetString(interp, nv, dStr, owPtr);
                    else Jsi_DSAppend(dStr, "undefined", NULL);
                }
                Jsi_DSAppend(dStr,len?" ":"","]", NULL);
            } else {
                int len = Jsi_TreeSize(o->tree);
                Jsi_DSAppend(dStr,"{",len?" ":"", NULL);
                owPtr->depth++;
                Jsi_TreeWalk(o->tree, _object_get_callback, owPtr, 0);
                owPtr->depth--;
                Jsi_DSAppend(dStr,len?" ":"","}", NULL);
            }
            return;
        }
#ifndef __cplusplus
        default:
            Jsi_LogBug("Unexpected value type: %d", v->vt);
#endif
    }
}

/* Format value into dStr.  Toplevel caller does init/free. */
const char* Jsi_ValueGetDString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, int quote)
{
    objwalker ow;
    ow.quote = quote;
    ow.depth = 0;
    ow.dStr = dStr;
    jsiValueGetString(interp, v, dStr, &ow);
    return Jsi_DSValue(dStr);
}

char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey)
{
    Jsi_MapEntry *hPtr;
    if (isKey) *isKey = 0;
    if (!nocreate) {
        *isKey = 1;
         if (isKey) *isKey = 1;
        return (char*)Jsi_KeyAdd(interp, str);
    }
    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);
    if (!hPtr) {
        return Jsi_Strdup(str);;
    }
    if (isKey) *isKey = 1;
    *isKey = 1;
    return (char*)Jsi_MapKeyGet(hPtr, 0);
}

static int balanced(char *str) {
    int cnt = 0, quote = 0;
    char *cp = str;
    while (*cp) {
        switch (*cp) {
        case '\\':
            cp++;
            break;
        case '{': case '(': case '[':
            cnt++;
            break;
        case '\'': case '\"':
            quote++;
            break;
        case '}': case ')': case ']':
            cnt--;
            break;
        }
        if (*cp == 0)
            break;
        cp++;
    }
    return ((quote%2) == 0 && cnt <= 0);
}

static char *get_inputline(Jsi_Interp *interp, int istty, const char *prompt)
{
    char *res;
#ifdef JSI_HAS_READLINE
    if (istty && interp->noReadline==0) {
        res = jsi_sh_readline(prompt);
        if (res && *res) jsi_sh_add_history(res);
        return res;
    }
#endif
    int done = 0;
    char bbuf[BUFSIZ];
    Jsi_DString dStr = {};
    if (istty)
        fputs(prompt, stdout);
    fflush(stdout);
    while (!done) { /* Read a line. */
        bbuf[0] = 0;
        if (fgets(bbuf, sizeof(bbuf), stdin) == NULL)
            return NULL;
        Jsi_DSAppend(&dStr, bbuf, NULL);
        if (Jsi_Strlen(bbuf) < (sizeof(bbuf)-1) || bbuf[sizeof(bbuf)-1] == '\n')
            break;
    }
    res = Jsi_Strdup(Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return res;
}

static Jsi_Interp* jsi_interactiveInterp = NULL;
#ifdef JSI_HAS_READLINE
static Jsi_Value *completeValues = NULL;

#ifdef USE_GNU_READLINE
static int jsiRlStart = 0;

static char *jsiRlCmdMatches(const char *text, int state) {
    static int idx, len;
    const char *name;
    Jsi_Interp* interp = jsi_interactiveInterp;
    if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))
        return NULL;
    Jsi_Value **arr = completeValues->d.obj->arr;
    int aLen = completeValues->d.obj->arrCnt;

    if (!state)
    {
        idx = 0;
        len = Jsi_Strlen(text)-jsiRlStart;
    }
    while (idx<aLen)
    {
        name = Jsi_ValueString(interp, arr[idx], NULL);
        if (!name) name = "";
        idx++;
        if (Jsi_Strncmp(name, text+jsiRlStart, len) == 0)
            return (Jsi_Strdup(name));
    }
    return NULL;
}

static char **jsiRlGetMatches(const char *cstr, int start, int end) {
    char **matches = NULL;
    char *str = rl_line_buffer;
    jsiRlStart = start;
    if (1 || start == 0 || !completeValues) {
        int rc;
        Jsi_Interp* interp = jsi_interactiveInterp;
        if (!completeValues)
            completeValues = Jsi_ValueNew1(interp);
        Jsi_Value *func = interp->onComplete;
        if (func == NULL || !Jsi_ValueIsFunction(interp, func))
            func = Jsi_NameLookup(interp, "Info.completions");
        if (func && Jsi_ValueIsFunction(interp, func)) {
            Jsi_Value *items[3] = {};
            items[0] = Jsi_ValueNewStringDup(interp, str);
            items[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);
            items[2] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);;
            Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));
            Jsi_IncrRefCount(interp, args);
            rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);
            Jsi_DecrRefCount(interp, args);
            if (rc != JSI_OK)
                fprintf(stderr, "bad completion: %s %d %d\n", str?str:"", start, end);
        }
        matches = rl_completion_matches(str, jsiRlCmdMatches);
    }
    return matches;
}
#else
static const char *jsiFilePreCmds[] = {
    "File.", "source", "load", "new Channel", "new Sqlite", NULL
};

char *jsiLNhints(const char *buf, int *color, int *bold) {
    int i, len = Jsi_Strlen(buf);
    for (i=0; jsiFilePreCmds[i]; i++)
        if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;
    if (jsiFilePreCmds[i]) {
        const char *ce = buf+len-1, *cp = "('<file>";
        if ((*ce =='\'' || *ce =='\"') && buf[len-2]=='(') cp+=2;
        else if (*ce=='(') cp++;
        else return NULL;
        
        *color = 35;
        *bold = 0;
        return (char*)cp;
    }
    return NULL;
}

static void jsiLNGetMatches(const char *str, linenoiseCompletions *lc) {
    char buf[1000], pre[1000];
    const char *cp, *fnam = "Info.completions";
    int i = 0, len;
    int rc, isfile = 0, start = 0, end = Jsi_Strlen(str);
    Jsi_Interp* interp = jsi_interactiveInterp;
    Jsi_Strncpy(buf, str, sizeof(buf)-1);
    buf[sizeof(buf)-1] = 0;
    pre[0] = 0;
    
    if (!completeValues)
        completeValues = Jsi_ValueNew1(interp);
    Jsi_Value *func = interp->onComplete;
    if (func == NULL || !Jsi_ValueIsFunction(interp, func)) {
        for (i=0; jsiFilePreCmds[i]; i++)
            if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;
        if (jsiFilePreCmds[i] && ((cp=Jsi_Strrchr(buf, '(')) && (cp[1]=='\"' || cp[1]=='\''))) {
            Jsi_Strcpy(pre, buf);
            pre[cp-buf+2] = 0;
            snprintf(buf, sizeof(buf), "%s*%s", cp+2, (buf[0]=='s'?".js*":""));
            isfile = 1;
            fnam = "File.glob";
        }
    }
    func = Jsi_NameLookup(interp, fnam);
    if (func && Jsi_ValueIsFunction(interp, func)) {
        //printf("PATTERN: %s\n", str);
        Jsi_Value *items[3] = {};;
        i = 0;
        items[i++] = Jsi_ValueNewStringDup(interp, buf);
        if (!isfile) {
            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);
            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);
        }
        Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));
        Jsi_IncrRefCount(interp, args);
        rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);
        Jsi_DecrRefCount(interp, args);
        if (rc != JSI_OK) {
            fprintf(stderr, "bad completion: %s %d %d\n", str?str:"", start, end);
            return;
        }
        const char *name;
        Jsi_Interp* interp = jsi_interactiveInterp;
        if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))
            return;
        Jsi_Value **arr = completeValues->d.obj->arr;
        int aLen = completeValues->d.obj->arrCnt;
        i = 0;
        while (i<aLen)
        {
            name = Jsi_ValueString(interp, arr[i], &len);
            if (name) {
                if (!pre[0])
                    linenoiseAddCompletion(lc, name);
                else {
                    snprintf(buf, sizeof(buf), "%s%s", pre, name);
                    linenoiseAddCompletion(lc, buf);
                }
            }
            i++;
        }
    }
}
#endif
#endif

/* Collect and execute code from stdin.  The first byte of flags are passed to Jsi_ValueGetDString(). */
Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags) 
{
    Jsi_RC rc = JSI_OK;
    int done = 0, len, quote = (flags & 0xff), istty = 1;
    const char *prompt = "# ";
    char *buf;
    if (jsi_interactiveInterp) 
        return Jsi_LogError("multiple interactive not supported");
    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;
    interp->framePtr->strict = 1;
    interp->strict = 1;
    interp->isInteractive = 1;
    jsi_interactiveInterp = interp;
    interp->istty = 1;
    interp->msgAllowDups = 1;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
#ifndef __WIN32
    istty = isatty(fileno(stdin));
#else
    istty = _isatty(_fileno(stdin));
#endif
#ifdef JSI_HAS_READLINE
    Jsi_DString dHist = {};
    char *hist = NULL;
#ifdef USE_GNU_READLINE
    rl_attempted_completion_function = jsiRlGetMatches;
#else
    linenoiseSetCompletionCallback(jsiLNGetMatches);
    linenoiseSetHintsCallback(jsiLNhints);
#endif
    if(interp->noReadline == 0 && !interp->parent)
    {
        const char *hfile = (interp->historyFile ? interp->historyFile : "~/.jsish_history");
        hist = Jsi_NormalPath(interp, hfile, &dHist);
        if (hist)
            jsi_sh_read_history(hist);
    }
#endif
    interp->level++;
    while (done==0 && interp->exited==0) {
        buf = get_inputline(interp, istty, prompt);
        if (buf) {
          Jsi_DSAppend(&dStr, buf, NULL);
          free(buf);
        } else {
          done = 1;
        }
        len = Jsi_DSLength(&dStr);
        if (done && len == 0)
            break;
        Jsi_DSAppendLen(&dStr, " ", 1); // Allow for added space.
        buf = Jsi_DSValue(&dStr);
        if (done == 0 && (!balanced(buf))) {
            prompt = "> ";
            if (len<5) {
                Jsi_LogWarn("terminating interactive mode on short unbalance");
                break;
            }
            continue;
        }
        prompt = "# ";
        while ((len = Jsi_Strlen(buf))>0 && (isspace(buf[len-1])))
            buf[len-1] = 0;
        if (buf[0] == 0)
            continue;
        if (interp->onEval == NULL) {
            /* Convenience: add semicolon to "var" statements (required by parser). */
            if (Jsi_Strncmp(buf,"var ", 4) == 0 && Jsi_Strchr(buf, '\n')==NULL && Jsi_Strchr(buf, ';')==NULL)
                Jsi_Strcpy(buf+Jsi_Strlen(buf), ";"); // Added space above so strcat ok.
            rc = Jsi_EvalString(interp, buf, JSI_EVAL_RETURN);
        }
        else
        {
            Jsi_Value *func = interp->onEval;
            if (func && Jsi_ValueIsFunction(interp, func)) {
                Jsi_Value *items[1] = {};
                items[0] = Jsi_ValueNewStringDup(interp, buf);
                Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
                Jsi_IncrRefCount(interp, args);
                rc = Jsi_FunctionInvoke(interp, func, args, &interp->retPtr, interp->csc);
                Jsi_DecrRefCount(interp, args);
                if (rc != JSI_OK)
                    fprintf(stderr, "bad eval");
            }
        }
        if (interp->exited)
            break;
        if (rc == JSI_OK) {
             if (interp->retPtr->vt != JSI_VT_UNDEF || interp->noUndef==0) {
                Jsi_DString eStr = {};
                fputs(Jsi_ValueGetDString(interp, interp->retPtr, &eStr, quote), stdout);
                Jsi_DSFree(&eStr);
                fputs("\n", stdout);
             }
        } else if (!interp->exited) {
            fputs("ERROR\n", stderr);
        }
        Jsi_DSSetLength(&dStr, 0);
        len = 0;
    }
    interp->level--;
#ifdef JSI_HAS_READLINE
    if (hist) {
        jsi_sh_stifle_history(100);
        jsi_sh_write_history(hist);
    }
    Jsi_DSFree(&dHist);
#endif
    Jsi_DSFree(&dStr);
    if (interp->exited && interp->level <= 0)
    {
        rc = JSI_EXIT;
        Jsi_InterpDelete(interp);
    } //else if (interp == interp->mainInterp)
      //  interp->retPtr = NULL; // TODO: hack?? Avoids coredump in InterpDelete.
    jsi_interactiveInterp = NULL;
    return rc;
}

Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value)
{
    bool isNew;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->thisTbl, _this, &isNew);
    if (!hPtr)
        return JSI_ERROR;
    Jsi_HashValueSet(hPtr, value);
    return JSI_OK;
}

void *Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this)
{
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(interp->thisTbl, _this);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

Jsi_RC Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *value)
{
    bool isNew;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->protoTbl, key, &isNew);
    if (!hPtr)
        return JSI_ERROR;
    Jsi_HashValueSet(hPtr, value);
    return JSI_OK;
}

void *Jsi_PrototypeGet(Jsi_Interp *interp, const char *key)
{
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj)
{
    Jsi_Value *val;
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);
    if (!hPtr)
        return JSI_ERROR;
    val = (Jsi_Value *)Jsi_HashValueGet(hPtr);
    obj->__proto__ = val;
    return JSI_OK;
}

const char *Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *o)
{
     switch (o->ot) {
        case JSI_OT_BOOL: return "boolean"; break;
        case JSI_OT_FUNCTION: return "function"; break;
        case JSI_OT_NUMBER: return "number"; break;
        case JSI_OT_STRING: return "string"; break;  
        case JSI_OT_REGEXP: return "regexp"; break;  
        case JSI_OT_ITER: return "iter"; break;  
        case JSI_OT_OBJECT: if (!o->isarrlist) return "object";
        case JSI_OT_ARRAY: return "array"; break;  
        case JSI_OT_USEROBJ:
            if (o->__proto__) {
                Jsi_HashEntry *hPtr;
                Jsi_HashSearch search;
                            
                for (hPtr = Jsi_HashSearchFirst(interp->thisTbl,&search); hPtr != NULL;
                    hPtr = Jsi_HashSearchNext(&search))
                    if (Jsi_HashValueGet(hPtr) == o->__proto__)
                        return (char*)Jsi_HashKeyGet(hPtr);
            }
            
            return "userobj";
            break;
            //return Jsi_ObjGetType(interp, v->d.obj);
        default:
            break;
     }
     return "";
}

extern Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj)
{
    return obj->ot;
}

const char *Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v)
{
    switch (v->vt) {
        case JSI_VT_BOOL: return "boolean"; break;
        case JSI_VT_UNDEF: return "undefined"; break;
        case JSI_VT_NULL: return "null"; break;
        case JSI_VT_NUMBER: return "number"; break;
        case JSI_VT_STRING: return "string"; break;  
        case JSI_VT_VARIABLE: return "variable"; break;  
        case JSI_VT_OBJECT: return Jsi_ObjTypeStr(interp, v->d.obj);
    }
    return "";
}

/* For user defined object  "name", invokes "new"  with "arg" + "opts".  Returns userobj data pointer for C use. */
void *Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var) {
    char buf[BUFSIZ];
    if (arg1)
        snprintf(buf, sizeof(buf), "%s%snew %s('%s', %s);", var?var:"", var?"=":"return ", name, arg1, opts?opts:"null");
    else
        snprintf(buf, sizeof(buf), "%s%snew %s(%s);", var?var:"", var?"=":"return ", name, opts?opts:"null");
    int rc = Jsi_EvalString(interp, buf, 0);
    if (rc != JSI_OK)
        return NULL;
    Jsi_Value *vObj = interp->retPtr;
    if (var)
        vObj = Jsi_NameLookup(interp, var);
    if (!vObj)
        return NULL;
    return Jsi_UserObjGetData(interp, vObj, NULL);
}

#endif

// List

Jsi_List *Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc)
{
    Jsi_List *list = (Jsi_List *)Jsi_Calloc(1, sizeof(Jsi_List));
    list->sig = JSI_SIG_LIST;
    list->opts.flags = flags;
    list->opts.freeHashProc = freeProc;
    list->opts.interp = interp;
    list->opts.mapType = JSI_MAP_LIST;
    list->opts.keyType = (Jsi_Key_Type)-1;
    return list;
}

Jsi_RC Jsi_ListConf(Jsi_List *listPtr, Jsi_MapOpts *opts, bool set)
{
    if (set) {
        listPtr->opts = *opts;
    } else {
        *opts = listPtr->opts;
    }
    return JSI_OK;
}

void Jsi_ListDelete(Jsi_List *list) {
    Jsi_ListClear(list);
    free(list);
}

void Jsi_ListClear(Jsi_List *list) {
    Jsi_ListEntry *l;
    while (list->head) {
        l = list->head;
        list->head = list->head->next;
        l->next = l->prev = NULL;
        if (list->opts.freeListProc && l->value)
            (list->opts.freeListProc)(list->opts.interp, l, l->value);
        Jsi_ListEntryDelete(l);
    }
    list->numEntries = 0;
}
 
Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *item, Jsi_ListEntry *before)
{
    Assert(item && list);
    if (item->list && (item->list->head == item || item->prev || item->next)) {
        Assert(list->opts.freeListProc == item->list->opts.freeListProc);
        Jsi_ListPop(item->list, item);
    }
        
    if (!item->list)
         item->list = list;
    else if (list != item->list) {
        Assert(list->opts.freeListProc == item->list->opts.freeListProc);
        item->list = list;
    }
    if (!list->head) {
        list->head = list->tail = item;
    } else if (item == list->head) {
        assert(0);
    } else if (before == NULL) {
        item->prev = list->tail;
        list->tail->next = item;
        list->tail = item;
    } else if (before == list->head) {
        item->next = list->head;
        list->head->prev = item;
        list->head = item;
    } else {
        item->next = before;
        item->prev = before->prev;
        before->prev->next = item;
        before->prev = item;
    }
    list->numEntries++;
    item->list = list;
    return item;
}
 
Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *item)
{
    Assert(item && list->head && list->tail && item->list);
    SIGASSERT(list, LIST);
    SIGASSERT(item, LISTENTRY);
    if (item == list->head) {
        if (list->head == list->tail)
            list->head = list->tail = NULL;
        else
            list->head = list->head->next;
    }
    else if (item == list->tail) {
        list->tail = list->tail->prev;
        list->tail->next = NULL;
    } else {
        item->prev->next = item->next;
        if (item->next)
            item->next->prev = item->prev;
    }
    list->numEntries--;
    item->next = item->prev = NULL;
    return item;
}

Jsi_ListEntry *Jsi_ListEntryNew(Jsi_List* list, const void *value, Jsi_ListEntry *before) {
    SIGASSERT(list, LIST);
    Jsi_ListEntry *l = (Jsi_ListEntry*)Jsi_Calloc(1, sizeof(Jsi_ListEntry));
    l->sig = JSI_SIG_LISTENTRY;
    l->typ = JSI_MAP_LIST;
    l->list = list;
    l->value = (void*)value;
    Jsi_ListPush(list, l, before);
    return l;
}

int Jsi_ListEntryDelete(Jsi_ListEntry *l) {
    SIGASSERT(l, LISTENTRY);
    if (l->next || l->prev)
        Jsi_ListPop(l->list, l);
    Jsi_Free(l);
    return 1;
}

Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *searchPtr, int flags)
{
    SIGASSERT(list, LIST);
    searchPtr->flags = flags;
    Jsi_ListEntry *lptr;
    if (flags & JSI_LIST_REVERSE) {
        lptr = Jsi_ListGetBack(list);
        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryPrev(lptr):NULL);
    } else {
        lptr = Jsi_ListGetFront(list);
        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryNext(lptr):NULL);
    }
    return lptr;
}

Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *searchPtr)
{
    Jsi_ListEntry *lptr = searchPtr->nextEntryPtr;
    searchPtr->nextEntryPtr = (lptr?(searchPtr->flags & JSI_LIST_REVERSE ? Jsi_ListEntryPrev(lptr): Jsi_ListEntryNext(lptr)):NULL);
    return lptr;
}


uint Jsi_ListSize(Jsi_List *list) {
    SIGASSERT(list, LIST);
    return list->numEntries;
}

void* Jsi_ListValueGet(Jsi_ListEntry *l) {
    SIGASSERT(l, LISTENTRY);
    return l?l->value:NULL;
}
void Jsi_ListValueSet(Jsi_ListEntry *l, const void *value) {
    SIGASSERT(l, LISTENTRY);
    l->value = (void*)value;
}


// Map

Jsi_Map* Jsi_MapNew (Jsi_Interp *interp, Jsi_Map_Type listType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc)
{
    Jsi_Map *lPtr, lval = {.sig=JSI_SIG_MAP};
    lval.typ = listType;
    switch (listType) {
        case JSI_MAP_HASH: lval.v.hash = Jsi_HashNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;
        case JSI_MAP_TREE: lval.v.tree = Jsi_TreeNew(interp, keyType, (Jsi_TreeDeleteProc*)freeProc); break;
        case JSI_MAP_LIST: lval.v.list = Jsi_ListNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;
        default: return NULL;
    }
    if (!lval.v.hash) return NULL;
    lPtr = (Jsi_Map*)Jsi_Malloc(sizeof(*lPtr));
    *lPtr = lval;
    return lPtr;
}

Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set)
{
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashConf(mapPtr->v.hash, opts, set);
        case JSI_MAP_TREE: return Jsi_TreeConf(mapPtr->v.tree, opts, set);
        case JSI_MAP_LIST: return Jsi_ListConf(mapPtr->v.list, opts, set);
        case JSI_MAP_NONE: break;
    }
    return JSI_ERROR;
}

void Jsi_MapClear (Jsi_Map *mapPtr) {
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: Jsi_HashClear(mapPtr->v.hash); break;
        case JSI_MAP_TREE: Jsi_TreeClear(mapPtr->v.tree); break;
        case JSI_MAP_LIST: Jsi_ListClear(mapPtr->v.list); break;
        default: return;
    }
}

void Jsi_MapDelete (Jsi_Map *mapPtr) {
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: Jsi_HashDelete(mapPtr->v.hash); break;
        case JSI_MAP_TREE: Jsi_TreeDelete(mapPtr->v.tree); break;
        case JSI_MAP_LIST: Jsi_ListDelete(mapPtr->v.list); break;
        default: return;
    }
    Jsi_Free(mapPtr);
}
Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value){
    SIGASSERT(mapPtr, MAP);
    Jsi_MapEntry* mptr = NULL;
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: mptr = (Jsi_MapEntry*)Jsi_HashSet(mapPtr->v.hash, (void*)key, (void*)value); break;
        case JSI_MAP_TREE: mptr = (Jsi_MapEntry*)Jsi_TreeSet(mapPtr->v.tree, (void*)key, (void*)value); break;
        case JSI_MAP_LIST: {
            mptr = Jsi_MapEntryNew(mapPtr, key, NULL);
            Jsi_MapValueSet(mptr, (void*)value);
            break;
        }
        case JSI_MAP_NONE: break;
    }
    return mptr;
}
void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags){
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashGet(mapPtr->v.hash, (void*)key, flags);
        case JSI_MAP_TREE: return Jsi_TreeGet(mapPtr->v.tree, (void*)key, flags);
        case JSI_MAP_LIST: {
            Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));
            if (lptr)
                return Jsi_ListValueGet(lptr);
            break;
        }
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
bool Jsi_MapUnset(Jsi_Map *mapPtr, const void *key){
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashUnset(mapPtr->v.hash, (void*)key);
        case JSI_MAP_TREE: return Jsi_TreeUnset(mapPtr->v.tree, (void*)key);
        case JSI_MAP_LIST: {
            /*Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));
            if (lptr)
                return Jsi_ListUnset(lptr);*/
            break;
        }
        case JSI_MAP_NONE: break;
    }
    return false;
}
static int jsi_GetListType(Jsi_MapEntry *h) {
    Jsi_HashEntry *hPtr =(Jsi_HashEntry *)h;
    return hPtr->typ;
}
void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashKeyGet((Jsi_HashEntry*)h);
        case JSI_MAP_TREE: return Jsi_TreeKeyGet((Jsi_TreeEntry*)h);
        case JSI_MAP_LIST: break;
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
#ifndef JSI_LITE_ONLY
Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags){
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashKeysDump(interp, mapPtr->v.hash, ret, flags);
        case JSI_MAP_TREE: return Jsi_TreeKeysDump(interp, mapPtr->v.tree, ret, flags);
        case JSI_MAP_LIST: break; // TODO: dump numbers?
        case JSI_MAP_NONE: break;
    }
    return JSI_ERROR;
}
#endif
void* Jsi_MapValueGet(Jsi_MapEntry *h){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashValueGet((Jsi_HashEntry*)h);
        case JSI_MAP_TREE: return Jsi_TreeValueGet((Jsi_TreeEntry*)h);
        case JSI_MAP_LIST: return Jsi_ListValueGet((Jsi_ListEntry*)h);
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashValueSet((Jsi_HashEntry*)h, (void*)value);
        case JSI_MAP_TREE: return Jsi_TreeValueSet((Jsi_TreeEntry*)h, (void*)value);
        case JSI_MAP_LIST: return Jsi_ListValueSet((Jsi_ListEntry*)h, (void*)value);
        case JSI_MAP_NONE: break;
    }
}
Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key){
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFind(mapPtr->v.hash, key);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFind(mapPtr->v.tree, key);
        case JSI_MAP_LIST:
            return (Jsi_MapEntry*) (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew){
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryNew(mapPtr->v.hash, key, isNew);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryNew(mapPtr->v.tree, key, isNew);
        case JSI_MAP_LIST: {
            Jsi_ListEntry *lptr = Jsi_ListEntryNew(mapPtr->v.list, NULL, (key?mapPtr->v.list->head:NULL));
            if (isNew) *isNew = 1;
            return (Jsi_MapEntry*)lptr;
        }
        break;
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr){
    switch (jsi_GetListType(entryPtr)) {
        case JSI_MAP_HASH: return Jsi_HashEntryDelete((Jsi_HashEntry*)entryPtr);
        case JSI_MAP_TREE: return Jsi_TreeEntryDelete((Jsi_TreeEntry*)entryPtr);
        case JSI_MAP_LIST: {
            Jsi_ListEntry *lptr = (Jsi_ListEntry*)entryPtr;
            Jsi_ListPop(lptr->list, lptr);
            Jsi_ListEntryDelete(lptr);
            return 1;
        }
    }
    return JSI_OK;
}
Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags){
    SIGASSERT(mapPtr, MAP);
    searchPtr->typ = mapPtr->typ;
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchFirst(mapPtr->v.hash, &searchPtr->v.hash);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchFirst(mapPtr->v.tree, &searchPtr->v.tree, flags, NULL);
        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchFirst(mapPtr->v.list, &searchPtr->v.list, flags);
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *searchPtr){
    switch (searchPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchNext(&searchPtr->v.hash);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchNext(&searchPtr->v.tree);
        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchNext(&searchPtr->v.list);
        case JSI_MAP_NONE: break;
    }
    return NULL;
}
void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr){
    switch (searchPtr->typ) {
        case JSI_MAP_HASH: break;
        case JSI_MAP_TREE: Jsi_TreeSearchDone(&searchPtr->v.tree); break;
        case JSI_MAP_LIST: break;
        case JSI_MAP_NONE: break;
    }
}
uint Jsi_MapSize(Jsi_Map *mapPtr) {
    SIGASSERT(mapPtr, MAP);
    switch (mapPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashSize(mapPtr->v.hash);
        case JSI_MAP_TREE: return Jsi_TreeSize(mapPtr->v.tree);
        case JSI_MAP_LIST: return Jsi_ListSize(mapPtr->v.list);
        case JSI_MAP_NONE: break;
    }
    return -1;
}


#ifndef JSI_OMIT_THREADS

#ifdef __WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

typedef struct Jsi_Mutex {
    int flags;
    int lockTimeout;
    int threadErrCnt;
#ifdef __WIN32
    CRITICAL_SECTION mtx;
#else
    pthread_mutex_t mtx;
#endif
} Jsi_Mutex;

#ifdef __WIN32
#include <windows.h>

static Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex* mtx) {
    int timeout = mtx->lockTimeout;
    if (interp && timeout<0)
        timeout = interp->lockTimeout;
    if (timeout<=0)
        EnterCriticalSection(&mtx->mtx);
    else {
        int cnt = timeout;
        while (cnt-- >= 0) {
            if (TryEnterCriticalSection(&mtx->mtx))
                return JSI_OK;
            usleep(1000);
        }
        Jsi_LogError("lock timed out");
        if (interp)
            interp->threadErrCnt++;
        mtx->threadErrCnt++;
        return JSI_ERROR;
    }
    return JSI_OK;
}
static void MutexUnlock(Jsi_Mutex* mtx) { LeaveCriticalSection(&mtx->mtx); }
static void MutexInit(Jsi_Mutex *mtx) {  InitializeCriticalSection(&mtx->mtx); }

static void MutexDone(Jsi_Mutex *mtx) { DeleteCriticalSection(&mtx->mtx); }
#else /* ! __WIN32 */

#include <pthread.h>
static Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) {
    int timeout = mtx->lockTimeout;
    if (interp && timeout<0)
        timeout = interp->lockTimeout;
    if (timeout<=0)
        pthread_mutex_lock(&mtx->mtx);
    else {
        struct timespec ts;
        ts.tv_sec = timeout/1000;
        ts.tv_nsec = 1000 * (timeout%1000);
        int rc = pthread_mutex_timedlock(&mtx->mtx, &ts);
        if (rc != 0) {
            Jsi_LogError("lock timed out");
            if (interp)
                interp->threadErrCnt++;
            mtx->threadErrCnt++;
            return JSI_ERROR;
        }
    }
    return JSI_OK;
}
static void MutexUnlock(Jsi_Mutex *mtx) { pthread_mutex_unlock(&mtx->mtx); }
static void MutexInit(Jsi_Mutex *mtx) {
    pthread_mutexattr_t Attr;
    pthread_mutexattr_init(&Attr);
    if (mtx->flags & JSI_MUTEX_RECURSIVE)
        pthread_mutexattr_settype(&Attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&mtx->mtx, &Attr);
}

static void MutexDone(Jsi_Mutex *mtx) { pthread_mutex_destroy(&mtx->mtx); }
#endif /* ! __WIN32 */

Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { if (interp) interp->lockRefCnt++; return MutexLock(interp, mtx);}
void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexUnlock(mtx); if (interp) interp->lockRefCnt--; }
Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) {
     Jsi_Mutex *mtx = (Jsi_Mutex *)Jsi_Calloc(1,sizeof(Jsi_Mutex));
     mtx->lockTimeout = timeout;
     mtx->flags = flags;
     MutexInit(mtx);
     return mtx;
}
void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexDone(mtx); Jsi_Free(mtx);}
//void Jsi_MutexInit(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexInit(mtx); }
void* Jsi_InterpThread(Jsi_Interp *interp) { return interp->threadId; }
void* Jsi_CurrentThread(void) {
#ifdef __WIN32
    return (void*)(uintptr_t)GetCurrentThreadId();
#else
    return (void*)pthread_self();
#endif
}

#else /* ! JSI_OMIT_THREADS */
Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { return JSI_OK; }
void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { }
Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) { return NULL; }
void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { }
void* Jsi_CurrentThread(void) { return NULL; }
void* Jsi_InterpThread(Jsi_Interp *interp) { return NULL; }
#endif

Jsi_Number Jsi_Version(void) {
    Jsi_Number d = JSI_VERSION;
    return d;
}

static const char *JsiCharsetMatch(const char *pattern, int c, int flags)
{
    int inot = 0;
    int pchar;
    int match = 0;
    int nocase = 0;

    if (flags & JSI_CMP_NOCASE) {
        nocase++;
        c = toupper(c);
    }

    if (flags & JSI_CMP_CHARSET_SCAN) {
        if (*pattern == '^') {
            inot++;
            pattern++;
        }

        /* Special case. If the first char is ']', it is part of the set */
        if (*pattern == ']') {
            goto first;
        }
    }

    while (*pattern && *pattern != ']') {
        /* Exact match */
        if (pattern[0] == '\\') {
first:
            pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);
        }
        else {
            /* Is this a range? a-z */
            int start;
            int end;
            pattern += Jsi_UtfToUniCharCase(pattern, &start, nocase);
            if (pattern[0] == '-' && pattern[1]) {
                /* skip '-' */
                pattern += Jsi_UtfToUniChar(pattern, &pchar);
                pattern += Jsi_UtfToUniCharCase(pattern, &end, nocase);

                /* Handle reversed range too */
                if ((c >= start && c <= end) || (c >= end && c <= start)) {
                    match = 1;
                }
                continue;
            }
            pchar = start;
        }

        if (pchar == c) {
            match = 1;
        }
    }
    if (inot) {
        match = !match;
    }

    return match ? pattern : NULL;
}


/* Split on char, or whitespace if ch==0. */
static void SplitChar(const char *str, int *argcPtr,
              char ***argvPtr, char ch, Jsi_DString *dStr)
{
    char *cp, *ep, *p, **argv;
    int cnt = 1, len, i;

    len = Jsi_Strlen(str);
    cp = (char*)str;
    while (*cp) {
        if (ch)
            cp = Jsi_Strchr(cp,ch);
        else {
            while (*cp && !isspace(*cp))
                cp++;
        }
        if (cp == NULL || *cp == 0) break;
        cp++;
        cnt++;
    }
    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    argv = (char**)Jsi_DSValue(dStr);
    *argvPtr = argv;
    *argcPtr = cnt;
    p = (char*)&(argv[cnt+2]);
    argv[cnt+1] = p;
    Jsi_Strcpy(p, str);
    cp = p;
    i = 0;
    argv[i++] = p;
    while (*cp) {
        if (ch)
            ep = Jsi_Strchr(cp,ch);
        else {
            ep = cp;
            while (*ep && !isspace(*ep))
                ep++;
        }
        if (ep == NULL || *ep == 0) break;
        *ep = 0;
        cp = ep+1;
        argv[i++] = cp;
    }
    argv[cnt] = NULL;
}

Jsi_RC
Jsi_GetIndex( Jsi_Interp *interp, const char *str,
    const char **tablePtr, const char *msg, int flags,
    int *indexPtr)
{
  const char *msg2 = "unknown ";
  char **cp, *c;
  int cond, index = -1, slen, i, dup = 0;
  int exact = (flags & JSI_CMP_EXACT);
  int nocase = (flags & JSI_CMP_NOCASE);
  slen = Jsi_Strlen(str);
 /* if (slen==0) 
        return Jsi_LogError("empty option %s %s", msg, str);*/
  cp = (char**)tablePtr;
  i = -1;
  while (*cp != 0) {
    i++;
    c = *cp;
    if (c[0] != str[0]) { cp++; continue; }
    if (!nocase)
        cond = (exact ? Jsi_Strcmp(c,str) : Jsi_Strncmp(c,str,slen));
    else {
        cond = (exact ? Jsi_Strncasecmp(c,str, -1) : Jsi_Strncasecmp(c,str,slen));
    }
    if (cond == 0) {
      if (index<0) {
        index = i;
      } else {
        dup = 1;
        break;
      }
    }
    cp++;
  }
  if (index >= 0 && dup == 0) {
    *indexPtr = index;
    return JSI_OK;
  }
  if (exact && (dup || index<=0)) {
    if (interp != NULL) {
      msg2 = (index>=0? "unknown ":"duplicate ");
    }
    goto err;
  }
  cp = (char**)tablePtr;
  i = -1;
  dup = 0;
  index = -1;
  while (*cp != 0) {
    i++;
    c = *cp;
    if (c[0] == str[0] && Jsi_Strncmp(c,str, slen) == 0) {
      if (index<0) {
        index = i;
        if (slen == (int)Jsi_Strlen(c))
            break;
      } else {
        if (interp != NULL) {
          msg2 = "ambiguous ";
        }
        goto err;
      }
    }
    cp++;
  }
  if (index >= 0 && dup == 0) {
    *indexPtr = index;
    return JSI_OK;
  }
err:
  if (interp != NULL) {
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, msg2, msg, " \"", str, "\" not one of: ", NULL);
    cp = (char**)tablePtr;
    while (*cp != 0) {
      c = *cp;
      Jsi_DSAppend(&dStr, c, NULL);
      Jsi_DSAppend(&dStr, " ", NULL);
      cp++;
    }
    Jsi_LogError("%s", Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
  }
  return JSI_ERROR;
}

bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase)
{
    int c;
    int pchar;
    while (*pattern) {
        switch (pattern[0]) {
            case '*':
                while (pattern[1] == '*') {
                    pattern++;
                }
                pattern++;
                if (!pattern[0]) {
                    return 1;   /* match */
                }
                while (*string) {
                    if (Jsi_GlobMatch(pattern, string, nocase))
                        return 1;       /* match */
                    string += Jsi_UtfToUniChar(string, &c);
                }
                return 0;       /* no match */

            case '?':
                string += Jsi_UtfToUniChar(string, &c);
                break;

            case '[': {
                    string += Jsi_UtfToUniChar(string, &c);
                    pattern = JsiCharsetMatch(pattern + 1, c, nocase ? JSI_CMP_NOCASE : 0);
                    if (!pattern) {
                        return 0;
                    }
                    if (!*pattern) {
                        /* Ran out of pattern (no ']') */
                        continue;
                    }
                    break;
                }
            case '\\':
                if (pattern[1]) {
                    pattern++;
                }
                /* fall through */
            default:
                string += Jsi_UtfToUniCharCase(string, &c, nocase);
                Jsi_UtfToUniCharCase(pattern, &pchar, nocase);
                if (pchar != c) {
                    return 0;
                }
                break;
        }
        pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);
        if (!*string) {
            while (*pattern == '*') {
                pattern++;
            }
            break;
        }
    }
    if (!*pattern && !*string) {
        return 1;
    }
    return 0;
}

Jsi_Stack* Jsi_StackNew(void)
{
    Jsi_Stack *stack = (Jsi_Stack*)Jsi_Calloc(1, sizeof(Jsi_Stack));
    return stack;
}

void Jsi_StackFree(Jsi_Stack *stack)
{
    Jsi_Free(stack->vector);
    Jsi_Free(stack);
}

int Jsi_StackSize(Jsi_Stack *stack)
{
    return stack->len;
}

void Jsi_StackPush(Jsi_Stack *stack, void *element)
{
    int neededLen = stack->len + 1;

    if (neededLen > stack->maxlen) {
        stack->maxlen = neededLen < 20 ? 20 : neededLen * 2;
        stack->vector = (void**)Jsi_Realloc(stack->vector, sizeof(void *) * stack->maxlen);
    }
    stack->vector[stack->len] = element;
    stack->len++;
}

void *Jsi_StackPop(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    stack->len--;
    return stack->vector[stack->len];
}

void *Jsi_StackUnshift(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    stack->len--;
    void *rc = stack->vector[0];
    memmove(stack->vector, stack->vector+1, sizeof(void*)*stack->len);
    return rc;
}

void *Jsi_StackPeek(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    return stack->vector[stack->len - 1];
}

void *Jsi_StackHead(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    return stack->vector[0];
}

void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeProc)
{
    int i;
    for (i = 0; i < stack->len; i++)
        freeProc(interp, stack->vector[i]);
    stack->len = 0;
}

typedef struct {
    void *data;
    Jsi_DeleteProc *delProc;
} AssocData;

/* Split on string. */
void Jsi_SplitStr(const char *str, int *argcPtr,
              char ***argvPtr, const char *ch, Jsi_DString *dStr)
{
    char *cp, *ep, *p, **argv;
    int cnt = 1, len, i, clen;
    if (!ch)
        ch = "";
    clen = Jsi_Strlen(ch);
    if (clen<=0)
        return SplitChar(str, argcPtr, argvPtr, *ch, dStr);
    len = Jsi_Strlen(str);
    cp = (char*)str;
    while (*cp) {
        cp = Jsi_Strstr(cp,ch);
 
        if (cp == NULL || *cp == 0) break;
        cp += clen;
        cnt++;
    }
    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    argv = (char**)Jsi_DSValue(dStr);
    *argvPtr = argv;
    *argcPtr = cnt;
    p = (char*)&(argv[cnt+2]);
    argv[cnt+1] = p;
    Jsi_Strcpy(p, str);
    cp = p;
    i = 0;
    argv[i++] = p;
    while (*cp) {
        ep = Jsi_Strstr(cp,ch);
        if (ep == NULL || *ep == 0) break;
        *ep = 0;
        cp = ep+clen;
        argv[i++] = cp;
    }
    argv[cnt] = NULL;
}

static Jsi_RC JsiCheckConversion(const char *str, const char *endptr)
{
    if (str[0] == '\0' || str == endptr) {
        return JSI_ERROR;
    }

    if (endptr[0] != '\0') {
        while (*endptr) {
            if (!isspace(UCHAR(*endptr))) {
                return JSI_ERROR;
            }
            endptr++;
        }
    }
    return JSI_OK;
}

static int JsiNumberBase(const char *str, int *base, int *sign)
{
    int i = 0;

    *base = 10;

    while (isspace(UCHAR(str[i]))) {
        i++;
    }

    if (str[i] == '-') {
        *sign = -1;
        i++;
    }
    else {
        if (str[i] == '+') {
            i++;
        }
        *sign = 1;
    }

    if (str[i] != '0') {
        /* base 10 */
        return 0;
    }

    /* We have 0<x>, so see if we can convert it */
    switch (str[i + 1]) {
        case 'x': case 'X': *base = 16; break;
        case 'o': case 'O': *base = 8; break;
        case 'b': case 'B': *base = 2; break;
        default: return 0;
    }
    i += 2;
    /* Ensure that (e.g.) 0x-5 fails to parse */
    if (str[i] != '-' && str[i] != '+' && !isspace(UCHAR(str[i]))) {
        /* Parse according to this base */
        return i;
    }
    /* Parse as base 10 */
    return 10;
}

/* Converts a number as per strtoull(..., 0) except leading zeros do *not*
 * imply octal. Instead, decimal is assumed unless the number begins with 0x, 0o or 0b
 */
static Jsi_Wide jsi_strtoull(const char *str, char **endptr)
{
#ifdef JSI__LONG_LONG
    int sign;
    int base;
    int i = JsiNumberBase(str, &base, &sign);

    if (base != 10) {
        Jsi_Wide value = strtoull(str + i, endptr, base);
        if (endptr == NULL || *endptr != str + i) {
            return value * sign;
        }
    }

    /* Can just do a regular base-10 conversion */
    return strtoull(str, endptr, 10);
#else
    return (unsigned long)jsi_strtol(str, endptr);
#endif
}

static Jsi_Wide jsi_strtoul(const char *str, char **endptr)
{
#ifdef JSI__LONG_LONG
    int sign;
    int base;
    int i = JsiNumberBase(str, &base, &sign);

    if (base != 10) {
        Jsi_Wide value = strtoul(str + i, endptr, base);
        if (endptr == NULL || *endptr != str + i) {
            return value * sign;
        }
    }

    /* Can just do a regular base-10 conversion */
    return strtoul(str, endptr, 10);
#else
    return (unsigned long)jsi_strtol(str, endptr);
#endif
}


Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *widePtr, int base)
{
    char *endptr;

    if (base) {
        *widePtr = strtoull(string, &endptr, base);
    }
    else {
        *widePtr = jsi_strtoull(string, &endptr);
    }

    return JsiCheckConversion(string, endptr);
}

Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base)
{
    char *endptr;
    if (base) {
        *n = strtoul(string, &endptr, base);
    }
    else {
        *n = (int)jsi_strtoul(string, &endptr);
    }
    return JsiCheckConversion(string, endptr);
}

Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n)
{
    char *endptr;

    /* Callers can check for underflow via ERANGE */
    errno = 0;

    *n = strtod(string, &endptr);

    return JsiCheckConversion(string, endptr);
}

Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n)
{
    int len = Jsi_Strlen(string);
    if ((Jsi_Strncasecmp(string, "true", len)==0 && len<=4)) {
        *n = 1;
        return JSI_OK;
    }
    if ((Jsi_Strncasecmp(string, "false", len)==0 && len<=5)) {
        *n = 0;
        return JSI_OK;
    }
    return JSI_ERROR;
}

/* Converts a hex character to its integer value */
char jsi_fromHexChar(char ch) {
    return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;
}

/* Converts an integer value to its hex character*/
char jsi_toHexChar(char code) {
    static char hex[] = "0123456789abcdef";
    return hex[code & 15];
}

void Jsi_ToHexStr(const uchar *indata, int dlen, char *out) {
    static char hex[] = "0123456789abcdef";
    int i, n=0;
    for (i=0; i<dlen; i++) {
        int c = indata[i];
        out[n++] = hex[(c>>4)&0xf];
        out[n++] = hex[c&0xf];
    }
    out[n] = 0;
}

int Jsi_FromHexStr(const char *in, uchar *outdata) {
    int n = 0;
    while (in[0] && in[1]) {
        if (!isxdigit(in[0]) || isxdigit(in[0]))
            return -1;
        outdata[n++] = jsi_fromHexChar(in[0]) << 4 | jsi_fromHexChar(in[1]);
        in+=2;
    }
    return n;
}

#ifndef JSI_LITE_ONLY

void *Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc)
{
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);
    if (!hPtr)
        return NULL;
    ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    if (!ptr)
        return NULL;
    if (proc)
        *proc = ptr->delProc;
    return ptr->data;
}
void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc)
{
    bool isNew;
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryNew(interp->assocTbl, key, &isNew);
    if (!hPtr)
        return;
    if (isNew) {
        ptr = (AssocData *)Jsi_Calloc(1,sizeof(*ptr));
        Jsi_HashValueSet(hPtr, ptr);
    } else
        ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    ptr->data = data;
    ptr->delProc = proc;
}

void jsi_DelAssocData(Jsi_Interp *interp, void *data) {
    AssocData *ptr = (AssocData *)data;
    if (!ptr) return;
    if (ptr->delProc)
        ptr->delProc(interp, ptr->data);
    Jsi_Free(ptr);
}

Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m)
{
    Jsi_Free(m);
    return JSI_OK;
}

void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key)
{
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);
    if (!hPtr)
        return;
    ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    Jsi_HashEntryDelete(hPtr);
    jsi_DelAssocData(interp, ptr);
}

Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **n)
{
    if (!value)
        return JSI_ERROR;
    if (value->vt == JSI_VT_STRING)
    {
        *n = (const char*)value->d.s.str;
         return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_STRING) {
        *n = value->d.obj->d.s.str;
        return JSI_OK;
    }
    Jsi_LogError("invalid string");
    return JSI_ERROR;
}

Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n)
{
    if (!value)
        return JSI_ERROR;

    if (value->vt == JSI_VT_BOOL) {
        *n = value->d.val;
        return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_BOOL) {
        *n = value->d.obj->d.val;
        return JSI_OK;
    }
    Jsi_LogError("invalid bool");
    return JSI_ERROR;
}


Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)
{
    if (!value)
        return JSI_ERROR;

    if (value->vt == JSI_VT_NUMBER) {
        *n = value->d.num;
        return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_NUMBER) {
        *n = value->d.obj->d.num;
        return JSI_OK;
    }
    if (interp)
        Jsi_LogError("invalid number");
    return JSI_ERROR;
}

Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags)
{
    int noMsg = (flags & JSI_NO_ERRMSG);
    /* TODO: inefficient to convert to double then back. */
    if (!value)
        return JSI_ERROR;
    Jsi_Number d = Jsi_ValueToNumberInt(interp, value, 1);
    if (!Jsi_NumberIsFinite(d))
    {
        if (!noMsg)
            Jsi_LogError("invalid number");
        return JSI_ERROR;
    }
    Jsi_ValueReset(interp,&value);
    Jsi_ValueMakeNumber(interp, &value, d);
    *n = (int)d;
    return JSI_OK;
}

Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n)
{
    if (!Jsi_ValueIsNumber(interp, value)) 
        return Jsi_LogError("invalid number");
    return Jsi_GetIntFromValueBase(interp, value, n, 0, 0);
}

Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n)
{
    /* TODO: inefficient to convert to double then back. */
    if (!value)
        return JSI_ERROR;
    if (!jsi_IsStrictMode(interp))
        jsi_ValueToOInt32(interp, value);
    if (!Jsi_ValueIsNumber(interp, value))
    
        return Jsi_LogError("invalid number");
    *n = (long)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);
    return JSI_OK;
}

Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n)
{
    if (!value)
        return JSI_ERROR;
    if (!jsi_IsStrictMode(interp))
        jsi_ValueToOInt32(interp, value);
    if (!Jsi_ValueIsNumber(interp, value))
    
        return Jsi_LogError("invalid number");
    *n = (Jsi_Wide)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);
    return JSI_OK;

}

Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)
{
    if (!value)
        return JSI_ERROR;
    if (!jsi_IsStrictMode(interp))
        Jsi_ValueToNumber(interp, value);
    if (!Jsi_ValueIsNumber(interp, value))
    
        return Jsi_LogError("invalid number");
    *n = (value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);
    return JSI_OK;
}

Jsi_RC
Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr,
    const char **tablePtr, const char *msg, int flags, int *indexPtr)
{
    char *val = Jsi_ValueString(interp, valPtr, NULL);
    if (val == NULL) 
        return Jsi_LogError("expected string");
    return Jsi_GetIndex(interp, val, tablePtr, msg, flags, indexPtr);
}

#endif // JSI_LITE_ONLY
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* Jsi_Obj constructor */
static Jsi_RC ObjectConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        /* new operator will do the rest */
        return JSI_OK;
    }
    
    if (Jsi_ValueGetLength(interp, args) <= 0) {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        o->__proto__ = interp->Object_prototype;
        Jsi_ValueMakeObject(interp, ret, o);
        return JSI_OK;
    }
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (!v || v->vt == JSI_VT_UNDEF || v->vt == JSI_VT_NULL) {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_ValueMakeObject(interp, ret, o);
        return JSI_OK;
    }
    Jsi_ValueDup2(interp, ret, v);
    Jsi_ValueToObject(interp, *ret);
    return JSI_OK;
}

/* Function.prototype pointed to a empty function */
static Jsi_RC jsi_FunctionPrototypeConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return JSI_OK;
}

static Jsi_RC jsi_Function_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return Jsi_LogError("Calling Function is unsupported");
  /*  if (Jsi_FunctionIsConstructor(funcPtr)) {
        _this->d.obj->ot = JSI_OT_FUNCTION;
        return JSI_OK;
    }
    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);
    Jsi_ValueMakeObject(interp, ret, o);
    return JSI_OK;*/
}

// Guesstimate type based on default value.
int jsi_GetDefaultType(const char *cp) {
    if (isdigit(*cp) || *cp == '-' || *cp == '.') return JSI_TT_NUMBER;
    if (*cp == 'f' || *cp == 't') return JSI_TT_BOOLEAN;
    if (*cp == 'n') return JSI_TT_NULL;
    if (*cp == 'v') return JSI_TT_VOID;
    if (*cp == '\'' || *cp == '\"') return JSI_TT_STRING;
    return 0;
}

// Extract typechecking info from argStr for builtin Jsi_CmdSpec on first call
Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr)
{
    int i;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    int argc;
    char **argv, *sname, *stype, *cp, *ap = NULL;
    Jsi_SplitStr(argStr, &argc, &argv, ",", &dStr);
    if (argc<=0)
        return NULL;
    Jsi_ScopeStrs *ss = jsi_ScopeStrsNew();
    for (i=0; i<argc; i++) {
        sname = argv[i];
        stype = NULL;
        ap = NULL;
        while (sname && *sname && isspace(*sname)) { sname++; }
        if ((cp=Jsi_Strchr(sname, '='))) {
            ap = cp+1;
            *cp = 0;
        }
        if ((cp=Jsi_Strchr(sname, ':'))) {
            stype = cp+1;
            *cp = 0;
            while (*stype && isspace(*stype)) { stype++; }
            if (*stype) {
                cp = stype+Jsi_Strlen(stype)-1;
                while (cp>=stype && isspace(*cp)) { *cp = 0; cp--; }
            }
        }
        int atyp = jsi_typeGet(interp, stype);
        if (ap) {
            int datyp = jsi_GetDefaultType(ap);
            if (datyp != JSI_TT_VOID)
                atyp |= datyp;
        }
        if (sname && *sname) {
            cp = sname+Jsi_Strlen(sname)-1;
            while (cp>=sname && isspace(*cp)) { *cp = 0; cp--; }
        }
        jsi_ScopeStrsPush(interp, ss, sname, atyp);
    }
    Jsi_DSFree(&dStr);
    return ss;
}

// Runtime function call checker.
Jsi_RC jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc)
{
    int i;
    Jsi_RC rc = JSI_OK;
    Jsi_ScopeStrs *argnames;
    // Extract typechecking info from argStr for builtin commands on first call
    const char *argStr = (func->cmdSpec ? func->cmdSpec->argStr: NULL);
    if (alloc && func->type == FC_BUILDIN && func->callCnt == 0 && func->argnames==NULL
        && argStr && Jsi_Strchr(argStr, ':'))
        func->argnames = jsi_ParseArgStr(interp, argStr);
    argnames = func->argnames;
    int argc = Jsi_ValueGetLength(interp, args);
    if (alloc && (interp->typeCheck.all|interp->typeCheck.run) && jsi_RunFuncCallCheck(interp, func, argc, func->name, NULL, NULL) != JSI_OK
        && (interp->typeCheck.error))
        rc = JSI_ERROR;
    if (!argnames)
        return rc;
    
    int addargs = func->callflags.bits.addargs;
    for (i = 0; i < argnames->count; ++i) {
        int n = i-addargs;
        const char *argkey = jsi_ScopeStrsGet(argnames, i);
        if (!argkey) break;
        
        Jsi_Value *dv = NULL, *v = Jsi_ValueArrayIndex(interp, args, i);
        if (!alloc) {
            if (func->type == FC_BUILDIN)
                continue;
            if (v==NULL  && i >= addargs)
                v = argnames->args[n].defValue;
            if (v)
                Jsi_DecrRefCount(interp, v);
        } else {
            if (v==NULL  && i >= addargs)
                dv = v = argnames->args[n].defValue;
            if (v && rc == JSI_OK && i >= addargs) {
                int typ = argnames->args[n].type;
                if ((typ && interp->typeCheck.run) || interp->typeCheck.all)
                    rc = jsi_ArgTypeCheck(interp, typ, v, "for argument", argkey, i+1, func, (dv!=NULL));
            }
            if (func->type == FC_BUILDIN)
                continue;
            if (v)
                Jsi_IncrRefCount(interp, v);
            else {
                v = Jsi_ValueNew(interp);
            }
            jsi_ValueObjSet(interp, args, argkey, v, JSI_OM_DONTENUM | JSI_OM_INNERSHARED, 1);
        }
    }
    return rc;
}

void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall)
{
    if (interp->hasCallee) {
        Jsi_Value *callee = Jsi_ValueNew1(interp);
        Jsi_ValueCopy(interp, callee, tocall);
        Jsi_ValueInsert(interp, args, "\1callee\1", callee, JSI_OM_DONTENUM);
        Jsi_DecrRefCount(interp, callee);
    }
}

static Jsi_RC jsi_FuncBindCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_FuncObj *fo = funcPtr->fobj;
    Jsi_Value *nargs = args, *fargs = fo->bindArgs;
    int i, argc = Jsi_ValueGetLength(interp, args);
    int fargc = (fargs? Jsi_ValueGetLength(interp, fargs) : 0);

    if (fargc>0) {
        Jsi_Value *nthis = Jsi_ValueArrayIndex(interp, fargs, 0);
        if (nthis && !Jsi_ValueIsNull(interp, nthis))
            _this = nthis;
        if (fargc>1) {
            nargs = Jsi_ValueNewArray(interp, NULL, 0);
            for (i=1; i<fargc; i++)
                Jsi_ValueArrayPush(interp, nargs, Jsi_ValueArrayIndex(interp, fargs, i));
            for (i=0; i<argc; i++)
                Jsi_ValueArrayPush(interp, nargs, Jsi_ValueArrayIndex(interp, args, i));
            Jsi_IncrRefCount(interp, nargs);
        }
    }
    Jsi_RC rc = Jsi_FunctionInvoke(interp, fo->bindFunc, nargs, ret, _this);
    if (nargs != args)
        Jsi_DecrRefCount(interp, nargs);
    return rc;
}

static Jsi_RC jsi_FunctionBindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *tocall = _this;
    if (!Jsi_ValueIsFunction(interp, tocall) || !tocall->d.obj->d.fobj) 
        return Jsi_LogError("can not execute expression, expression is not a function");
    
    Jsi_Value *oval = jsi_MakeFuncValue(interp, jsi_FuncBindCall, NULL, ret, NULL);
    Jsi_Obj *obj = oval->d.obj;
    Jsi_FuncObj *fo = obj->d.fobj;
    Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
    Jsi_ObjDecrRefCount(interp, obj);
    fo->bindArgs = Jsi_ValueDup(interp, args);
    fo->bindFunc = tocall;
    Jsi_IncrRefCount(interp, tocall);
    if (fstatic->callback == jsi_NoOpCmd)
        obj->isNoOp = 1;
    return JSI_OK;
}

Jsi_RC Jsi_FunctionCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret)
{
    Jsi_Value *tocall = _this;
    if (!Jsi_ValueIsFunction(interp, tocall)) 
        return Jsi_LogError("can not execute expression, expression is not a function");

    if (!tocall->d.obj->d.fobj) {   /* empty function */
        return JSI_OK;
    }
    
    /* func to call */
    Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
    
    /* new this */
    Jsi_Value *ntPtr;
    Jsi_Value *arg1 = NULL;
    if ((arg1 = Jsi_ValueArrayIndex(interp, args, 0)) && !Jsi_ValueIsUndef(interp, arg1)
        && !Jsi_ValueIsNull(interp, arg1))
        ntPtr = Jsi_ValueDup(interp, arg1);
    else
        ntPtr = Jsi_ValueDup(interp, interp->Top_object);
    Jsi_ValueToObject(interp, ntPtr);
    
    /* prepare args */
    Jsi_ValueArrayShift(interp, args);
    Jsi_RC res = jsi_SharedArgs(interp, args, fstatic, 1);
    
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, args, fstatic);
        jsi_SetCallee(interp, args, tocall);
        
        if (fstatic->type == FC_NORMAL) {
            res = jsi_evalcode(interp->ps, fstatic, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                       args, ntPtr, ret);
        } else {
            res = fstatic->callback(interp, args, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic, 0);
    jsi_SharedArgs(interp, args, fstatic, 0);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}

static Jsi_RC jsi_FunctionCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) 
        return Jsi_LogError("Execute call as constructor");
    
    return Jsi_FunctionCall(interp, args, _this, ret);
}


static Jsi_RC ObjectKeysCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
   int argc = Jsi_ValueGetLength(interp, args);
   Jsi_Value *val = _this;
   
   if (argc>0)
        val = Jsi_ValueArrayIndex(interp, args, 0);

    Jsi_RC rc = Jsi_ValueGetKeys(interp, val, *ret);
    if (rc != JSI_OK)
        Jsi_LogError("can not call Keys() with non-object");
    return rc;
}

Jsi_RC jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_ValueIsString(interp, _this)) {
        Jsi_ValueCopy(interp, *ret, _this);
        return JSI_OK;
    }    
    int quote = JSI_OUTPUT_QUOTE;
    Jsi_DString dStr = {};
    Jsi_ValueGetDString(interp, _this, &dStr, quote);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}


Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret)
{
    int isalloc = 0;
    Jsi_Value *tocall = _this;
    if (!Jsi_ValueIsFunction(interp, tocall)) 
        return Jsi_LogError("can not execute expression, expression is not a function");

    if (!tocall->d.obj->d.fobj) {   /* empty function */
        return JSI_OK;
    }
    
    /* func to call */
    Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
   /* if (fstatic == NULL || fstatic->callback == jsi_Function_constructor) 
        return Jsi_LogError("can not use apply to itself");*/
    
    /* new this */
    Jsi_Value *ntPtr;
    Jsi_Value *arg1 = NULL;
    if ((arg1 = Jsi_ValueArrayIndex(interp, args, 0)) && !Jsi_ValueIsUndef(interp, arg1)
        && !Jsi_ValueIsNull(interp, arg1))
        ntPtr = Jsi_ValueDup(interp, arg1);
    else
        ntPtr = Jsi_ValueDup(interp, interp->Top_object);
    Jsi_ValueToObject(interp, ntPtr);
    
    /* prepare args */
    Jsi_RC res = JSI_ERROR;
    Jsi_Value *newscope = Jsi_ValueArrayIndex(interp, args, 1);
    if (newscope) {
        if (newscope->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, newscope->d.obj)) {
            Jsi_LogError("second argument to Function.prototype.apply must be an array");
            goto done;
        }
    } else {
        isalloc = 1;
        newscope = jsi_ObjValueNew(interp);
        Jsi_ObjSetLength(interp, newscope->d.obj, 0);
        Jsi_IncrRefCount(interp, newscope);
    }
    
    res = jsi_SharedArgs(interp, newscope, fstatic, 1);
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, newscope, fstatic);
        jsi_SetCallee(interp, newscope, tocall);
    
        if (fstatic->type == FC_NORMAL) {
            res = jsi_evalcode(interp->ps, fstatic, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                newscope, ntPtr, ret);
        } else {
            res = fstatic->callback(interp, newscope, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic, 0);
    jsi_SharedArgs(interp, newscope, fstatic, 0);
done:
    if (isalloc)
        Jsi_DecrRefCount(interp, newscope);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}


static Jsi_RC ObjectValueOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_ValueDup2(interp, ret, _this);
    return JSI_OK;
}

#if (JSI_HAS___PROTO__==1)
Jsi_RC jsi_GetPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args,0);
    if (v->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    Jsi_ValueDup2(interp, ret, v->d.obj->__proto__);
    return JSI_OK;
}

Jsi_RC jsi_SetPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *a = Jsi_ValueArrayIndex(interp, args,1);
    if (v->vt != JSI_VT_OBJECT || a->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    v->d.obj->__proto__ = Jsi_ValueDup(interp, a);
    v->d.obj->clearProto = 1;
    return JSI_OK;
}
#endif

Jsi_RC jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    char *key = Jsi_ValueArrayIndexToStr(interp, args,0, NULL);
    v = Jsi_ValueObjLookup(interp, _this, key, 0);
    Jsi_ValueMakeBool(interp, ret, (v != NULL));
    return JSI_OK;
}

static Jsi_RC ObjectIsPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *proto, *sproto, *v = Jsi_ValueArrayIndex(interp, args,0);
    int bval = 0;
    if (v->vt != JSI_VT_OBJECT || _this->vt != JSI_VT_OBJECT) {
        goto retval;
    }
    proto = _this->d.obj->__proto__;
    sproto = v->d.obj->__proto__;
    if (!proto)
        goto retval;
    while (sproto) {
        if ((bval=(sproto == proto)))
            break;
        if (sproto->vt != JSI_VT_OBJECT)
            break;
        sproto = sproto->d.obj->__proto__;
    }
retval:
    Jsi_ValueMakeBool(interp, ret, bval);
    return JSI_OK;
    
}

static Jsi_RC ObjectIsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *v2 = Jsi_ValueArrayIndex(interp, args,1);
    Jsi_ValueMakeBool(interp, ret, Jsi_ValueIsEqual(interp, v1, v2));
    return JSI_OK;
}

static Jsi_RC ObjectCreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->noInherit) 
        return Jsi_LogError("inheritance is disabled in interp");
    Jsi_Obj *obj;
    Jsi_Value *proto = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *props = Jsi_ValueArrayIndex(interp, args,1);

    if (proto->vt != JSI_VT_NULL && proto->vt != JSI_VT_OBJECT) 
        return Jsi_LogError("arg 1 is not a proto object or null");
    if (props && (props->vt != JSI_VT_OBJECT || props->d.obj->ot != JSI_OT_OBJECT)) 
        return Jsi_LogError("arg 2 is not a properties object");
        
    Jsi_ValueMakeObject(interp, ret, obj=Jsi_ObjNew(interp));
    if (proto->vt == JSI_VT_OBJECT) {
        obj->__proto__ = proto;
        obj->clearProto = 1;
        Jsi_IncrRefCount(interp, proto);
    }
    if (props) {
        Jsi_Obj *pobj = props->d.obj;
        Jsi_TreeEntry *tPtr;
        Jsi_TreeSearch search;
        for (tPtr = Jsi_TreeSearchFirst(pobj->tree, &search, 0, NULL);
            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
            Jsi_Value *v = (Jsi_Value *)Jsi_TreeValueGet(tPtr);
            if (v && v->f.bits.dontenum == 0)
                Jsi_ObjInsert(interp, obj, (const char *)Jsi_TreeKeyGet(tPtr), v, 0);
        }
        Jsi_TreeSearchDone(&search);
    }
    return JSI_OK;
    
}

static Jsi_RC ObjectPropertyIsEnumerableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    int b = 0;

    char *key = Jsi_ValueArrayIndexToStr(interp, args,0, NULL);
    v = Jsi_ValueObjLookup(interp, _this, key, 0);
    b = (v && (v->f.bits.dontenum==0));

    Jsi_ValueMakeBool(interp, ret, b);
    return JSI_OK;
}

static Jsi_RC ObjectToLocaleStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
}

static Jsi_RC jsi_FunctionApplyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) 
        return Jsi_LogError("Execute apply as constructor");
    
    return Jsi_FunctionApply(interp, args, _this, ret);
}

Jsi_Value *jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name) {
    Jsi_Value *v = jsi_ObjValueNew(interp);
    Jsi_IncrRefCount(interp, v);
    //v->f.bits.isglob = 1;
#ifdef JSI_MEM_DEBUG
    v->VD.label = "jsi_ProtoValueNew1";
    v->VD.label2 = name;
#endif
    if (name != NULL)
        Jsi_PrototypeDefine(interp, name, v);
    return v;
}

Jsi_Value *jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent)
{
    Jsi_Value *fproto;
    if (parent == NULL)
        parent = "Object";
    fproto = jsi_ProtoObjValueNew1(interp, name);
    Jsi_PrototypeObjSet(interp, parent, Jsi_ValueGetObj(interp, fproto));
    return fproto;
}

static Jsi_CmdSpec functionCmds[] = {
    { "Function",  jsi_Function_constructor,   0, 0,  "", .help="Function constructor (unimplemented)", .retType=(uint)JSI_TT_FUNCTION, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { "apply",     jsi_FunctionApplyCmd,       1, 2,  "thisArg:null|object, args:array=void", .help="Call function passing args array", .retType=(uint)JSI_TT_ANY },
    { "bind",      jsi_FunctionBindCmd,        0, -1, "thisArg:object=null,arg,...", .help="Return function that calls bound function prepended with thisArg+arguments", .retType=(uint)JSI_TT_ANY },
    { "call",      jsi_FunctionCallCmd,        1, -1, "thisArg:null|object, arg1, ...", .help="Call function with args", .retType=(uint)JSI_TT_ANY },
    { NULL, 0,0,0,0, .help="Commands for accessing functions" }
};

int jsi_InitFunction(Jsi_Interp *interp, int release)
{
    if (!release)
        Jsi_CommandCreateSpecs(interp, NULL, functionCmds, interp->Function_prototype, JSI_CMDSPEC_PROTO|JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

/* TODO: defineProperty, defineProperties, */
static Jsi_CmdSpec objectCmds[] = {
#ifndef __JSI_OMITDECL
    { "Object",         ObjectConstructor,      0,  1,  "val:object|null=void", .help="Object constructor", .retType=(uint)JSI_TT_OBJECT, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { "create",         ObjectCreateCmd,        1, 2, "proto:null|object, properties:object=void", .help="Create a new object with prototype object and properties", .retType=(uint)JSI_TT_OBJECT },
#if (JSI_HAS___PROTO__>0)
    { "getPrototypeOf", jsi_GetPrototypeOfCmd,  1, 1, "name:object", .help="Return prototype of an object", .retType=(uint)JSI_TT_OBJECT },
#endif
    { "hasOwnProperty", jsi_HasOwnPropertyCmd,  1, 1, "name:string", .help="Returns a true if object has the specified property", .retType=(uint)JSI_TT_BOOLEAN },
    { "is",             ObjectIsCmd, 2, 2, "value1, value2", .help="Tests if two values are equal", .retType=(uint)JSI_TT_BOOLEAN },
    { "isPrototypeOf",  ObjectIsPrototypeOfCmd, 1, 1, "name", .help="Tests for an object in another object's prototype chain", .retType=(uint)JSI_TT_BOOLEAN },
    { "keys",           ObjectKeysCmd,          0, 1, "obj:object=void", .help="Return the keys of an object or array", .retType=(uint)JSI_TT_ARRAY },
    { "propertyIsEnumerable", ObjectPropertyIsEnumerableCmd,1, 1, "name", .help="Determine if a property is enumerable", .retType=(uint)JSI_TT_BOOLEAN },
#if (JSI_HAS___PROTO__>0)
    { "setPrototypeOf", jsi_SetPrototypeOfCmd,  2, 2, "name:object, value:object", .help="Set prototype of an object" },
#endif
    { "toLocaleString", ObjectToLocaleStringCmd,0, 1, "quote:boolean=false", .help="Convert to string", .retType=(uint)JSI_TT_STRING },
    { "toString",       jsi_ObjectToStringCmd,  0, 1, "quote:boolean=false", .help="Convert to string", .retType=(uint)JSI_TT_STRING }, 
    { "valueOf",        ObjectValueOfCmd,       0, 0, "", .help="Returns primitive value", .retType=(uint)JSI_TT_ANY },
    { NULL, 0,0,0,0, .help="Commands for accessing Objects" }
#endif
};

int jsi_InitObject(Jsi_Interp *interp, int release)
{
    if (!release)
        Jsi_CommandCreateSpecs(interp, NULL, objectCmds, interp->Object_prototype, JSI_CMDSPEC_PROTO|JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

Jsi_RC jsi_InitProto(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
     /* Function and Object are created together. */
    Jsi_Value *global = interp->csc;
    /* Top, the default "this" value, pointed to global, is an object */
    interp->Top_object = global;

    /* object_prototype the start of protochain */
    interp->Object_prototype = jsi_ProtoObjValueNew1(interp, "Object");
    interp->Top_object->d.obj->__proto__ = interp->Object_prototype;
        
    /* Function.prototype.prototype is a common object */
    interp->Function_prototype_prototype = jsi_ProtoObjValueNew1(interp, "Function.prototype");
    interp->Function_prototype_prototype->d.obj->__proto__ = interp->Object_prototype;
    
    /* Function.prototype.__proto__ pointed to Jsi_Obj.prototype */
    interp->Function_prototype = jsi_MakeFuncValue(interp, jsi_FunctionPrototypeConstructor, "prototype", NULL, NULL);
    //Jsi_IncrRefCount(interp, interp->Function_prototype);
    Jsi_ValueInsertFixed(interp, interp->Function_prototype, "prototype", 
                              interp->Function_prototype_prototype);
    interp->Function_prototype->d.obj->__proto__ = interp->Object_prototype;
    
    /* Jsi_Obj.__proto__ pointed to Function.prototype */
    Jsi_Value *_Object = jsi_MakeFuncValue(interp, ObjectConstructor, "prototype", NULL, NULL);
    //Jsi_IncrRefCount(interp, _Object);
    Jsi_ValueInsertFixed(interp, _Object, "prototype", interp->Object_prototype);
    _Object->d.obj->__proto__ = interp->Function_prototype;

    /* both Function.prototype,__proto__ pointed to Function.prototype */
    Jsi_Value *_Function = jsi_MakeFuncValue(interp, jsi_Function_constructor, "prototype", NULL, NULL);
    //Jsi_IncrRefCount(interp, _Function);
    Jsi_ValueInsertFixed(interp, _Function, "prototype", interp->Function_prototype);
    _Function->d.obj->__proto__ = interp->Function_prototype;

    Jsi_ValueInsert(interp, global, "Object", _Object, JSI_OM_DONTENUM);
    Jsi_ValueInsert(interp, global, "Function", _Function, JSI_OM_DONTENUM);

    //Jsi_HashSet(interp->genValueTbl, _Object, _Object);
    //Jsi_HashSet(interp->genValueTbl, _Function, _Function);
    //Jsi_HashSet(interp->genValueTbl, interp->Object_prototype , interp->Object_prototype);
    //Jsi_HashSet(interp->genValueTbl, interp->Function_prototype, interp->Function_prototype);
    Jsi_HashSet(interp->genObjTbl, interp->Function_prototype->d.obj, interp->Function_prototype->d.obj);

    interp->cleanObjs[0] = _Function->d.obj;
    interp->cleanObjs[1] = _Object->d.obj;
    interp->cleanObjs[2] = NULL;

    jsi_InitObject(interp, 0);
    jsi_InitFunction(interp, 0);
    
    jsi_InitString(interp, 0);
    jsi_InitBoolean(interp, 0);
    jsi_InitNumber(interp, 0);
    jsi_InitArray(interp, 0);
    jsi_InitRegexp(interp, 0);
#ifndef JSI_OMIT_MATH
    jsi_InitMath(interp, 0);
#endif
    jsi_InitTree(interp, 0);
    interp->protoInit = 1;
    return JSI_OK;
}

#endif
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <assert.h>
#include <dirent.h>

#ifndef __WIN32
#include <pwd.h>
#include <unistd.h>
#else
#include <windef.h>
#endif
#include <limits.h>

static Jsi_Filesystem *cwdFsPtr = NULL;
static Jsi_DString pwdStr = {};
static char *jsi_pwd = NULL;

#ifndef JSI_LITE_ONLY

#define _JSI_GETFP(ch,in) (ch && ch->fp ? ch->fp : (in?stdin:stdout))

//static Jsi_CmdSpec filesysCmds[];

static char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *path, char *newPath);


typedef struct FileObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Channel chan;
    Jsi_Value *fname;
    char *filename;
    char *mode;
    Jsi_Obj *fobj;
    int objId;
} FileObj;

static void fileObjErase(FileObj *fo);
static Jsi_RC fileObjFree(Jsi_Interp *interp, void *data);
static bool fileObjIsTrue(void *data);
static bool fileObjEqual(void *data1, void *data2);

#ifdef __WIN32
char *get_current_dir_name() {
    static char buf[MAX_PATH];
     getcwd(buf, sizeof(buf));
     return buf;
}
#endif

static const char *jsi_TildePath(Jsi_Interp *interp, const char* path, Jsi_DString *dStr) {
    if (*path != '~')
        return path;
    const char *homedir = jsi_GetHomeDir(interp);
    if (!homedir)
        return path;
    Jsi_DSAppend(dStr, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
    return Jsi_DSValue(dStr);
}

int jsi_FSScandirProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,
   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))
{
    const char *dirname = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*dirname == '~')
        dirname = jsi_TildePath(interp, dirname, &dStr);
    int rc = scandir(dirname, namelist, filter, compar);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSCreateDirectoryProc(Jsi_Interp *interp, Jsi_Value* path) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    int rc;
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);

#ifdef __WIN32
    rc = mkdir(pathPtr);
#else
    rc = mkdir(pathPtr, 0666);
#endif
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSRenameProc(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dest) {
    const char *zSrc = Jsi_ValueToString(interp, src, NULL);
    const char *zDest = Jsi_ValueToString(interp, dest, NULL);
    Jsi_DString dStr = {}, eStr = {};
    if (*zSrc == '~')
        zSrc = jsi_TildePath(interp, zSrc, &dStr);
    if (*zDest == '~')
        zDest = jsi_TildePath(interp, zDest, &eStr);
    int rc = rename(zSrc, zDest);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
    return rc;
}

static Jsi_Value * jsi_FSListVolumesProc(Jsi_Interp *interp) {return 0;}

static int jsi_FSRemoveProc(Jsi_Interp *interp, Jsi_Value* path, int flags) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = remove(pathPtr);
    Jsi_DSFree(&dStr);
    return rc;
}

static bool jsi_FSPathInFilesystemProc(Jsi_Interp *interp, Jsi_Value* path,void **clientDataPtr) {return 1;}

static int jsi_FSAccessProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = access(pathPtr, mode);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSChmodProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {
#ifdef __WIN32
    return -1;
#else
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = chmod(pathPtr, mode);
    Jsi_DSFree(&dStr);
    return rc;
#endif
}

static int jsi_FSStatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = stat(pathPtr, buf);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSLstatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
#ifdef __WIN32
    return jsi_FSStatProc(interp, path, buf);
#else
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = lstat(pathPtr, buf);
    Jsi_DSFree(&dStr);
    return rc;
#endif
}
static int jsi_FSFlushProc(Jsi_Channel chan) { return fflush(_JSI_GETFP(chan,0));}
static int jsi_FSTellProc(Jsi_Channel chan) { return ftell(_JSI_GETFP(chan,1));}
static int jsi_FSEofProc(Jsi_Channel chan) { return feof(_JSI_GETFP(chan,1));}
static int jsi_FSTruncateProc(Jsi_Channel chan, unsigned int len) { return ftruncate(fileno(_JSI_GETFP(chan,1)), len);}
static int jsi_FSRewindProc(Jsi_Channel chan) { rewind(_JSI_GETFP(chan,1)); return 0;}
static int jsi_FSCloseProc(Jsi_Channel chan) { return fclose(_JSI_GETFP(chan,1));}
static int jsi_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) { return fseek(_JSI_GETFP(chan,1), offset, mode);}

static int jsi_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {
    return fwrite(buf, 1, size, _JSI_GETFP(chan,0));
}

static int jsi_FSReadProc(Jsi_Channel chan, char *buf, int size) {
    return fread(buf, 1, size, _JSI_GETFP(chan,0));
}

#ifdef __WIN32
#define jsi_FSLinkProc NULL
#define jsi_FSReadlinkProc NULL
#else //__WIN32
static int jsi_FSLinkProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    const char *toPtr = Jsi_ValueToString(interp, toPath, NULL);
    Jsi_DString dStr = {}, eStr = {};
    int rc;
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    if (*toPtr == '~')
        toPtr = jsi_TildePath(interp, toPtr, &eStr);
    if (linkType != 0)
        rc = link(pathPtr, toPtr);
    else
        rc = symlink(pathPtr, toPtr);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
    return rc;
}

static int jsi_FSReadlinkProc(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = readlink(pathPtr, buf, size);
    Jsi_DSFree(&dStr);
    return rc;
}
#endif // __WIN32

static int jsi_FSGetcProc(Jsi_Channel chan) {
    return fgetc(_JSI_GETFP(chan,1));
}

static int jsi_FSUngetcProc(Jsi_Channel chan, int ch) {
    return ungetc(ch, _JSI_GETFP(chan,1));
}

static char * jsi_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    return fgets(s, size, _JSI_GETFP(chan,1));
}

static int jsi_FSPutsProc(Jsi_Channel chan, const char *s) {
    return fputs(s, _JSI_GETFP(chan,0));
}

/* Not used as Jsi_Open already handles native. */
Jsi_Channel jsi_FSOpenProc(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)
{
    return Jsi_Open(interp, file, modeString);
}

typedef struct FSList {
    Jsi_Filesystem* fsPtr;
    void *data;
    struct FSList *next;
} FSList;

static FSList *jsiFSList = NULL;
Jsi_Chan jsi_StdChans[3];

static Jsi_Filesystem jsiFilesystem = {
    .typeName="native",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .pathInFilesystemProc=jsi_FSPathInFilesystemProc,
    .realpathProc=jsi_FSRealPathProc,
    .statProc=jsi_FSStatProc,
    .lstatProc=jsi_FSLstatProc,
    .accessProc=jsi_FSAccessProc,
    .chmodProc=jsi_FSChmodProc,
    .openProc=jsi_FSOpenProc,
    .scandirProc=jsi_FSScandirProc,
    .readProc=jsi_FSReadProc,
    .writeProc=jsi_FSWriteProc,
    .getsProc=jsi_FSGetsProc,
    .getcProc=jsi_FSGetcProc,
    .ungetcProc=jsi_FSUngetcProc,
    .putsProc=jsi_FSPutsProc,
    .flushProc=jsi_FSFlushProc,
    .seekProc=jsi_FSSeekProc,
    .tellProc=jsi_FSTellProc,
    .eofProc=jsi_FSEofProc,
    .truncateProc=jsi_FSTruncateProc,
    .rewindProc=jsi_FSRewindProc,
    .closeProc=jsi_FSCloseProc,
    .linkProc=jsi_FSLinkProc,
    .readlinkProc=jsi_FSReadlinkProc,
    .listVolumesProc=jsi_FSListVolumesProc,
    .createDirectoryProc=jsi_FSCreateDirectoryProc,
    .removeProc=jsi_FSRemoveProc,
    .renameProc=jsi_FSRenameProc,
};

Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id) {
    if (id<0 || id>2)
        return NULL;
    return jsi_StdChans+id;
}

Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data) {
    FSList *fsl = (FSList *)Jsi_Calloc(1, sizeof(*fsl));
    fsl->fsPtr = fsPtr;
    fsl->data = data;
    fsl->next = jsiFSList;
    jsiFSList = fsl;
    return JSI_OK;
}

Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr) {
    FSList *fsl = jsiFSList, *flast = NULL;
    while (fsl) {
        if (fsl->fsPtr == fsPtr) {
            if (flast)
                flast->next = fsl->next;
            else
                jsiFSList = fsl->next;
            Jsi_Free(fsl);
            break;
        }
        flast = fsl;
        fsl = fsl->next;
    }
    return JSI_OK;
}

Jsi_Filesystem* Jsi_FilesystemForPath(Jsi_Interp *interp, Jsi_Value* path, void**clientDataPtr) {
    FSList *fsl = jsiFSList;
    if (!fsl) return NULL;
    clientDataPtr = NULL;
    const char *pathStr = Jsi_ValueToString(interp, path, NULL);
    if (pathStr[0] == '~')
        return &jsiFilesystem;
    if (pathStr[0] == '.' && pathStr[1] == 0)
        return (cwdFsPtr ? cwdFsPtr : &jsiFilesystem);
    while (1) {
        if (fsl->fsPtr->pathInFilesystemProc && fsl->fsPtr->pathInFilesystemProc(interp, path, clientDataPtr))
            break;
        if (!fsl->next)
            break;
        fsl = fsl->next;
    }
    return (fsl ? fsl->fsPtr : &jsiFilesystem);
}

int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len) {
#ifdef __WIN32
    return -1;
#else
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->readlinkProc) return -1;
    return fsPtr->readlinkProc(interp, path, ret, len);
#endif
}

int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->statProc) return -1;
    return fsPtr->statProc(interp, path, buf);
}

int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);
    if (fsPtr == NULL || !fsPtr->linkProc) return -1;
    return fsPtr->linkProc(interp, src, dest, typ);
}

int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->lstatProc) return -1;
    return fsPtr->lstatProc(interp, path, buf);
}

int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->chmodProc) return -1;
    return fsPtr->chmodProc(interp, path, mode);
}
int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->accessProc) return -1;
    return fsPtr->accessProc(interp, path, mode);
}
int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->removeProc) return -1;
    return fsPtr->removeProc(interp, path, flags);
}
int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);
    if (fsPtr != Jsi_FilesystemForPath(interp, src, &data)) return -1;
    if (fsPtr == NULL || !fsPtr->renameProc) return -1;
    return fsPtr->renameProc(interp, src,dst);
}

int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value* path, Jsi_Dirent ***namelist,
 int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**)) 
 {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->scandirProc) return -1;
    return fsPtr->scandirProc(interp, path, namelist, filter, compar);
}

bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value *file) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, file, &data);
    if (fsPtr && fsPtr == &jsiFilesystem)
        return 1;
    else
        return 0;
}

static Jsi_Filesystem *jsi_FilesysFind(const char *name)
{
    FSList *fsPtr = jsiFSList;
    while (fsPtr != NULL) {
        if (!Jsi_Strcmp(fsPtr->fsPtr->typeName, name))
            return fsPtr->fsPtr;
        fsPtr = fsPtr->next;
    }
    return NULL;
}

Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)
{
    /* Find fsys, and use open there. */
    Jsi_Filesystem *fsPtr;
    Jsi_Chan *ch = NULL;
    void *data;
    const char *fileName = Jsi_ValueToString(interp, file, NULL);
    if (!fileName) {
        Jsi_LogError("expected string");
        return NULL;
    }
    if (!Jsi_Strcmp(fileName, "stdin")) return jsi_StdChans;
    if (!Jsi_Strcmp(fileName, "stdout")) return jsi_StdChans+1;
    if (!Jsi_Strcmp(fileName, "stderr")) return jsi_StdChans+2;
    const char *s = modeString;
    char Mode[sizeof(ch->modes)];
    Jsi_StatBuf sb;
    Jsi_Value *path = NULL;
    int n, i, mode = 0, rc, writ;
    if (!s)
        s = "r";
    if (Jsi_Strlen(s) >= sizeof(ch->modes)) {
        Jsi_LogError("mode too long: %s", s);
        return NULL;
    }
    if (Jsi_Strchr(s, 'z') || Jsi_Strchr(s, 'Z')) {
        Jsi_Filesystem *fsPtr = jsi_FilesysFind("jfz");
        if (!fsPtr) {
            Jsi_LogError("compressed files unsupported");
            return NULL;
        }
        ch = fsPtr->openProc(interp, file, s);
        if (!ch) {
            Jsi_LogError("File open failed '%s'", fileName);
            return NULL;
        }
        Jsi_Chan *nch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*nch));
        *nch = *ch;
        nch->fsPtr = fsPtr;
        return nch;
    }
    for (i=0, n = 0; s[i]; i++) {
        switch (s[i]) {
            case '+': break;
            case 'b': break;
            case 'r': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_READONLY; break;
            case 'a':
            case 'w': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_WRITEONLY; break;
            default: Jsi_LogError("unknown mode char: %c", s[i]); return NULL;
        }
        Mode[n++] = s[i];
    }
    Mode[n] = 0;
    /* Fixup files in the ~ dir */
    rc = Jsi_Stat(interp, file,&sb);
    if ((rc != 0 || *fileName == '~') && (fileName = Jsi_FileRealpath(interp, file, NULL))) {
        path = Jsi_ValueNewString(interp, fileName, -1);
        Jsi_IncrRefCount(interp, path);
        rc = Jsi_Stat(interp, path, &sb);
        if (rc == 0)
            file = path;
    }

    if (rc == 0 &&  sb.st_mode & S_IFDIR )
    {
        Jsi_LogError("can not open directory: %s", fileName);
        goto done;
    }
    fsPtr = Jsi_FilesystemForPath(interp, file, &data);
    writ = (Jsi_Strchr(s,'w') || Jsi_Strchr(s,'a') || Jsi_Strchr(s,'+'));
    if (interp->isSafe && Jsi_InterpAccess(interp, file, writ) != JSI_OK) {
        Jsi_LogError("%s access denied", writ?"write":"read");
        goto done;
    }
    if (fsPtr && fsPtr != &jsiFilesystem) {
        ch = fsPtr->openProc(interp, file, Mode);
        if (ch)
            ch->isNative = 0;
        else
            Jsi_LogError("File open failed '%s'", fileName);
    } else {
        FILE *fp = fopen(fileName, Mode);
        fsPtr = &jsiFilesystem;
        if (!fp) {
            Jsi_LogError("File open failed '%s'", fileName);
            goto done;
        }
        ch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*ch));
        ch->fp = fp;
        ch->isNative = 1;
    }
    if (ch) {
        ch->flags |= mode; // + (zLevel<<24);
        Jsi_Strcpy(ch->modes, s);
        ch->interp = interp;
        ch->fsPtr = fsPtr;
        ch->fname = fileName;
    }
done:
    if (path)
        Jsi_DecrRefCount(interp, path);
    return ch;
}

int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName,
    const char *newValue) {return JSI_OK;}
    
Jsi_Wide Jsi_Seek(Jsi_Channel chan, Jsi_Wide offset, int mode) {
    if (chan->fsPtr==0 || !chan->fsPtr->seekProc) return -1;
    return chan->fsPtr->seekProc(chan, offset, mode);
}
Jsi_Wide Jsi_Tell(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->tellProc) return -1;
    return chan->fsPtr->tellProc(chan);
}
int Jsi_Eof(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->eofProc) return -1;
    return chan->fsPtr->eofProc(chan);
}
Jsi_Wide Jsi_Rewind(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->rewindProc) return -1;
    return chan->fsPtr->rewindProc(chan);
}

/*Jsi_StatBuf* Jsi_AllocStatBuf(void) {return 0;}*/

int Jsi_Read(Jsi_Channel chan, char *bufPtr, int toRead) {
    if (chan->fsPtr==0 || !chan->fsPtr->readProc) return -1;
    return chan->fsPtr->readProc(chan, bufPtr, toRead);
}
int Jsi_Write(Jsi_Channel chan, const char *bufPtr, int slen) {
    if (chan->fsPtr==0 || !chan->fsPtr->writeProc) return -1;
    return chan->fsPtr->writeProc(chan, bufPtr, slen);
}
int Jsi_Truncate(Jsi_Channel chan, unsigned int len) {
    if (chan->fsPtr==0 || !chan->fsPtr->truncateProc) return -1;
    return chan->fsPtr->truncateProc(chan, len);
}

int Jsi_Close(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->closeProc) return -1;
    if (chan->flags&JSI_FS_NOCLOSE) return -1;
    int rc = chan->fsPtr->closeProc(chan);
    if (rc == 0)
        Jsi_Free(chan);
    return rc;
}
int Jsi_Flush(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->flushProc) return -1;
    return chan->fsPtr->flushProc(chan);
}

int Jsi_Getc(Jsi_Channel chan) {
    if (chan->fsPtr==0 || !chan->fsPtr->getcProc) return -1;
    return chan->fsPtr->getcProc(chan);
}

int Jsi_Ungetc(Jsi_Channel chan, int ch) {
    if (chan->fsPtr==0 || !chan->fsPtr->ungetcProc) return -1;
    return chan->fsPtr->ungetcProc(chan, ch);
}

char * Jsi_Gets(Jsi_Channel chan, char *s, int size) {
    if (chan->fsPtr==0 || !chan->fsPtr->getsProc) return NULL;
    return chan->fsPtr->getsProc(chan, s, size);
}

int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path) {
    void *data;
    int rc = 0;
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    if (interp->isSafe && Jsi_InterpAccess(interp, path, 0) != JSI_OK) 
        return Jsi_LogError("read access denied");
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == &jsiFilesystem) {
        rc = chdir(pathPtr);
        if (rc < 0)
            return -1;
        /* If change out of native fs, GetCwd will use pwdStr */
        fsPtr = NULL;
    }
    Jsi_DSSetLength(&pwdStr, 0);
    Jsi_DSAppendLen(&pwdStr, pathPtr, -1);
    cwdFsPtr = fsPtr;
    jsi_pwd = fsPtr ? Jsi_DSValue(&pwdStr) : NULL;
    return rc;
}

char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *file, Jsi_DString *dStr) {
    return Jsi_NormalPath(interp, Jsi_ValueString(interp, file, NULL), dStr);
}

char *Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *spath, char *newname)
{
    char *path = Jsi_ValueString(interp, spath, 0);
    if (!path) return NULL;
    return Jsi_FileRealpathStr(interp, path, newname);
}

static char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *src, char *newPath) {
    return Jsi_FileRealpath(interp, src, newPath);
}

char *Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *src, char *newname)
{
    /* TODO: resolve pwd first. */
    void *data;
    const char *cp = NULL;
    Jsi_Filesystem *fsPtr;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    const char *npath = Jsi_ValueNormalPath(interp, src, &dStr);
    if (!npath) return NULL;
    Jsi_Value *tPtr = Jsi_ValueNew1(interp);
    Jsi_ValueMakeStringDup(interp, &tPtr, npath);
    fsPtr = Jsi_FilesystemForPath(interp, tPtr, &data);
    if (fsPtr) {
        if (fsPtr->realpathProc)
            cp = fsPtr->realpathProc(interp, src, newname);
        else
            cp = Jsi_Strdup(npath);
    }
    Jsi_DSFree(&dStr);
    Jsi_DecrRefCount(interp, tPtr);
    return (char*)cp;
}


static void fileObjErase(FileObj *fo)
{
    if (fo->filename) {
        Jsi_Close(fo->chan);
        Jsi_Free(fo->filename);
        Jsi_DecrRefCount(fo->interp, fo->fname);
        Jsi_Free(fo->mode);
    }
    fo->filename = NULL;
}

static Jsi_RC fileObjFree(Jsi_Interp *interp, void *data)
{
    FileObj *fo = (FileObj *)data;
    SIGASSERT(fo,FILEOBJ);
    fileObjErase(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static bool fileObjIsTrue(void *data)
{
    FileObj *fo = (FileObj *)data;
    SIGASSERT(fo,FILEOBJ);
    if (!fo->filename) return JSI_OK;
    else return 1;
}

static bool fileObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static int try_open_file(Jsi_Interp *interp, FileObj *udf, Jsi_Value *args)
{
    int ret = JSI_ERROR;
    fileObjErase(udf);
    // TODO: stdin, stdout, stderr, etc.
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    if (fname && Jsi_ValueIsString(interp, fname)) {
        Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);
        const char *mode = NULL;
        const char *fstr = Jsi_ValueString(interp, fname, NULL);
        if (vmode && Jsi_ValueIsString(interp,vmode)) {
            mode = Jsi_ValueString(interp, vmode, NULL);
        }
        if (interp->isSafe && Jsi_InterpAccess(interp, fname, (mode && (Jsi_Strchr(mode,'w')||Jsi_Strchr(mode,'+')))) != JSI_OK)
            return JSI_ERROR;
        char *rmode = Jsi_Strdup(mode ? mode : "r");
        Jsi_Channel chan = Jsi_Open(interp, fname, rmode);
        if (chan) {
            udf->chan = chan;
            udf->fname = fname;
            udf->interp = interp;
            Jsi_IncrRefCount(interp, fname);
            udf->filename = Jsi_Strdup(fstr);
            udf->mode = Jsi_Strdup(rmode);
            ret = JSI_OK;
        }
        Jsi_Free(rmode);
    }
    return ret;
}

#define UdfGet(udf, _this, funcPtr) \
   FileObj *udf = (FileObj *)Jsi_UserObjGetData(interp, _this, funcPtr); \
    if (!udf) \
        return Jsi_LogError("Channel.%s called with non-file object", funcPtr->cmdSpec->name);

static Jsi_RC FilesysOpenCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (try_open_file(interp, udf, args) != JSI_OK) {
        Jsi_ValueMakeBool(interp, ret, 0);
    }
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static Jsi_RC FilesysCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    fileObjErase(udf);
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static Jsi_RC FilesysGetsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int len;
    UdfGet(udf, _this, funcPtr);
    if (!udf->filename) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    char buf[BUFSIZ>8196?BUFSIZ:8196];
    if (!Jsi_Gets(udf->chan, buf, sizeof(buf))) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    buf[sizeof(buf)-1] = 0;
    len = Jsi_Strlen(buf);
    if (len > 0 && buf[len-1] == '\n')
        buf[len-1] = 0;
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(buf));
    return JSI_OK;
}


static Jsi_RC FilesysModeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (udf->mode)
        Jsi_ValueMakeStringKey(interp, ret, udf->mode);
    return JSI_OK;
}

static Jsi_RC FilesysFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (udf->filename)
        Jsi_ValueMakeString(interp, ret, Jsi_Strdup(udf->filename));
    return JSI_OK;
}

static Jsi_RC FilesysReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int  sum = 0, n;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    UdfGet(udf, _this, funcPtr);
    char buf[BUFSIZ];
    int argc = Jsi_ValueGetLength(interp, args);
    int nsiz = -1, cnt = 0, rsiz;
    
    if (!udf->filename) {
        goto bail;
    }
    if (argc>0 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &nsiz) != JSI_OK)
        goto bail;
    while (cnt++ < MAX_LOOP_COUNT) {
        rsiz = sizeof(buf);
        if (nsiz>0 && ((sum+rsiz)>nsiz))
            rsiz = (nsiz-sum);
        if ((n = Jsi_Read(udf->chan, buf, rsiz)) <= 0)
            break;
        Jsi_DSAppendLen(&dStr, buf, n);
        sum += n;
        if (nsiz>=0 && sum >=nsiz)
            break;
    }
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
    return JSI_OK;
    
bail:
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeUndef(interp, ret);
    return JSI_OK;
}


static Jsi_RC FilesysSeekCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    static const char *posStr[] = { "set", "cur", "end", NULL };
    enum { W_SET, W_CUR, W_END };
    UdfGet(udf, _this, funcPtr);
    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vWhence = Jsi_ValueArrayIndex(interp, args, 1);
    int mode = 0, p;
    Jsi_Wide pos;
    Jsi_Number num;
    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)
        return JSI_ERROR;
    if (Jsi_ValueGetIndex(interp, vWhence, posStr, "position", 0, &p) != JSI_OK)
        return JSI_ERROR;
    switch (p) {
        case W_SET: mode = SEEK_SET; break;
        case W_CUR: mode = SEEK_CUR; break;
        case W_END: mode = SEEK_END; break;
    }
    pos = (Jsi_Wide)num;
    pos = Jsi_Seek(udf->chan, pos, mode);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static Jsi_RC FilesysTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Number num;
    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)
        return JSI_ERROR;
    num = (Jsi_Number)Jsi_Truncate(udf->chan, (unsigned int)num);
    Jsi_ValueMakeNumber(interp, ret, num);
    return JSI_OK;
}

static Jsi_RC FilesysStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
#if JSI__FILESYS==1
    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 0);
#else
    return JSI_ERROR;
#endif
}

static Jsi_RC FilesysLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
#if JSI__FILESYS==1
    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 1);
#else
    return JSI_ERROR;
#endif
}

static Jsi_RC FilesysTellCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_Wide pos = Jsi_Tell(udf->chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static Jsi_RC FilesysFlushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    int pos = Jsi_Flush(udf->chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static Jsi_RC FilesysWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int  sum = 0, n, m;
    UdfGet(udf, _this, funcPtr);
    char *buf = Jsi_ValueArrayIndexToStr(interp, args, 0, &m);

    if (!udf->filename) {
        goto bail;
    }
    while (m > 0 && sum < MAX_LOOP_COUNT && (n = Jsi_Write(udf->chan, buf, m)) > 0) {
        /* TODO: limit max size. */
        sum += n;
        m -= n;
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);
    return JSI_OK;
}

static Jsi_RC FilesysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
   
    UdfGet(udf, _this, funcPtr);
    if (!udf->filename) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *toput = Jsi_ValueArrayIndex(interp, args, 0);
    if (!toput) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    const char * cp = Jsi_ValueToString(interp, toput, NULL);

    if (Jsi_Printf(udf->chan, "%s\n", cp?cp:"") < 0) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static Jsi_RC FilesysEofCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_ValueMakeBool(interp, ret, Jsi_Eof(udf->chan));
    return JSI_OK;
}

int Jsi_Printf(Jsi_Channel chan, const char *fmt, ...)
{
    va_list va;
    int n;
    FILE *fp = (chan && chan->fp ? chan->fp : stdout);
    va_start(va,fmt);
    n = vfprintf(fp, fmt, va);
    va_end(va);
    return n;
}

int Jsi_Puts(Jsi_Channel chan, const char *str)
{
    if (chan->fsPtr==0 || !chan->fsPtr->putsProc) {
        FILE *fp = (chan && chan->fp ? chan->fp : stdout);
        fputs(str, fp);
    } else {
        Jsi_Interp *interp = (chan?chan->interp:NULL);
        if (interp && interp->debugOpts.putsCallback && interp->parent) {
            int code = 0;
            Jsi_DString jStr={}, kStr={};
            Jsi_DSPrintf(&kStr, "[%s, %d]",
                Jsi_JSONQuote(interp, str, -1, &jStr), (chan->fp == stderr?1:0));
            if (Jsi_CommandInvokeJSON(interp->parent, interp->debugOpts.putsCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)
                code = 1;
            Jsi_DSFree(&jStr);
            Jsi_DSFree(&kStr);
            return code;
        } else if (interp && interp->stdoutStr) {
            Jsi_DString dStr = {};
            Jsi_DSAppend(&dStr, Jsi_ValueString(interp, interp->stdoutStr, NULL), NULL);
            Jsi_DSAppend(&dStr, str, NULL);
            Jsi_ValueMakeStringDup(interp, &interp->stdoutStr, Jsi_DSValue(&dStr));
            Jsi_DSFree(&dStr);
        } else

            return chan->fsPtr->putsProc(chan, str);
    }
    return 0;
}

static Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    

static Jsi_CmdSpec filesysCmds[] = {
    { "Channel",   FilesysConstructor,1,  2,  "file:string, mode:string='r'", .help="A file input/output object. The mode string is r or w and an optional +", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { "close",  FilesysCloseCmd,   0,  0, "", .help="Close the file", .retType=(uint)JSI_TT_BOOLEAN },
    { "eof",    FilesysEofCmd,     0,  0, "", .help="Return true if read to end-of-file", .retType=(uint)JSI_TT_BOOLEAN },
    { "filename", FilesysFilenameCmd, 0,  0, "", .help="Get file name", .retType=(uint)(uint)JSI_TT_STRING },
    { "flush",  FilesysFlushCmd,   0,  0, "", .help="Flush file output", .retType=(uint)JSI_TT_NUMBER },
    { "gets",   FilesysGetsCmd,    0,  0, "", .help="Get one line of input", .retType=(uint)JSI_TT_STRING|JSI_TT_UNDEFINED },
    { "lstat",  FilesysLstatCmd,   0,  0, "", .help="Return status for file", .retType=(uint)JSI_TT_OBJECT },
    { "mode",   FilesysModeCmd,    0,  0, "", .help="Get file mode used with open", .retType=(uint)JSI_TT_STRING },
    { "open",   FilesysOpenCmd,    1, -1, "file:string, mode:string='r'", .help="Open the file (after close)", .retType=(uint)JSI_TT_BOOLEAN },
    { "puts",   FilesysPutsCmd,    1,  1, "str", .help="Write one line of output", .retType=(uint)JSI_TT_BOOLEAN },
    { "read",   FilesysReadCmd,    0,  1, "size:number=-1", .help="Read some or all of file", .retType=(uint)JSI_TT_STRING|JSI_TT_UNDEFINED },
    { "seek",   FilesysSeekCmd,    2,  2, "pos:number, whence:string", .help="Seek to position. Return 0 if ok", .retType=(uint)JSI_TT_NUMBER },
    { "stat",   FilesysStatCmd,    0,  0, "", .help="Return status for file", .retType=(uint)JSI_TT_OBJECT },
    { "truncate",FilesysTruncateCmd,    1,  1, "pos:number", .help="Truncate file", .retType=(uint)JSI_TT_NUMBER },
    { "tell",   FilesysTellCmd,    0,  0, "", .help="Return current position", .retType=(uint)JSI_TT_NUMBER },
    { "write",  FilesysWriteCmd,   1,  1, "data", .help="Write data to file", .retType=(uint)JSI_TT_NUMBER },
    { NULL, 0,0,0,0, .help="Commands for accessing Channel objects for file IO" }
};


static Jsi_UserObjReg fileobject = {
    "Channel",
    filesysCmds,
    fileObjFree,
    fileObjIsTrue,
    fileObjEqual
};

static Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *that = _this;
    if (!Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "File", o);
        Jsi_ValueMakeObject(interp, ret, o);
        that = *ret;
    }

    FileObj *fobj = (FileObj *)Jsi_Calloc(1,sizeof(*fobj));
    SIGINIT(fobj, FILEOBJ);
    if (try_open_file(interp, fobj, args) != JSI_OK) { /* Error out on open fail */
        Jsi_Free(fobj);
        return Jsi_LogError("open failed");
    }
    Jsi_Obj *nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);
    fobj->objId = Jsi_UserObjNew(interp, &fileobject, nobj, fobj);
    if (fobj->objId<0) {
        Jsi_Free(fobj); // TODO: finish cleanup
        return JSI_ERROR;
    }
    fobj->fobj = nobj;
    return JSI_OK;
}

static void SetupStdChan(Jsi_Chan* ch, FILE *fp, Jsi_Filesystem *fsPtr, int flags) {
    memset(ch, 0, sizeof(*ch));
    ch->fp = fp;
    ch->fsPtr = fsPtr;
    ch->flags = flags|JSI_FS_NOCLOSE;
}

Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name)
{
    if (Jsi_Strlen(name)==1) {
        switch (name[0]) {
            case '0' : return jsi_StdChans;
            case '1' : return jsi_StdChans+1;
            case '2' : return jsi_StdChans+2;
        }
    }
    if (!Jsi_Strcmp(name, "stdin")) return jsi_StdChans;
    if (!Jsi_Strcmp(name, "stdout")) return jsi_StdChans+1;
    if (!Jsi_Strcmp(name, "stderr")) return jsi_StdChans+2;
    Jsi_Obj *obj = jsi_UserObjFromName(interp, name);
    if (!obj)
        return NULL;
    Jsi_UserObj *uobj = obj->d.uobj;
    if (uobj->reg != &fileobject)
        return NULL;
    FileObj *fobj = (FileObj *)uobj->data;
    return fobj->chan;
}

void jsi_FilesysDone(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &fileobject);
    Jsi_InitZvfs(interp, 1);
    while (jsiFSList != NULL) {
        FSList *fsPtr = jsiFSList;
        jsiFSList = fsPtr->next;
        if (fsPtr)
            Jsi_Free(fsPtr);
    }
}

Jsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release)
{
    if (release) {
        jsi_FilesysDone(interp);
        return JSI_OK;
    }
    Jsi_DSInit(&pwdStr);
    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &fileobject);
    if (!fsys)
        return Jsi_LogBug("Can not init file system");
    Jsi_CommandCreateSpecs(interp, fileobject.name, filesysCmds, fsys, JSI_CMDSPEC_ISOBJ);
    if (jsiFSList == NULL) {
        Jsi_FSRegister(&jsiFilesystem, NULL);
        SetupStdChan(jsi_StdChans, stdin, &jsiFilesystem, JSI_FS_READONLY);
        SetupStdChan(jsi_StdChans+1, stdout, &jsiFilesystem, JSI_FS_WRITEONLY);
        SetupStdChan(jsi_StdChans+2, stderr, &jsiFilesystem, JSI_FS_WRITEONLY);
    }
#if JSI__ZVFS==1
    Jsi_InitZvfs(interp, 0);
#endif
    return JSI_OK;
}

#endif // JSI_LITE_ONLY


const char *jsi_GetHomeDir(Jsi_Interp *interp) {
    const char *str = NULL;
    if (interp->homeDir)
        return interp->homeDir;
#ifdef __WIN32
    str = getenv("USERPROFILE"); /* TODO: windows home dir. */
#else
        
    if ((str = getenv("HOME")) == NULL) {
        struct passwd pwd, *pw;
        char buf[20000];
        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        
            str = pw->pw_dir;
    }
#endif
    if (!str) {
        Jsi_LogBug("no home dir");
        str = "/";
    }
#ifdef JSI_LITE_ONLY
    return str;
#else
    return (interp->homeDir = Jsi_KeyAdd(interp, str));
#endif
}

/* TODO: reconcile with NormalizeUnixPath */
char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr) {
    char prefix[3] = "";
    char cdbuf[PATH_MAX];
    Jsi_DSInit(dStr);
    if (!path || !path[0]) return NULL;
    if (*path == '/')
        Jsi_DSAppend(dStr, path, NULL);
#ifdef __WIN32  /* TODO: add proper handling for windows paths. */
    else if (*path && path[1] == ':') {
        prefix[0] = *path;
        prefix[1] = path[1];
        prefix[2] = 0;
        path += 2;
        goto full;
    }
#endif
    else if (path[0] == '~') {
        Jsi_DSAppend(dStr, jsi_GetHomeDir(interp), (path[1] == '/' ? "" : "/"), path+1, NULL);
    } else if (path[0] == '.' && path[1] == 0) {
        if (jsi_pwd) {
            Jsi_DSAppend(dStr, jsi_pwd, NULL);
        } else {
            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), NULL);
        }
    } else {
#ifdef __WIN32
full:
#endif
        if (jsi_pwd) {
            Jsi_DSAppend(dStr, jsi_pwd, "/", path, NULL);
        } else {
            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), "/", path, NULL);
        }
    }
    Jsi_DString sStr = {};
    char *cp = Jsi_DSValue(dStr);
    int i=0, n=0, m, nmax, unclean=0, slens[PATH_MAX];
    char *sp = cp, *ss;
    char *sptrs[PATH_MAX];
    while (*cp && n<PATH_MAX) {
        while (*cp && *cp == '/') {
            cp++;
            if (*cp == '/')
                unclean = 1;
        }
        sptrs[n] = cp;
        if (cp[0] == '.' && (cp[1] == '.' || cp[1] == '/'))
            unclean = 1;
        ss = cp++;
        while (*ss && *ss != '/')
            ss++;
        slens[n++] = (ss-cp) + 1;
        cp = ss;
    }
    if (!unclean)
        return sp;
    /* Need to remove //, /./, /../ */
    nmax = n--;
    while (n>0) {
        if (slens[n]<=0) {
            n--;
            continue;
        }
        if (Jsi_Strncmp(sptrs[n],".",slens[n])==0)
            slens[n] = 0;
        else if (Jsi_Strncmp(ss,"..",slens[n])==0) {
            int cnt = 0;
            m = n-1;
            while (m>=0 && cnt<1) {
                if (slens[m])
                    cnt++;
                slens[m] = 0;
                m--;
            }
            if (cnt<1)
                return sp;  /* Can't fix it */
        }
        n--;
    }
    /* TODO: prefix for windows. */
    Jsi_DSAppend(&sStr, prefix, NULL);
    for (i=0; i<nmax; i++) {
        if (slens[i]) {
            Jsi_DSAppend(&sStr, "/", NULL);
            Jsi_DSAppendLen(&sStr, sptrs[i], slens[i]);
        }
    }
    Jsi_DSSetLength(dStr, 0);
    Jsi_DSAppend(dStr, Jsi_DSValue(&sStr), NULL);
    Jsi_DSFree(&sStr);
    return Jsi_DSValue(dStr);
}

#ifdef __WIN32
#define realpath(R,N) _fullpath(N,R, _MAX_PATH)

/* For ridding backslashes from env vars */
static void DeBackSlashify(char *cp) {
    char *dp = cp;
    while (*cp) {
        if (*cp == '\\') {
            *dp = '/';
        } else
            *dp = *cp;
        cp++; dp++;
    }
    *dp = 0;
}

#else

static void NormalizeUnixPath(Jsi_Interp *interp, char *path) {
    char **argv; int argc, i;
    if (!Jsi_Strstr(path, "./")) return;
    Jsi_DString dStr = {}, eStr = {};
    if (path[0] != '/' && Jsi_Strstr(path, "..")) {
        char *npath = Jsi_GetCwd(interp, &eStr);
        if (npath && Jsi_Strcmp(npath,"/")) {
            Jsi_DSAppend(&eStr, "/", path, NULL);
            path = Jsi_DSValue(&eStr);
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(path, &argc, &argv, "/", &sStr);
    char *cp = path;
    *cp = 0;
    for (i=0; i<argc; i++) {
        if (i == 0 && argv[0][0] == 0) {
            continue;
        } else if (argv[i][0] == 0) {
            continue;
        } else if (!Jsi_Strcmp(argv[i],".")) {
            continue;
        } else if (!Jsi_Strcmp(argv[i],"..")) {
            char *pcp = Jsi_DSValue(&dStr);
            pcp = Jsi_Strrchr(pcp, '/');
            if (pcp && pcp != Jsi_DSValue(&dStr)) {
                *pcp = 0;
            }
            continue;
        } else {
            Jsi_DSAppend(&dStr, (i>0?"/":""), argv[i], NULL);
        }
    }
    Jsi_DSFree(&sStr);
    Jsi_Strcpy(path, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
}
#endif

char * Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr) {
    char cdbuf[PATH_MAX];
    Jsi_DSInit(cwdPtr);
    if (cwdFsPtr)
        Jsi_DSAppend(cwdPtr, Jsi_DSValue(&pwdStr), NULL);
    else
        Jsi_DSAppend(cwdPtr, getcwd(cdbuf, sizeof(cdbuf)), NULL);
#ifdef __WIN32
    DeBackSlashify(Jsi_DSValue(cwdPtr));
#endif
    return Jsi_DSValue(cwdPtr);
}

char *Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newname)
{
    if (!path) return NULL;
    Jsi_DString dStr;
    char *npath = (char*)path, *apath;
    Jsi_DSInit(&dStr);
    if (*path == '~') {
#ifndef __WIN32
        struct passwd pw, *pwp; /* TODO: could fallback to using env HOME. */
        char buf[BUFSIZ];
        int n = getpwuid_r(getuid(), &pw, buf, sizeof(buf), &pwp);
        const char *homedir = (n == 0 ? pwp->pw_dir : "");
        Jsi_DSAppend(&dStr, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
#else
        const char *homedir = getenv("HOMEPATH");
        if (!homedir) homedir = "/";
        const char *homedrv = getenv("HOMEDRIVE");
        if (!homedrv) homedrv = "";
        Jsi_DSAppend(&dStr, homedrv, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
#endif
        npath = Jsi_DSValue(&dStr);
    }
#ifdef __WIN32
    if (Jsi_Strncmp(path, "/zvfs", 5)==0)
        apath = NULL;
    else
#endif
    apath = realpath(npath, newname);
    if (!apath) {
        if (newname)
            Jsi_Strcpy(newname, apath=npath);
        else
            apath = Jsi_Strdup(npath);
#ifndef __WIN32
        /* If path not exists on unix we try to eliminate ../ and /./ etc.*/
        NormalizeUnixPath(interp, apath);
#endif
    }
#ifdef __WIN32
    DeBackSlashify(apath);
#endif
    Jsi_DSFree(&dStr);
    return apath;
}

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifdef __WIN32
char *strcasestr(const char *haystack, const char *needle)
{
        int nlen = strlen(needle);
        int hlen = strlen(haystack) - nlen + 1;
        int i;

        for (i = 0; i < hlen; i++) {
                int j;
                for (j = 0; j < nlen; j++) {
                        unsigned char c1 = haystack[i+j];
                        unsigned char c2 = needle[j];
                        if (toupper(c1) != toupper(c2))
                                goto next;
                }
                return (char *) haystack + i;
        next:
                ;
        }
        return NULL;
}
#endif

uint Jsi_Strlen(const char *str) {
    return strlen(str);
}

int Jsi_Strncasecmp(const char *str1, const char *str2, int n)
{
    if (n<0)
        return strcasecmp(str1,str2);
    return strncasecmp(str1,str2,n);
}
int Jsi_Strncmp(const char *str1, const char *str2, int n)
{
   return strncmp(str1,str2,n);
}

uint Jsi_StrlenSet(const char *str, uint len) {
    char *s = (char*)str;
    uint olen = strlen(str);
    if (olen<len)
        return olen;
    s[len] = 0;
    return len;
}

char *Jsi_Strstr(const char *str, const char *sub) {
    return (char*)strstr(str, sub);
}

char *Jsi_Strdup(const char *str) {
    return strdup(str);
}

char *jsi_SubstrDup(const char *a, int start, int len)
{
    if (len == 0) return Jsi_Strdup("");
    
    int lenofa = Jsi_Strlen(a);
    while (start < 0) start += lenofa;
    if (start >= lenofa) return Jsi_Strdup("");
    
    int maxcpy = lenofa - start;
    
    if (len > 0) {
        maxcpy = maxcpy < len ? maxcpy : len;
    }
    
    char *r = (char*)Jsi_Malloc(maxcpy + 1);

    Jsi_Strncpy(r, a + start, maxcpy + 1);
    return r;
}


char* Jsi_Strrchr(const char *str, int c)
{
    return strrchr((char*)str, c);
}

char* Jsi_Strchr(const char *str, int c)
{
    return strchr((char*)str, c);
}

char* Jsi_Strcpy(char *dst, const char *src)
{
    return strcpy(dst, src);
}

char* Jsi_Strncpy(char *str1, const char *str2, int len)
{
    char* cp = strncpy(str1, str2, len-1);
    str1[len-1] = 0;
    return cp;
}

int Jsi_Strcmp(const char *str1, const char *str2)
{
    return strcmp(str1, str2);
}

int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict)
{
    if (dict==0)
        return (nocase ? Jsi_Strncasecmp(str1,str2, -1) : strcmp(str1, str2));
    return Jsi_DictionaryCompare(str1, str2);
}

char *Jsi_Strcatdup(const char *str1, const char *str2)
{
    int l1 = strlen(str1), l2 = strlen(str2);
    char *cp = (char*)Jsi_Malloc(l1+l2+1);
    strcpy(cp, str1);
    strcpy(cp+l1, str2);
    return cp;
}

int Jsi_Strpos(const char *str, int start, const char *s2, int nocase)
{
    const char *sstr = str;
    int len = strlen(str);
    if (len<start)
        return -1;
    str += start;
    const char *s = (nocase?strcasestr(str,s2):Jsi_Strstr(str, s2));
    if (!s)
        return -1;
    return (s-sstr);
}

int Jsi_Strrpos(const char *str, int start, const char *s2, int nocase)
{
    const char *sstr = str, *s, *os = NULL;
    int len = strlen(str);
    if (len<start)
        return -1;
    str += start;
    while (*str && (s = (nocase?strcasestr(str,s2):Jsi_Strstr(str, s2)))) {
        os = s;
        str += 1;
    }
    if (!os)
        return -1;
    return (os-sstr);
}

int
Jsi_DictionaryCompare( const char *left, const char *right)
{
  int diff, zeros;
  int secondaryDiff = 0;

  while (1) {
    if (isdigit(UCHAR(*right)) && isdigit(UCHAR(*left))) {
      /*
       * There are decimal numbers embedded in the two
       * strings.  Compare them as numbers, rather than
       * strings.  If one number has more leading zeros than
       * the other, the number with more leading zeros sorts
       * later, but only as a secondary choice.
       */

      zeros = 0;
      while ((*right == '0') && (isdigit(UCHAR(right[1])))) {
        right++;
        zeros--;
      }
      while ((*left == '0') && (isdigit(UCHAR(left[1])))) {
        left++;
        zeros++;
      }
      if (secondaryDiff == 0) {
        secondaryDiff = zeros;
      }

      /*
       * The code below compares the numbers in the two
       * strings without ever converting them to integers.  It
       * does this by first comparing the lengths of the
       * numbers and then comparing the digit values.
       */

      diff = 0;
      while (1) {
        if (diff == 0) {
          diff = UCHAR(*left) - UCHAR(*right);
        }
        right++;
        left++;
        /* Ignore commas in numbers. */
        if (*left == ',') {
          left++;
        }
        if (*right == ',') {
          right++;
        }
        if (!isdigit(UCHAR(*right))) {
          if (isdigit(UCHAR(*left))) {
            return 1;
          } else {
            /*
             * The two numbers have the same length. See
             * if their values are different.
             */

            if (diff != 0) {
              return diff;
            }
            break;
          }
        } else if (!isdigit(UCHAR(*left))) {
          return -1;
        }
      }
      continue;
    }
    diff = UCHAR(*left) - UCHAR(*right);
    if (diff) {
      if (isupper(UCHAR(*left)) && islower(UCHAR(*right))) {
        diff = UCHAR(tolower(*left)) - UCHAR(*right);
        if (diff) {
          return diff;
        } else if (secondaryDiff == 0) {
          secondaryDiff = -1;
        }
      } else if (isupper(UCHAR(*right)) && islower(UCHAR(*left))) {
        diff = UCHAR(*left) - UCHAR(tolower(UCHAR(*right)));
        if (diff) {
          return diff;
        } else if (secondaryDiff == 0) {
          secondaryDiff = 1;
        }
      } else {
        return diff;
      }
    }
    if (*left == 0) {
      break;
    }
    left++;
    right++;
  }
  if (diff == 0) {
    diff = secondaryDiff;
  }
  return diff;
}

#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
    
#define ChkString(_this, funcPtr, dest, lenPtr, bytePtr) \
    int skip __attribute__((unused)); skip = 0; \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->String_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndexToStr(interp, args, 0, bytePtr); \
        *lenPtr = Jsi_NumUtfChars(dest, -1); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_STRING) { \
        Jsi_LogError("apply String.%s to a non-string object", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    } else  { \
        dest = Jsi_ValueString(interp, _this, bytePtr); \
        *lenPtr = Jsi_NumUtfChars(dest, -1); \
        if (!dest) dest = (char*)""; \
    }

static Jsi_RC StringConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        const char *nv = "";
        if (Jsi_ValueGetLength(interp, args) > 0) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
            if (v) {
                
                nv = Jsi_ValueToString(interp, v, NULL);
            }
        }
        _this->d.obj->ot = JSI_OT_STRING;
        _this->d.obj->d.s.str = Jsi_Strdup(nv);
        _this->d.obj->d.s.len = -1;
        return JSI_OK;
    }
    if (Jsi_ValueGetLength(interp, args) > 0) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueDup2(interp, ret, v);
            Jsi_ValueToString(interp, *ret, NULL);
            return JSI_OK;
        }
    }
    Jsi_ValueMakeStringDup(interp, ret, "");
    return JSI_OK;
}


static Jsi_RC StringSplitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, //TODO: UTF
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char **argv; int argc;
    int sLen, bLen, noEmpty=0;
    Jsi_RC rc = JSI_OK;
    char *v;
    const char *split = " ";
    
    ChkString(_this, funcPtr, v, &sLen, &bLen);

    Jsi_Value *spliton = Jsi_ValueArrayIndex(interp, args, skip);
    
    if (spliton) {
        if (Jsi_ValueIsNull(interp, spliton))
            noEmpty = 1;
        else if (Jsi_ValueIsString(interp, spliton))
            split = Jsi_ValueString(interp, spliton, NULL);
    }

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(v, &argc, &argv, split, &sStr);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    int i, n = 0, siz = argc;
    if (noEmpty)
        for (i=0, siz=0; i<argc; i++) if (argv[i][0]) siz++;
    if (Jsi_ObjArraySizer(interp, obj, siz) <= 0) {
        rc = Jsi_LogError("index too large: %d", siz);
        Jsi_ObjFree(interp, obj);
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, obj);
    for (i = 0; i < argc; ++i) {
        if (noEmpty && !argv[i][0]) continue;
        Jsi_Value *v = Jsi_ValueNewStringDup(interp, argv[i]);
        Jsi_IncrRefCount(interp, v);
        obj->arr[n++] = v;
    }
    Jsi_ObjSetLength(interp, obj, siz);
    
bail:
    Jsi_DSFree(&sStr);
    return rc;
}

static Jsi_RC StringSubstrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *v;
    ChkString(_this, funcPtr, v, &sLen, &bLen);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *len = Jsi_ValueArrayIndex(interp, args, skip+1);
    
    Jsi_Number nstart, nlen;
    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {
        Jsi_ValueMakeStringDup(interp, ret, v);
        return JSI_OK;
    }
    int istart = (int)nstart;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    if (!len || Jsi_GetNumberFromValue(interp,len, &nlen) != JSI_OK) {
        if (sLen == bLen)
            Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, -1));
        else {
            Jsi_UtfSubstr(v, istart, -1, &dStr);
            Jsi_ValueFromDS(interp, &dStr, ret);
        }
        return JSI_OK;
    }
    int ilen = (int)nlen;
    if (ilen <= 0) {
        Jsi_ValueMakeStringDup(interp, ret, "");
    } else {
        if (sLen == bLen)
            Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, ilen));
        else {
            Jsi_UtfSubstr(v, istart, ilen, &dStr);
            Jsi_ValueFromDS(interp, &dStr, ret);
        }
    }
    return JSI_OK;
}

static Jsi_RC StringSubstringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen = 0, bLen;
    char *v;
    ChkString(_this, funcPtr, v, &sLen, &bLen);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, skip+1);
    
    Jsi_Number nstart, nend;
    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {
        Jsi_ValueMakeStringDup(interp, ret, v);
        return JSI_OK;
    }
    int istart = (int)nstart;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    
    if (!end || Jsi_GetNumberFromValue(interp,end, &nend) != JSI_OK) {
        if (sLen == bLen)
            Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, -1));
        else {
            Jsi_UtfSubstr(v, istart, -1, &dStr);
            Jsi_ValueFromDS(interp, &dStr, ret);
        }
        return JSI_OK;
    }
    int iend = (int)nend;
    if (iend>sLen)
        iend = sLen;
    if (iend < istart) {
        Jsi_ValueMakeStringDup(interp, ret, "");
    } else {
        if (sLen == bLen)
            Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, iend-istart+1));
        else {
            Jsi_UtfSubstr(v, istart, iend-istart+1, &dStr);
            Jsi_ValueFromDS(interp, &dStr, ret);
        }
    }
    return JSI_OK;
}


static Jsi_RC StringIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *v;
    ChkString(_this, funcPtr, v, &sLen, &bLen);

    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip+1);

    if (!seq) {
        Jsi_ValueMakeNumber(interp,ret, -1);
        return JSI_OK;
    }

    const char *vseq = Jsi_ValueToString(interp, seq, NULL);
    int istart = 0;
    if (start) {
        if (Jsi_GetIntFromValue(interp, start, &istart)) {
            return JSI_ERROR;
        }
        if (istart < 0) istart = 0;
    }

    int r = Jsi_Strpos(v, istart, vseq, 0);
    Jsi_ValueMakeNumber(interp, ret, r);

    return JSI_OK;
}

static Jsi_RC StringMatchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *source_str;
    ChkString(_this, funcPtr, source_str, &sLen, &bLen);
    char *v = source_str;
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);

    if (Jsi_ValueIsString(interp, seq)) {
        char *cp = Jsi_ValueString(interp, seq, NULL);

        if (jsi_RegExpValueNew(interp, cp, seq) != JSI_OK)
            return JSI_ERROR;
    }
    /* TODO: differentiate from re.exec() */
    return Jsi_RegExpMatches(interp, seq, v, *ret);
}

static Jsi_RC StringCharCodeAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *source_str;
    ChkString(_this, funcPtr, source_str, &sLen, &bLen);
    char *v = source_str;

    Jsi_Value *ttPtr = Jsi_ValueNew1(interp);
    Jsi_ValueCopy(interp, ttPtr, _this);
    
    int pos = 0;
    Jsi_Value *vpos;
    if ((vpos = Jsi_ValueArrayIndex(interp, args, skip))) {
        jsi_ValueToOInt32(interp, vpos);
        pos = (int)vpos->d.num;
    }

#if JSI__UTF8
    int m;
    if ((pos < 0 || pos >= sLen) && ((m=Jsi_UtfIndexToOffset(v, pos))>0)) {
        int32_t n;
        Jsi_UtfToUniChar(v+m, &n);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    }
#else
    int slen = Jsi_Strlen(v);
    if (pos >= 0 && pos < slen) {
        Jsi_ValueMakeNumber(interp, ret, v[pos]);
    }
#endif
    else
        Jsi_ValueMakeNumber(interp, ret, Jsi_NumberNaN());
    Jsi_DecrRefCount(interp, ttPtr);
    return JSI_OK;
}


static Jsi_RC _StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, // TODO: UTF
    Jsi_Value **ret, Jsi_Func *funcPtr, int ends)
{
    const char *tstr = " \t\n\r", *vstr;
    int vend,  n, tlen = Jsi_Strlen(tstr), clen, bLen;
    ChkString(_this, funcPtr, vstr, &clen, &bLen);
    
    Jsi_Value *tchars = Jsi_ValueArrayIndex(interp, args, skip);
    
    if (tchars) {
        tstr = Jsi_ValueToString(interp, tchars, NULL);
        tlen = Jsi_Strlen(tstr);
    }
    
    if (ends&1) {
        while (*vstr) {
            for (n=0; n<tlen; n++)
                if (tstr[n] == *vstr) break;
            if (n>=tlen) break;
            vstr++;
            clen--;
        }
    }
    vend = clen-1;
    if (ends&2) {
        for (; vend>=0; vend--) {
            for (n=0; n<tlen; n++)
                if (tstr[n] == vstr[vend]) break;
            if (n>=tlen) break;
        }
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_UtfSubstr(vstr, 0, vend+1, &dStr);
    Jsi_ValueFromDS(interp, &dStr, ret);
    return JSI_OK;
}

static Jsi_RC StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 3);
}
static Jsi_RC StringTrimLeftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 1);
}

static Jsi_RC StringTrimRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 2);
}


char *jsi_utf_tocase(const char *cp, int upper, Jsi_DString *dsPtr)
{
    char unibuf[10];
    while (*cp) {
#if JSI__UTF8
        if (*cp&0x80) {
            int32_t c;
            Jsi_UtfToUniChar(cp, &c);
            int n = Jsi_UniCharToUtf(c, unibuf);
            unibuf[n] = 0;
            cp += n;
        } else
#endif
        {
            unibuf[0] = (upper?toupper(*cp):tolower(*cp));
            unibuf[1] = 0;
            cp++;
        }
        if (upper==2) //totile
            upper = 0;
        Jsi_DSAppend(dsPtr, unibuf, NULL);
    }
    return Jsi_DSValue(dsPtr);
}



static Jsi_RC StringToLowerCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *vstr;
    ChkString(_this, funcPtr, vstr, &sLen, &bLen);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    jsi_utf_tocase(vstr, 0, &dStr);
    Jsi_ValueFromDS(interp, &dStr, ret);
    return JSI_OK;
}

static Jsi_RC StringToUpperCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *vstr;
    ChkString(_this, funcPtr, vstr, &sLen, &bLen);

    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    jsi_utf_tocase(vstr, 1, &dStr);
    Jsi_ValueFromDS(interp, &dStr, ret);
    return JSI_OK;
}

static Jsi_RC StringToTitleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *vstr;
    ChkString(_this, funcPtr, vstr, &sLen, &bLen);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    jsi_utf_tocase(vstr, 2, &dStr);
    Jsi_ValueFromDS(interp, &dStr, ret);
    return JSI_OK;
}

static Jsi_RC StringCharAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int pos = 0, len, bLen;
    char *vstr;
    ChkString(_this, funcPtr, vstr, &len, &bLen);
   
    Jsi_Value *vpos = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetIntFromValue(interp, vpos, &pos)) {
        return JSI_ERROR;        
    }
    if (pos<0 || pos >=len)
        Jsi_ValueMakeStringDup(interp, ret, "");
    else {
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        Jsi_UtfSubstr(vstr, pos, 1, &dStr);
        Jsi_ValueFromDS(interp, &dStr, ret);
    }
    return JSI_OK;
}

static Jsi_RC StringLastIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    char *v;
    ChkString(_this, funcPtr, v, &sLen, &bLen);

    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1+skip);

    if (!seq) {
        Jsi_ValueMakeNumber(interp, ret, -1);
        return JSI_OK;
    }

    const char *vseq = Jsi_ValueToString(interp, seq, NULL);
    int istart = 0;
    if (start) {
        if (Jsi_GetIntFromValue(interp, start, &istart)) {
            return JSI_ERROR;
        }
        if (istart < 0) istart = 0;
    }

    int r = Jsi_Strrpos(v, istart, vseq, 0);
    Jsi_ValueMakeNumber(interp, ret, r);

    return JSI_OK;;
}

static Jsi_RC StringConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    const char *vstr;
    ChkString(_this, funcPtr, vstr, &sLen, &bLen);
    
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, vstr, NULL);
    int i, argc = Jsi_ValueGetLength(interp, args);
    for (i=skip; i<argc; i++)
    {
        Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetStringFromValue(interp, s, &vstr)) {
            Jsi_LogError("String get failure");
            Jsi_DSFree(&dStr);
            return JSI_ERROR;
        }
        Jsi_DSAppend(&dStr, vstr, NULL);
    }

    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    return JSI_OK;
    
}

static Jsi_RC StringSliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int sLen, bLen;
    const char *vstr;
    ChkString(_this, funcPtr, vstr, &sLen, &bLen);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1+skip);
    int istart, iend, len = Jsi_Strlen(vstr);

    if (Jsi_GetIntFromValue(interp, start, &istart)) {
        return JSI_ERROR;
    }
    if (istart < 0)
        istart = len-istart;
    if (istart < 0)
        istart = 0;
    if (istart>=len)
        istart = len-1;
    iend = len-1;
    if (end) {
        if (Jsi_GetIntFromValue(interp, end, &iend)) {
            return JSI_ERROR;
        }
        if (iend < 0)
            iend = len+iend;
        if (iend>=len)
            iend = len-1;
        if (iend<istart)
            iend = istart;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_UtfSubstr(vstr, istart, iend, &dStr);
    Jsi_ValueFromDS(interp, &dStr, ret);
    return JSI_OK;
}

static Jsi_RC StringMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    /* Now handles perl regex flag extensions.*/
    const char *source_str;
    const char *replace_str = NULL;
    uint i, j;
    int slen, source_len, replace_len, bLen;

    const char *p;
    bool nocase = 0;
    /* Is a generic  String.replace if _this->d.obj is a function */
    ChkString(_this, funcPtr, source_str, &source_len, &bLen);
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, skip);
    if (Jsi_ValueIsArray(interp, repVal)==0 || repVal->d.obj->arrCnt&1) 
        return Jsi_LogError("expected even length array");
    if (argc>(skip+1) && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, skip+1), &nocase) != JSI_OK) 
        return Jsi_LogError("expected boolean");
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_Obj *obj = repVal->d.obj;
    p = source_str;
    for (j=0; j<(uint)source_len; j++, p++) {
        for (i=0; i<obj->arrCnt; i+=2) {
            if (!obj->arr[i]) continue;
            if (!obj->arr[i+1]) continue;
            const char *cp = Jsi_ValueToString(interp, obj->arr[i], &slen);
            int res = (nocase ? Jsi_Strncasecmp(cp, p, slen) : Jsi_Strncmp(cp, p, slen));
            if (!res) {
                replace_str = Jsi_ValueToString(interp, obj->arr[i+1], &replace_len);
                Jsi_DSAppend(&dStr, replace_str, NULL);
                p += slen;
                j += slen;
            }
        }
        if (i>=obj->arrCnt)
            Jsi_DSAppendLen(&dStr, p, 1);
    }

    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    return JSI_OK;
}
    
#define FN_strreplace JSI_INFO("\
If the replace argument is a function, it is called with match,p1,p2,...,offset,string.  \
If called function is known to have 1 argument, it is called with just the match.\
Otherwise if the first argument is a regexp, the replace can contain the $ escapes: $&, $1, etc.")
static Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    /* Now handles perl regex flag extensions.*/
    const char *source_str;
    int source_len, bLen;
    const char *replace_str = NULL;
    int replace_len;
    int regexec_flags = 0;
    Jsi_Value *seq, *strVal;
    Jsi_DString dStr = {};
    regex_t *regex;
    Jsi_Regex *re;
    const char *p;
    int maxArgs = 1;

    int offset = 0, n, j, opt_all = 0, num_matches = 0;
    /* Is a generic  String.replace if _this->d.obj is a function */
    ChkString(_this, funcPtr, source_str, &source_len, &bLen);
    if (!skip)
        strVal = _this;
    else
        strVal = Jsi_ValueArrayIndex(interp, args, 0);
    seq = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip);
    if (!Jsi_ValueIsFunction(interp, repVal))
        replace_str = Jsi_ValueToString(interp, repVal, &replace_len);
    else
        maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt;
    Jsi_DSInit(&dStr);

    if (Jsi_ValueIsString(interp, seq)) {
        const char *ce, *cp = Jsi_ValueString(interp, seq, NULL);
        if (!(ce = Jsi_Strstr(source_str, cp)))
            Jsi_ValueMakeStringDup(interp, ret, source_str);
        else {
            int slen;
            slen = (ce-source_str);
            if (slen)
                Jsi_DSAppendLen(&dStr, source_str, slen);
            if (replace_str)
                Jsi_DSAppendLen(&dStr, replace_str, replace_len);
            else {
                Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str);
                Jsi_IncrRefCount(interp, inStr);
                if (Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr) != JSI_OK) {
                    Jsi_DSFree(&dStr);
                    Jsi_DecrRefCount(interp, inStr);
                    return JSI_ERROR;
                }
                Jsi_DecrRefCount(interp, inStr);
            }
            Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL);
            Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
        }
        return JSI_OK;
    }
    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNull(interp, ret);
        return JSI_OK;
    }

    re = seq->d.obj->d.robj;
    regex = &re->reg;
    opt_all = (re->eflags & JSI_REG_GLOB);
    
    regmatch_t pmatch[MAX_SUBREGEX] = {};
    /* If an offset has been specified, adjust for that now.
     * If it points past the end of the string, point to the terminating null
     */
    int eoffset=0;
    if (offset) {
        if (offset < 0) {
            offset += source_len + 1;
        }
        if (offset > source_len) {
            offset = source_len;
        }
        else if (offset < 0) {
            offset = 0;
        }
    }

    Jsi_DSAppendLen(&dStr, source_str, offset);
    n = source_len - offset;
    p = source_str + offset;
    Jsi_RC rc = JSI_OK;
    do {
        if (num_matches > 10000000) {
            Jsi_LogBug("regexp infinite loop");
            rc = JSI_ERROR;
            break;
        }
        int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags);

        if (match >= REG_BADPAT) {
            char buf[100];

            regerror(match, regex, buf, sizeof(buf));
            Jsi_LogError("error while matching pattern: %s", buf);
            Jsi_DSFree(&dStr);
            return JSI_ERROR;
        }
        if (match == REG_NOMATCH) {
            break;
        }
        num_matches++;
        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);

        if (replace_str &&  !Jsi_Strchr(replace_str, '$'))
            Jsi_DSAppend(&dStr, replace_str, NULL);
        else if (replace_str) {
            for (j = 0; j < replace_len; j++) {
                int idx;
                int c = replace_str[j];
     
                if (c == '$' && j < replace_len) {
                    c = replace_str[++j];
                    if ((c >= '0') && (c <= '9')) {
                        idx = c - '0';
                    } else if (c == '&') {
                        idx = 0;
                    } else if (c == '$') {
                        Jsi_DSAppendLen(&dStr, replace_str + j, 1);
                        continue;
                    }
                    else if (c == '\'') {
                        Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p));
                        continue;
                    }
                    else if (c == '`') {
                        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);
                        continue;
                    }
                    else {
                        Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2);
                        continue;
                    }
                } else {
                     Jsi_DSAppendLen(&dStr, replace_str + j, 1);
                     continue;
                }
                if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) {
                    Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so,
                        pmatch[idx].rm_eo - pmatch[idx].rm_so);
                }
            }
    
        } else {
            Jsi_DString sStr;
            Jsi_DSInit(&sStr); 
            if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0)
                break;
    
            Jsi_Value *inStr = Jsi_ValueMakeString(interp, NULL, 
                jsi_SubstrDup(p, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so));
            Jsi_DSFree(&sStr);
            Jsi_IncrRefCount(interp, inStr);
            if (pmatch[1].rm_so<0 || maxArgs==1) {
                if (Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr) != JSI_OK) {
                    Jsi_DSFree(&dStr);
                    Jsi_DecrRefCount(interp, inStr);
                    return JSI_ERROR;
                }
            } else {
                Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret;
                int i;
                items[0] = inStr;
                for (i=1; pmatch[i].rm_so>=0 && i<(MAX_SUBREGEX-3); i++)
                    items[i] = Jsi_ValueMakeString(interp, NULL, jsi_SubstrDup(p, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so));;
                items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so);
                items[i++] = strVal;
                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));
                Jsi_IncrRefCount(interp, vpargs);
                ret = Jsi_ValueNew1(interp);
                rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL);
                Jsi_DecrRefCount(interp, vpargs);
                if (rc == JSI_OK)
                    Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL);
                Jsi_DecrRefCount(interp, ret);
                if (rc != JSI_OK) {
                    Jsi_DSFree(&dStr);
                    Jsi_DecrRefCount(interp, inStr);
                    return JSI_ERROR;
                }
            }
            Jsi_DecrRefCount(interp, inStr);
        }
        eoffset += pmatch[0].rm_eo;
        p += pmatch[0].rm_eo;
        n -= pmatch[0].rm_eo;
        /* If -all is not specified, or there is no source left, we are done */
        if (!opt_all || n == 0 || pmatch[0].rm_eo == 0) {
            break;
        }
        /* An anchored pattern without -line must be done */
        if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') {
            break;
        }
        
        /* If the pattern is empty, need to step forwards */
        if (re->pattern[0] == '\0' && n) {
            /* Need to copy the char we are moving over */
            Jsi_DSAppendLen(&dStr, p, 1);
            p++;
            n--;
        }

        regexec_flags |= REG_NOTBOL;
    } while (n);

    /*
     * Copy the portion of the string after the last match to the
     * result variable.
     */
    Jsi_DSAppend(&dStr, p, NULL);
    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    return rc;

}

static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{

    int sLen, bLen;
    char *source_str;
    ChkString(_this, funcPtr, source_str, &sLen, &bLen);
    
    char *v = _this->d.obj->d.s.str;
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);

    if (Jsi_ValueIsString(interp, seq)) {
        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);
        int n = -1;
        if ((ce = Jsi_Strstr(source_str, cp))) {
            n = (ce-source_str);
        }
        Jsi_ValueMakeNumber(interp, ret, n);
        return JSI_OK;
    }
    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNumber(interp, ret, -1);
        return JSI_OK;
    }

    regex_t *reg = &seq->d.obj->d.robj->reg;
    
    regmatch_t pos[MAX_SUBREGEX] = {};
    int r;
    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {
        if (r == REG_NOMATCH) {
            Jsi_ValueMakeNumber(interp, ret, -1.0);
            return JSI_OK;
        }
        if (r >= REG_BADPAT) {
            char buf[100];

            regerror(r, reg, buf, sizeof(buf));
            Jsi_LogError("error while matching pattern: %s", buf);
            return JSI_ERROR;
        }

    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);
    return JSI_OK;
}

/* UNIMPL: 'toLocaleLowerCase', 'toLocaleUpperCase', 'localeCompare', */

static Jsi_CmdSpec stringCmds[] = {
    { "String",     StringConstructor,      0,  1,  "str", .help="String constructor", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMD_IS_CONSTRUCTOR },
/*    { "localeCompare",StringLocaleCompareCmd,1, 1, "pos" },*/
    { "charAt",     StringCharAtCmd,        1, 1, "index:number", .help="Return char at index", .retType=(uint)JSI_TT_STRING},
    { "charCodeAt", StringCharCodeAtCmd,    1, 1, "index:number", .help="Return char code at index", .retType=(uint)JSI_TT_NUMBER },
    { "concat",     StringConcatCmd,        0,-1, "str:string, ...", .help="Append one or more strings", .retType=(uint)JSI_TT_STRING },
    { "indexOf",    StringIndexOfCmd,       1, 2, "str:string, start:number", .help="Return index of char", .retType=(uint)JSI_TT_NUMBER },
    { "lastIndexOf",StringLastIndexOfCmd,   1, 2, "str:string, start:number", .help="Return index of last char", .retType=(uint)JSI_TT_NUMBER },
    { "match",      StringMatchCmd,         1, 1, "pattern:regexp|string", .help="Return array of matches", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },
    { "map",        StringMapCmd,           1, 2, "strMap:array, nocase:boolean=false", .help="Replaces characters in string based on the key-value pairs in strMap", .retType=(uint)JSI_TT_STRING },
    { "replace",    StringReplaceCmd,       2, 2, "pattern:regexp|string, replace:string|function", .help="Regex/string replacement", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strreplace },
    { "search",     StringSearchCmd,        1, 1, "pattern:regexp|string", .help="Return index of first char matching pattern", .retType=(uint)JSI_TT_NUMBER },
    { "slice",      StringSliceCmd,         1, 2, "start:number, end:number", .help="Return section of string", .retType=(uint)JSI_TT_STRING },
    { "split",      StringSplitCmd,         0, 1, "char:string|null=void", .help="Split on char and return Array: null removes empty elements", .retType=(uint)JSI_TT_ARRAY },
    { "substr",     StringSubstrCmd,        0, 2, "start:number, length:number", .help="Return substring", .retType=(uint)JSI_TT_STRING },
    { "substring",  StringSubstringCmd,     0, 2, "start:number, end:number", .help="Return substring", .retType=(uint)JSI_TT_STRING },
    { "toLocaleLowerCase",StringToLowerCaseCmd,0, 0, "",.help="Lower case", .retType=(uint)JSI_TT_STRING },
    { "toLocaleUpperCase",StringToUpperCaseCmd,0, 0, "",.help="Upper case", .retType=(uint)JSI_TT_STRING },
    { "toLowerCase",StringToLowerCaseCmd,   0, 0, "",.help="Return lower cased string", .retType=(uint)JSI_TT_STRING },
    { "toUpperCase",StringToUpperCaseCmd,   0, 0, "",.help="Return upper cased string", .retType=(uint)JSI_TT_STRING },
    { "toTitle",    StringToTitleCmd,       0, 1, "chars:string",.help="Make first char upper case", .retType=(uint)JSI_TT_STRING },
    { "trim",       StringTrimCmd,          0, 1, "chars:string",.help="Trim chars", .retType=(uint)JSI_TT_STRING },
    { "trimLeft",   StringTrimLeftCmd,      0, 1, "chars:string",.help="Trim chars from left", .retType=(uint)JSI_TT_STRING },
    { "trimRight",  StringTrimRightCmd,     0, 1, "chars:string",.help="Trim chars from right", .retType=(uint)JSI_TT_STRING },
    { NULL, 0,0,0,0, .help="Commands for accessing string objects." }
};

Jsi_RC jsi_InitString(Jsi_Interp *interp, int release)
{
    if (!release)
        interp->String_prototype = Jsi_CommandCreateSpecs(interp, "String", stringCmds, NULL, JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

static Jsi_RC BooleanConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        int nv = 0;
        if (Jsi_ValueGetLength(interp, args) > 0) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
            if (v) {
                nv = Jsi_ValueIsTrue(interp, v);
            }
        }
        _this->d.obj->ot = JSI_OT_BOOL;
        _this->d.obj->d.val = nv;
        return JSI_OK;
    }
    if (Jsi_ValueGetLength(interp, args) > 0) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueMakeBool(interp, ret, Jsi_ValueIsTrue(interp, v));
            return JSI_OK;
        }
    }
    Jsi_ValueMakeBool(interp, ret, 0);
    return JSI_OK;
}

static Jsi_CmdSpec booleanCmds[] = {
    { "Boolean",  BooleanConstructor, 0,  1,  "bool:boolean=false", .help="Boolean constructor", .retType=(uint)JSI_TT_BOOLEAN, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { NULL, 0,0,0,0, .help="A Boolean object" }
};

Jsi_RC jsi_InitBoolean(Jsi_Interp *interp, int release)
{
    if (!release)
        interp->Boolean_prototype = Jsi_CommandCreateSpecs(interp, "Boolean", booleanCmds, NULL, JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}
#endif

#include <math.h>
#include <float.h>
#include <stdio.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

bool Jsi_NumberIsSubnormal(Jsi_Number a) { return fpclassify(a) == FP_SUBNORMAL; }

bool Jsi_NumberIsNormal(Jsi_Number a) { return (fpclassify(a) == FP_ZERO || isnormal(a)); }

bool Jsi_NumberIsNaN(Jsi_Number n)
{
    return isnan(n);
}

int Jsi_NumberIsInfinity(Jsi_Number a) {
#if JSI__MUSL==1 || defined(__FreeBSD__) || defined(__WIN32)
    if (!isinf(a))
        return 0;
    return (a<0 ? -1 : 1);
#else
    return isinf(a);
#endif
}
bool Jsi_NumberIsInteger(Jsi_Number n) { return (isnormal(n) ? (Jsi_Number)((int)(n)) == (n) : n==0.0); }

bool Jsi_NumberIsWide(Jsi_Number n) { return (isnormal(n) && (Jsi_Number)((Jsi_Wide)(n)) == (n)); }

Jsi_Number Jsi_NumberInfinity(int i)
{
    Jsi_Number r = INFINITY;
    if (i < 0) r = -r;
    return r;
}

Jsi_Number Jsi_NumberNaN(void)
{
    return NAN;
}

void Jsi_NumberItoA10(int value, char* buf, int bsiz)
{
    snprintf(buf, bsiz, "%d", value);
    return;
}

void Jsi_NumberUtoA10(unsigned int value, char* buf, int bsiz)
{
    snprintf(buf, bsiz, "%u", value);
}

bool Jsi_NumberIsFinite(Jsi_Number value)
{
    Jsi_Number r = INFINITY;
    return (Jsi_NumberIsNaN(value)==0 && value != r && r != -value);
}

void Jsi_NumberDtoA(Jsi_Number value, char* buf, int bsiz, int prec)
{
    if (Jsi_NumberIsNaN(value)) {
        Jsi_Strcpy(buf,"NaN");
        return;
    }
    snprintf(buf, bsiz, "%.*" JSI_NUMGFMT, prec, value);
}

bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2)
{
    return (n1 == n2); // TODO: Do we need more?
   /* int n1n = jsi_num_isNan(n1); 
    int n2n = jsi_num_isNan(n2);
    if (n1n && n2n)
        return 1;
    if (n1n || n2n)
        return 0;
    return ((n2-n1)==0);*/
}

#ifndef JSI_LITE_ONLY
static Jsi_RC NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Number nv = 0.0;
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueToNumber(interp, v);
            nv = v->d.num;
        }
        _this->d.obj->ot = JSI_OT_NUMBER;
        _this->d.obj->d.num = nv;
        Jsi_ValueToObject(interp, _this);
        Jsi_ValueMakeNumber(interp, ret, nv);
        return JSI_OK;
    }
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v) {
        Jsi_ValueToNumber(interp, v);
        Jsi_ValueDup2(interp, ret, v);
        Jsi_ValueToObject(interp, *ret);
        return JSI_OK;
    }
    Jsi_ValueMakeNumber(interp, ret, 0.0);
    return JSI_OK;
}

   
#define ChkStringN(_this, funcPtr, dest) \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->Number_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndex(interp, args, 0); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_NUMBER) { \
        Jsi_LogError("apply Number.%s to a non-number object", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    } else  { \
        dest = _this; \
    }
    
static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec = 0, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);
    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<0) prec = 0;
    Jsi_GetDoubleFromValue(interp, v, &num);
    snprintf(buf, sizeof(buf), "%.*" JSI_NUMFFMT, prec, num);
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec = 0, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<=0) return JSI_ERROR;
    Jsi_GetDoubleFromValue(interp, v, &num);
    snprintf(buf, sizeof(buf),"%.*" JSI_NUMFFMT, prec, num);
    if (num<0)
        prec++;
    buf[prec+1] = 0;
    if (buf[prec] == '.')
        buf[prec] = 0;
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec = 0, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<0) prec = 0;
    Jsi_GetDoubleFromValue(interp, v, &num);
    snprintf(buf, sizeof(buf), "%.*" JSI_NUMEFMT, prec, num);
#ifdef __WIN32
    char *e = strrchr(buf, 'e');
    if (e && (e[1]=='+' || e[1]=='-')) {
        e++;
        int eNum = atoi(e);
        if (e[0]=='-')
            eNum = -eNum;
        e++;
        snprintf(e, (e-buf), "%02d", eNum);
    }
#endif
    /*int len = Jsi_Strlen(buf);
    if (len >= 4 && strrchr(buf, '+') && buf[len-1] == '0') {
        while (buf[len-1] == '0' && buf[len-2]=='0')
            buf[--len] = 0;
    }*/
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[500];
    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    Jsi_GetDoubleFromValue(interp, v, &num);
    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK
        || radix<2))
        return JSI_ERROR;
    if (argc==skip)
        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
    switch (radix) {
        case 16: snprintf(buf, sizeof(buf), "%"PRIx64, (Jsi_Wide)num); break;
        case 8: snprintf(buf, sizeof(buf), "%" PRIo64, (Jsi_Wide)num); break;
        case 10: snprintf(buf, sizeof(buf), "%" PRId64, (Jsi_Wide)num); break;
        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
    }
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static Jsi_CmdSpec numberCmds[] = {
    { "Number",         NumberConstructor,      0, 1, "num:string=0", .help="Number constructor", .retType=(uint)JSI_TT_NUMBER, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { "toFixed",        NumberToFixedCmd,       0, 1, "num:number=0", .help="Formats a number with x numbers of digits after the decimal point", .retType=(uint)JSI_TT_STRING },
    { "toExponential",  NumberToExponentialCmd, 1, 1, "num:number", .help="Converts a number into an exponential notation", .retType=(uint)JSI_TT_STRING },
    { "toPrecision",    NumberToPrecisionCmd,   1, 1, "num:number", .help="Formats a number to x length", .retType=(uint)JSI_TT_STRING },
    { "toString",       NumberToStringCmd,      0, 1, "radix:number=10", .help="Convert to string", .retType=(uint)JSI_TT_STRING }, 
    { NULL, 0,0,0,0, .help="Commands for accessing number objects" }
};

Jsi_RC jsi_InitNumber(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    Jsi_Value *val, *global = interp->csc;
    val = interp->Number_prototype = Jsi_CommandCreateSpecs(interp, "Number", numberCmds, NULL, JSI_CMDSPEC_ISOBJ);

    Jsi_Value *NaN = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberNaN());

    Jsi_Value *Inf = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberInfinity(1));
    
    Jsi_ValueInsertFixed(interp, global, "NaN", NaN);
    Jsi_ValueInsertFixed(interp, global, "Infinity", Inf);
    interp->NaNValue = NaN;
    interp->InfValue = Inf;
#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)
    MCONST("MAX_VALUE", DBL_MAX);
    MCONST("MIN_VALUE", DBL_MIN);
    MCONST("NEGATIVE_INFINITY", Jsi_NumberInfinity(-1));
    Jsi_ValueInsertFixed(interp, val, "POSITIVE_INFINITY", Inf);
    Jsi_ValueInsertFixed(interp, val, "NaN", NaN);
    return JSI_OK;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#if JSI__MUSL==1 || defined(__FreeBSD__)
#define NO_QSORT_R 1
#endif

static Jsi_RC ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *obj;
    
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    
    int argc = Jsi_ValueGetLength(interp, args);
    int curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);
        if (!ov) { Jsi_LogBug("Arguments Error"); ov = Jsi_ValueNew(interp); }
        jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);
    }
    
    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));
    return JSI_OK;
}

static Jsi_RC ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    Jsi_Obj *obj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    int i = Jsi_ObjGetLength(interp, obj) - 1;

    if (i < 0) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    
    if (obj->arr) {
        if ((v = obj->arr[i])) {
            obj->arr[i] = NULL;
            obj->arrCnt--;
        }
    } else {
        v = Jsi_ValueArrayIndex(interp, _this, i);
    }
    if (v) {
        Jsi_DecrRefCount(interp, *ret);
        *ret = v;
    }
    Jsi_ObjSetLength(interp, obj, i);
    return JSI_OK;
}


static Jsi_RC ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *jstr = "";
    int argc, curlen;
    Jsi_DString dStr = {};
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    curlen = Jsi_ObjGetLength(interp, _this->d.obj);
    if (curlen == 0) {
        goto bail;
    }

    if (Jsi_ValueGetLength(interp, args) >= 1) {
        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);
        if (sc != NULL)
            jstr = Jsi_ValueToString(interp, sc, NULL);
    }
    
    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {
        goto bail;
    }
    int i;
    for (i = 0; i < argc; ++i) {
        const char *cp;
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);
        if (!ov) {
            /* TODO: are NULL args ok? */ 
            continue;
            cp = "";
        } else
            cp = Jsi_ValueToString(interp, ov, NULL);
        if (i && jstr[0])
            Jsi_DSAppend(&dStr, jstr, NULL);
        Jsi_DSAppend(&dStr, cp, NULL);
    }
    
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
bail:
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(""));
    return JSI_OK;        
}


Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {
    Jsi_Value *va;
    Jsi_Obj *obj;
    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj)) {
        return NULL;
    }
    if (arg2->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg2->d.obj)) {
        return NULL;
    }
    int len1 = arg1->d.obj->arrCnt;
    int len2 = arg2->d.obj->arrCnt;
    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ObjArraySizer(interp, nobj, len1+len2);

    int i, j = 0;
    obj = arg1->d.obj;
    for (i = 0; i<len1; i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[j] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);
    }
    obj = arg2->d.obj;
    for (i = 0; i<len2; i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[j] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);
    }
    Jsi_ObjSetLength(interp, nobj, len1+len2);
    va = Jsi_ValueMakeArrayObject(interp, NULL, nobj);
    return va;
}

Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {
    Jsi_Obj *obj;
    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj))
        return JSI_ERROR;
    if (!arg2)
        return JSI_ERROR;
    int len1 = arg1->d.obj->arrCnt;
    obj = arg1->d.obj;
    Jsi_ObjArraySizer(interp, obj, len1);
    obj->arr[len1] = arg2;
    Jsi_IncrRefCount(interp, arg2);
    obj->arrCnt++;
    return JSI_OK;
}


Jsi_Value *Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Jsi_ValueArrayPop, target is not object");
        return NULL;
    }
    Jsi_Obj *o = v->d.obj;
    if (!o->isarrlist) {
        Jsi_LogBug("Jsi_ValueArrayPop, target is not array");
        return NULL;
    }
    if (o->arrCnt<=0)
        return NULL;
    int idx = o->arrCnt-1;
    if (!o->arr[idx])
        return NULL;
    Jsi_DecrRefCount(interp, o->arr[idx]);
    Jsi_Value *ret = o->arr[idx];
    o->arr[idx] = NULL;
    o->arrCnt--;
    return ret;
}


Jsi_Value *Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Jsi_ValueArrayUnshift, target is not object");
        return NULL;
    }
    Jsi_Obj *o = v->d.obj;
    if (!o->isarrlist) {
        Jsi_LogBug("Jsi_ValueArrayUnshift, target is not array");
        return NULL;
    }
    if (o->arrCnt<=0)
        return NULL;
    if (!o->arr[0])
        return NULL;
    Jsi_DecrRefCount(interp, o->arr[0]);
    Jsi_Value *ret = o->arr[0];
    o->arr[0] = NULL;
    o->arrCnt--;
    return ret;
}

/* delete array[0], array[1]->array[0] */
void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Jsi_ValueArrayShift, target is not object");
        return;
    }
    Jsi_Obj *o = v->d.obj;
    if (o->isarrlist) {
        uint i;
        if (!o->arrCnt)
            return;
        if (o->arr[0])
            Jsi_DecrRefCount(interp, o->arr[0]);
        for (i=1; i<o->arrCnt; i++) {
            o->arr[i-1] = o->arr[i];
        }
        o->arr[o->arrCnt--] = NULL;
        return;
    }
    
    int len = Jsi_ObjGetLength(interp, v->d.obj);
    if (len <= 0) return;
    
    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);
    if (!v0) return;
    
    Jsi_ValueReset(interp, &v0);
    
    int i;
    Jsi_Value *last = v0;
    for (i = 1; i < len; ++i) {
        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);
        if (!t) return;
        Jsi_ValueCopy(interp, last, t);
        Jsi_ValueReset(interp, &t);
        last = t;
    }
    Jsi_ObjSetLength(interp, v->d.obj, len - 1);
}

static Jsi_RC ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Value *va;
    Jsi_Obj *obj;
    int curlen, argc, nsiz;
    Jsi_RC rc = JSI_OK;
    Jsi_Obj *nobj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    obj = _this->d.obj;
    
    argc = Jsi_ValueGetLength(interp, args);
    curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
   
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrMaxSize;
    if (nsiz<=0) nsiz = 100;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {
        rc = JSI_ERROR;
        Jsi_LogError("index too large: %d", nsiz+1);
        goto bail;
    }

    int i, j, m;
    for (i = 0; i<curlen; i++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[i] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);
    }
    m = i;
    for (i = 0; i < argc; i++) {
         va = Jsi_ValueArrayIndex(interp, args, i);
         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {
            int margc = Jsi_ValueGetLength(interp, va);
            Jsi_Obj *mobj = va->d.obj;
            Jsi_ObjListifyArray(interp, mobj);
            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {
                rc = JSI_ERROR;
                Jsi_LogError("index too large: %d", curlen);
                goto bail;
            }
            for (j = 0; j<margc; j++, m++)
            {
                if (!mobj->arr[j]) continue;
                nobj->arr[m] = NULL;
                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);
            }
        } else {
            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {
                rc = JSI_ERROR;
                Jsi_LogError("index too large: %d", curlen);
                goto bail;
            }
            nobj->arr[m] = NULL;
            Jsi_ValueDup2(interp, nobj->arr+m++, va);
       }
    }
    Jsi_ObjSetLength(interp, nobj, curlen);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return JSI_OK;
        
bail:
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}

static Jsi_RC ArrayMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj, *nobj;
    int curlen, nsiz;
    int i;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) 
        return Jsi_LogError("expected function");
    sthis = Jsi_ValueArrayIndex(interp, args, 1);
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);
    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrCnt;
    if (nsiz<=0) nsiz = 1;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, nobj);

    for (i = 0; i < curlen; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        nobj->arr[i] = Jsi_ValueNew1(interp);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, nobj->arr+i, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        if( JSI_OK!=rc ) {
            goto bail;
        }
    }
    Jsi_ObjSetLength(interp, nobj, curlen);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
        
bail:
    Jsi_ValueMakeNull(interp, ret);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return rc;
}

static Jsi_RC ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj, *nobj;
    int curlen, nsiz;
    int i;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *func, *vpargs, *nthis = NULL;
    int fval, n = 0;
    Jsi_Value *sthis, *nrPtr = NULL;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) 
        return Jsi_LogError("expected function");
    sthis = Jsi_ValueArrayIndex(interp, args, 1);
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);
    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrCnt;
    if (nsiz<=0) nsiz = 1;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    nrPtr = Jsi_ValueNew1(interp);
    for (i = 0; i < curlen; i++) {
        if (!obj->arr[i]) continue;
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        fval = Jsi_ValueIsTrue(interp, nrPtr);
        Jsi_ValueMakeUndef(interp, &nrPtr);
        if( JSI_OK!=rc ) {
            goto bail;
        }
        if (fval) {
            nobj->arr[n++] = obj->arr[i];
            Jsi_IncrRefCount(interp, obj->arr[i]);
        }
    }
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    Jsi_DecrRefCount(interp, nrPtr);
    Jsi_ObjSetLength(interp, nobj, n);
    return JSI_OK;
        
bail:
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    if (nrPtr)
        Jsi_DecrRefCount(interp, nrPtr);
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}


static Jsi_RC ArrayReverseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    int i, n, m;
    Jsi_Value *tval;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) 
        return Jsi_LogError("expected array");
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    m = obj->arrCnt/2;
    for (i = 0, n=obj->arrCnt-1; i < m; i++, n--) {
        tval = obj->arr[i];
        obj->arr[i] = obj->arr[n];
        obj->arr[n] = tval;
    }
    Jsi_ValueDup2(interp, ret, _this);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
}

static Jsi_RC ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) 
{
    Jsi_Obj *obj;
    int curlen;
    uint i;
    Jsi_Value *func, *vpargs;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) 
        return Jsi_LogError("expected array");
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) 
        return Jsi_LogError("expected function");
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);

    for (i = 0; i < obj->arrCnt; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        Jsi_RC rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        if( JSI_OK!=rc ) {
            return rc;
        }
    }
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
}

static Jsi_RC ArraySomeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    int curlen;
    uint i;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *func, *vpargs;
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) 
        return Jsi_LogError("expected array");
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) 
        return Jsi_LogError("expected function");
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    int fval = 0;
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        fval = Jsi_ValueIsTrue(interp, nrPtr);
        Jsi_ValueMakeUndef(interp, &nrPtr);
        if (fval)
            break;
    }
    if (rc == JSI_OK)
        Jsi_ValueMakeBool(interp, ret, fval);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    Jsi_DecrRefCount(interp, nrPtr);
    return rc;

}
/* // Not required as typeof returns "array"
static int ArrayIsarrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    int isa = (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj));
    Jsi_ValueMakeBool(interp, ret, isa);
    return JSI_OK;
}*/

static Jsi_RC ArrayIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1);
    int istart, n;
    Jsi_Obj *obj = _this->d.obj;
    if (!seq) {
        goto bail;
    }
    
    n = Jsi_ObjGetLength(interp, obj);    
    if (n == 0) {
        goto bail;
    }
    Jsi_Number nstart;
    istart = 0;
    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {
        istart = (int) nstart;
        if (istart > n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            istart = 0;
    }
    Jsi_ObjListifyArray(interp, obj);
    int i;
    for (i = istart; i < n; i++)
    {
        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {
            Jsi_ValueMakeNumber(interp, ret, i);
            return JSI_OK;
        }
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, -1);
    return JSI_OK;
}

static Jsi_RC ArrayLastindexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1);
    int istart, n;
    Jsi_Obj *obj = _this->d.obj;
    if (!seq) {
        goto bail;
    }
    
    n = Jsi_ObjGetLength(interp, obj);    
    if (n == 0) {
        goto bail;
    }
    Jsi_Number nstart;
    istart = n-1;
    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {
        istart = (int)nstart;
        if (istart > n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            goto bail;
    }
    Jsi_ObjListifyArray(interp, obj);
    int i;
    for (i = istart; i >= 0; i--)
    {
        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {
            Jsi_ValueMakeNumber(interp, ret, i);
            return JSI_OK;
        }
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, -1);
    return JSI_OK;
}


static Jsi_RC ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    int i;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))
        i = 0;
    else
        i = Jsi_ObjGetLength(interp, _this->d.obj);
    Jsi_ValueMakeNumber(interp, ret, i);
    return JSI_OK;
}

static Jsi_RC ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    Jsi_Value *v;
    uint n;
    
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    n = Jsi_ObjGetLength(interp, obj);
    assert(n <= obj->arrCnt);
    if (n<=0) {
        Jsi_ValueMakeUndef(interp, ret);
    } else {
        n--;
        v = obj->arr[0];
        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));
        obj->arr[n] = NULL;
        Jsi_ValueDup2(interp, ret, v);
        Jsi_DecrRefCount(interp, v);
        Jsi_ObjSetLength(interp, obj, n);
    }
    return JSI_OK;
}

static Jsi_RC ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    
    int argc = Jsi_ValueGetLength(interp, args);
    int curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    if (argc <= 0) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_ObjListifyArray(interp, obj);
    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) 
        return Jsi_LogError("too long");
    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));
    obj->arrCnt += argc;
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);
        obj->arr[i] = NULL;
        if (!ov) { Jsi_LogBug("Arguments Error"); continue; }
        obj->arr[i] = ov;
        Jsi_IncrRefCount(interp, ov);
    }
    Jsi_ObjSetLength(interp, obj, curlen+argc);
    
    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));
    return JSI_OK;
}

static Jsi_RC ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) 
        return Jsi_LogError("expected array");
    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 2);
    int istart = 0, iend, n, nsiz;
    Jsi_RC rc = JSI_OK;
    Jsi_Obj *obj = _this->d.obj;
    n = Jsi_ObjGetLength(interp, obj);
    Jsi_Number nstart = 0;  // TODO: merge with code in ArraySliceCmd.
    Jsi_Number nend = 0;
    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {
        istart = (int)nstart;
        if (istart > n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            goto bail;
    }
      
    if (n == 0) {
        goto bail;
    }
    iend = n-1;
    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {
        iend = (int) nend;
        if (iend >= n)
            iend = n;
        if (iend < 0)
            iend = (n+iend);
        if (iend<0)
            goto bail;
    }
    nsiz = iend-istart+1;
    if (nsiz<=0)
        goto bail;

    int i, m;
    for (m = 0, i = istart; i <= iend; i++, m++)
    {
        if (obj->arr[i] == value) continue;
        if (obj->arr[i]) Jsi_DecrRefCount(interp, obj->arr[i]);
        obj->arr[m] = value;
        Jsi_IncrRefCount(interp, value);
    }
bail:
    if (_this != *ret) {
        if (*ret)
            Jsi_DecrRefCount(interp, *ret);
        *ret = _this;
        Jsi_IncrRefCount(interp, *ret);
    }
    return rc;
}


static Jsi_RC ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1);
    int istart = 0, iend, n, nsiz;
    Jsi_RC rc = JSI_OK;
    Jsi_Obj *nobj, *obj;
    if (!start) {
        goto bail;
    }
    obj = _this->d.obj;
    n = Jsi_ObjGetLength(interp, obj);
    Jsi_Number nstart;
    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {
        istart = (int)nstart;
        if (istart > n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            goto bail;
    }
      
    if (n == 0) {
        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));
        return JSI_OK;
    }
    Jsi_Number nend;
    iend = n-1;
    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {
        iend = (int) nend;
        if (iend >= n)
            iend = n;
        if (iend < 0)
            iend = (n+iend);
        if (iend<0)
            goto bail;
    }
    nsiz = iend-istart+1;
    if (nsiz<=0)
        goto bail;
    Jsi_ObjListifyArray(interp, obj);
    
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);

    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }

    int i, m;
    for (m = 0, i = istart; i <= iend; i++, m++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[m] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);
    }
    Jsi_ObjSetLength(interp, nobj, nsiz);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return JSI_OK;
    
bail:
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}

typedef struct {
    Jsi_Interp *interp;
    int flags;
    int mode;
    bool unique;
    Jsi_Value *compare;
    int errCnt;
} SortInfo;

static const char *sortArrayStrs[] = {"default", "desc", "dict", "nocase", 0};

static Jsi_OptionSpec ArraySortOptions[] = {
    JSI_OPT(CUSTOM, SortInfo, mode,     .help="Mode to sort by", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=sortArrayStrs),
    JSI_OPT(FUNC,   SortInfo, compare,  .help="Function to do comparison", .flags=0, .custom=0, .data=(void*)"val1,val2"),
    JSI_OPT(BOOL,   SortInfo, unique,   .help="Eliminate duplicate items"),
    JSI_OPT_END(SortInfo)
};

#ifdef NO_QSORT_R

SortInfo *curSortInfo = NULL;

static int SortSubCmd(const void *p1, const void *p2) {
    SortInfo *si = curSortInfo;
#else
#ifdef __WIN32
static int SortSubCmd(void *thunk, const void *p1, const void *p2)
#else
static int SortSubCmd(const void *p1, const void *p2, void *thunk)
#endif
{
    SortInfo *si = (SortInfo *)thunk;
#endif
    Jsi_Interp *interp = si->interp;
    int sortFlags = si->flags;

    if (interp == NULL || interp->deleting)
        return 0;
    Jsi_Value *v1 = *(Jsi_Value**)p1, *v2 = *(Jsi_Value**)p2;
    VALCHK(v1);
    VALCHK(v2);
    int rc = 0;
    if (v1 != NULL && v2 != NULL) {
        if (!si->compare)
            rc = Jsi_ValueCmp(interp, v1, v2, sortFlags);
        else {
            Jsi_Value *vv[2] = {v1, v2};
            Jsi_Value *retP = Jsi_ValueNew1(interp);
            Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vv, 2, 0));
            Jsi_IncrRefCount(interp, vpargs);
            rc = Jsi_FunctionInvoke(interp, si->compare, vpargs, &retP, NULL);
            Jsi_DecrRefCount(interp, vpargs);
            Jsi_Number d = 0;
            if (Jsi_ValueGetNumber(interp, retP, &d) == JSI_OK)
                rc = -(int)d;
            else {
                if (!si->errCnt)
                    Jsi_LogWarn("invalid function return");
                si->errCnt++;
            }
            Jsi_DecrRefCount(interp, retP);
        }
    } else {
        if (v1 == v2) 
            rc = 0;
        else if (v1 == NULL)
            rc = 1;
        else
            rc = -1;
    }
    if ((sortFlags&JSI_SORT_DESCEND))
        return rc;
    return -rc;
}

Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int flags)
{
    if (val->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, val->d.obj)) {
        return JSI_ERROR;
    }
    Jsi_Obj *obj = val->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    if (obj->arrCnt <= 0) {
        return JSI_OK;
    }
#ifdef __WIN32
#define qsort_r qsort_s
#endif

    SortInfo si = {};
    si.interp = interp;
    si.flags = flags;
#ifdef NO_QSORT_R
    curSortInfo = &si;
    qsort(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd);
    curSortInfo = NULL;
#else
    qsort_r(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd, &si);
#endif
    return JSI_OK;
}

static Jsi_RC ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int flags = 0, i, curlen;
    Jsi_Obj *obj;
    Jsi_Value *v;
    SortInfo si = {};
    Jsi_Value *arg = NULL;
    int hasopt = 0;
    si.interp = interp;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    obj = _this->d.obj;
    curlen = obj->arrCnt;

    if (curlen <= 1) {
        goto done;
    }
    
    arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg) {
        if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {
            if (Jsi_OptionsProcess(interp, ArraySortOptions, &si, arg, 0) < 0)
                return JSI_ERROR;
            hasopt = 1;
            switch (si.mode) {
                case 1: flags |= JSI_SORT_DESCEND; break;
                case 2: flags |= JSI_SORT_DICT; break;
                case 3: flags |= JSI_SORT_NOCASE; break;
            }
        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION))
            si.compare = arg;
        else 
            return Jsi_LogError("expected object or function");
    }
    si.flags = flags;
    Jsi_ObjListifyArray(interp, obj);
#ifdef NO_QSORT_R
    /* TODO: mutex. */
    curSortInfo = &si;
    qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd);
#else
    qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si);
#endif

    if (interp->deleting) {
#ifdef NO_QSORT_R
        curSortInfo = NULL;
#endif
        return JSI_ERROR;
    }
    if (si.unique) {
        int n, diff = 1, dupCnt=0;
        for (n=0, i=1; i<(int)obj->arrCnt; i++) {
            if (obj->arr[n] == obj->arr[i])
                diff = 1;
            else
#ifdef NO_QSORT_R
                diff = SortSubCmd(&obj->arr[n], &obj->arr[i]);
#else
#ifdef __WIN32
                diff = SortSubCmd(&si, &obj->arr[n], &obj->arr[i]);
#else
                diff = SortSubCmd(&obj->arr[n], &obj->arr[i], &si);
#endif
#endif
            if (diff) {
                n++;
                if (n!=i)
                    obj->arr[n] = obj->arr[i];
            } else {
                dupCnt++;
                if (obj->arr[i])
                    Jsi_DecrRefCount(interp, obj->arr[i]);
                obj->arr[i] = 0;
            }
        }
        obj->arrCnt -= dupCnt;
    }
#ifdef NO_QSORT_R
    curSortInfo = NULL;
#endif
    if (hasopt)
        Jsi_OptionsFree(interp, ArraySortOptions, &si, 0);
done:
    v = Jsi_ValueMakeObject(interp, NULL, obj);
    Jsi_ValueReplace(interp, ret, v);
    return JSI_OK;
bail:
    Jsi_ValueMakeNull(interp, ret);
    return JSI_OK;
}

static Jsi_RC ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *va;
    Jsi_Obj *obj, *nobj;
    int newlen, argc, istart, n, rhowmany, ilen, curlen;
    Jsi_Value *start, *howmany;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail2;
    }
    obj = _this->d.obj;
    
    start = Jsi_ValueArrayIndex(interp, args, 0);
    howmany = Jsi_ValueArrayIndex(interp, args, 1);
    argc = Jsi_ValueGetLength(interp, args);
    istart = 0;
    ilen = (argc>=2 ? argc - 2 : 0);
    n = Jsi_ObjGetLength(interp, obj);
    curlen = n;
    
    if (!start) {
        goto bail2;
    }

    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    Jsi_ObjSetLength(interp, nobj, 0);
    
    /* Determine start index. */
    Jsi_Number nstart;
    if (Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {
        istart = (int)nstart;
        if (istart > n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            istart=0;
    }
      
    Jsi_Number nhow;
    rhowmany = n-istart;
    if (howmany && Jsi_GetNumberFromValue(interp, howmany, &nhow) == JSI_OK) {
        rhowmany = (int)nhow;
        if (rhowmany >= (n-istart))
            rhowmany = n-istart;
        if (rhowmany < 0)
            rhowmany = (n-istart);
        if (rhowmany<0)
            goto bail;
    }
    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
   
    Jsi_ObjArraySizer(interp, nobj, rhowmany);

    /* Move elements to return object. */
    int i, j, m;
    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++,i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[m] = NULL;
        nobj->arr[m] = obj->arr[i];
    }
    Jsi_ObjSetLength(interp, nobj, m);
    
    /* Shift remaining down. */
    for (; rhowmany && i<curlen; i++)
    {
        obj->arr[i-rhowmany] = obj->arr[i];
        obj->arr[i] = NULL;
    }
    curlen -= j;
    /* Add elements. */
    newlen = curlen + argc - (argc>=2?2:1);
    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {
        Jsi_LogError("too long");
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    if (ilen>0) {
        for (i = curlen-1; i>=istart; i--) {
            obj->arr[i+ilen] = obj->arr[i];
            obj->arr[i] = NULL;
        }
        for (m=istart, i = 2; i<argc; m++,i++) {
            va = Jsi_ValueArrayIndex(interp, args, i);
            if (!va) continue;
            obj->arr[m] = NULL;
            Jsi_ValueDup2(interp, obj->arr+m, va);
        }
    }
    Jsi_ObjSetLength(interp, obj, newlen);
bail:    
    return JSI_OK;
     
            
bail2:
    Jsi_ValueMakeNull(interp, ret);
    return JSI_OK;
}

static Jsi_RC ArrayConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *target;
    
    if (Jsi_FunctionIsConstructor(funcPtr)) target = _this;
    else {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        o->__proto__ = interp->Array_prototype;
        Jsi_ValueMakeObject(interp, ret, o);
        target = *ret;
    }

    if (argc == 1) {
        Jsi_Number nv;
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v && Jsi_GetNumberFromValue(interp,v, &nv) == JSI_OK) {
            int len = (int)nv;
            if (!Jsi_NumberIsInteger(v->d.num) || len < 0) 
                return Jsi_LogError("Invalid array length");
            target->d.obj->isarrlist = 1;
            if (Jsi_ObjArraySizer(interp, target->d.obj, len) <= 0)
                return JSI_ERROR;
            return JSI_OK;
        }
    }

    int i;
    target->d.obj->isarrlist = 1;
    if (Jsi_ObjArraySizer(interp, target->d.obj, 0) <= 0)
            return JSI_ERROR;
    
    for (i = 0; i < argc; ++i) {
        Jsi_Value *argv = Jsi_ValueArrayIndex(interp, args, i);   ;
        jsi_ValueInsertArray(interp, _this, i, argv, 0);
    }
    return JSI_OK;
}
            
static Jsi_CmdSpec arrayCmds[] = {
    { "Array",      ArrayConstructor,   0,-1, "...", .help="Array constructor", .retType=(uint)JSI_TT_ARRAY, .flags=JSI_CMD_IS_CONSTRUCTOR },
    { "concat",     ArrayConcatCmd,     0,-1, "...", .help="Return array with args appended", .retType=(uint)JSI_TT_ARRAY },
    { "fill",       ArrayFillCmd,       1, 3, "value:any, start:number=0, end:number=-1", .help="Fill an array with values", .retType=(uint)JSI_TT_ARRAY },
    { "filter",     ArrayFilterCmd,     1, 2, "callback:function, this:object=void", .help="Return a filtered array", .retType=(uint)JSI_TT_ARRAY },
    { "forEach",    ArrayForeachCmd,    1, 2, "callback:function, this:object=void", .help="Invoke function with each item in object", .retType=(uint)JSI_TT_UNDEFINED },
    { "indexOf",    ArrayIndexOfCmd,    1, 2, "str:any, startIdx:number=0", .help="Return index of first occurrance in array", .retType=(uint)JSI_TT_NUMBER },
    { "join",       ArrayJoinCmd,       0, 1, "sep:string=''", .help="Return elements joined by char", .retType=(uint)JSI_TT_STRING },
    { "lastIndexOf",ArrayLastindexOfCmd,1, 2, "val:any, start:number=0", .help="Return index of last occurence in array", .retType=(uint)JSI_TT_NUMBER },
    { "map",        ArrayMapCmd,        1, 2, "callback:function, this:object=void", .help="Creates a new array with the results of calling a provided function on every element in this array", .retType=(uint)JSI_TT_ARRAY },
    { "pop",        ArrayPopCmd,        0, 0, "", .help="Remove and return last element of array", .retType=(uint)JSI_TT_ANY },
    { "push",       ArrayPushCmd,       1,-1, "val:any, ...", .help="Push one or more elements onto array and return size", .retType=(uint)JSI_TT_NUMBER },
    { "shift",      ArrayShiftCmd,      0, 0, "", .help="Remove first element and shift downwards", .retType=(uint)JSI_TT_ANY },
    { "sizeOf",     ArraySizeOfCmd,     0, 0, "", .help="Return size of array", .retType=(uint)JSI_TT_NUMBER },
    { "slice",      ArraySliceCmd,      1, 2, "start:number, end:number=void", .help="Return sub-array", .retType=(uint)JSI_TT_ARRAY },
    { "some",       ArraySomeCmd,       1, 2, "callback:function, this:object=void", .help="Return true if function returns true some element", .retType=(uint)JSI_TT_BOOLEAN },
    { "sort",       ArraySortCmd,       0, 1, "options:function|object=void", .help="Sort an array", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=0, .opts=ArraySortOptions },
    { "splice",     ArraySpliceCmd,     1,-1, "start:number, howmany:number=void, ...", .help="Change the content of an array, adding new elements while removing old elements", .retType=(uint)JSI_TT_ARRAY },
    { "reverse",    ArrayReverseCmd,    0, 0, "", .help="Reverse order of all elements in an array", .retType=(uint)JSI_TT_ARRAY },
    { "unshift",    ArrayUnshiftCmd,    0,-1, "...", .help="Add new elements to start of array and return size", .retType=(uint)JSI_TT_NUMBER },
    { NULL, 0,0,0,0, .help="Provide access to array objects" }
};

Jsi_RC jsi_InitArray(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    interp->Array_prototype = Jsi_CommandCreateSpecs(interp, "Array", arrayCmds, NULL, JSI_CMDSPEC_ISOBJ);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifndef JSI_OMIT_LOAD

#ifdef __WIN32
#define dlsym(l,s) GetProcAddress(l,s)
#define dlclose(l) FreeLibrary(l)
#include <windows.h>
#else
#include <dlfcn.h>
#endif

#ifndef RTLD_NOW
    #define RTLD_NOW 0
#endif
#ifndef RTLD_LOCAL
    #define RTLD_LOCAL 0
#endif

#endif

typedef struct LoadData {
    const char *name;
    const char *fpath;
#ifdef __WIN32
    HMODULE handle;
#else
    void *handle;
#endif
    Jsi_InitProc *onload;
} LoadData;

#ifndef JSI_OMIT_LOAD

/**
 * Note that jsi_LoadLibrary() requires a path to an existing file.
 *
 * If it is necessary to search autoFiles, use Jsi_PkgLoad() instead.
 */
Jsi_RC jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName)
{
#ifdef __WIN32
    HMODULE handle = LoadLibrary(pathName);
#else
    void *handle = dlopen(pathName, RTLD_NOW | RTLD_LOCAL);
#endif
    if (handle == NULL) {
        // FYI: Valgrind shows a mem-leak here.
        Jsi_LogError("loading extension \"%s\": %s", pathName, dlerror());
        return JSI_ERROR;
    }
    /* We use a unique init symbol depending on the extension name.
     * This is done for compatibility between static and dynamic extensions.
     * For extension readline.so, the init symbol is "Jsi_readlineInit"
     */
    const char *pt;
    const char *pkgname;
    int pkgnamelen, n;
    char initsym[100];
    const char *cp = "";
    Jsi_InitProc *onload = NULL;
    Jsi_HashEntry *hPtr;
    LoadData *d;

    pt = Jsi_Strrchr(pathName, '/');
    if (pt) {
        pkgname = pt + 1;
    }
    else {
        pkgname = pathName;
    }
    pt = Jsi_Strchr(pkgname, '.');
    if (pt) {
        pkgnamelen = pt - pkgname;
    }
    else {
        pkgnamelen = Jsi_Strlen(pkgname);
    }
    for (n = 0; n<6 && onload==NULL; n++)
    {
        char ch;
        if (n==2) { /* Skip lib prefix. */
            if (pkgnamelen<4 || Jsi_Strncasecmp(pkgname,"lib",3))
                break;
            pkgname += 3;
            pkgnamelen -= 3;
        }
        if (n==4) { /* Skip lib prefix. */
            if (pkgnamelen<4 || Jsi_Strncasecmp(pkgname,"jsi",3))
                break;
            pkgname += 3;
            pkgnamelen -= 3;
        }
        ch = ((n%2) ? pkgname[0] : toupper(pkgname[0]));
        snprintf(initsym, sizeof(initsym), "Jsi_Init%c%.*s", ch, pkgnamelen-1, pkgname+1);
        cp = initsym+8;
        hPtr = Jsi_HashEntryFind(interp->loadTbl, cp);
        if (hPtr) { /* Already loaded? */
            d = (LoadData*)Jsi_HashValueGet(hPtr);
            if (d && d->handle)
                return JSI_OK;
        }
        onload = (Jsi_InitProc *)dlsym(handle, initsym);
#ifndef JSI_OMIT_STUBS
        if (onload) {
            /* Handle stubs. TODO: handle other libs like sqliteStubsPtr, websocketStubsPtr, etc... */
            struct Jsi_Stubs **vp = (struct Jsi_Stubs**)dlsym(handle, "jsiStubsPtr");
            if (vp) {
                *vp = jsiStubsTblPtr;
            }
        }
#endif
    }
    
    if (onload == NULL)
        Jsi_LogError("No %s symbol found in extension %s", initsym, pathName);
    else if (onload(interp, 0) != JSI_ERROR) {
        bool isNew;
        hPtr = Jsi_HashEntryNew(interp->loadTbl, cp, &isNew);
        if (hPtr && isNew) {
            d = (LoadData*)Jsi_Calloc(1, sizeof(*d));
            d->handle = handle;
            d->name = (char*)Jsi_HashKeyGet(hPtr);
            d->fpath = pathName;
            d->onload = onload;
            Jsi_HashValueSet(hPtr, d);
            return JSI_OK;
        }
        Jsi_LogError("duplicate load");
    }

    if (handle) {
        dlclose(handle);
    }
    return JSI_ERROR;
}
#else
Jsi_RC jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName)
{
    return Jsi_LogError("load not supported");
}
#endif

Jsi_RC jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    LoadData *d = (LoadData*)ptr;
    if (d->onload)
        (*d->onload)(interp, interp==jsiMainInterp?2:1);
#ifndef JSI_OMIT_LOAD
    dlclose(d->handle);
#endif
    Jsi_Free(d);
    return JSI_OK;
}

Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr)
{
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->loadTbl, name);
    if (!hPtr)
        return JSI_ERROR;
    LoadData *d = (LoadData*)Jsi_HashValueGet(hPtr);
    if (d==NULL || !d->handle)
        return JSI_ERROR;
    char initsym[100];
    snprintf(initsym, sizeof(initsym), "%sStubsTblPtr", name);
    void **vp = NULL;
#ifndef JSI_OMIT_LOAD
    vp = (void**)dlsym(d->handle, initsym);
#endif
    if (vp == NULL || !*vp)
        return JSI_ERROR;
    *ptr = *vp;
    return JSI_OK;
}

Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *fval = Jsi_ValueArrayIndex(interp, args, 0);
    char *v = Jsi_Realpath(interp, fval, NULL);
    Jsi_StatBuf fbuf;
    Jsi_RC rc;
    if (v == NULL || Jsi_Stat(interp, fval, &fbuf) || !Jsi_FSNative(interp, fval))
        rc = Jsi_LogError("can not load: %s", (v?v:"null"));
    else
        rc = jsi_LoadLibrary(interp, v);
    if (v)
        Jsi_Free(v);
    return rc;
}

Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return Jsi_LogError("unload is unimplemented");
}

Jsi_InitProc jsi_InitLoad;

Jsi_RC jsi_InitLoad(Jsi_Interp *interp, int release)
{
    return JSI_OK;
}


#ifdef __WIN32
#undef dlsym
#undef dlclose
#endif

#else
Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_LogWarn("load is unimplemented");
    return JSI_OK;
}
Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return Jsi_LogError("unload is unimplemented");
}
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdint.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define REBUILD_MULTIPLIER  3

#if JSI_IS64BIT
#define RANDOM_INDEX        HashOneWord
#define DOWNSHIFT_START     62
#else 
#define RANDOM_INDEX(tablePtr, i) \
    (((((uintptr_t) (i))*1103515245) >> (tablePtr)->downShift) & (tablePtr)->mask)
#define DOWNSHIFT_START 28
#endif

static jsi_Hash jsi_HashArray (const void *key, size_t length);
static Jsi_HashEntry *jsi_HashArrayFind (Jsi_Hash *tablePtr, const void 
*key);
static Jsi_HashEntry *jsi_HashArrayCreate (Jsi_Hash *tablePtr,
    const void *key, bool *newPtr);
static jsi_Hash HashString (const char *string);
static void RebuildTable (Jsi_Hash *tablePtr);
static Jsi_HashEntry *HashStringFind (Jsi_Hash *tablePtr,
    const void *key);
static Jsi_HashEntry *HashStringCreate (Jsi_Hash *tablePtr,
    const void *key, bool *newPtr);
static Jsi_HashEntry *HashOneWordFind (Jsi_Hash *tablePtr,
    const void *key);
static Jsi_HashEntry *HashOneWordCreate (Jsi_Hash *tablePtr,
    const void *key, bool *newPtr);

#if JSI_IS64BIT
static jsi_Hash HashOneWord (Jsi_Hash *tablePtr,
    const void *key));

#endif /* JSI_IS64BIT */

static jsi_Hash
HashString( const char *string)
{
    jsi_Hash result = 0;
    jsi_Hash c;
    while ((c = *string++) != 0)
        result += (result << 3) + c;

    return (jsi_Hash)result;
}
static Jsi_HashEntry *
HashStringFind( Jsi_Hash *tablePtr, const void *key)
{
    jsi_Hash hval;
    Jsi_HashEntry *hPtr;
    size_t hindex;

    hval = HashString((char *)key);
    hindex = hval & tablePtr->mask;

    /*
     * Search all of the entries in the appropriate bucket.
     */

    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
            hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            const char *p1, *p2;

            for (p1 = (char*)key, p2 = hPtr->key.string; ; p1++, p2++) {
                if (*p1 != *p2) {
                    break;
                }
                if (*p1 == '\0') {
                    return hPtr;
                }
            }
        }
    }
    return NULL;
}

static Jsi_HashEntry *
HashStringCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)
{
    jsi_Hash hval;
    Jsi_HashEntry **bucketPtr;
    Jsi_HashEntry *hPtr;
    size_t size, hindex;

    hval = HashString((const char*)key);
    hindex = hval & tablePtr->mask;

    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
            hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            const char *p1, *p2;

            for (p1 = (const char*)key, p2 = hPtr->key.string; ; p1++, p2++) {
                if (*p1 != *p2) {
                    break;
                }
                if (*p1 == '\0') {
                    if (newPtr)
                        *newPtr = 0;
                    return hPtr;
                }
            }
        }
    }

    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_HashEntry) + Jsi_Strlen((char*)key) - sizeof(jsi_HashKey) + 1;
    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);
    hPtr->typ = JSI_MAP_HASH;
    bucketPtr = tablePtr->buckets + hindex;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = hval;
    hPtr->clientData = 0;
    Jsi_Strcpy(hPtr->key.string, (char*)key);
    *bucketPtr = hPtr;
    tablePtr->numEntries++;

    if (tablePtr->numEntries >= tablePtr->rebuildSize)
        RebuildTable(tablePtr);
        
    return hPtr;
}

#if JSI_IS64BIT
/*
 *----------------------------------------------------------------------
 *
 * HashOneWord --
 *
 *  Compute a one-word hash value of a 64-bit word, which then can
 *  be used to generate a hash index.
 *
 *  From Knuth, it's a multiplicative hash.  Multiplies an unsigned
 *  64-bit value with the golden ratio (sqrt(5) - 1) / 2.  The
 *  downshift value is 64 - n, when n is the log2 of the size of
 *  the hash table.
 *      
 * Results:
 *  The return value is a one-word summary of the information in
 *  64 bit word.
 *
 * Side effects:
 *  None.
 *
 *----------------------------------------------------------------------
 */
static jsi_Hash
HashOneWord(
    Jsi_Hash *tablePtr,
    const void *key)
{
    uint64_t a0, a1;
    uint64_t y0, y1;
    uint64_t y2, y3;
    uint64_t p1, p2;
    uint64_t result;
    /* Compute key * GOLDEN_RATIO in 128-bit arithmetic */
    a0 = (uint64_t)key & 0x00000000FFFFFFFF;
    a1 = (uint64_t)key >> 32;

    y0 = a0 * 0x000000007f4a7c13;
    y1 = a0 * 0x000000009e3779b9;
    y2 = a1 * 0x000000007f4a7c13;
    y3 = a1 * 0x000000009e3779b9;
    y1 += y0 >> 32;     /* Can't carry */
    y1 += y2;           /* Might carry */
    if (y1 < y2) {
        y3 += (1LL << 32);  /* Propagate */
    }

    /* 128-bit product: p1 = loword, p2 = hiword */
    p1 = ((y1 & 0x00000000FFFFFFFF) << 32) + (y0 & 0x00000000FFFFFFFF);
    p2 = y3 + (y1 >> 32);

    /* Left shift the value downward by the size of the table */
    if (tablePtr->downShift > 0) {
        if (tablePtr->downShift < 64) {
            result = ((p2 << (64 - tablePtr->downShift)) |
                      (p1 >> (tablePtr->downShift & 63)));
        } else {
            result = p2 >> (tablePtr->downShift & 63);
        }
    } else {
        result = p1;
    }
    /* Finally mask off the high bits */
    return (jsi_Hash)(result & tablePtr->mask);
}

#endif /* JSI_IS64BIT */

static Jsi_HashEntry *
HashOneWordFind( Jsi_Hash *tablePtr,  const void *key)
{
     Jsi_HashEntry *hPtr;
    size_t hindex;

    hindex = RANDOM_INDEX(tablePtr, key);

    /*
     * Search all of the entries in the appropriate bucket.
     */
    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
        hPtr = hPtr->nextPtr) {
    if (hPtr->key.oneWordValue == key) {
        return hPtr;
    }
    }
    return NULL;
}

static Jsi_HashEntry *
HashOneWordCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)
{
    Jsi_HashEntry **bucketPtr;
     Jsi_HashEntry *hPtr;
    size_t hindex;

    hindex = RANDOM_INDEX(tablePtr, key);


    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
        hPtr = hPtr->nextPtr) {
        if (hPtr->key.oneWordValue == key) {
            if (newPtr)
                *newPtr = 0;
            return hPtr;
        }
    }

    if (newPtr)
        *newPtr = 1;
    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, sizeof(*hPtr));
    hPtr->typ = JSI_MAP_HASH;
    bucketPtr = tablePtr->buckets + hindex;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = (jsi_Hash)key;
    hPtr->clientData = 0;
    hPtr->key.oneWordValue = (void *)key; 
    *bucketPtr = hPtr;
    tablePtr->numEntries++;


    if (tablePtr->numEntries >= tablePtr->rebuildSize)
        RebuildTable(tablePtr);

    return hPtr;
}

static jsi_Hash
jsi_HashArray(const void *key, size_t length )
{
    const uchar *string = (const uchar *) key;
    unsigned int result = 0;
    int i;

     for (i=0 ; i<(int)length; i++) {
        result += (result<<3) + string[i];
    }
    return (jsi_Hash)result;
}

static Jsi_HashEntry *
jsi_HashArrayFind( Jsi_Hash *tablePtr, const void *key)
{
    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);
    size_t hindex = hval & tablePtr->mask;
    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];

    for (; hPtr != NULL; hPtr = hPtr->nextPtr)
        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType))
            return hPtr;

    return NULL;
}

static Jsi_HashEntry *
jsi_HashArrayCreate( Jsi_Hash *tablePtr,  const void *key, bool *newPtr)
{
    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);
    size_t size, hindex = hval & tablePtr->mask;
    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];

    for (; hPtr != NULL; hPtr = hPtr->nextPtr)
        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType)) {
            if (newPtr)
                *newPtr = 0;
            return hPtr;
        }

    /* Entry not found.  Add a new one to the bucket. */
    if (newPtr)
        *newPtr = 1;
    assert(tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE);
    size = sizeof(Jsi_HashEntry) + tablePtr->keyType;
    if ((uint)tablePtr->keyType > sizeof(jsi_HashKey)) // Avoid memory checker problems by not truncating struct.
        size -= sizeof(jsi_HashKey);
    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);
    Jsi_HashEntry **bucketPtr = tablePtr->buckets + hindex;
    hPtr->typ = JSI_MAP_HASH;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = hval;
    hPtr->clientData = 0;
    memcpy(hPtr->key.string, key, tablePtr->keyType);
    *bucketPtr = hPtr;
    tablePtr->numEntries++;

    /*
     * If the table has exceeded a decent size, rebuild it with many
     * more buckets.
     */
    if (tablePtr->numEntries >= tablePtr->rebuildSize)
        RebuildTable(tablePtr);

    return hPtr;
}


Jsi_HashEntry *
Jsi_HashEntryFind( Jsi_Hash *tablePtr, const void *key)
{
    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)
        return NULL;
    Jsi_HashEntry *hPtr = (*((tablePtr)->findProc))(tablePtr, key);
    if (tablePtr->opts.lockHashProc)
        (*tablePtr->opts.lockHashProc)(tablePtr, 0);
    return hPtr;
}

Jsi_HashEntry *
Jsi_HashEntryNew(Jsi_Hash *tablePtr, const void *key, bool *newPtr)
{
    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)
        return NULL;
    Jsi_HashEntry *hPtr =  (*((tablePtr)->createProc))(tablePtr, key, newPtr);
#ifdef JSI_HAS_SIG_HASHENTRY
    SIGINIT(hPtr, HASHENTRY);
#endif
    if (tablePtr->opts.lockHashProc)
        (*tablePtr->opts.lockHashProc)(tablePtr, 0);
    return hPtr;
}

static void
RebuildTable(Jsi_Hash *tablePtr)
{
    Jsi_HashEntry **bucketPtr, **oldBuckets;
    Jsi_HashEntry **oldChainPtr, **endPtr;
    Jsi_HashEntry *hPtr, *nextPtr;
    size_t hindex;

    oldBuckets = tablePtr->buckets;
    endPtr = tablePtr->buckets + tablePtr->numBuckets;
    tablePtr->numBuckets <<= 2;
    tablePtr->buckets = (Jsi_HashEntry**)Jsi_Calloc(tablePtr->numBuckets, 
                   sizeof(Jsi_HashEntry *));
    tablePtr->rebuildSize <<= 2;
    tablePtr->downShift -= 2;
    tablePtr->mask = tablePtr->numBuckets - 1;

 
    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {

        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {
            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {
            nextPtr = hPtr->nextPtr;
            hindex = RANDOM_INDEX(tablePtr, hPtr->key.oneWordValue);
            bucketPtr = tablePtr->buckets + hindex;
            hPtr->nextPtr = *bucketPtr;
            *bucketPtr = hPtr;
            }
        }
    } else {
        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {
            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {
            nextPtr = hPtr->nextPtr;
            hindex = hPtr->hval & tablePtr->mask;
            bucketPtr = tablePtr->buckets + hindex;
            hPtr->nextPtr = *bucketPtr;
            *bucketPtr = hPtr;
            }
        }
    }

    if (oldBuckets != tablePtr->staticBuckets) {
        Jsi_Free(oldBuckets);
    }
}

Jsi_Hash *
Jsi_HashNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc freeProc)
{
    Jsi_Hash *tablePtr = (Jsi_Hash*)Jsi_Calloc(1,sizeof(*tablePtr));
    SIGINIT(tablePtr, HASH);
    tablePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_HASH;
    tablePtr->typ = JSI_MAP_HASH;
    tablePtr->opts.interp = interp;
    tablePtr->buckets = tablePtr->staticBuckets;
#if !(JSI_SMALL_HASH_TABLE && !(JSI_SMALL_HASH_TABLE & (JSI_SMALL_HASH_TABLE - 1)))
#error "small hash must be a power of two"
#endif
    tablePtr->numBuckets = JSI_SMALL_HASH_TABLE;
    tablePtr->rebuildSize = JSI_SMALL_HASH_TABLE * REBUILD_MULTIPLIER;
    tablePtr->downShift = DOWNSHIFT_START;
    tablePtr->opts.freeHashProc = freeProc;
    tablePtr->mask = (jsi_Hash)(tablePtr->numBuckets - 1);
    tablePtr->opts.keyType = (Jsi_Key_Type)keyType;
    tablePtr->keyType = (Jsi_Key_Type)keyType;

    switch (keyType) {
    case JSI_KEYS_STRING:   /* NUL terminated string keys. */
        tablePtr->findProc = HashStringFind;
        tablePtr->createProc = HashStringCreate;
        break;

    case JSI_KEYS_STRINGKEY: /* Lookup from another String hash, eg. Jsi_KeyAdd() */
    case JSI_KEYS_ONEWORD: /* A pointer. */
        tablePtr->findProc = HashOneWordFind;
        tablePtr->createProc = HashOneWordCreate;
        break;

    default:            /* Structs. */
        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {
            Jsi_LogError("Jsi_HashNew: Key size can't be %d, must be >= %d", keyType, JSI_KEYS_STRUCT_MINSIZE);
            Jsi_Free(tablePtr);
            return NULL;
        }
        tablePtr->findProc = jsi_HashArrayFind;
        tablePtr->createProc = jsi_HashArrayCreate;
        break;
    }
    return tablePtr;
}

int
Jsi_HashEntryDelete(Jsi_HashEntry *entryPtr)
{
    Jsi_HashEntry *prevPtr;
    Jsi_HashEntry **bucketPtr;
    size_t hindex;
    Jsi_Hash *tablePtr = entryPtr->tablePtr;
    Jsi_Interp *interp = tablePtr->opts.interp;
    JSI_NOTUSED(interp);
    int cnt = 0;
#ifdef JSI_HAS_SIG_HASHENTRY
    SIGASSERT(entryPtr, HASHENTRY);
#endif
    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)
        return 0;
    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {
        hindex = RANDOM_INDEX(tablePtr, (const void *)entryPtr->hval);
    } else {
        hindex = (entryPtr->hval & tablePtr->mask);
    }
    bucketPtr = tablePtr->buckets + hindex;
    if (*bucketPtr == entryPtr) {
        *bucketPtr = entryPtr->nextPtr;
        cnt++;
    } else {
        for (prevPtr = *bucketPtr; /*empty*/; prevPtr = prevPtr->nextPtr) {
            if (prevPtr == NULL) {
                Jsi_LogBug("malformed bucket chain in Jsi_HashEntryDelete");
            }
            if (prevPtr->nextPtr == entryPtr) {
                prevPtr->nextPtr = entryPtr->nextPtr;
                cnt++;
                break;
            }
        }
    }
    if (tablePtr->opts.freeHashProc && entryPtr->clientData)
        (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, entryPtr, entryPtr->clientData);

    if (tablePtr->opts.lockHashProc)
        (*tablePtr->opts.lockHashProc)(tablePtr, 0);
    tablePtr->numEntries--;
    Jsi_Free(entryPtr);
    return cnt;
}

void
Jsi_HashClear(Jsi_Hash *tablePtr)
{
    Jsi_HashEntry *hPtr, *nextPtr;
    size_t i;
    if (!tablePtr)
        return;
    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)
        return;
    for (i = 0; i < (size_t)tablePtr->numBuckets; i++) {
        hPtr = tablePtr->buckets[i];
        while (hPtr != NULL) {
            nextPtr = hPtr->nextPtr;
            if (tablePtr->opts.freeHashProc && hPtr->clientData)
                (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, hPtr, hPtr->clientData);
            Jsi_Free(hPtr);
            hPtr = nextPtr;
            tablePtr->buckets[i] = hPtr;
        }
    }
    
    if (tablePtr->buckets != tablePtr->staticBuckets) {
        Jsi_Free(tablePtr->buckets);
    }
    if (tablePtr->opts.lockHashProc)
        (*tablePtr->opts.lockHashProc)(tablePtr, 0);
}


void
Jsi_HashDelete(Jsi_Hash *tablePtr)
{
    Jsi_HashClear(tablePtr);
    Jsi_Free(tablePtr);
}

Jsi_HashEntry *
Jsi_HashSearchFirst(Jsi_Hash *tablePtr, Jsi_HashSearch *searchPtr) 
{
    searchPtr->tablePtr = tablePtr;
    searchPtr->nextIndex = 0;
    searchPtr->nextEntryPtr = NULL;
    return Jsi_HashSearchNext(searchPtr);
}


void *Jsi_HashValueGet(Jsi_HashEntry *h)
{
    return h->clientData;
}

void Jsi_HashValueSet(Jsi_HashEntry *h, void *value)
{
    h->clientData = value;
}

void *Jsi_HashKeyGet(Jsi_HashEntry *hPtr)
{
    Jsi_Hash *t = hPtr->tablePtr;
    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);
}

Jsi_HashEntry *
Jsi_HashSearchNext(Jsi_HashSearch *searchPtr)
{
    Jsi_HashEntry *hPtr;
    Jsi_Hash *tablePtr = searchPtr->tablePtr;
    int locked = 0;
    
    while (searchPtr->nextEntryPtr == NULL) {
        if (searchPtr->nextIndex >= (size_t)tablePtr->numBuckets) {
            if (tablePtr->opts.lockHashProc && locked)
                (*tablePtr->opts.lockHashProc)(tablePtr, 0);
            return NULL;
        }
        if (tablePtr->opts.lockHashProc && locked == 0 && (*tablePtr->opts.lockHashProc)(tablePtr, locked++) != JSI_OK)
            return NULL;
        searchPtr->nextEntryPtr =
            tablePtr->buckets[searchPtr->nextIndex];
        searchPtr->nextIndex++;
    }
    if (tablePtr->opts.lockHashProc && locked)
        (*tablePtr->opts.lockHashProc)(tablePtr, 0);
    hPtr = searchPtr->nextEntryPtr;
    searchPtr->nextEntryPtr = hPtr->nextPtr;
    return hPtr;
}


Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *tbl, const void *key, void *value) {
    Jsi_HashEntry *hPtr;
    bool isNew;
    hPtr = Jsi_HashEntryNew(tbl, key, &isNew);
    if (!hPtr) return hPtr;
    Jsi_HashValueSet(hPtr, value);
    return hPtr;
}

void *Jsi_HashGet(Jsi_Hash *tbl, const void *key, int flags) {
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(tbl, key);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

// Delete entry, invoking the freeProc.
bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key) {
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(tbl, key);
    if (!hPtr)
        return false;
    Jsi_HashEntryDelete(hPtr);
    return true;
}

Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set)
{
    if (set)
        hashPtr->opts = *opts;
    else
        *opts = hashPtr->opts;
    return JSI_OK;
}

#ifndef JSI_LITE_ONLY

static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)
{
    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;
    void *key = Jsi_HashKeyGet(hPtr);
    if (opts->keyType == JSI_KEYS_ONEWORD)
        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);
    char nbuf[100];
    snprintf(nbuf, sizeof(nbuf), "%p", key);
    return Jsi_ValueNewStringDup(opts->interp, nbuf);
}

Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *tablePtr, Jsi_Value **ret, int flags) {
    char *key;
    int n = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Obj *nobj;
    Jsi_MapFmtKeyProc* fmtKeyProc = (Jsi_MapFmtKeyProc*)tablePtr->opts.fmtKeyProc;
    
    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )
        fmtKeyProc = jsi_hashFmtKey;
    
    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) 
        return Jsi_LogError("Can not dump struct hash");
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (hPtr = Jsi_HashSearchFirst(tablePtr, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        key = (char*)Jsi_HashKeyGet(hPtr);
        Jsi_Value *val;
        if (fmtKeyProc) {
            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);
            if (!val) {
                Jsi_LogError("key format failed");
                Jsi_ValueMakeUndef(interp, ret);
                return JSI_ERROR;
            }
        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)
            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);
        else
            val = Jsi_ValueNewStringKey(interp, key);
        Jsi_ObjArraySet(interp, nobj, val, n++);
    }
    return JSI_OK;
}
#endif

uint Jsi_HashSize(Jsi_Hash *hashPtr) { return hashPtr->numEntries; }
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define _JSI_OPNM(nam) .id=JSI_OPTION_##nam, .idName=#nam
// Note: these need to be in the same order as JSI_OPT_* in jsi.h 
static Jsi_OptionType jsi_OptTypeInfo[] = {
    {.id=JSI_OPTION_END,.idName="NONE", },
    {_JSI_OPNM(BOOL),    .cName="bool",     .size=sizeof(bool),       .fmt=PRIu8,  .xfmt=""  PRIu8,    .sfmt=SCNu8, .help="Boolean value: true or false" },
    {_JSI_OPNM(INT8),    .cName="int8_t",   .size=sizeof(int8_t),     .fmt=PRId8,  .xfmt="#" PRIx8,    .sfmt=SCNd8, .help="An 8-bit integer" },
    {_JSI_OPNM(INT16),   .cName="int16_t",  .size=sizeof(int16_t),    .fmt=PRId16, .xfmt="#" PRIx16,   .sfmt=SCNd16, .help="An 16-bit integer" },
    {_JSI_OPNM(INT32),   .cName="int32_t",  .size=sizeof(int32_t),    .fmt=PRId32, .xfmt="#" PRIx32,   .sfmt=SCNd32, .help="An 32-bit integer" },
    {_JSI_OPNM(INT64),   .cName="int64_t",  .size=sizeof(int64_t),    .fmt=PRId64, .xfmt="#" PRIx64,   .sfmt=SCNd64, .help="An 64-bit integer" },
    {_JSI_OPNM(UINT8),   .cName="uint8_t",  .size=sizeof(uint8_t),    .fmt=PRIu8,  .xfmt="#" PRIx8,    .sfmt=SCNu8, .help="Unsigned 8-bit integer" },
    {_JSI_OPNM(UINT16),  .cName="uint16_t", .size=sizeof(uint16_t),   .fmt=PRIu16, .xfmt="#" PRIx16,   .sfmt=SCNu16, .help="Unsigned 16-bit integer" },
    {_JSI_OPNM(UINT32),  .cName="uint32_t", .size=sizeof(uint32_t),   .fmt=PRIu32, .xfmt="#" PRIx32,   .sfmt=SCNu32, .help="Unsigned 32-bit integer" },
    {_JSI_OPNM(UINT64),  .cName="uint64_t", .size=sizeof(uint64_t),   .fmt=PRIu64, .xfmt="#" PRIx64,   .sfmt=SCNu64, .help="Unsigned 64-bit integer" },
    {_JSI_OPNM(FLOAT),   .cName="float",    .size=sizeof(float),      .fmt="g",    .xfmt="#" "g",      .sfmt="g", .help="Floating point" },
    {_JSI_OPNM(DOUBLE),  .cName="double",   .size=sizeof(double),     .fmt="lg",   .xfmt="#" "lg",     .sfmt="lg", .help="Floating point double" },
    {_JSI_OPNM(LDOUBLE),  .cName="ldouble", .size=sizeof(ldouble),    .fmt="Lg",   .xfmt="#" "Lg",     .sfmt="Lg", .help="Floating point long double" },
    {_JSI_OPNM(STRBUF),  .cName="Jsi_Strbuf",.size=0,                 .fmt="s",    .xfmt="s",    .sfmt=0 /*"s"*/, .help="A fixed size string buffer" },
    {_JSI_OPNM(TIME_W),  .cName="time_w",   .size=sizeof(time_w),     .fmt=PRId64, .xfmt="#" PRIx64,   .sfmt=SCNd64, .help="A time value in milliseconds stored as a 64 bit integer" },
    {_JSI_OPNM(TIME_D),  .cName="time_d",   .size=sizeof(time_d),     .fmt="g",    .xfmt="#" "g",      .sfmt="g", .help="A time value in milliseconds stored as a double" },
    {_JSI_OPNM(TIME_T),  .cName="time_t",   .size=sizeof(time_t),     .fmt="ld",   .xfmt="#lx",  .sfmt="ld", .help="A time value stored in a unix time_t" },
    {_JSI_OPNM(SIZE_T),  .cName="size_t",   .size=sizeof(size_t),     .fmt="zd",   .xfmt="#zx",  .sfmt="z", .help="Size unsigned" },
    {_JSI_OPNM(SSIZE_T), .cName="ssize_t",  .size=sizeof(ssize_t),    .fmt="zu",   .xfmt="#zx",  .sfmt="zu", .help="Size integer" },
    {_JSI_OPNM(INTPTR_T),.cName="intptr_t", .size=sizeof(intptr_t),   .fmt="d",    .xfmt="#x",   .sfmt="d", .help="Integer large enough to store pointer" },
    {_JSI_OPNM(UINTPTR_T),.cName="uintptr_t",.size=sizeof(uintptr_t), .fmt="u",    .xfmt="#x",   .sfmt="u", .help="Unsigned large enough to store pointer" },
    {_JSI_OPNM(NUMBER),   .cName="Jsi_Number",.size=sizeof(Jsi_Number),.fmt=JSI_NUMGFMT, .xfmt="#" JSI_NUMGFMT,   .sfmt=JSI_NUMGFMT, .help="Double or long double" },
    {_JSI_OPNM(INT),     .cName="int",      .size=sizeof(int),        .fmt="d",    .xfmt="#x",   .sfmt="d", .help="Integer" },
    {_JSI_OPNM(UINT),    .cName="uint",     .size=sizeof(uint),       .fmt="u",    .xfmt="#x",   .sfmt="u", .help="Unsigned" },
    {_JSI_OPNM(LONG),    .cName="long",     .size=sizeof(long),       .fmt="ld",   .xfmt="#lx",  .sfmt="ld", .help="Long" },
    {_JSI_OPNM(ULONG),   .cName="ulong",    .size=sizeof(ulong),      .fmt="lu",   .xfmt="#lx",  .sfmt="lu", .help="Unsigned long" },
    {_JSI_OPNM(SHORT),   .cName="short",    .size=sizeof(short),      .fmt="hd",   .xfmt="#hx",  .sfmt="hd", .help="Short" },
    {_JSI_OPNM(USHORT),  .cName="ushort",   .size=sizeof(ushort),     .fmt="hu",   .xfmt="#hx",  .sfmt="hu", .help="Unsigned short" },
    {_JSI_OPNM(STRING),  .cName="Jsi_Value*",.size=sizeof(Jsi_Value*),.fmt="s",    .xfmt="s", .sfmt=0, .help="A string Value"},
    {_JSI_OPNM(DSTRING), .cName="Jsi_DString",.size=sizeof(Jsi_DString), .fmt=0,    .xfmt=0, .sfmt=0, .help="A dynamic string"},
    {_JSI_OPNM(STRKEY),  .cName="const char*",.size=sizeof(const char *), .fmt=0,    .xfmt=0, .sfmt=0, .help="Const string"},
    {_JSI_OPNM(VALUE),   .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="A Value"},
    {_JSI_OPNM(VAR),     .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="A Var Value"},
    {_JSI_OPNM(OBJ),     .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="An Object Value"},
    {_JSI_OPNM(ARRAY),   .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="An Array Value"},
    {_JSI_OPNM(REGEXP),  .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="A Regex Value"},
    {_JSI_OPNM(FUNC),    .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="A Func Value"}, 
    {_JSI_OPNM(USEROBJ), .cName="Jsi_Value*",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help="A User-define Object Value"}, 
    {_JSI_OPNM(CUSTOM),  .cName="", .size=0, .fmt=0,    .xfmt=0, .sfmt=0, .help="A Custom value"},
    {_JSI_OPNM(END)}
};

const Jsi_OptionType* Jsi_OptionsStr2Type(const char *str, bool cName) {
    int typ;
    for (typ=JSI_OPTION_BOOL; typ < JSI_OPTION_END; typ++) {
        const char *snam = (cName?jsi_OptTypeInfo[typ].cName:jsi_OptTypeInfo[typ].idName);
        if (snam && snam[0] && !Jsi_Strcmp(str, snam))
            return jsi_OptTypeInfo+typ;
    }
    return NULL;
}

const Jsi_OptionType* Jsi_OptionTypeInfo(Jsi_OptionId typ) {
    if (typ>=JSI_OPTION_BOOL && typ < JSI_OPTION_END)
        return jsi_OptTypeInfo+typ;
    return NULL;
}

const char *jsi_OptionTypeStr(Jsi_OptionId typ, bool cName)
{
    const Jsi_OptionType* ti = Jsi_OptionTypeInfo(typ);
    if (ti)
        return (cName?ti->cName:ti->idName);
    return NULL;
}

bool Jsi_OptionsValid(Jsi_Interp *interp,  Jsi_OptionSpec* spec)
{
    int i = 0;
    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {
        if (spec[i].help && Jsi_Strchr(spec[i].help, '\n')) {
            if (interp)
                Jsi_LogError("item \"%s\": help contains newline", spec[i].name);
            return 0;
        }
        i++;
    }
    return (i>0);
}

#ifndef JSI_LITE_ONLY

static void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName);

static Jsi_RC jsi_DeleteSpecCacheTable(Jsi_Interp *interp, void *clientData)
{
  Jsi_Hash *tablePtr = (Jsi_Hash *) clientData;
  Jsi_HashEntry *entryPtr;
  Jsi_HashSearch search;

  for (entryPtr = Jsi_HashSearchFirst(tablePtr,&search); entryPtr != NULL;
      entryPtr = Jsi_HashSearchNext(&search)) {

    Jsi_Free(Jsi_HashValueGet(entryPtr));
  }
  Jsi_HashDelete(tablePtr);
  return JSI_OK;
}

static Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    Jsi_OptionSpec *cachedSpecs;
    Jsi_Hash *specCacheTablePtr;
    Jsi_HashEntry *entryPtr;
    bool isNew;

    specCacheTablePtr = (Jsi_Hash*)Jsi_InterpGetData(interp, "jsi:OptionSpec", NULL);
    if (specCacheTablePtr == NULL) {
        specCacheTablePtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);
        Jsi_InterpSetData(interp, "jsi:OptionSpec", specCacheTablePtr, jsi_DeleteSpecCacheTable);
    }
    
    entryPtr = Jsi_HashEntryNew(specCacheTablePtr, (char *) staticSpecs, &isNew);
    if (isNew) {
        unsigned int entrySpace = sizeof(Jsi_OptionSpec);
        const Jsi_OptionSpec *staticSpecPtr;

        for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id!=JSI_OPTION_END; staticSpecPtr++)
            entrySpace += sizeof(Jsi_OptionSpec);
        assert(staticSpecPtr->id==JSI_OPTION_END);

        cachedSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);
        memcpy((void *) cachedSpecs, (void *) staticSpecs, entrySpace);
        Jsi_HashValueSet(entryPtr, cachedSpecs);

    } else {
        cachedSpecs = (Jsi_OptionSpec *) Jsi_HashValueGet(entryPtr);
    }

    return cachedSpecs;
}

const Jsi_OptionSpec *
Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
#ifdef NO_CACHED_SPECS
    return (Jsi_OptionSpec*)staticSpecs;
#else
    /* If we aren't master interp, need to cache due to init and modified flags if Jsi_OptionsChanged is called. */
    if (interp->mainInterp == NULL) {
        interp->mainInterp = interp;
    }
    if (interp == interp->mainInterp) {
        return staticSpecs;
    }
    return jsi_GetCachedOptionSpecs(interp, staticSpecs);
#endif
}

/**********************************/
Jsi_OptionSpec *
Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags)
{
    Jsi_OptionSpec *specPtr;
    char c;      /* First character of current argument. */
    Jsi_OptionSpec *matchPtr; /* Matching spec, or NULL. */
    size_t length;
    const char *matStr = NULL;

    
    if (name == NULL) {
        Jsi_LogError("Null name for option");
        return NULL;
    }
    c = name[0];
    length = Jsi_Strlen(name);
    matchPtr = NULL;
    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {

        if ((specPtr->name[0] != c)
                || (Jsi_Strncmp(specPtr->name, name, length) != 0)) {
            continue;
        }
        if (specPtr->name[length] == 0) {
            return specPtr;   /* Stop on a perfect match. */
        }
        if (matchPtr != NULL) {
            Jsi_LogError("ambiguous option \"%s\" matches both \"%s\" and \"%s\"", name, matStr, specPtr->name);
            return (Jsi_OptionSpec *) NULL;
        }
        matchPtr = specPtr;
        matStr = specPtr->name;
    }

    if (matchPtr == NULL) {
        Jsi_DString dStr = {};
        Jsi_DSAppend(&dStr, "unknown option \"", name, "\" not one of: ", NULL);
    
        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {
            if (specPtr->name == NULL) {
                break;
            }
            if (name[0] != '?' || _JSICASTINT(specPtr->id) < 0 || specPtr->id >= JSI_OPTION_END) {
                Jsi_DSAppend(&dStr, specPtr->name, " ", NULL);
            } else {

                Jsi_DSAppend(&dStr, "?", specPtr->name, " <", jsi_OptTypeInfo[specPtr->id].idName, ">? ", NULL);
            }
        }
        assert(specPtr->id == JSI_OPTION_END);
        Jsi_LogError("%s", Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        return (Jsi_OptionSpec *) NULL;
    }
    return matchPtr;
}


static Jsi_RC
jsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags)
{
    char *ptr;
    Jsi_Wide wcount = 0;
    bool bn;
    Jsi_Number nv;
    char *record = (char*)rec;

    ptr = (char *)record + specPtr->offset;
    if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) 
        return Jsi_LogError("unknown option id \"%d\" for \"%s\"", specPtr->id, specPtr->name);
    if (specPtr->custom) {
        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
        if (cust && cust->parseProc) {
            if ((*cust->parseProc)(interp, specPtr, argValue, NULL, record, flags) != JSI_OK) {
                if (!interp->csc)
                    Jsi_LogError("failed parse for option \"%s\"", specPtr->name);
                return JSI_ERROR;
            }
        } else 
            return Jsi_LogError("missing or bad custom for \"%s\"", specPtr->name);
        goto done;
    }

    switch (specPtr->id) {
    case JSI_OPTION_CUSTOM:
        if (!specPtr->custom) 
            return Jsi_LogError("missing or custom for \"%s\"", specPtr->name);

    case JSI_OPTION_BOOL: {
        if (!argValue)
            *(char*)ptr = 0;
        else if (Jsi_GetBoolFromValue(interp, argValue, &bn) != JSI_OK)
            return JSI_ERROR;
        else
            *(char*)ptr = bn;
        break;
    }

    case JSI_OPTION_INT:
    case JSI_OPTION_UINT:
    case JSI_OPTION_LONG:
    case JSI_OPTION_INTPTR_T:
    case JSI_OPTION_UINTPTR_T:
    case JSI_OPTION_SIZE_T:
    case JSI_OPTION_SSIZE_T:
    case JSI_OPTION_ULONG:
    case JSI_OPTION_SHORT:
    case JSI_OPTION_USHORT:
    case JSI_OPTION_UINT64:
    case JSI_OPTION_INT64:
    case JSI_OPTION_INT8:
    case JSI_OPTION_UINT8:
    case JSI_OPTION_INT16:
    case JSI_OPTION_UINT16:
    case JSI_OPTION_INT32:
    case JSI_OPTION_UINT32:
        wcount = 0;
       if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        switch (specPtr->id) {
#define _JSI_OPTSETTYP(typ, n, ptr) if (((Jsi_Wide)(typ)n) == n) *((typ *)ptr) = (typ)n; \
            else { Jsi_LogType("not a " #typ); return JSI_ERROR; }
            case JSI_OPTION_INT:    _JSI_OPTSETTYP(int, wcount, ptr); break;
            case JSI_OPTION_UINT:   _JSI_OPTSETTYP(uint, wcount, ptr); break;
            case JSI_OPTION_INTPTR_T: _JSI_OPTSETTYP(intptr_t, wcount, ptr); break;
            case JSI_OPTION_UINTPTR_T:_JSI_OPTSETTYP(uintptr_t, wcount, ptr); break;
            case JSI_OPTION_SIZE_T:   _JSI_OPTSETTYP(size_t, wcount, ptr); break;
            case JSI_OPTION_SSIZE_T:  _JSI_OPTSETTYP(ssize_t, wcount, ptr); break;
            case JSI_OPTION_LONG:   _JSI_OPTSETTYP(long, wcount, ptr); break;
            case JSI_OPTION_ULONG:  _JSI_OPTSETTYP(ulong, wcount, ptr); break;
            case JSI_OPTION_SHORT:  _JSI_OPTSETTYP(short, wcount, ptr); break;
            case JSI_OPTION_USHORT: _JSI_OPTSETTYP(ushort, wcount, ptr); break;
            case JSI_OPTION_INT8:   _JSI_OPTSETTYP(int8_t, wcount, ptr); break;
            case JSI_OPTION_UINT8:  _JSI_OPTSETTYP(uint8_t, wcount, ptr) break;
            case JSI_OPTION_INT16:  _JSI_OPTSETTYP(int16_t, wcount, ptr); break;
            case JSI_OPTION_UINT16: _JSI_OPTSETTYP(uint16_t, wcount, ptr); break;
            case JSI_OPTION_INT32:  _JSI_OPTSETTYP(int32_t, wcount, ptr); break;
            case JSI_OPTION_UINT32: _JSI_OPTSETTYP(uint32_t, wcount, ptr); break;
            case JSI_OPTION_INT64:  _JSI_OPTSETTYP(int64_t, wcount, ptr); break;
            case JSI_OPTION_UINT64: _JSI_OPTSETTYP(uint64_t, wcount, ptr); break; // TODO: might loose top bit...
            default: break;
        }
        break;

    case JSI_OPTION_NUMBER:
        if (!argValue)
            *(Jsi_Number*)ptr = 0;
        else if (Jsi_GetDoubleFromValue(interp, argValue, (Jsi_Number *)ptr) != JSI_OK)
            return JSI_ERROR;
        break;
    case JSI_OPTION_DOUBLE:
        if (!argValue)
            *(double*)ptr = 0;
        else if (Jsi_GetDoubleFromValue(interp, argValue, &nv) != JSI_OK)
            return JSI_ERROR;
        else
            *(double *)ptr = (double)nv;
        break;
    case JSI_OPTION_FLOAT:
        if (!argValue)
            *(float*)ptr = 0;
        else if (Jsi_GetDoubleFromValue(interp, argValue, &nv) != JSI_OK)
            return JSI_ERROR;
        else
            *(float *)ptr = (float)nv;
        break;
    case JSI_OPTION_LDOUBLE:
        if (!argValue)
            *(ldouble*)ptr = 0;
        else if (Jsi_GetDoubleFromValue(interp, argValue, &nv) != JSI_OK)
            return JSI_ERROR;
        else
            *(ldouble *)ptr = (ldouble)nv;
        break;
    case JSI_OPTION_STRKEY:
    {
        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))
            *(const char**)ptr = NULL;
        else {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            *(const char**)ptr = Jsi_KeyAdd(interp,scp);
        }
    }
    break;
    case JSI_OPTION_STRBUF:
    {
        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))
            *(char*)ptr = 0;
        else {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            Jsi_Strncpy((char*)ptr, scp, specPtr->size);
            ((char*)ptr)[specPtr->size-1] = 0;
        }
    }
    break;
    
#define _JSI_OPT_CHECKNULL(argValue) if (!argValue || Jsi_ValueIsNull(interp, argValue)) { \
         if (*((Jsi_Value **)ptr)) \
            Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \
        *((Jsi_Value **)ptr) = NULL; \
        break; \
    }

#define _JSI_OPT_ARGSET(argValue, ptr) \
    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {\
        Jsi_IncrRefCount(interp, argValue); \
        if (*((Jsi_Value **)ptr)) Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \
    }\
    *((Jsi_Value **)ptr) = argValue;
    
    case JSI_OPTION_STRING:
        if (argValue == *((Jsi_Value **)ptr))
            break;
        _JSI_OPT_CHECKNULL(argValue);
        if (!Jsi_ValueIsString(interp, argValue)) 
            return Jsi_LogError("expected a string");
        _JSI_OPT_ARGSET(argValue, ptr);
        break;
        
    case JSI_OPTION_DSTRING:
        Jsi_DSInit((Jsi_DString *)ptr);
        if (argValue && !Jsi_ValueIsNull(interp, argValue))
        {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            Jsi_DSAppend((Jsi_DString *)ptr, scp, NULL);
        }
        break;
    
    case JSI_OPTION_TIME_D: {
       if (argValue)
        {
            Jsi_Number nv = 0;
            if (Jsi_ValueIsNumber(interp, argValue)) {
                Jsi_GetNumberFromValue(interp, argValue, &nv);
                *(double*)ptr = nv;
            } else {
                const char *scp;
                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                    return JSI_ERROR;
                }
                if (JSI_OK != Jsi_DatetimeParse(interp, scp, "", 0, &nv))
                    return JSI_ERROR;
                *(double*)ptr = nv;
            }
        } else {
            *(double*)ptr = 0;
        }
        break;
    }
    case JSI_OPTION_TIME_W: {
       if (argValue)
        {
            if (Jsi_ValueIsNumber(interp, argValue)) {
                Jsi_GetNumberFromValue(interp, argValue, (Jsi_Number*)ptr);
            } else {
                const char *scp;
                Jsi_Number num;
                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                    return JSI_ERROR;
                }
                if (JSI_OK != Jsi_DatetimeParse(interp, scp, "", 0, &num))
                    return JSI_ERROR;
                *(Jsi_Wide*)ptr = (Jsi_Wide)num;
            }
        } else {
            *(Jsi_Wide*)ptr = 0;
        }
        break;
    }
    case JSI_OPTION_TIME_T: {
       if (argValue)
        {
            if (Jsi_ValueIsNumber(interp, argValue)) {
                Jsi_Number num;
                Jsi_GetNumberFromValue(interp, argValue, &num);
                *(time_t*)ptr = (time_t)num;
            } else {
                const char *scp;
                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                    return JSI_ERROR;
                }
                Jsi_Number nval;
                if (JSI_OK != Jsi_DatetimeParse(interp, scp, "", 0, &nval))
                    return JSI_ERROR;
                *(time_t*)ptr = nval/1000LL;
            }
        } else {
            *(time_t*)ptr = 0;
        }
        break;
    }
    case JSI_OPTION_VAR:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_NULL && argValue->vt != JSI_VT_VARIABLE) 
            return Jsi_LogError("expected a var");
        _JSI_OPT_ARGSET(argValue, ptr);
        break;

    case JSI_OPTION_FUNC:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_FUNCTION) 
            return Jsi_LogError("expected a func value");
        if (specPtr->data && (interp->typeCheck.run|interp->typeCheck.all))
            if (!jsi_FuncArgCheck(interp, argValue->d.obj->d.fobj->func, (char*)specPtr->data)) 
                return Jsi_LogError("failed setting func pointer for %s", specPtr->name);

        _JSI_OPT_ARGSET(argValue, ptr);
        break;
        
    case JSI_OPTION_USEROBJ:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_USEROBJ) 
            return Jsi_LogError("expected a userobj value");
        if (specPtr->data && Jsi_Strcmp((char*)specPtr->data, argValue->d.obj->d.uobj->reg->name)) 
            return Jsi_LogError("expected id %s for %s",(char*)specPtr->data,  specPtr->name);
        _JSI_OPT_ARGSET(argValue, ptr);
        break;

    case JSI_OPTION_REGEXP:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_REGEXP) 
            return Jsi_LogError("expected a regexp value");
        _JSI_OPT_ARGSET(argValue, ptr);
        break;

    case JSI_OPTION_OBJ:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_OBJECT) 
            return Jsi_LogError("expected an object");

    case JSI_OPTION_VALUE:
         _JSI_OPT_CHECKNULL(argValue);
         _JSI_OPT_ARGSET(argValue, ptr);
        break;
    case JSI_OPTION_ARRAY:
        _JSI_OPT_CHECKNULL(argValue);
        if (argValue->vt != JSI_VT_OBJECT || !argValue->d.obj->isarrlist) 
            return Jsi_LogError("expected an array");
        _JSI_OPT_ARGSET(argValue, ptr);
        break;
#ifdef __cplusplus
    case JSI_OPTION_END:
#else
    default:
#endif
        Jsi_LogBug("invalid option id: %d", specPtr->id);
    }
done:
    specPtr->flags |= JSI_OPT_IS_SPECIFIED;
    return JSI_OK;
}

Jsi_RC
Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* rec, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr;
    specs = jsi_GetCachedOptionSpecs(interp, specs);
    const char *cp = NULL, *cb = NULL;
    if (option) {
        cp = Jsi_Strchr(option, '.');
        cb = Jsi_Strchr(option, '[');
    }
    if (cp && (!cb || cp<cb) ) {
        Jsi_DString dStr;
        int len = (cp-option);
        Jsi_DSInit(&dStr);
        cp = Jsi_DSAppendLen(&dStr, option, len);
        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);
        Jsi_DSFree(&dStr);
        if (!specPtr || !specPtr->data|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) 
            return Jsi_LogError("unknown or bad sub-config option: %s", option);
        cp = option+len+1;
        return Jsi_OptionsSet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);
    }
    if (cb && cb != option) {
        char *ce = Jsi_Strchr(option, ']');
        Jsi_Wide ul;
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        int len = 0;
        if (ce && ce>cb) {
            len = (ce-cb-1);
            cp = Jsi_DSAppendLen(&dStr, cb+1, len);
        }
        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) 
            return Jsi_LogError("bad sub-array option: %s", option);
        len = (cb-option);
        Jsi_DSSetLength(&dStr, 0);
        cp = Jsi_DSAppendLen(&dStr, option, len);
        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);
        Jsi_DSFree(&dStr);
        if (!specPtr || !specPtr->data|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {
bail:
            return Jsi_LogError("unknown or bad array option: %s", option);
        }
        cp = cb+1;
        Jsi_OptionSpec *subSpec = specPtr->iniVal.ini_OPT_CARRAY;
        int isize, size = specPtr->value;
        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)
            goto bail;
        isize = isize/size;
        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);
        if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)
            return JSI_ERROR;
        return JSI_OK;
    }
    specPtr = Jsi_OptionsFind(interp, specs, option, flags);
    if (!specPtr)
        return JSI_ERROR;
    return jsi_SetOption(interp, specPtr, option, record, valuePtr, flags);
}

static int
jsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags)
{
    char *ptr;
    
    if (specPtr == NULL) 
        return Jsi_LogError("no such option: %s", option);
    //isNull = ((*string == '\0') && (specPtr->flags & JSI_OPTION_NULL_OK));
    
    ptr = (char *)record + specPtr->offset;
    if (_JSICASTINT(specPtr->id)<0 || specPtr->id>=JSI_OPTION_END) 
        return Jsi_LogError("no such option: %s", option);
    if (specPtr->custom) {
        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
        if (cust->formatProc)
            return (*cust->formatProc) (interp, specPtr, valuePtr, NULL, record, flags);
    }

    switch (specPtr->id) {
    case JSI_OPTION_BOOL:
        Jsi_ValueMakeBool(interp, valuePtr,*(bool*)ptr );
        break;
    case JSI_OPTION_INT:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int *)ptr));
        break;
    case JSI_OPTION_UINT:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint *)ptr));
        break;
    case JSI_OPTION_INT8:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int8_t *)ptr));
        break;
    case JSI_OPTION_INT16:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int16_t *)ptr));
        break;
    case JSI_OPTION_INT32:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int32_t *)ptr));
        break;
    case JSI_OPTION_INT64:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_Wide *)ptr));
        break;
    case JSI_OPTION_UINT8:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint8_t *)ptr));
        break;
    case JSI_OPTION_UINT16:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint16_t *)ptr));
        break;
    case JSI_OPTION_UINT32:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint32_t *)ptr));
        break;
    case JSI_OPTION_UINT64:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint64_t *)ptr));
        break;
    case JSI_OPTION_FLOAT:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(float *)ptr);
        break;
    case JSI_OPTION_DOUBLE:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(double *)ptr);
        break;
    case JSI_OPTION_LDOUBLE:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(ldouble *)ptr);
        break;
    case JSI_OPTION_NUMBER:
        Jsi_ValueMakeNumber(interp, valuePtr, *(Jsi_Number *)ptr);
        break;
    case JSI_OPTION_SIZE_T:
        Jsi_ValueMakeNumber(interp, valuePtr, *(size_t *)ptr);
        break;
    case JSI_OPTION_SSIZE_T:
        Jsi_ValueMakeNumber(interp, valuePtr, *(ssize_t *)ptr);
        break;
    case JSI_OPTION_INTPTR_T:
        Jsi_ValueMakeNumber(interp, valuePtr, *(intptr_t *)ptr);
        break;
    case JSI_OPTION_UINTPTR_T:
        Jsi_ValueMakeNumber(interp, valuePtr, *(uintptr_t *)ptr);
        break;
    case JSI_OPTION_LONG:
        Jsi_ValueMakeNumber(interp, valuePtr, *(long *)ptr);
        break;
    case JSI_OPTION_ULONG:
        Jsi_ValueMakeNumber(interp, valuePtr, *(ulong *)ptr);
        break;
    case JSI_OPTION_SHORT:
        Jsi_ValueMakeNumber(interp, valuePtr, *(short *)ptr);
        break;
    case JSI_OPTION_USHORT:
        Jsi_ValueMakeNumber(interp, valuePtr, *(ushort *)ptr);
        break;
        
    case JSI_OPTION_DSTRING:
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue((Jsi_DString*)ptr));
        break;
    
    case JSI_OPTION_TIME_W: {
        Jsi_DString dStr = {};
        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(Jsi_Wide*)ptr), "", 0, &dStr);
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        break;
    }
    case JSI_OPTION_TIME_D: {
        Jsi_DString dStr = {};
        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(double*)ptr), "", 0, &dStr);
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        break;
    }
    case JSI_OPTION_TIME_T: {
        Jsi_DString dStr = {};
        Jsi_DatetimeFormat(interp, 1000LL* (Jsi_Number)*(time_t*)ptr, "%Y-%m-%d %H:%M:%S", 0, &dStr);
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        break;
    }
    case JSI_OPTION_STRBUF:
        if (ptr)
            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_STRKEY:
        ptr = *(char **)ptr;
        if (ptr)
            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_STRING:
    case JSI_OPTION_VAR:
    case JSI_OPTION_FUNC:
    case JSI_OPTION_USEROBJ:
    case JSI_OPTION_OBJ:
    case JSI_OPTION_VALUE:
    case JSI_OPTION_REGEXP:
    case JSI_OPTION_ARRAY:
        if (*(Jsi_Value **)ptr)
            Jsi_ValueCopy(interp, *valuePtr, *(Jsi_Value **)ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_CUSTOM:
        break;

#ifdef __cplusplus
    case JSI_OPTION_END:
#else
    default:
#endif
        Jsi_LogBug("invalid option id %d", specPtr->id);
        return JSI_ERROR;
    }

    return JSI_OK;
}

Jsi_Value *
Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *name, void *rec, int offset)
{
    char *record = (char*)rec;
    Jsi_Value *valuePtr;
    valuePtr = *(Jsi_Value **)(record + offset);
    return valuePtr;
}


Jsi_RC
Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr;
    const char *cp = NULL, *cb = NULL;
    if (option) {
        cp = Jsi_Strchr(option, '.');
        cb = Jsi_Strchr(option, '[');
    }
    if (cp && (!cb || cp<cb) ) {
        Jsi_DString dStr;
        int len = (cp-option);
        Jsi_DSInit(&dStr);
        cp = Jsi_DSAppendLen(&dStr, option, len);
        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);
        Jsi_DSFree(&dStr);
        if (!specPtr || !specPtr->data || specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) 
            return Jsi_LogError("unknown or bad sub-config option: %s", option);
        cp = option+len+1;
        return Jsi_OptionsGet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);
    }
    if (cb && cb != option) {
        char *ce = Jsi_Strchr(option, ']');
        Jsi_Wide ul;
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        int len = 0;
        if (ce && ce>cb) {
            len = (ce-cb-1);
            cp = Jsi_DSAppendLen(&dStr, cb+1, len);
        }
        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) 
            return Jsi_LogError("bad sub-array option: %s", option);
        len = (cb-option);
        Jsi_DSSetLength(&dStr, 0);
        cp = Jsi_DSAppendLen(&dStr, option, len);
        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);
        Jsi_DSFree(&dStr);
        if (!specPtr || !specPtr->data|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {
bail:
            return Jsi_LogError("unknown or bad array option: %s", option);
        }
        cp = cb+1;
        Jsi_OptionSpec *subSpec = specPtr->iniVal.ini_OPT_CARRAY;
        int isize, size = specPtr->value;
        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)
            goto bail;
        isize = isize/size;
        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);
        if (jsi_GetOption(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)
            return JSI_ERROR;
        return JSI_OK;
    }

    specPtr = Jsi_OptionsFind(interp, specs, option, flags);
    if (specPtr == NULL || jsi_GetOption(interp, specPtr, record, option, valuePtr, flags) != JSI_OK) {
        return JSI_ERROR;
    }

    return JSI_OK;

}

Jsi_RC
Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Value **ret, Jsi_Wide flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr = specs;
    int len = 0, i = 0, count = 0;
    if (!Jsi_OptionsValid(interp, specs))
        return Jsi_LogError("invalid options");
    
    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {
        specPtr++;
        len+=2;
    }
    if (!len)
        return JSI_OK;
    Jsi_Value *rv = Jsi_ValueMakeObject(interp, NULL, NULL);
    Jsi_IncrRefCount(interp, rv);
    Jsi_Obj *obj = rv->d.obj;
    specPtr = specs;
    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {
        Jsi_Value  *vv = Jsi_ValueNew1(interp);
        if (jsi_GetOption(interp, specPtr, record, NULL, &vv, flags) != JSI_OK) {
            Jsi_DecrRefCount(interp, vv);
            Jsi_DecrRefCount(interp, rv);
            return JSI_ERROR;
        }
        if (flags&JSI_OPTS_VERBOSE) {
            // dump: id,value,help,info,init
            Jsi_Value *vrv = Jsi_ValueMakeObject(interp, NULL, NULL);
            Jsi_IncrRefCount(interp, vrv);
            Jsi_Obj *vobj = vrv->d.obj;
            Jsi_ObjInsert(interp, vobj, "value", vv, 0);
            Jsi_DecrRefCount(interp, vv);
            vv = vrv;
            jsi_DumpOptionSpec(interp, vobj, specPtr, 0);
        }
        Jsi_ObjInsert(interp, obj, specPtr->name, vv, 0);
        Jsi_DecrRefCount(interp, vv);
        count++;
        i++;
        specPtr++;
    }
    assert(specPtr->id == JSI_OPTION_END);
    Jsi_ValueReplace(interp, ret, rv);
    Jsi_DecrRefCount(interp, rv);
    return JSI_OK;
}

int
Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *args, Jsi_Wide flags)
{
    Jsi_OptionSpec *specPtr;
    int count = 0;
    char *record = (char*)rec;
    Jsi_TreeEntry *tPtr;
    Jsi_TreeSearch search;
    Jsi_Obj *to;
    if (!Jsi_OptionsValid(interp, specs))
        return -1;

    if (interp->compat && !(flags&JSI_OPTS_FORCE_STRICT))
        flags |=  JSI_OPTS_IGNORE_EXTRA;
    specs = jsi_GetCachedOptionSpecs(interp, specs);
    
    if (args == NULL || args->vt == JSI_VT_NULL) {
        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {
            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;
            if (jsi_SetOption(interp, specPtr, (char*)specPtr->name, record, NULL, flags) != JSI_OK)
                return -1;
        }
        assert(specPtr->id == JSI_OPTION_END);
        return 0;
    }
    if (args->vt != JSI_VT_OBJECT || args->d.obj->ot != JSI_OT_OBJECT || args->d.obj->arr) {
        Jsi_LogError("expected object");
        return -1;
    }
    to = args->d.obj;
    int reqCnt = 0;
    if ((JSI_OPTS_IS_UPDATE&flags)==0) {
        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {
            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;
            if (specPtr->flags &  JSI_OPT_REQUIRED)
                reqCnt++;
        }
        assert(specPtr->id == JSI_OPTION_END);
    }
        
    for (tPtr = Jsi_TreeSearchFirst(to->tree, &search, 0, NULL);
        tPtr != NULL; tPtr = Jsi_TreeSearchNext(&search)) {
        
        const char *arg;
        Jsi_Value *optval;
        count++;
        arg =(char*) Jsi_TreeKeyGet(tPtr);
        optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);

        specPtr = Jsi_OptionsFind(interp, specs, arg, flags);
        if (specPtr == NULL) {
            if (flags&JSI_OPTS_IGNORE_EXTRA)
                continue;
            count = -1;
            goto done;
        }

        if ((JSI_OPT_READ_ONLY&specPtr->flags)) {
            Jsi_LogWarn("Error option is readonly: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }
        if ((JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_INIT_ONLY&specPtr->flags)) {
            Jsi_LogWarn("Error can not update option: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }

        if (jsi_SetOption(interp, specPtr, (char*)arg, record, optval, flags) != JSI_OK) {
            Jsi_LogWarn("Error processing option: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }
 
        specPtr->flags |= JSI_OPT_IS_SPECIFIED;
    }
    if (reqCnt) {
        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {
            if (specPtr->flags &  JSI_OPT_REQUIRED &&
                !(specPtr->flags&JSI_OPT_IS_SPECIFIED)) {

                Jsi_LogWarn("Error required field not specified: \"%.40s\"", specPtr->name);
                count = -1;
            }
        }
    }

done:
    Jsi_TreeSearchDone(&search);
    return count;

}

Jsi_RC
Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *val, Jsi_Value **ret, Jsi_Wide flags)
{
    flags |= JSI_OPTS_IS_UPDATE;
    if (!Jsi_OptionsValid(interp, specs))
        return Jsi_LogError("invalid options");
    
    if (!val)
        return Jsi_OptionsDump(interp, specs, rec, ret, flags);
    if (val->vt == JSI_VT_NULL)
        return Jsi_OptionsDump(interp, specs, rec, ret, flags|JSI_OPTS_VERBOSE);
    if (Jsi_ValueIsString(interp, val)) {
        const char *cp = Jsi_ValueString(interp, val, NULL);
        if (cp && *cp)
            return Jsi_OptionsGet(interp, specs, rec, cp, ret, flags);
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, specs);
        Jsi_ValueReplace(interp, ret, svalue);
        return JSI_OK;
    }
    if (val->vt != JSI_VT_OBJECT) 
        return Jsi_LogError("expected string, object, or null");
    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE) < 0)
        return JSI_ERROR;
    return JSI_OK;
}

static const char **jsi_OptGetEnumList(Jsi_OptionSpec* spec) {
    const char **list = (const char**)spec->data;
    Jsi_OptionSpec* es=NULL;
    int fflags = (spec->flags);
    if (spec->id != JSI_OPTION_CUSTOM || spec->custom != Jsi_Opt_SwitchEnum)
        return list;
    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {
        es = (typeof(es))list;
        while (es->id != JSI_OPTION_END)
            es++;
        list = es->iniVal.ini_STRKEY;
    }
    return list;
}

static void jsi_DumpCustomSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)
{
    Jsi_OptionCustom* cspec = Jsi_OptionCustomBuiltin(spec->custom);
    void *data = spec->data;
    if (cspec->help) {
        if (Jsi_Strchr(cspec->help, '\n'))
            Jsi_LogError("%s .help contains newline: %s", cspec->name, cspec->help);
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, cspec->help),0);
    }
    if (cspec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, cspec->info),0);
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, cspec->name),0);

    if (data && (spec->custom == Jsi_Opt_SwitchEnum || spec->custom == Jsi_Opt_SwitchBitset)) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        const char **lst = jsi_OptGetEnumList(spec);
        int i = 0;
        while (lst[i]) {
            Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringKey(interp, lst[i]));
            i++;
        }
        Jsi_ObjInsert(interp, nobj, (spec->custom == Jsi_Opt_SwitchBitset?"bitSet":"enumList"), svalue, 0);
    } else if (spec->custom == Jsi_Opt_SwitchSuboption) {
        Jsi_OptionSpec* subSpec = (Jsi_OptionSpec*)data;
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, subSpec);
        Jsi_ObjInsert(interp, nobj, "subSpec", svalue, 0);
    }
}

static void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName)
{
    if (addName)
        Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, spec->name),0);
    if (spec->help) {
        if (Jsi_Strchr(spec->help, '\n'))
            Jsi_LogError("%s .help contains newline: %s", spec->name, spec->help);
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, spec->help),0);
    }
    if (spec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, spec->info),0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,0)),0);
    Jsi_ObjInsert(interp, nobj, "cName", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,1)),0);
    Jsi_ObjInsert(interp, nobj, "initOnly", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_INIT_ONLY)!=0), 0);
    Jsi_ObjInsert(interp, nobj, "readOnly", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_READ_ONLY)!=0), 0);
    Jsi_ObjInsert(interp, nobj, "noCase", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_CUST_NOCASE)!=0), 0);
    Jsi_ObjInsert(interp, nobj, "size", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->size), 0);
    if (spec->flags)
        Jsi_ObjInsert(interp, nobj, "flags", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->flags), 0);
    if (spec->data) {
        if (spec->id == JSI_OPTION_FUNC && spec->data) 
            Jsi_ObjInsert(interp, nobj, "args", Jsi_ValueNewStringDup(interp, (char*)spec->data), 0);
        else if (spec->id == JSI_OPTION_CUSTOM && (spec->custom == Jsi_Opt_SwitchBitset ||
            spec->custom == Jsi_Opt_SwitchEnum)) {
            const char **list = jsi_OptGetEnumList(spec);
            if (list)
                Jsi_ObjInsert(interp, nobj, "data", Jsi_ValueNewArray(interp, list, -1), 0);
        } else
            Jsi_ObjInsert(interp, nobj, "data", Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)spec->data), 0);
    }
    if (spec->id == JSI_OPTION_CUSTOM && spec->custom) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_Value *cvalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpCustomSpec(interp, sobj,  spec);
        Jsi_ObjInsert(interp, nobj, "customArg", cvalue,0);
    }
}

void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)
{
    int i = 0;
    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpec(interp, sobj, spec+i, 1);
        Jsi_ObjArrayAdd(interp, nobj, svalue);
        i++;
    }
}

static Jsi_RC jsi_ValueToVerify(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    if (inStr)
        return JSI_ERROR;
    Jsi_Value **s = (Jsi_Value**)((char*)record) + spec->offset;
    Jsi_ValueHandlerProc *vfunc = (Jsi_ValueHandlerProc*)spec->data;
    if (!vfunc) 
        return Jsi_LogError("custom value spec did not set data: %s", spec->name);
    if (!inValue) {
        if (*s)
            Jsi_DecrRefCount(interp, *s);
        *s = NULL;
        return JSI_OK;
    }
    if (vfunc(interp, inValue, spec, record) != JSI_OK)
        return JSI_ERROR;
    *s = inValue;
    if (*s)
        Jsi_IncrRefCount(interp, *s);
    return JSI_OK;
}

static Jsi_RC jsi_VerifyToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)
{
    if (dStr)
        return JSI_ERROR;
    Jsi_Value **s = (Jsi_Value**)(((char*)record) + spec->offset);
    if (*s)
        Jsi_ValueReplace(interp, outValue, *s);
    return JSI_OK;
}

static void jsi_VerifyFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)
{
    Jsi_Value **v = (Jsi_Value**)ptr;
    if (v)
        Jsi_DecrRefCount(interp, *v);
}

static Jsi_OptionCustom jsi_OptSwitchValueVerify = {
    .name="verify", .parseProc=jsi_ValueToVerify, .formatProc=jsi_VerifyToValue, .freeProc=jsi_VerifyFree, .help="Verify that a value id is correct"
};


static Jsi_RC ValueToCArray(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    if (inStr)
        return JSI_ERROR;
    uchar *s = (uchar*)((char*)record) + spec->offset;
    Jsi_OptionSpec *subSpec = spec->iniVal.ini_OPT_CARRAY;
    int argc, i, isize, size = spec->value;
    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)
        goto bail;
    isize = isize/size;
    if (!Jsi_ValueIsArray(interp, inValue)) 
        return Jsi_LogError("expected array");
    argc = Jsi_ValueGetLength(interp, inValue);
    if (argc != size) 
        return Jsi_LogError("array length %d was not %d", argc, size);
    for (i = 0; i<size; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);
        if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, v, 0) != JSI_OK)
            return JSI_ERROR;
        s += isize;
    }
    return JSI_OK;
bail:
    return Jsi_LogError("bad config");
}

static Jsi_RC jsi_CArrayToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)
{
    Jsi_Obj *obj = NULL;
    if (dStr)
        return JSI_ERROR;
    uchar *s = (uchar*)((char*)record) + spec->offset;
    Jsi_OptionSpec *subSpec = spec->iniVal.ini_OPT_CARRAY;
    int i, cnt, isize, size = spec->value;
    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)
        goto bail;
    isize = isize/size;
#ifndef JSI_LITE_ONLY //TODO: already in lite #ifdef
    obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    cnt = 0;
    for (i=0; i<size; i++) {
        Jsi_Value *v = Jsi_ValueNew1(interp);
        cnt++;
        Jsi_RC rc = Jsi_OptionsGet(interp, subSpec, s, spec->name, &v, 0);
        Jsi_ObjArrayAdd(interp, obj, v);
        Jsi_DecrRefCount(interp, v);
        if (JSI_OK != rc)
            goto bail;
        s += isize;
    }
    Jsi_ValueMakeArrayObject(interp, outValue, obj);
#endif
    return JSI_OK;
bail:
    if (obj)
        Jsi_ObjFree(interp, obj);
    Jsi_LogError("bad config");
    return JSI_ERROR;
}

static void jsi_CArrayFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)
{
    /*Jsi_OptionSpec *subSpec = spec->iniVal.ini_OPT_CARRAY; // TODO: ???
    if (!subSpec) {
        Jsi_Value **v = (Jsi_Value**)ptr;
        if (v)
            Jsi_DecrRefCount(interp, *v);
    }
    int i, isize, size = spec->asize;
    if ((isize=subSpec->size)<=0)
        return;
    isize = isize/size;
    uchar *s = (uchar*)ptr;
    for (i=0; i<size; i++) {
        Jsi_OptionsFree(interp, subSpec, s, 0);
        s += isize;
    }*/
}

static Jsi_OptionCustom jsi_OptSwitchCArray = {
    .name="array", .parseProc=ValueToCArray, .formatProc=jsi_CArrayToValue, .freeProc=jsi_CArrayFree, .help="Array of OPT types"
};
#else

static Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    return (Jsi_OptionSpec *)staticSpecs;
}

#endif


/*
 *----------------------------------------------------------------------
 * Given the configuration specifications and one or more option
 * patterns (terminated by a NULL), indicate if any of the matching
 * configuration options has been reset.
 *
 * Results:
 *      Returns count of each options that has changed, 0 otherwise.
 *
 *----------------------------------------------------------------------
 */
int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *spec, const char *pattern, ...)
{
    va_list argList;
    Jsi_OptionSpec *specPtr;
    const char *option = pattern;
    int cnt = 0;
    
    va_start(argList, pattern);
    spec = jsi_GetCachedOptionSpecs(interp, spec);
    do  {
        for (specPtr = spec; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {
            if ((Jsi_GlobMatch(option, specPtr->name, 0)) &&
                    (specPtr->flags & JSI_OPT_IS_SPECIFIED)) {
                cnt++;
            }
        }
        assert(specPtr->id == JSI_OPTION_END);

    } while ((option = va_arg(argList, char *)) != NULL);
    va_end(argList);
    return cnt;
}

Jsi_OptionSpec *
Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    unsigned int entrySpace = sizeof(Jsi_OptionSpec);
    const Jsi_OptionSpec *staticSpecPtr;
    Jsi_OptionSpec *newSpecs;

    for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id<JSI_OPTION_END && staticSpecPtr->name;
            staticSpecPtr++) {
        entrySpace += sizeof(Jsi_OptionSpec);
    }

    newSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);
    memcpy((void *) newSpecs, (void *) staticSpecs, entrySpace);
    return newSpecs;
}

/* Free data items and reset values back to 0. */
void
Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Wide flags /*unused*/)
{
    Jsi_OptionSpec *specPtr;
    char *record = (char*)rec;
    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {
        char *ptr = record + specPtr->offset;
        if (specPtr->flags&JSI_OPT_NO_CLEAR)
            continue;
        if ((*(char **)ptr != NULL) && specPtr->custom) {
            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
            if (cust->freeProc != NULL) {
                (*cust->freeProc)(interp, specPtr, (char **)ptr);
                continue;
            }
        }

        switch (specPtr->id) {
#ifndef JSI_LITE_ONLY
        case JSI_OPTION_VALUE:
        case JSI_OPTION_STRING:
        case JSI_OPTION_OBJ:
        case JSI_OPTION_REGEXP:
        case JSI_OPTION_ARRAY:
        case JSI_OPTION_FUNC:
        case JSI_OPTION_USEROBJ:
        case JSI_OPTION_VAR:
        {
            Jsi_Value **vpp = (Jsi_Value**)ptr, *vPtr = *vpp;
            if (vPtr && (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)))
                Jsi_DecrRefCount(interp, vPtr);
            *vpp = 0;
            break;
        }
#endif
        case JSI_OPTION_STRKEY:
            *(char**)ptr = 0;
            break;
        case JSI_OPTION_STRBUF:
            *(char*)ptr = 0;
            break;
        case JSI_OPTION_DSTRING:
            Jsi_DSFree((Jsi_DString *)ptr);
            break;
        case JSI_OPTION_TIME_T:
            *(time_t*)ptr = 0;
            break;
        case JSI_OPTION_NUMBER:
            *(Jsi_Number*)ptr = 0;
            break;
        case JSI_OPTION_FLOAT:
            *(float*)ptr = 0;
            break;
        case JSI_OPTION_LDOUBLE:
            *(ldouble*)ptr = 0;
            break;
        case JSI_OPTION_DOUBLE:
        case JSI_OPTION_TIME_D:
            *(double*)ptr = 0;
            break;
        case JSI_OPTION_TIME_W:
            *(Jsi_Wide*)ptr = 0;
            break;
        case JSI_OPTION_INT8:  *(int8_t*)ptr = 0; break;
        case JSI_OPTION_INT16: *(int16_t*)ptr = 0; break;
        case JSI_OPTION_INT32: *(int32_t*)ptr = 0; break;
        case JSI_OPTION_INT64: *(int64_t*)ptr = 0; break;
        case JSI_OPTION_UINT8: *(uint8_t*)ptr = 0; break;
        case JSI_OPTION_UINT16:*(uint16_t*)ptr = 0; break;
        case JSI_OPTION_UINT32:*(uint32_t*)ptr = 0; break;
        case JSI_OPTION_UINT64:*(uint64_t*)ptr = 0; break;
        case JSI_OPTION_INT: *(int*)ptr = 0; break;
        case JSI_OPTION_UINT: *(uint*)ptr = 0; break;
        case JSI_OPTION_BOOL: *(bool*)ptr = 0; break;
        case JSI_OPTION_CUSTOM:
            break;
        default:
            if (specPtr->size>0)
                memset(ptr, 0, specPtr->size);
            break;
        }
    }
}

static Jsi_RC jsi_ValueToEnum(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    int n = 0;
    char *s = (char*)(((char*)record) + spec->offset);
    const char **list = (const char **)spec->data;
    Jsi_OptionSpec* es=NULL;
    int fflags = (flags|spec->flags);
    int cflags = (fflags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (fflags&JSI_OPT_ENUM_EXACT)
        cflags |= JSI_CMP_EXACT;
    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {
        es = (typeof(es))list;
        while (es->id != JSI_OPTION_END) es++;
        list = es->iniVal.ini_STRKEY;
        es = (typeof(es))spec->data;
    }
    if (!list) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);
    if (inStr) {
        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "enum", cflags, &n))
            return JSI_ERROR;
    } else
#ifndef JSI_LITE_ONLY
    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, "enum", cflags, &n))
        return JSI_ERROR;

#endif
    if (fflags&JSI_OPT_ENUM_UNSIGNED) {
        uint64_t u = (uint64_t)n;
        if (es)
            u = es[n].value;
        switch (spec->size) {
            case 1: *(uint8_t*)s = (uint8_t)u; break;
            case 2: *(uint16_t*)s = (uint16_t)u; break;
            case 4: *(uint32_t*)s = (uint32_t)u; break;
            case 8: *(uint64_t*)s = (uint64_t)u; break;
            default:
                return Jsi_LogError("bitset size must be 1, 2, 4, or 8: %s", spec->name);
        }
    } else {
        int64_t m = n;
        if (es)
            m = es[n].value;
        switch (spec->size) {
            case 1: *(int8_t*)s = (int8_t)m; break;
            case 2: *(int16_t*)s = (int16_t)m; break;
            case 4: *(int32_t*)s = (int32_t)m; break;
            case 8: *(int64_t*)s = (int64_t)m; break;
            default: 
                return Jsi_LogError("bitset size must be 1, 2, 4, or 8: %s", spec->name);
        }
    }
    
    return JSI_OK;
}

static Jsi_RC jsi_EnumToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    uint i = 0, j, esiz = 0;
    int64_t n;
    char *s = (char*)(((char*)record) + spec->offset);
    const char **list = (const char**)spec->data;
    Jsi_OptionSpec* es=NULL, *esp = NULL;
    int fflags = (flags|spec->flags);
    int uflag = (fflags&JSI_OPT_ENUM_UNSIGNED);
    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {
        esp = es = (typeof(es))list;
        while (es->id != JSI_OPTION_END) es++;
        list = es->iniVal.ini_STRKEY;
        esiz = es->size;
        es = (typeof(es))spec->data;
    }
    if (!list) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);
    if (outStr) {
        if (uflag) {
            switch (spec->size) {
                case 1: n = *(uint8_t*)s; break;
                case 2: n = *(uint16_t*)s; break;
                case 4: n = *(uint32_t*)s; break;
                case 8: n = *(uint64_t*)s; break;
                default: 
                    return Jsi_LogError("bitset size must be 1, 2, 4, or 8: %s", spec->name);
            }
        } else {
            switch (spec->size) {
                case 1: n = *(int8_t*)s; break;
                case 2: n = *(int16_t*)s; break;
                case 4: n = *(int32_t*)s; break;
                case 8: n = *(int64_t*)s; break;
                default: 
                    return Jsi_LogError("bitset size must be 1, 2, 4, or 8: %s", spec->name);
            }
        }
        if (spec->flags&JSI_OPT_FMT_NUMBER) {
            Jsi_DSPrintf(outStr, "%" PRIu64, (uint64_t)n);
            return JSI_OK;
        }
        
        if (es) {
            for (j=0; j<esiz && list[j]; j++) {
                if (n == esp[j].value) {
                    i = j;
                    break;
                }
                if (j>=esiz)
                    i = esiz;
            }
        } else
            for (i=0; i<n && list[i]; i++) ; /* Look forward til n */
        if (list[i])
            Jsi_DSAppendLen(outStr, list[i], -1);
        else if ((spec->flags&JSI_OPT_COERCE)) {
            Jsi_DSPrintf(outStr, "%" PRIu64, (uint64_t)n);
            return JSI_OK;
        } else
            return Jsi_LogWarn("enum has unknown value: %d", *s);
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_RC rc = jsi_EnumToValue(interp, spec, NULL, &dStr, record, flags);
    if (rc == JSI_OK)
        Jsi_ValueMakeStringKey(interp, outValue, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return rc;
#endif
    return JSI_ERROR;
}

static Jsi_OptionCustom jsi_OptSwitchEnum = {
    .name="enum", .parseProc=jsi_ValueToEnum, .formatProc=jsi_EnumToValue, .freeProc=0, .help="one value from list"
};


static Jsi_RC jsi_ValueToBitset(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    // TODO: change this to not use byte instead of int...
    int i, argc, n;
    char *s =(((char*)record) + spec->offset);
    char **argv;
    const char *cp, **list = (const char**)spec->data;
    uint64_t m = 0, im = 0;
    int fflags = ((flags|spec->flags)&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (!list) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);
    switch (spec->size) {
        case 1: im = *(uint8_t*)s; break;
        case 2: im = *(uint16_t*)s; break;
        case 4: im = *(uint32_t*)s; break;
        case 8: im = *(uint64_t*)s; break;
        default: 
            return Jsi_LogError("bitset size must be 1, 2, 4, or 8: %s", spec->name);
    }

#ifndef JSI_LITE_ONLY
    if (!inStr && Jsi_ValueIsString(interp, inValue))
        inStr = Jsi_ValueString(interp, inValue, NULL);
#endif
    if (inStr) {
        if (*inStr == '+') {
            inStr++;
            m = im;
        }
        if (*inStr) {
            Jsi_DString sStr;
            Jsi_DSInit(&sStr);
            Jsi_SplitStr(inStr, &argc, &argv, ",", &sStr);
            
            for (i=0; i<argc; i++) {
                int isnot = 0;
                cp = argv[i];
                if (*cp == '!') { isnot = 1; cp++; }
                if (JSI_OK != Jsi_GetIndex(interp, cp, list, "enum", fflags, &n))
                    return JSI_ERROR;
                if (n >= (int)(spec->size*8)) 
                    return Jsi_LogError("list larger than field size: %s", spec->name);
                if (isnot)
                    m &= ~(1<<n);
                else
                    m |= (1<<n);
            }
            Jsi_DSFree(&sStr);
        }
    } else {
#ifndef JSI_LITE_ONLY
        if (!inValue) {
            *s = 0;
            return JSI_OK;
        }
        if (!Jsi_ValueIsArray(interp, inValue)) 
        return Jsi_LogError("expected array");
        argc = Jsi_ValueGetLength(interp, inValue);
        for (i=0; i<argc; i++) {
            int isnot = 0;
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);
            const char *cp = (v?Jsi_ValueString(interp, v, NULL):"");
            if (!cp) 
                return Jsi_LogError("expected string");
            if (i == 0) {
                if (*cp == '+' && !cp[1]) {
                    m = im;
                    continue;
                }
            }
            if (*cp == '!') { isnot = 1; cp++; }
            if (JSI_OK != Jsi_GetIndex(interp, cp, list, "bitset", fflags, &n))
                return JSI_ERROR;
            if (isnot)
                m &= ~(1<<n);
            else
                m |= (1<<n);
        }
        *s = m;
#endif
    }
    switch (spec->size) {
        case 1: *(uint8_t*)s = (uint8_t)m; break;
        case 2: *(uint16_t*)s = (uint16_t)m; break;
        case 4: *(uint32_t*)s = (uint32_t)m; break;
        case 8: *(uint64_t*)s = (uint64_t)m; break;
    }
    return JSI_OK;
}

static Jsi_RC jsi_BitsetToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    int i, n, cnt = 0, *s = (int*)(((char*)record) + spec->offset);
    const char **list = (const char**)spec->data;
    if (!list) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);
    if (outStr) {
        n = *s;
        for (i=0; list[i]; i++) {
            if (i >= (int)(spec->size*8)) 
                return Jsi_LogError("list larger than field size: %s", spec->name);
            if (!(n & (1<<i)))
                continue;
            if (cnt++)
                Jsi_DSAppendLen(outStr, ", ", 1);
            Jsi_DSAppendLen(outStr, list[i], -1);
        }
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    n = *s;
    for (i=0; list[i]; i++) {
        Jsi_Value *v;
        if (!(n&(1<<i))) continue;
        cnt++;
        v = Jsi_ValueMakeStringKey(interp, NULL, list[i]);
        Jsi_ObjArrayAdd(interp, obj, v);
    }
    Jsi_ValueMakeArrayObject(interp, outValue, obj);
#endif
    return JSI_OK;
}

static Jsi_OptionCustom jsi_OptSwitchBitset = {
    .name="bitset", .parseProc=jsi_ValueToBitset, .formatProc=jsi_BitsetToValue, .freeProc=0, .help="An int field accessed a bit at a time"
};

#ifndef JSI_LITE_ONLY
/* Scanning function */
static Jsi_RC jsi_ValueToSubopt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    if (inStr)
        return JSI_ERROR;
    char *s = ((char*)record) + spec->offset;
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
  
    if (spec == subspec) 
        return Jsi_LogError("subspec was recursive");
    if (!subspec) 
        return Jsi_LogError("custom suboption spec did not set data: %s", spec->name);
    if (inValue && Jsi_ValueIsNull(interp, inValue) == 0 &&
        (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT)==0 || inValue->d.obj->isarrlist)) 
        return Jsi_LogError("expected object");
    return (Jsi_OptionsProcess(interp, subspec, s, inValue, flags)<0 ? JSI_ERROR : JSI_OK);
}

/* Printing function. */
static Jsi_RC jsi_SuboptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    if (outStr)
        return JSI_ERROR;
    char *s = ((char*)record) + spec->offset;
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
    if (spec == subspec) 
        return Jsi_LogError("recursive subspec not allowed");
    if (!subspec) 
        return Jsi_LogError("custom suboption spec did not set data: %s", spec->name);
    return Jsi_OptionsDump(interp, subspec, s, outValue, flags);
}

static void jsi_SuboptFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)
{
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
    Jsi_OptionsFree(interp, subspec, ptr, 0);
}

static Jsi_OptionCustom jsi_OptSwitchSuboption = {
    .name="suboption", .parseProc=jsi_ValueToSubopt, .formatProc=jsi_SuboptToValue, .freeProc=jsi_SuboptFree,
};

/* Scanning function */
static Jsi_RC jsi_ValueToBitfield(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue,
    const char *inStr, void *record, Jsi_Wide flags)
{
    // TODO: handle JSI_OPT_BITSET_BOOL
    Jsi_csgset *bsget = spec->iniVal.ini_OPT_BITS;
    Jsi_Interp *d = interp;
    int idx = spec->idx;
    uchar *data = (uchar*)record;
    Jsi_Number num;
    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;

    if (!d || !bsget || idx<0) 
        return Jsi_LogError("invalid bitfield");
    if (enumSpec) {
        struct numStruct { int64_t numVal; } nval = {};
        Jsi_OptionSpec eSpec[] = {
            JSI_OPT(CUSTOM, typeof(nval), numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC,
                .custom=Jsi_Opt_SwitchEnum, .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ),
            JSI_OPT_END(typeof(nval))
        };
        if (JSI_OK != jsi_ValueToEnum(interp, eSpec, inValue, inStr, (void*)&nval, flags))
            return JSI_ERROR;
        num = (Jsi_Number)nval.numVal;
    } else if (inStr) {
        if (Jsi_GetDouble(interp, inStr, &num) != JSI_OK)
            return JSI_ERROR;
    } else {
        if (inValue && !Jsi_ValueIsNumber(interp, inValue)) 
            return Jsi_LogError("expected number");
        Jsi_ValueGetNumber(interp, inValue, &num);
    }
    int64_t inum = (int64_t)num;
    return (*bsget)(interp, data, &inum, spec, idx, 1);
}

/* Printing function. */
static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,
    Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    // TODO: handle JSI_OPT_BITSET_BOOL
    Jsi_csgset *bsget = spec->iniVal.ini_OPT_BITS;
    Jsi_Interp *d = interp;
    int idx = spec->idx;
    uchar *data = (uchar*)record;
    int64_t inum;
    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;

    if (!d || !bsget || idx<0) 
        return Jsi_LogError("invalid bitfield");
    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);
    if (rc != JSI_OK)
        return JSI_ERROR;

    if (enumSpec) {
        struct numStruct { int64_t numVal; } nval = { inum };
        Jsi_OptionSpec eSpec[] = {
            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,
            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), //TODO: extra
            JSI_OPT_END(struct numStruct)
        };
        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))
            return JSI_ERROR;
    } else if (outStr) {
        char obuf[100];
        snprintf(obuf, sizeof(obuf), "%" PRId64, inum);
        Jsi_DSAppend(outStr, obuf, NULL);
    } else {
        Jsi_Number num = (Jsi_Number)inum;
        Jsi_ValueMakeNumber(interp, outValue, num);
    }
    return JSI_OK;
}

static Jsi_OptionCustom jsi_OptSwitchBitfield = {
    .name="suboption", .parseProc=jsi_ValueToBitfield, .formatProc=jsi_BitfieldToValue
};

/* Scanning function */
static Jsi_RC jsi_ValueToNull(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    return JSI_OK;
}

/* Printing function. */
static Jsi_RC jsi_NullToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    Jsi_ValueMakeNull(interp, outValue);
    return JSI_OK;
}

static Jsi_OptionCustom jsi_OptSwitchNull = {
    .name="suboption", .parseProc=jsi_ValueToNull, .formatProc=jsi_NullToValue
};
#endif

static Jsi_OptionCustom* custOpts[] = { NULL,
    &jsi_OptSwitchEnum, 
    &jsi_OptSwitchBitset,
#ifndef JSI_LITE_ONLY
    &jsi_OptSwitchSuboption, 
    &jsi_OptSwitchBitfield,
    &jsi_OptSwitchValueVerify,
    &jsi_OptSwitchCArray,
    &jsi_OptSwitchNull
#else
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
#endif
};

Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust) {
    if ((uintptr_t)cust < (uintptr_t)(sizeof(custOpts)/sizeof(custOpts[0])))
        return custOpts[(uintptr_t)cust];
    return cust;
}

Jsi_RC jsi_InitOptions(Jsi_Interp *interp, int release) {
    if (release) return JSI_OK;
    assert((sizeof(jsi_OptTypeInfo)/sizeof(jsi_OptTypeInfo[0])) == (JSI_OPTION_END+1));
    int i;
    for (i=JSI_OPTION_BOOL; i<JSI_OPTION_END; i++)
        assert(jsi_OptTypeInfo[i].id == (Jsi_OptionId)i);
    return JSI_OK;
}
#ifndef JSI_LITE_ONLY

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#ifndef JSI_OMIT_STUBS
#include "jsiStubs.h"
  
static int Jsi_Stubs__initialize(Jsi_Interp *interp, double version, const char* name, int flags, 
    const char *md5, int bldFlags, int stubSize, int structSizes, void **ptr);

Jsi_Stubs jsiStubsTbl = { __JSI_STUBS_INIT__ };
Jsi_Stubs *jsiStubsTblPtr = &jsiStubsTbl;

int Jsi_Stubs__initialize(Jsi_Interp *interp, double version, const char* name, int flags, 
    const char *md5, int bldFlags, int stubSize, int structSizes, void **ptr)
{
    
    if (Jsi_Strcmp(name,"jsi")) { /* Sub-stub support */
        int rc = Jsi_StubLookup(interp, name, ptr);
        if (rc != JSI_OK)
            return JSI_ERROR;
        Jsi_Stubs *sp = *(Jsi_Stubs **)ptr;
        if (sp->_Jsi_Stubs__initialize && sp->sig == JSI_STUBS_SIG &&
            sp->_Jsi_Stubs__initialize != jsiStubsTbl._Jsi_Stubs__initialize)
            return (*sp->_Jsi_Stubs__initialize)(interp, version, name, flags, md5, bldFlags, stubSize, structSizes, ptr);
        return Jsi_LogError("failed to find stub for %s", name);
    }
    int structSize = JSI_STUBS_STRUCTSIZES;
    int strict = (flags & JSI_STUBS_STRICT);
    int sizediff = (sizeof(Jsi_Stubs) - stubSize);
    assert(jsiStubsTbl.sig == JSI_STUBS_SIG);
    if (sizediff<0 || (strict && (Jsi_Strcmp(md5, JSI_STUBS_MD5) || sizediff || structSize != structSizes))) {
        fprintf(stderr, "%s: extension from incompatible build: %s\n", name, (sizediff ? "size changed": md5));
        return JSI_ERROR;
    }
    if (bldFlags != jsiStubsTbl.bldFlags) {
        fprintf(stderr, "%s: extension build flags mismatch (different libc?)\n", name);
        if (strict)
            return JSI_ERROR;
    }
    if (version > JSI_VERSION) {
        fprintf(stderr, "%s: extension version newer than jsish (%g > %g)\n", name, version, JSI_VERSION);
        if (strict)
            return JSI_ERROR;
    }
    return JSI_OK;
}
#endif
#endif
#ifndef JSI_LITE_ONLY
/*
 * Implements the internals of the format command for jsi
 *
 * The FreeBSD license
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE JSI PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * JSI OR TCL PROJECTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the Jsi Tcl Project.
 *
 * Based on code originally from Tcl 8.5:
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 *
 * See the file "tcl.license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 */
#include <ctype.h>
#include <string.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define MAX_INTEGER_WIDTH 24
#define MAX_FLOAT_WIDTH 320

/**
 * Apply the printf-like format in fmtObjPtr with the given arguments.
 *
 * Returns a new object with zero reference count if OK, or NULL on error.
 */
Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr)
{
    const char *span, *format, *formatEnd, *msg = "invalid";
    int numBytes = 0, argIndex = 1, argCnt;
    static const char* badIndex = "not enough arguments for specifiers";
    int formatLen;
    Jsi_Value *v;
    Jsi_DString jStr, pStr, sStr;
    char stat_buf[100], *num_buffer = stat_buf;
    int num_buffer_size = sizeof(stat_buf);
    argCnt = Jsi_ValueGetLength(interp, args);
    Jsi_DSInit(&pStr);
    Jsi_DSInit(&jStr);
    Jsi_DSInit(&sStr);

    const char *fmtStart = format = Jsi_ValueArrayIndexToStr(interp, args,0, &formatLen);
    if (argCnt<1)
        goto error;
    
    span = format;
    formatEnd = format + formatLen;
    Jsi_DSInit(dStr);

    while (format != formatEnd) {
        char *end;
        int gotMinus, sawFlag;
        int gotPrecision;
        long width, precision;
        int ch;
        int step;
        int doubleType;
        char pad = ' ';
        char spec[100];
        char *p;

        int formatted_chars;
        int formatted_bytes;
        const char *formatted_buf = NULL;
        fmtStart = format;
        step = Jsi_UtfToUniChar(format, &ch);
        format += step;
        if (ch != '%') {
            numBytes += step;
            continue;
        }
        if (numBytes) {
            Jsi_DSAppendLen(dStr, span, numBytes);
            numBytes = 0;
        }

        /*
         * Saw a % : process the format specifier.
         *
         * Step 0. Handle special case of escaped format marker (i.e., %%).
         */

        step = Jsi_UtfToUniChar(format, &ch);
        if (ch == '%') {
            span = format;
            numBytes = step;
            format += step;
            continue;
        }
        
        if ((argIndex < 0) || (argIndex >= argCnt)) {
            msg = badIndex;
            goto error;
        }

        /*
         * Step 2. Set of flags. Also build up the sprintf spec.
         */
        p = spec;
        *p++ = '%';

        gotMinus = 0;
        sawFlag = 1;
        do {
            switch (ch) {
            case '-':
                gotMinus = 1;
                break;
            case '0':
                pad = ch;
                break;
            case ' ':
            case '+':
            case '#':
            case '\'':
                break;
            default:
                sawFlag = 0;
                continue;
            }
            *p++ = ch;
            if ((p-spec)>(int)(sizeof(spec)-10)) {
                msg = "spec too long";
                goto error;
            }
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
        } while (sawFlag);

        /*
         * Step 3. Minimum field width.
         */

        width = 0;
        if (isdigit(ch)) {
            width = strtoul(format, &end, 10);
            format = end;
            step = Jsi_UtfToUniChar(format, &ch);
        } else if (ch == '*') {
            if (argIndex >= argCnt - 1) {
                msg = badIndex;
                goto error;
            }
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetLongFromValue(interp, v, &width) != JSI_OK) {
                goto error;
            }
            if (width < 0) {
                width = -width;
                if (!gotMinus) {
                    *p++ = '-';
                    gotMinus = 1;
                }
            }
            argIndex++;
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
        }

        /*
         * Step 4. Precision.
         */

        gotPrecision = precision = 0;
        if (ch == '.') {
            gotPrecision = 1;
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
        }
        if (isdigit(ch)) {
            precision = strtoul(format, &end, 10);
            format = end;
            step = Jsi_UtfToUniChar(format, &ch);
        } else if (ch == '*') {
            if (argIndex >= argCnt - 1) {
                msg = badIndex;
                goto error;
            }
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetLongFromValue(interp, v, &precision) != JSI_OK)
                goto error;

            /*
             * TODO: Check this truncation logic.
             */

            if (precision < 0) {
                precision = 0;
            }
            argIndex++;
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
        }

        /*
         * Step 5. Length modifier.
         */

        if (ch == 'h') {
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
        } else if (ch == 'l') {
            format += step;
            step = Jsi_UtfToUniChar(format, &ch);
            if (ch == 'l') {
                format += step;
                step = Jsi_UtfToUniChar(format, &ch);
            }
        }

        format += step;
        span = format;

        /*
         * Step 6. The actual conversion character.
         */

        if (ch == 'i') {
            ch = 'd';
        }

        doubleType = 0;

        /* Each valid conversion will set:
         * formatted_buf   - the result to be added
         * formatted_chars - the length of formatted_buf in characters
         * formatted_bytes - the length of formatted_buf in bytes
         */
        switch (ch) {
        case '\0':
            msg = "string ended in middle of field specifier";
            goto error;
        case 'q': {
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (!Jsi_ValueIsString(interp, v)) {
                Jsi_DSSetLength(&pStr, 0);
                Jsi_ValueGetDString(interp,  v, &pStr, JSI_OUTPUT_JSON);
                formatted_buf = Jsi_DSValue(&pStr);
                formatted_chars = Jsi_Strlen(formatted_buf);
                goto doprec;
            }
        }
        case 'S':
            Jsi_DSFree(&sStr);
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            formatted_buf = Jsi_ValueGetDString(interp, v, &sStr, 0);
            formatted_chars = Jsi_DSLength(&sStr);
            goto doprec;
        case 's':
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (jsi_IsStrictMode(interp) && !Jsi_ValueIsString(interp, v)) {
                msg = "expected string argument";
                goto error;
            } else
                Jsi_ValueToString(interp, v, NULL);
            if (!(formatted_buf = Jsi_ValueString(interp, v, &formatted_chars))) {
                if (Jsi_GetStringFromValue(interp, v, &formatted_buf) != JSI_OK)
                    goto error;
                formatted_chars = Jsi_Strlen(formatted_buf);
            }
doprec:
            formatted_bytes = formatted_chars;
            if (gotPrecision && (precision < formatted_chars)) {
                /* Need to build a (null terminated) truncated string */
                Jsi_DSSetLength(&pStr, 0);
                formatted_bytes = formatted_chars = precision;
                formatted_buf = Jsi_DSAppendLen(&pStr, formatted_buf, precision);
                //formatted_bytes = Jsi_UtfIndexToOffset(formatted_buf, precision);
            }
            break;
        case 'c':
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if ((formatted_buf = Jsi_ValueString(interp, v, &formatted_bytes))==NULL || formatted_bytes!=1) {
                Jsi_Wide code;
                if (!Jsi_ValueIsNumber(interp, v))
                    goto error;
                Jsi_GetWideFromValue(interp, v, &code);
                if (code<0 || code>255)
                    goto error;
                /* Just store the value in the 'spec' buffer */
                formatted_bytes = Jsi_UniCharToUtf(code, spec);
                formatted_buf = spec;
            }
            formatted_chars = 1;
            break;

        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'f':
        case 'g':
        case 'G':
            doubleType = 1;
            /* fall through */
        case 'i':
        case 'd':
        case 'u':
        case 'o':
        case 'x':
        case 'X': {
            Jsi_Wide w;
            Jsi_Number d;
            int length;

            /* Fill in the width and precision */
            if (width) {
                p += sprintf(p, "%ld", width);
            }
            if (gotPrecision) {
                p += sprintf(p, ".%ld", precision);
            }
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (jsi_IsStrictMode(interp) && !Jsi_ValueIsNumber(interp, v)) {
                msg = "expected number argument";
                goto error;
            }

            /* Now the modifier, and get the actual value here */
            if (doubleType) {
                if (Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK)
                    goto error;
                length = MAX_FLOAT_WIDTH;
            }
            else {
                if (Jsi_GetWideFromValue(interp, v, &w) != JSI_OK)
                    goto error;
                length = MAX_INTEGER_WIDTH;
                *p++ = 'l';
                *p++ = 'l';
            }

            *p++ = (char) ch;
            *p = '\0';

            /* Adjust length for width and precision */
            if (width > length) {
                length = width;
            }
            if (gotPrecision) {
                length += precision;
            }

            /* Increase the size of the buffer if needed */
            if (num_buffer_size < length + 1) {
                num_buffer_size = length + 1;
                num_buffer = (char*)Jsi_Realloc((num_buffer==stat_buf?NULL:num_buffer), num_buffer_size);
            }

            if (doubleType) {
                snprintf(num_buffer, length + 1, spec, d);
            }
            else {
                formatted_bytes = snprintf(num_buffer, length + 1, spec, w);
            }
            formatted_chars = formatted_bytes = Jsi_Strlen(num_buffer);
            formatted_buf = num_buffer;
            break;
        }

        default: {
            /* Just reuse the 'spec' buffer */
            *p++ = ch;
            Jsi_Strcpy(p, ": unknown or invalid spec");
            msg = spec;
            goto error;
        }
        }

        if (!gotMinus) {
            while (formatted_chars < width) {
                Jsi_DSAppendLen(dStr, &pad, 1);
                formatted_chars++;
            }
        }

        Jsi_DSAppendLen(dStr, formatted_buf, formatted_bytes);

        while (formatted_chars < width) {
            Jsi_DSAppendLen(dStr, &pad, 1);
            formatted_chars++;
        }

        argIndex += 1;
    }
    if (numBytes) {
        Jsi_DSAppendLen(dStr, span, numBytes);
    }
    Jsi_DSFree(&sStr);
    Jsi_DSFree(&jStr);
    Jsi_DSFree(&pStr);
    if (num_buffer!=stat_buf)
        Jsi_Free(num_buffer);
    return JSI_OK;

error:
    Jsi_LogError("format error at \"%s\": %s", fmtStart, msg);
    Jsi_DSFree(&pStr);
    Jsi_DSFree(&jStr);
    Jsi_DSFree(dStr);
    if (num_buffer!=stat_buf)
        Jsi_Free(num_buffer);
    return JSI_ERROR;
}
#endif
#ifndef JSI_LITE_ONLY

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)
{
    char buf[100], *dp = buf;
    const char *cp = str;
    int ulen;
    
    while ((cp-str)<len) {
        if (*cp == '\\') {
            switch (cp[1]) {
                case 'b': *dp++ = '\b'; break;
                case 'n': *dp++ = '\n'; break;
                case 'r': *dp++ = '\r'; break;
                case 'f': *dp++ = '\f'; break;
                case 't': *dp++ = '\t'; break;
                case '\"': *dp++ = '\"'; break;
                //  case '\\': *dp++ = '\\'; break;
                case 'u': 
                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {
                        dp += ulen;
                        cp += 4;
                    } else {                    
                        *dp++ = '\\';
                        *dp++ = 'u';
                    }
                    break;
            }
            cp+=2;
        } else {
            *dp++ = *cp++;
        }
        if ((dp-buf)>90) {
            *dp = 0;
            dp = buf;
            Jsi_DSAppend(dStr, buf, NULL);
        }
    }
    *dp = 0;
    Jsi_DSAppend(dStr, buf, NULL);
}

static Jsi_Value *jsonNewStringObj(Jsi_Interp *interp, const char* str, int len)
{
    Jsi_Value *v = NULL;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    jsonNewDString(interp, &dStr, str, len);
    v = Jsi_ValueMakeString(interp, NULL, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return v;
}

static Jsi_Value* jsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);
static Jsi_Value* jsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);

static Jsi_Value*
jsonGen1Value(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint i, uint *endPos, int incr)
{
    uint len;
    const char *t;
    Jsi_Value *v = NULL;
    
    switch (p->tokens[i].type) {
        case JSI_JTYPE_PRIMITIVE:
            t = Jsi_JsonGetTokstr(p, js, i, &len);
            if (len == 4 && Jsi_Strncmp(t, "true", len)==0)
                v = Jsi_ValueMakeBool(interp, NULL, 1);
            else if (len == 5 && Jsi_Strncmp(t, "false", len)==0)
                v = Jsi_ValueMakeBool(interp, NULL, 0);
            else if (len == 4 && Jsi_Strncmp(t, "null", len)==0)
                v = Jsi_ValueMakeNull(interp, NULL);
            else if (len == 9 && Jsi_Strncmp(t, "undefined", len)==0)
                v = Jsi_ValueMakeNull(interp, NULL);
            else {
                char *ep;
                Jsi_Number d;
                d = strtod(t,&ep);
                if (ep>(t+len))
                    Jsi_LogWarn("bad number %*s", len, t);
                v = Jsi_ValueMakeNumber(interp, NULL, d);
            }
            break;
        case JSI_JTYPE_STRING:
            t = Jsi_JsonGetTokstr(p, js, i, &len);
            v = jsonNewStringObj(interp, t, len);
            break;
        case JSI_JTYPE_ARRAY:
            v = jsonGenArray(interp, p, js, i, &i);
            i--;
            break;
        case JSI_JTYPE_OBJECT:
            v = jsonGenObject(interp, p, js, i, &i);
            i--;
            break;
        default:
            break;
    }
    if (endPos)
        *endPos = i;
    if (v == NULL)
        v = Jsi_ValueMakeUndef(interp, NULL);
    if (incr)
        Jsi_IncrRefCount(interp, v);
    return v;
}

static Jsi_Value*
jsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    Jsi_Value *nv, *v = Jsi_ValueMakeObject(interp, NULL, obj);
    uint i, n, len;
    Jsi_JsonTok *tok;
    const char *t;
    tok = p->tokens+pos;
    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {

        Jsi_DString dStr;
        t = Jsi_JsonGetTokstr(p, js, i, &len);
        i++; n++;
        if (n>=tok->size)
            nv = Jsi_ValueMakeUndef(interp, NULL);
        else
            nv = jsonGen1Value(interp, p, js, i, &i, 0);
        Jsi_DSInit(&dStr);
        Jsi_DSAppendLen(&dStr, t, len);
        Jsi_ObjInsert(interp, obj, Jsi_DSValue(&dStr), nv, 0);
        Jsi_DSFree(&dStr);
    }
    if (endPos)
        *endPos = i;
    return v;
}

static Jsi_Value*
jsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)
{
    if (js==NULL || !js[0])
        return NULL;
    Jsi_Value *v = Jsi_ValueNewArray(interp, 0, 0);
    Jsi_Obj *nobj = v->d.obj;
    uint i, n;
    Jsi_JsonTok *tok;
    
    tok = p->tokens+pos;
    Jsi_ValueMakeArrayObject(interp, &v, nobj);
    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {
        if (n >= nobj->arrMaxSize) {
            if (Jsi_ObjArraySizer(interp, nobj, n+1)<=0) {
                break;
            }
        }
        nobj->arr[n] = jsonGen1Value(interp, p, js, i, &i, 1);
    }
    Jsi_ObjSetLength(interp, nobj, n);
    if (endPos)
        *endPos = i;
    return v;
}

Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags)
{
    uint i = 0, r;
    Jsi_RC result = JSI_OK;
    int strict = (flags & JSI_JSON_STRICT);
    Jsi_JsonTok *tok;
    Jsi_Value *v;
    const char *err;
    Jsi_Number d;
    if (js == NULL)
        return JSI_OK;
    while (isspace(*js))
        js++;
    if (js[0] == 0)
        return JSI_OK;
    switch (js[0]) {
        case 't': if (Jsi_Strcmp(js,"true")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 1); return JSI_OK; } break;
        case 'f': if (Jsi_Strcmp(js,"false")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 0); return JSI_OK; } break;
        case 'n': if (Jsi_Strcmp(js,"null")==0) { if (ret) Jsi_ValueMakeNull(interp, ret); return JSI_OK; } break;
        case '0': case '1': case '2': case '3': case '4': case '5': 
        case '6': case '7': case '8': case '9': case '-':
            if (Jsi_GetDouble(interp, js, &d) == JSI_OK) { if (ret) Jsi_ValueMakeNumber(interp, ret, d); return JSI_OK; } break;
    }
    JSI_JSON_DECLARE(pp, tokens, 0);
    Jsi_JsonParser *p = &pp;
    pp.strict = strict;
    pp.flags = flags;

    r = Jsi_JsonParse(p, js);
    if (r != JSI_JSON_ERR_NONE) {
        int ofs = pp.pos, len = Jsi_Strlen(js);
        if (ofs<0 || ofs>len)
            ofs = 0;
        err = p->errStr;
        if (!err)
            err = Jsi_JsonGetErrname(r);
        if (interp)
            Jsi_LogError("JSON parse error (%s) at offset %d \"%.30s\"", err, ofs, js+ofs);
        result = JSI_ERROR;
        goto done;
    }
    if (!ret)
        goto done;
    tok = p->tokens;
    if (tok->size<=0) {
        if (!*ret)
            *ret = Jsi_ValueNew1(interp);
        if (tok->type == JSI_JTYPE_OBJECT)
            Jsi_ValueMakeObject(interp, ret, Jsi_ObjNewObj(interp, NULL, 0));
        else if (tok->type == JSI_JTYPE_ARRAY)
            Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNew(interp));
        else
            Jsi_ValueMakeUndef(interp, ret);
        goto done;
    }
    v = jsonGen1Value(interp, p, js, i, &i, 1);
    Jsi_ValueReplace(interp, ret, v);
    Jsi_DecrRefCount(interp, v);
done:
    Jsi_JsonFree(&pp);
    return result;
}

// Perform an sprintf format, then return the JSON parsed results.
Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) 
{
    va_list argList;
    uint n;
    char buf[BUFSIZ], *cp = buf;
    Jsi_DString dStr = {};
    va_start(argList, fmt);
    n = vsnprintf(buf, sizeof(buf), fmt, argList);
    if (n>JSI_MAX_ALLOC_BUF) {
        Jsi_LogError("Jsi_JSONParseFmt error: rc = %d", n);
        va_end(argList);
        return JSI_ERROR;
    }
    if (n >= sizeof(buf)) {
        uint m;
        Jsi_DSSetLength(&dStr, n+1);
        m = vsnprintf(Jsi_DSValue(&dStr), n+1, fmt, argList);
        assert(m == n);
        JSI_NOWARN(m);
        cp = Jsi_DSValue(&dStr);
    }
    va_end(argList);
    return Jsi_JSONParse(interp, cp, ret, 0);
}

// Process options from json string. Handles only primatives and string. Returns number of fields parsed.
int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags)
{
    uint i = 0, r, len;
    Jsi_RC rc = JSI_OK;
    int result = 0;
    int strict = (flags & JSI_JSON_STRICT);
    Jsi_JsonTok *tok;
    const char *err;
    Jsi_Value *v = NULL;
    Jsi_DString nStr;
    const char *t, *name = NULL;
    if (json == NULL)
        return 0;
    while (isspace(*json))
        json++;
    if (json[0] == 0)
        return 0;
        
    JSI_JSON_DECLARE(pp, tokens, 0);
    Jsi_JsonParser *p = &pp;
    pp.strict = strict;
    pp.flags = flags;

    r = Jsi_JsonParse(p, json);
    if (r != JSI_JSON_ERR_NONE) {
        int ofs = pp.pos, len = Jsi_Strlen(json);
        if (ofs<0 || ofs>len)
            ofs = 0;
        err = p->errStr;
        if (!err)
            err = Jsi_JsonGetErrname(r);
        Jsi_LogError("JSON parse error (%s) at offset %d \"%.30s\"", err, ofs, json+ofs);
        result = -1;
        goto done;
    }
    tok = p->tokens;
    Jsi_DSInit(&nStr);
    if (tok->size%2 || tok->type != JSI_JTYPE_OBJECT) {
        result = -1;
        goto done;
    }
    v = Jsi_ValueNew1(interp);
    for (i=1; i<p->toknext && i<tok->size; i++) {
        if (p->tokens[i].type != JSI_JTYPE_STRING) {
            Jsi_LogWarn("expected string at %d", i-1);
            goto bail;
        }
        name = Jsi_JsonGetTokstr(p, json, i, &len);
        Jsi_DSSetLength(&nStr, 0);
        Jsi_DSAppendLen(&nStr, name, len);
        name = Jsi_DSValue(&nStr);
        i++;
        switch (p->tokens[i].type) {
            case JSI_JTYPE_PRIMITIVE:
                t = Jsi_JsonGetTokstr(p, json, i, &len);
                if ((len == 4 && Jsi_Strncmp(t, "true", len)==0) || (len == 5 && Jsi_Strncmp(t, "false", len)==0)) {
                    Jsi_ValueMakeBool(interp, &v, (bool)(len==4?1:0));
                } else if (len == 4 && Jsi_Strncmp(t, "null", len)==0) {
                    Jsi_ValueMakeNull(interp, &v);
                } else {
                    char *ep;
                    Jsi_Number d = strtod(t,&ep);
                    if (ep>(t+len)) {
                        Jsi_LogWarn("bad number %*s", len, t);
                        goto bail;
                    }
                    Jsi_ValueMakeNumber(interp, &v, d);
                }
                break;
            case JSI_JTYPE_STRING:
                t = Jsi_JsonGetTokstr(p, json, i, &len);
                Jsi_DString dStr;
                Jsi_DSInit(&dStr);
                jsonNewDString(interp, &dStr, t, len);
                Jsi_ValueMakeStringKey(interp, &v, Jsi_DSValue(&dStr));
                Jsi_DSFree(&dStr);
                break;
            case JSI_JTYPE_ARRAY:
            case JSI_JTYPE_OBJECT:
            default:
                result = -1;
                goto bail;
                break;
        }
        result++;
        rc = Jsi_OptionsSet(interp, opts, data, name, v, 0);
        if (rc == JSI_OK)
            continue;

bail:
        Jsi_LogError("bad at field: %s", name);
        result = -1;
        break;
    }

done:
    Jsi_DSFree(&nStr);
    if (v)
        Jsi_DecrRefCount(interp, v);
    Jsi_JsonFree(&pp);
    return result;
}

static Jsi_RC JSONParseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    bool strict = 1;
    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);
    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) 
        return Jsi_LogError("Expected boolean");
    jsv = Jsi_ValueArrayIndex(interp, args, 0); 
    const char *js = Jsi_ValueToString(interp, jsv, NULL);
    return Jsi_JSONParse(interp, js, ret, strict);
}



static Jsi_RC JSONCheckCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{

    int r;
    Jsi_RC result = JSI_OK;
    bool strict = 1;
    const char *cp;
    JSI_JSON_DECLARE(p, tokens, 0);
    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);
    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) 
        return Jsi_LogError("Expected boolean");
    p.strict = strict;
    jsv = Jsi_ValueArrayIndex(interp, args, 0);
    cp = Jsi_ValueToString(interp, jsv, NULL);
    
    r = Jsi_JsonParse(&p, cp);
    Jsi_ValueMakeBool(interp, ret, r == JSI_JSON_ERR_NONE);
    Jsi_JsonFree(&p);
    return result;
}

// Apply JSON quoting to str and append result to dsPtr.
char *
Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dsPtr)
{
    const char *cp = str;
    int i = 0;
    if (len<0)
        len = Jsi_Strlen(str);
    char cbuf[10];
    Jsi_DSAppend(dsPtr,"\"",NULL);
    while (*cp && i++<len) {
        if (*cp == '\\' /* || *cp == '/' */ || *cp == '\"') {
            cbuf[0] = '\\';
            cbuf[1] = *cp;
            cbuf[2] = 0;
            Jsi_DSAppend(dsPtr,cbuf,NULL);
        } else if (!isprint(*cp)) {
            int ilen;
            switch (*cp) {
                case '\b': Jsi_DSAppend(dsPtr,"\\b",NULL); break;
                case '\n': Jsi_DSAppend(dsPtr,"\\n",NULL); break;
                case '\r': Jsi_DSAppend(dsPtr,"\\r",NULL); break;
                case '\f': Jsi_DSAppend(dsPtr,"\\f",NULL); break;
                case '\t': Jsi_DSAppend(dsPtr,"\\t",NULL); break;
                default:
                    if ((ilen = Jsi_UtfEncode(cp, cbuf))) {
                        Jsi_DSAppend(dsPtr,cbuf,NULL);
                        cp += (ilen-1);
                    }
            }
        } else {
            cbuf[0] = *cp;
            cbuf[1] = 0;
            Jsi_DSAppend(dsPtr,cbuf,NULL);
        }
        cp++;
    }
    
    Jsi_DSAppend(dsPtr,"\"", NULL);
    return Jsi_DSValue(dsPtr);;
}

static Jsi_RC JSONStringifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    bool strict = 1;
    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);
    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) 
        return Jsi_LogError("Expected boolean");
    int quote = JSI_OUTPUT_JSON;
    if (strict) quote|=JSI_JSON_STRICT;
    Jsi_DString dStr = {};
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_ValueGetDString(interp, arg, &dStr, quote);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret)
{
    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);
    if (func)
        return Jsi_FunctionInvoke(interp, func, args, ret, NULL);
    return Jsi_LogError("can not find cmd: %s", cmdstr);
}

static Jsi_CmdSpec jsonCmds[] = {
    { "check",      JSONCheckCmd,       1, 2, "str:string, strict:boolean=true", .help="Return true if str is JSON", .retType=(uint)JSI_TT_BOOLEAN },
    { "parse",      JSONParseCmd,       1, 2, "str:string, strict:boolean=true", .help="Parse JSON and return js", .retType=(uint)JSI_TT_ANY },
    { "stringify",  JSONStringifyCmd,   1, 2, "value:any,  strict:boolean=true", .help="Return JSON from a js object", .retType=(uint)JSI_TT_STRING },
    { NULL, 0,0,0,0, .help="Commands for handling JSON data" }
};

Jsi_RC jsi_InitJSON(Jsi_Interp *interp, int release) {
    if (release) return JSI_OK;
    Jsi_CommandCreateSpecs(interp, "JSON", jsonCmds, NULL, 0);
#ifdef TEST_JSON_INVOKE
    Jsi_Value *ret = Jsi_ValueNew1(interp);
    Jsi_CommandInvokeJSON(interp, "Info.cmds", "[\"*\", true]", ret);
    Jsi_DString dStr = {};
    Jsi_Puts(NULL, Jsi_ValueGetDString(interp, ret, &dStr, 1));
    Jsi_DSFree(&dStr);
    Jsi_DecrRefCount(interp, ret);
#endif
    return JSI_OK;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#else
char *strptime(const char *buf, const char *fmt, struct tm *tm);
#endif
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <signal.h>
#include <limits.h>

static Jsi_RC consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[1024];
    char *cp, *p = buf;
    buf[0] = 0;
    if (!interp->stdinStr)
        p=fgets(buf, sizeof(buf), stdin);
    else {
        int ilen;
        cp = Jsi_ValueString(interp, interp->stdinStr, &ilen);
        if (!cp || ilen<=0)
            p = NULL;
        else {
            Jsi_Strncpy(buf, cp, sizeof(buf));
            buf[sizeof(buf)-1] = 0;
            p = Jsi_Strchr(buf, '\n');
            if (p) { *p = 0;}
            ilen = Jsi_Strlen(buf);
            p = (cp + ilen + (p?1:0));
            Jsi_ValueMakeStringDup(interp, &interp->stdinStr, p);
            p = buf;
        }
    }
    
    if (p == NULL) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    if ((p = Jsi_Strchr(buf, '\r'))) *p = 0;
    if ((p = Jsi_Strchr(buf, '\n'))) *p = 0;
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

typedef struct {
    bool trace;
    bool once;
    bool autoIndex;
    bool isMain;
} SourceData;

static Jsi_OptionSpec SourceOptions[] = {
    JSI_OPT(BOOL,   SourceData, autoIndex,  .help="Look for and load Jsi_Auto.jsi auto-index file" ),
    JSI_OPT(BOOL,   SourceData, isMain, .help="Coerce to true the value of Info.isMain()" ),
    JSI_OPT(BOOL,   SourceData, once,   .help="Source file only if not already sourced (Default: Interp.debugOpts.includeOnce)" ),
    JSI_OPT(BOOL,   SourceData, trace,  .help="Trace include statements (Default: Interp.debugOpts.includeTrace)" ),
    JSI_OPT_END(SourceData, .help="Options for source command")
};


static Jsi_RC SysSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jsi_Pstate *ps = interp->ps;
    Jsi_RC rc = JSI_OK;
    int flags = 0;
    int i, argc;
    SourceData data = {.trace = interp->debugOpts.includeTrace, .once = interp->debugOpts.includeOnce};
    Jsi_Value *v, *va = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);
    if (vo) {
        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) { /* Future options. */
            Jsi_LogError("expected options object");
            return JSI_ERROR;
        }
        if (Jsi_OptionsProcess(interp, SourceOptions, &data, vo, 0) < 0) {
            return JSI_ERROR;
        }
        if (data.autoIndex)
            flags |= JSI_EVAL_AUTOINDEX;
    }
    if ((interp->includeDepth+1) > interp->maxIncDepth) 
        return Jsi_LogError("max source depth exceeded");
    if (data.once)
        flags|= JSI_EVAL_ONCE;
    interp->includeCnt++;
    interp->includeDepth++;
    int oisi = interp->isMain;
    interp->isMain = data.isMain;
    const char *sop = (data.once?" <ONCE>":"");
    if (!Jsi_ValueIsArray(interp, va)) {
        v = va;
        if (v && Jsi_ValueIsString(interp,v)) {
            if (data.trace)
                Jsi_LogInfo("sourcing: %s%s", Jsi_ValueString(interp, v, 0), sop);
            rc = Jsi_EvalFile(ps->interp, v, flags);
        } else {
            Jsi_LogError("expected string");
            rc = JSI_ERROR;
        }
        goto done;
    }
    argc = Jsi_ValueGetLength(interp, va);
    for (i=0; i<argc && rc == JSI_OK; i++) {
        v = Jsi_ValueArrayIndex(interp, va, i);
        if (v && Jsi_ValueIsString(interp,v)) {
            if (data.trace)
                Jsi_LogInfo("sourcing: %s%s", Jsi_ValueString(interp, v, 0), sop);
            rc = Jsi_EvalFile(ps->interp, v, flags);
        } else {
            Jsi_LogError("expected string");
            rc = JSI_ERROR;
            break;
        }
    }
done:
    interp->isMain = oisi;
    interp->includeDepth--;
    return rc;
}

static void jsiGetTime(long *seconds, long *milliseconds)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);
    *seconds = tv.tv_sec;
    *milliseconds = tv.tv_usec / 1000;
}

void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event) {
    SIGASSERT(event,EVENT);
    if (event->funcVal)
        Jsi_DecrRefCount(interp, event->funcVal);
    if (event->hPtr) {
        Jsi_HashValueSet(event->hPtr, NULL);
        Jsi_HashEntryDelete(event->hPtr);
    }
    _JSI_MEMCLEAR(event);
    Jsi_Free(event);
}

/* Create an event and add to interp event table. */
Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data)
{
    Jsi_Event *evPtr;
    while (1) {
        bool isNew;
        uintptr_t id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));
        SIGINIT(evPtr,EVENT);
        evPtr->id = id;
        evPtr->handler = callback;
        evPtr->data = data;
        evPtr->hPtr = hPtr;
        Jsi_HashValueSet(hPtr, evPtr);
        break;
    }
    return evPtr;
}

/* Process events and return count. */
int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents)
{
    Jsi_Event *evPtr;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Value* nret = NULL;
    Jsi_RC rc;
    int cnt = 0, newIdx = interp->eventIdx;
    long cur_sec, cur_ms;
    jsiGetTime(&cur_sec, &cur_ms);
    Jsi_Value *vpargs = NULL;

    /*if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return JSI_ERROR;*/

    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {

        if (!(evPtr = (Jsi_Event*)Jsi_HashValueGet(hPtr)))
            continue;
        SIGASSERT(evPtr,EVENT);
        if ((int)evPtr->id >= newIdx) /* Avoid infinite loop of event creating events. */
            continue;
        switch (evPtr->evType) {
        case JSI_EVENT_SIGNAL:
#ifndef JSI_OMIT_SIGNAL   /* TODO: win signals? */
            if (!jsi_SignalIsSet(interp, evPtr->sigNum))
                continue;
            jsi_SignalClear(interp, evPtr->sigNum);
#endif
            break;
        case JSI_EVENT_TIMER:
            if (cur_sec <= evPtr->when_sec && (cur_sec != evPtr->when_sec || cur_ms < evPtr-> when_ms)) {
                if (evPtr->when_sec && evPtr->when_ms)
                    continue;
            }
            cnt++;
            evPtr->count++;
            break;
        case JSI_EVENT_ALWAYS:
            break;
        default:
            assert(0);
        }

        if (evPtr->handler) {
            rc = evPtr->handler(interp, evPtr->data);
        } else {
            if (vpargs == NULL) {
                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
                Jsi_IncrRefCount(interp, vpargs);
            }
            nret = Jsi_ValueNew1(interp);
            rc = Jsi_FunctionInvoke(interp, evPtr->funcVal, vpargs, &nret, NULL);
        }
        if (interp->deleting) {
            cnt = -1;
            goto bail;
        }
        if (rc != JSI_OK) {
            if (interp->exited) {
                cnt = rc;
                goto bail;
            }
            Jsi_LogError("event function call failure");
        }
        if (evPtr->once) {
            Jsi_EventFree(interp, evPtr);
        } else {
            evPtr->when_sec = cur_sec + evPtr->initialms / 1000;
            evPtr->when_ms = cur_ms + evPtr->initialms % 1000;
            if (evPtr->when_ms >= 1000) {
                evPtr->when_sec++;
                evPtr->when_ms -= 1000;
            }
        }
        if (maxEvents>0 && cnt>=maxEvents)
            break;
    }
bail:
    if (vpargs)
        Jsi_DecrRefCount(interp, vpargs);
    if (nret)
        Jsi_DecrRefCount(interp, nret);
    /*Jsi_MutexUnlock(interp, interp->Mutex);*/

    static int evCnt = 0;
    evCnt++;
    if (interp->parent && interp->busyCallback &&
            (interp->busyCallback[0]==0 || !Jsi_Strcmp(interp->busyCallback, "update")))
        Jsi_EventProcess(interp->parent, maxEvents);
    return cnt;
}

/*
 * \brief: sleep for so many milliseconds with interp mutex unlocked.
 */
Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim) {
    uint utim = 0;
    if (dtim <= 0)
        return JSI_OK;
    Jsi_MutexUnlock(interp, interp->Mutex);
    dtim = (dtim/1e3);
    if (dtim>1) {
        utim = 1e6*(dtim - (Jsi_Number)((int)dtim));
        dtim = (int)dtim;
    } else if (dtim<1) {
        utim = 1e6 * dtim;
        dtim = 0;
    }
    if (utim>0)
        usleep(utim);
    if (dtim>0)
        sleep(dtim);
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        Jsi_LogBug("could not reget mutex");
        return JSI_ERROR;
    }
    return JSI_OK;
}

#ifndef JSI_OMIT_EVENT
typedef struct {
    int minTime;
    int maxEvents;
    int maxPasses;
    int sleep;
} UpdateData;

static Jsi_OptionSpec UpdateOptions[] = {
    JSI_OPT(INT,    UpdateData, maxEvents,  .help="Maximum number of events to process (or -1 for all)" ),
    JSI_OPT(INT,    UpdateData, maxPasses,  .help="Maximum passes through event queue" ),
    JSI_OPT(INT,    UpdateData, minTime,    .help="Minimum milliseconds before returning, or -1 to loop forever (default is 0)" ),
    JSI_OPT(INT,    UpdateData, sleep,      .help="Time to sleep time (in milliseconds) between event checks. Default is 1" ),
    JSI_OPT_END(UpdateData, .help="Options for update command")
};

#define FN_update JSI_INFO("\
Returns the number of events processed. \
Events are processed until minTime (in milliseconds) is exceeded, or forever if -1. \
The default minTime is 0, meaning return as soon as no events can be processed. \
A positive mintime will result in sleeps between event checks.")
static Jsi_RC SysUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int maxEvents = -1, hasopts = 0;
    int cnt = 0, lcnt = 0;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);
    long cur_sec, cur_ms;
    long start_sec, start_ms;
    jsiGetTime(&start_sec, &start_ms);
    UpdateData udata = {};
    udata.sleep = 1;
    jsi_AddEventHandler(interp); 
       
    if (opts != NULL) {
        Jsi_Number dms = 0;
        if (opts->vt == JSI_VT_OBJECT) {
            hasopts = 1;
            if (Jsi_OptionsProcess(interp, UpdateOptions, &udata, opts, 0) < 0) {
                return JSI_ERROR;
            }
        } else if (opts->vt != JSI_VT_NULL && Jsi_GetNumberFromValue(interp, opts, &dms) != JSI_OK)
            return JSI_ERROR;
        else
            udata.minTime = (unsigned long)dms;
    }
  
    while (1) {
        long long diftime;
        int ne = Jsi_EventProcess(interp, maxEvents);
        if (ne<0)
            break;
        cnt += ne;
        if (Jsi_InterpGone(interp))
            return JSI_ERROR;
        if (udata.minTime==0)
            break;
        jsiGetTime(&cur_sec, &cur_ms);
        if (cur_sec == start_sec)
            diftime = (long long)(cur_ms-start_ms);
        else
            diftime = (cur_sec-start_sec)*1000LL + cur_ms + (1000-start_ms);
        if (udata.minTime>0 && diftime >= (long long)udata.minTime)
            break;
        if (udata.maxPasses && ++lcnt >= udata.maxPasses)
            break;
        if ((rc = Jsi_Sleep(interp, udata.sleep)) != JSI_OK)
            break;
    }
    if (hasopts)
        Jsi_OptionsFree(interp, UpdateOptions, &udata, 0);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);
    return rc;
}

static Jsi_RC intervalTimer(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int once)
{
    bool isNew;
    Jsi_Event *evPtr;
    uintptr_t id;
    Jsi_Number milli;
    long milliseconds, cur_sec, cur_ms;
    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 1);
    
    if (!Jsi_ValueIsFunction(interp, fv)) 
        return Jsi_LogError("expected function");
    if (Jsi_GetNumberFromValue(interp, tv, &milli) != JSI_OK) 
        return Jsi_LogError("expected number");
    milliseconds = (long)milli;
    if (milliseconds < 0)
        milliseconds = 0;
    while (1) {
        id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));
        SIGINIT(evPtr,EVENT);
        evPtr->id = id;
        evPtr->funcVal = fv;
        Jsi_IncrRefCount(interp, fv);
        evPtr->hPtr = hPtr;
        jsiGetTime(&cur_sec, &cur_ms);
        evPtr->initialms = milliseconds;
        evPtr->when_sec = cur_sec + milliseconds / 1000;
        evPtr->when_ms = cur_ms + milliseconds % 1000;
        if (evPtr->when_ms >= 1000) {
            evPtr->when_sec++;
            evPtr->when_ms -= 1000;
        }
        evPtr->once = once;
        Jsi_HashValueSet(hPtr, evPtr);
        break;
    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);
    return JSI_OK;
}

static Jsi_RC setIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return intervalTimer(interp, args, _this, ret, funcPtr, 0);
}

static Jsi_RC clearIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number nid;
    uintptr_t id;
    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_HashEntry *hPtr;
    if (Jsi_GetNumberFromValue(interp, tv, &nid) != JSI_OK) 
        return Jsi_LogError("expected number");
    id = (uintptr_t)nid;
    hPtr = Jsi_HashEntryFind(interp->eventTbl, (void*)id);
    if (hPtr == NULL) 
        return Jsi_LogError("id not found: %" PRId64, (Jsi_Wide)id);
    Jsi_HashEntryDelete(hPtr);
    return JSI_OK;
}

static Jsi_RC setTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return intervalTimer(interp, args, _this, ret, funcPtr, 1);
}
#endif

static Jsi_RC SysExitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int err = 0;
    Jsi_Value *v = NULL;
    Jsi_Number n;
    if (Jsi_ValueGetLength(interp, args) > 0) {
        v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v && Jsi_GetNumberFromValue(interp,v, &n) == JSI_OK)
            err = (int)n;
        else 
            return Jsi_LogError("expected number");
    }
    if (interp->onExit && interp->parent && Jsi_FunctionInvokeBool(interp->parent, interp->onExit, v))
        return JSI_OK;
    if (interp->parent == NULL && interp == interp->mainInterp && interp->debugOpts.isDebugger)
        jsi_DoExit(interp, err);
    else {
        interp->exited = 1;
        interp->exitCode = err;
        return JSI_ERROR;
        /* TODO: cleanup events, etc. */
    }
    return JSI_OK;
}


static Jsi_RC parseIntCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide w = 0;
    Jsi_Number d = 0;

    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *bv = Jsi_ValueArrayIndex(interp, args, 1);
    if (!v)
        return JSI_ERROR;
    char *eptr, *str = Jsi_ValueString(interp, v, NULL);
    int base = 0;
    if (!str) {
        if (Jsi_ValueIsNumber(interp, v))
            Jsi_GetNumberFromValue(interp, v, &d);
        else
            goto nanval;
    }
    else if (str[0] == '0' && str[1] == 'x')
        d = (Jsi_Number)strtoll(str, &eptr, 16);
    else if (str[0] == '0' && !bv)
        d = (Jsi_Number)strtoll(str, &eptr, 8);
    else if (base == 0 && !bv)
        d = Jsi_ValueToNumberInt(interp, v, 1);
    else {
        if (str == NULL || JSI_OK != Jsi_GetIntFromValue(interp, bv, &base) || base<2 || base>36)
            return JSI_ERROR;
        d = (Jsi_Number)strtoll(str, &eptr, base);
    }
    if (Jsi_NumberIsNaN(d) || (Jsi_NumberIsFinite(d)==0 && Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK))
nanval:
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
    else {
        w = (Jsi_Wide)d;
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)w);
    }
    return JSI_OK;
}

static Jsi_RC parseFloatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_ValueToNumber(interp, v);
    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK)
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
    else {
        Jsi_ValueMakeNumber(interp, ret, n);
    }
    return JSI_OK;
}

// Return file path as a Jsi_Value, if it exists.
Jsi_Value * jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode)
{
    //TODO: Optimize by not allocing Jsi_Value if access() fails and not in /zvfs with no other mounts.
    if (0 && access(name, R_OK) <0) {
        if (interp->mountCnt==0)
            return NULL;
        if (interp->selfZvfs && interp->mountCnt==1 && Jsi_Strncmp(name, JSI_ZVFS_DIR, Jsi_Strlen(JSI_ZVFS_DIR)))
            return NULL;
    }
    Jsi_Value *fpath = Jsi_ValueNewStringDup(interp, name); 
    Jsi_IncrRefCount(interp, fpath);
    if (Jsi_Access(interp, fpath, mode) >= 0)
        return fpath;
    Jsi_DecrRefCount(interp, fpath);
    return NULL;
}

static int jsiValidPkgName(const char *n) {
    if (!*n) return 0;
    while (*n) {
        if (*n != '_' && !isalnum(*n))
            return 0;
        n++;
    }
    return 1;
}


static jsi_PkgInfo* jsiPkgGet(Jsi_Interp *interp, const char *name)
{
     return (jsi_PkgInfo*)Jsi_HashGet(interp->packageHash, name, 0);
}

Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr)
{
    jsi_PkgInfo *ptr = jsiPkgGet(interp, name);
    if (ptr) {
        if (filePtr)
            *filePtr = ptr->loadFile;
        return ptr->version;
    }
    return -1;
}

// Load one package. Note: Currently ver is ignored.
static Jsi_RC jsi_PkgLoadOne(Jsi_Interp *interp, const char *name, const char *path, int len, Jsi_Value **fval, Jsi_Number ver)
{
    bool trace = interp->debugOpts.pkgTrace;
    Jsi_RC rc = JSI_CONTINUE;
    const char *fn;
    const char *ext;
    if (!path)
        return JSI_CONTINUE;
    if (len<0)
        len = Jsi_Strlen(path);
#ifdef __WIN32
    ext = ".dll";
#else
    ext = ".so";
#endif
    Jsi_Value *fpath = NULL;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    int i;
    const char *sf = "";
    if (trace)
        sf = jsi_GetCurFile(interp);
    for (i=0; i<4 && rc == JSI_CONTINUE; i++) {
        const char *pref = (i%2 ? name : ""), *ps = (i%2 ? "/" : "");
        if (i<2) {
#ifdef JSI_OMIT_LOAD
        continue;
#endif
            Jsi_DSSetLength(&dStr, 0);
            Jsi_DSAppendLen(&dStr, path, len);
            Jsi_DSAppend(&dStr, "/", pref, ps, name, ext, NULL);
            fn = Jsi_DSValue(&dStr);
            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {
                if (trace)
                    Jsi_Printf(jsi_Stderr,"Package-Trace: load('%s') from %s\n", fn, sf);
                rc = jsi_LoadLibrary(interp, fn);
            }
        } else {
            Jsi_DSSetLength(&dStr, 0);
            Jsi_DSAppendLen(&dStr, path, len);
            Jsi_DSAppend(&dStr, "/", pref, ps, name, ".jsi", NULL);
            fn = Jsi_DSValue(&dStr);
            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {
                if (trace)
                    Jsi_Printf(jsi_Stderr, "Package-Trace: source('%s') from %s\n", fn, sf);
                rc = Jsi_EvalFile(interp, fpath, 0);
            }
        }
    }
    int needErr = 1;
    if (rc == JSI_OK) {
        ver = Jsi_PkgVersion(interp, name, NULL);
        if (ver < 0) {
            rc = Jsi_LogError("package missing provide('%s') in file: %s", name, Jsi_DSValue(&dStr));
            needErr = 0;
        }
    }
    if (rc == JSI_OK) {
        *fval = fpath;
    }
    else if (fpath)
        Jsi_DecrRefCount(interp, fpath);
    if (rc == JSI_ERROR && needErr)
        Jsi_LogError("within require('%s') in file: %s", name, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return rc;
}

// Load package from pkgDirs or executable path.  Note. ver is unused.
static Jsi_RC jsi_PkgLoad(Jsi_Interp *interp, const char *name, Jsi_Number ver) {
    Jsi_RC rc;
    const char *cp = NULL, *path;
    int len;
    uint i;
    Jsi_Value *fval = NULL;
    Jsi_Value *pval = interp->pkgDirs;
    if (pval) {
        Jsi_Obj* obj = pval->d.obj;
        
        for (i=0; i<obj->arrCnt; i++) {
            rc = jsi_PkgLoadOne(interp, name, Jsi_ValueString(interp, obj->arr[i], NULL), -1, &fval, ver);
            if (rc != JSI_CONTINUE)
                goto done;
        }
    }
    // Check executable dir.
    path = jsi_execName;
    if (path)
        cp = Jsi_Strrchr(path, '/');
    if (cp) {
        len = cp-path;
        rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);
        if (rc != JSI_CONTINUE)
            goto done;
    }
    // Check script dir.
    if ((path = interp->framePtr->fileName) || (interp->argv0 && (path = Jsi_ValueString(interp, interp->argv0, NULL)))) {
        if ((cp = Jsi_Strrchr(path, '/'))) {
            len = (cp-path);
            rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);
            if (rc != JSI_CONTINUE)
                goto done;
        }
    } else if (interp->curDir) { // Interactive mode 
        rc = jsi_PkgLoadOne(interp, name, interp->curDir, Jsi_Strlen(interp->curDir), &fval, ver);
        if (rc != JSI_CONTINUE)
            goto done;
    }
    return JSI_ERROR;
    
done:
    if (rc == JSI_CONTINUE)
        rc = JSI_ERROR;
    if (rc == JSI_OK) {
        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);
        if (!hPtr)
            rc = JSI_ERROR;
        else {
            jsi_PkgInfo *ptr, *ptr2;
            Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);
            if (hPtr) {
                ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);
                if (ptr)
                    if (fval) {
                        char *fval2 = Jsi_Realpath(interp, fval, NULL);
                        ptr->loadFile = Jsi_KeyAdd(interp, fval2);
                        if (interp->parent && ptr->initProc) {
                            ptr2 = jsiPkgGet(interp->topInterp, name);
                            if (ptr2)
                                ptr2->loadFile = Jsi_KeyAdd(interp, ptr->loadFile);
                        }
                        Jsi_DecrRefCount(interp, fval);
                        free(fval2);
                    }
            }
        }
    }
    if (rc != JSI_OK && fval)
        Jsi_DecrRefCount(interp, fval);
    return rc;
}


Jsi_Number Jsi_PkgRequire(Jsi_Interp *interp, const char *name, int version)
{
    int ver = 0;
    jsi_PkgInfo *ptr = jsiPkgGet(interp, name), *ptr2 = NULL;
    if (ptr) {
        if (ptr->initProc && ptr->needInit) {
            if ((*ptr->initProc)(interp, 0) != JSI_OK) 
                return -1;
            ptr->needInit = 0;
        }
        return ptr->version;
    } else if ((ptr2 = jsiPkgGet(interp->topInterp, name)) && ptr2->initProc) {
        // C-extension is in topInterp
        if (interp->debugOpts.pkgTrace)
            Jsi_Printf(jsi_Stderr , "Package-Trace: load from topLevel\n");
        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));
        *ptr = *ptr2;
        if (ptr->loadFile)
            ptr->loadFile = Jsi_KeyAdd(interp, ptr->loadFile);
        ptr->needInit = 1;
        Jsi_HashSet(interp->packageHash, name, ptr);
        if ((*ptr2->initProc)(interp, 0) == JSI_OK && (ptr = jsiPkgGet(interp, name))) {
            ptr->needInit = 0;
            return ptr->version;
        }
    }
    if (interp->pkgReqDepth>interp->maxIncDepth) {
        Jsi_LogError("recursive require('%s')", name);
        return -1;
    }
    
    interp->pkgReqDepth++;
    if (jsi_PkgLoad(interp, name, version) != JSI_OK) {
        //       Jsi_Value *vl = jsi_LoadFunction(interp, name, NULL);
        Jsi_LogError("failed require('%s')", name);
        interp->pkgReqDepth--;
        return -1;
    }
    interp->pkgReqDepth--;
    ver = Jsi_PkgVersion(interp, name, NULL);
    if (ver < 0)
        Jsi_LogError("package not found for require('%s')", name);

    return ver;
}

#define FN_require JSI_INFO("\
With no arguments, returns the list of all loaded packages. \
With one argument, loads the package (if necessary) and returns its version. \
With two arguments, also returns an object containing the version and loadFile, \
but if version argument is less than package version throws an error.")
static Jsi_RC SysRequireCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n = 1;
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0)
        return Jsi_HashKeysDump(interp, interp->packageHash, ret, 0);
        
    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);
    const char *name = NULL;
    if (Jsi_ValueIsString(interp, vname)) {
        name = Jsi_ValueString(interp, vname, NULL);
        if (!jsiValidPkgName(name))
            name = NULL;
    }
    if (!name) 
        return Jsi_LogError("invalid or missing package name");
    if (argc>1) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);
        if (v && (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || Jsi_NumberIsNaN(n) || n<0)) 
            return Jsi_LogError("bad version: %" JSI_NUMGFMT, n);
    }
    int isMain = interp->isMain;
    interp->isMain = 0;
    Jsi_Number ver = Jsi_PkgRequire(interp, name, n);
    interp->isMain = isMain;
    if (ver < 0)
        return JSI_ERROR;
    if (argc>1) {
        if (ver < n) 
            Jsi_LogWarn("package %s downlevel: %" JSI_NUMGFMT " < %" JSI_NUMGFMT, name, ver, n);
        jsi_PkgInfo *ptr;
        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);
        if (hPtr && ((ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr)))) {
            return Jsi_JSONParseFmt(interp, ret, "{version:%" JSI_NUMGFMT ", loadFile:\"%s\"}",
                ptr->version, ptr->loadFile?ptr->loadFile:"" );
        }
    }
    Jsi_ValueMakeNumber(interp, ret, ver);
    return JSI_OK;
}

Jsi_RC Jsi_PkgProvide(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc)
{
    jsi_PkgInfo *ptr;
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);
    if (version<0) {
        if (hPtr) {
            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);
            Jsi_HashEntryDelete(hPtr);
        }
    } else if (version == 0) 
        return Jsi_LogError("Version must be > 0");
    else {
        if (hPtr) {
            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);
            if (ptr && ptr->needInit==0) 
                return Jsi_LogError("package %s already provided from: %s", name, ptr->loadFile?ptr->loadFile:"");
            return JSI_OK;
        }
        if (!jsiValidPkgName(name)) 
            return Jsi_LogError("invalid package name");
        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));
        ptr->version = version;
        ptr->initProc = initProc;
        if (interp->framePtr->fileName && !initProc)
            ptr->loadFile = Jsi_KeyAdd(interp, interp->framePtr->fileName);
        Jsi_HashSet(interp->packageHash, (void*)name, ptr);
        if (initProc && interp->parent) { // Provide C extensions to topInterp.
            ptr = jsiPkgGet(interp->topInterp, name);
            if (ptr == NULL) {
                if (Jsi_PkgProvide(interp->topInterp, name, version, initProc) != JSI_OK)
                    return JSI_ERROR;
                ptr = jsiPkgGet(interp->topInterp, name);
                if (!ptr)
                    return JSI_ERROR;
                ptr->needInit = 1;
            }
        }

    }
    return JSI_OK;
}

static Jsi_RC SysProvideCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n = 1;
    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);
    const char *name = NULL;
    if (Jsi_ValueIsString(interp, vname)) {
        name = Jsi_ValueString(interp, vname, NULL);
        if (!jsiValidPkgName(name))
            name = NULL;
    }
    if (!name) 
        return Jsi_LogError("invalid or missing package name");

    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);
    if (v && (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || Jsi_NumberIsNaN(n) || n<=0)) 
        return Jsi_LogError("bad version: %" JSI_NUMGFMT, n);
    return Jsi_PkgProvide(interp, name, n, NULL);
}

Jsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return JSI_OK;
}

static Jsi_RC isNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    int rc = 0;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsBoolean(interp, v))
        rc = 0;
    else if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || Jsi_NumberIsNaN(n))
        rc = 1;
    Jsi_ValueMakeBool(interp, ret, rc);
    return JSI_OK;
}
static Jsi_RC isFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    int rc = 1;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || !Jsi_NumberIsFinite(n))
        rc = 0;
    Jsi_ValueMakeBool(interp, ret, rc);
    return JSI_OK;
}

/* Returns a url-encoded version of str */
/* IMPORTANT: be sure to free() the returned string after use */
static char *url_encode(char *str) {
  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) * 3 + 1), *pbuf = buf;
  while (*pstr) {
    if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') 
      *pbuf++ = *pstr;
    else if (*pstr == ' ') 
      *pbuf++ = '+';
    else 
      *pbuf++ = '%', *pbuf++ = jsi_toHexChar(*pstr >> 4), *pbuf++ = jsi_toHexChar(*pstr & 15);
    pstr++;
  }
  *pbuf = '\0';
  return buf;
}

/* Returns a url-decoded version of str */
/* IMPORTANT: be sure to free() the returned string after use */
static char *url_decode(char *str) {
  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) + 1), *pbuf = buf;
  while (*pstr) {
    if (*pstr == '%') {
      if (pstr[1] && pstr[2]) {
        *pbuf++ = jsi_fromHexChar(pstr[1]) << 4 | jsi_fromHexChar(pstr[2]);
        pstr += 2;
      }
    } else if (*pstr == '+') { 
      *pbuf++ = ' ';
    } else {
      *pbuf++ = *pstr;
    }
    pstr++;
  }
  *pbuf = '\0';
  return buf;
}

static Jsi_RC EncodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    cp = url_encode(str);
    Jsi_ValueMakeString(interp, ret, cp);
    return JSI_OK;
}

static Jsi_RC DecodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    cp = url_decode(str);
    Jsi_ValueMakeString(interp, ret, cp);
    return JSI_OK;
}

static Jsi_RC SysSleepCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number dtim = 1;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v) {
        if (Jsi_GetDoubleFromValue(interp, v, &dtim) != JSI_OK) {
            return JSI_ERROR;
        }
    }
    return Jsi_Sleep(interp, dtim);
}


static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    extern char **environ;
    char *cp;
    int i;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v != NULL) {
        const char *fnam = Jsi_ValueString(interp, v, NULL);
        if (!fnam) 
            return Jsi_LogError("expected string");
        cp = getenv(fnam);
        if (cp != NULL) {
            Jsi_ValueMakeString(interp, ret, Jsi_Strdup(cp));
        }
        return JSI_OK;
    }
   /* Single object containing result members. */
    Jsi_Value *vres;
    Jsi_Obj  *ores = Jsi_ObjNew(interp);
    Jsi_Value *nnv;
    char *val, nam[200];
    Jsi_ObjIncrRefCount(interp, ores);
    vres = Jsi_ValueMakeObject(interp, NULL, ores);
    Jsi_IncrRefCount(interp, vres);
    
    for (i=0; ; i++) {
        int n;
        cp = environ[i];
        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))
            break;
        n = val-cp;
        if (n>=(int)sizeof(nam))
            n = sizeof(nam)-1;
        Jsi_Strncpy(nam, cp, n);
        val = val+1;
        nnv = Jsi_ValueMakeString(interp, NULL, Jsi_Strdup(val));
        Jsi_ObjInsert(interp, ores, nam, nnv, 0);
    }
    Jsi_ValueReplace(interp, ret, vres);
    return JSI_OK;
}

static Jsi_RC SysSetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *fnam = Jsi_ValueString(interp, v, NULL);
    Jsi_Value *vv = Jsi_ValueArrayIndex(interp, args, 1);
    const char *cp = NULL, *fval = (vv?Jsi_ValueString(interp, vv, NULL):NULL);
    int rc = -1;
    if (fnam == 0) 
        return Jsi_LogError("expected string");

    if (fnam[0] != 0) {
#ifndef __WIN32
        if (fval)
            rc = setenv(fnam, fval, 1);
        else
            cp = getenv(fnam);
#else  /* TODO: win setenv */
        if (!fval)
            cp = getenv(fnam);
        else {
            char ebuf[BUFSIZ];
            snprintf(ebuf, sizeof(ebuf), "%s=%s", fnam, fval);
            rc = _putenv(ebuf);
        }
#endif
    }
    if (rc != 0) 
        return Jsi_LogError("setenv failure: %s = %s", fnam, fval);
    if (cp)
        Jsi_ValueMakeStringDup(interp, ret, cp);
    return JSI_OK;
}

static Jsi_RC SysGetPidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifdef __WIN32
    return Jsi_LogError("unsupported");
#else
    Jsi_Number pid = 0;
    bool bv = 0;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg && Jsi_GetBoolFromValue(interp, arg, &bv) != JSI_OK)
        return JSI_ERROR;
    if (bv)
        pid = (Jsi_Number)getppid();
    else
        pid = (Jsi_Number)getpid();
    Jsi_ValueMakeNumber(interp, ret, pid);
    return JSI_OK;
#endif
}

typedef struct {
    Jsi_Value* inputStr;
    bool bg;
    bool noError;
    bool noTrim;
    bool retCode;
    bool retAll;
    bool retval;
} ExecOpts;

static Jsi_OptionSpec ExecOptions[] = {
    JSI_OPT(BOOL,   ExecOpts, bg,       .help="Run command in background using system() and return OS code" ),
    JSI_OPT(STRING, ExecOpts, inputStr, .help="Use string as input and return OS code" ),
    JSI_OPT(BOOL,   ExecOpts, noError,  .help="Suppress all OS errors" ),
    JSI_OPT(BOOL,   ExecOpts, noTrim,   .help="Do not trim trailing whitespace from output" ),
    JSI_OPT(BOOL,   ExecOpts, retAll,   .help="Return the OS return code and data as an object" ),
    JSI_OPT(BOOL,   ExecOpts, retCode,  .help="Return only the OS return code" ),
    {JSI_OPTION_END}
};

#define FN_exec JSI_INFO("\
If the command ends with '&', set the 'bg' option to true. \
If the second argument is a string, the 'inputStr' option is set. \
By default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used")
static Jsi_RC SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->isSafe) 
        return Jsi_LogError("no exec in safe mode");
    int n, exitCode = 0, hasopts = 0, sLen, sLen2;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    const char *cp2=NULL, *cp = Jsi_ValueString(interp, arg, &sLen);
    Jsi_DString dStr = {};
    ExecOpts edata = {};
    edata.retval = 1;
    
    if (opt != NULL) {
        if (opt->vt == JSI_VT_OBJECT && opt->d.obj->ot == JSI_OT_OBJECT) {
            hasopts = 1;
            if (Jsi_OptionsProcess(interp, ExecOptions, &edata, opt, 0) < 0) {
                return JSI_ERROR;
            }
            if (edata.retCode)
                edata.retval = 0;
        } else if ((cp2=Jsi_ValueString(interp, opt, &sLen2))) {
            edata.inputStr = opt;
        } else 
            return Jsi_LogError("expected: string?,null|instr?");
    }

    int isbg = 0, ec = 0;
    if (edata.bg || (isbg=((sLen>1 && cp[sLen-1] == '&')))) {
        if (edata.inputStr) {
            rc = Jsi_LogError("inputStr can not used with bg");
            goto done;
        }
        if (!isbg) {
            Jsi_DSAppend(&dStr, cp, " &", NULL);
            cp = Jsi_DSValue(&dStr);
        }
        edata.bg = 1;
        edata.retCode = 1;
        edata.retval = 0;
        exitCode = ((ec=system(cp))>>8);
        Jsi_DSSetLength(&dStr, 0);
    } else if (edata.inputStr) {
        edata.retCode = 1;
        edata.retval = 0;
        cp2 = Jsi_ValueString(interp, edata.inputStr, &sLen2);
        FILE *fp = popen(cp, "w");
        if (!fp) 
            exitCode = errno;
        else {
            while ((n=fwrite(cp2, 1, sLen2, fp))>0) {
                sLen2 -= n;
            }
            exitCode = ((ec=pclose(fp))>>8);
        }
    } else {
        FILE *fp = popen(cp, "r");
        if (!fp) 
            exitCode = errno;
        else {
            char buf[BUFSIZ];;
            while ((n=fread(buf, 1, sizeof(buf), fp))>0)
                Jsi_DSAppendLen(&dStr, buf, n);
            exitCode = ((ec=pclose(fp))>>8);
        }
    }
    if (exitCode && edata.noError==0 && edata.retCode==0 && edata.retAll==0) {
        if (exitCode==ENOENT)
            Jsi_LogError("command not found: %s", cp);
        else
            Jsi_LogError("program exit code (%x)", exitCode);
        rc = JSI_ERROR;
    }
    if (!edata.noTrim) {
        char *cp = Jsi_DSValue(&dStr);
        int iLen = Jsi_DSLength(&dStr);
        while (iLen>0 && isspace(cp[iLen-1]))
            iLen--;
        cp[iLen] = 0;
    }
    if (edata.retAll) {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, nobj);
        Jsi_Value *cval = Jsi_ValueNewNumber(interp, (Jsi_Number)exitCode);
        Jsi_ObjInsert(interp, nobj, "code", cval, 0);
        cval = Jsi_ValueNewNumber(interp, (Jsi_Number)(ec&0xff));
        Jsi_ObjInsert(interp, nobj, "status", cval, 0);
        cval = Jsi_ValueNew(interp);
        Jsi_ValueFromDS(interp, &dStr, &cval);
        Jsi_ObjInsert(interp, nobj, "data", cval, 0);
        
    } else if (edata.retval)
        Jsi_ValueFromDS(interp, &dStr, ret);
    else {
        Jsi_DSFree(&dStr);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)exitCode);
    }
done:
    if (hasopts)
        Jsi_OptionsFree(interp, ExecOptions, &edata, 0);
    return rc;
}

static Jsi_RC SysPutsCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr, bool stdErr, jsi_LogOptions *popts, const char *argStr)
{
    int i, cnt = 0, quote = (popts->file);
    const char *fn = NULL;
    Jsi_DString dStr, oStr;
    if (interp->noStderr)
        stdErr = 0;
    Jsi_Chan *chan = (stdErr ? jsi_Stderr : jsi_Stdout);
    Jsi_DSInit(&dStr);
    Jsi_DSInit(&oStr);
    if (popts->chan && !stdErr) {
        Jsi_UserObj *uobj = popts->chan->d.obj->d.uobj;
        jsi_UserObjToName(interp, uobj, &dStr);
        Jsi_Channel nchan = Jsi_FSNameToChannel(interp, Jsi_DSValue(&dStr));
        if (nchan)
            chan = nchan;
        Jsi_DSSetLength(&dStr, 0);
    }
    if (interp->curIp) {
        int didx = 0;
        const char *cp;
        fn = interp->curIp->fname;
        if (fn && !popts->full && (cp=Jsi_Strrchr(fn, '/')))
            fn = cp +1;
        if (popts->time || (didx=popts->date)) {
            if (popts->time && popts->date)
                didx = 2;
            const char *fmts[3] = { "%H-%M-%f", "%F", "%F %H-%M-%f" },
                *fmt = (popts->timeFmt?popts->timeFmt:fmts[didx]);
            Jsi_DatetimeFormat(interp, Jsi_DateTime(), fmt, popts->isUTC, &dStr);
            Jsi_DSAppend(&dStr, ", ", NULL);
        }
        if (popts->file && popts->before) {
            Jsi_DSPrintf(&dStr, "%s:%d: ", fn, interp->curIp->Line);
            if (interp->curIp->Line<1000)
                Jsi_DSAppend(&dStr, (interp->curIp->Line<10?"  ":" "), NULL);
        }
        if (Jsi_DSLength(&dStr)) {
            quote = 1;
        }
        if (quote)
            Jsi_DSAppendLen(&dStr, "\"", 1);
    }
    if (!args)
        Jsi_DSAppend(&dStr, argStr?argStr:"", NULL);
    else {
        int argc = Jsi_ValueGetLength(interp, args);
        for (i = 0; i < argc; ++i) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);
            if (!v) continue;
            if (cnt++)
                Jsi_DSAppendLen(&dStr, " ", 1);
            const char *cp = Jsi_ValueString(interp, v, 0);
            if (cp) {
                Jsi_DSAppend(&dStr, cp, NULL);
                continue;
            }
            Jsi_DSSetLength(&oStr, 0);
            Jsi_ValueGetDString(interp, v, &oStr, 1);
            Jsi_DSAppend(&dStr, Jsi_DSValue(&oStr), NULL);
        }
    }
    if (quote)
        Jsi_DSAppendLen(&dStr, "\"", 1);
    if (popts->file && !popts->before) {
        Jsi_DSPrintf(&dStr, ", %s:%d", fn?fn:"", interp->curIp->Line);
    }
    if (popts->func) {
        // Note: could have looked this up on the stackFrame.
        if (!interp->prevActiveFunc || !((fn=interp->prevActiveFunc->name)))
            fn = "";
        Jsi_DSPrintf(&dStr, ", %s%s", fn[0]?fn:"", fn[0]?"()":"");
    }
    Jsi_DSAppend(&dStr, "\n", NULL);
    chan->interp = interp;
    Jsi_Puts(chan, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&oStr);
    return JSI_OK;
}

static Jsi_RC SysPrintfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    Jsi_DString dStr;
    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);
    if (rc != JSI_OK)
        return rc;
    const char *cp;
    (jsi_Stdout)->interp = interp;
    Jsi_Puts(jsi_Stdout, cp = Jsi_DSValue(&dStr));
    if (!Jsi_Strchr(cp, '\n'))
        Jsi_Flush(jsi_Stdout);
    Jsi_DSFree(&dStr);
    return rc;
}

static Jsi_RC consoleLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, &interp->logOpts, NULL);
}

#define FN_consolelogf JSI_INFO("\
Also, if there are multiple arguments, and the first argument does not contains a %, \
the second argument is the format, and the first is prepended to the output. \
This command is used with bind/alias to handle LogDebug, LogTrace, ...")
static Jsi_RC consoleLogfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    Jsi_DString dStr;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *nargs = args, *pval = Jsi_ValueArrayIndex(interp, args, 0);
    int pLen;
    const char *cp = NULL;
    if (pval) cp = Jsi_ValueString(interp, pval, &pLen);
    if (argc>1 && cp && !Jsi_Strchr(cp, '%')) {
        nargs = Jsi_ValueDup(interp, args);
        Jsi_ValueArrayShift(interp, nargs);
    }
    Jsi_RC rc = Jsi_FormatString(interp, nargs, &dStr);
    if (nargs != args)
        Jsi_DecrRefCount(interp, nargs);
    if (rc != JSI_OK)
        return rc;
    if (nargs != args) {
        int dlen = Jsi_DSLength(&dStr);
        Jsi_DSSetLength(&dStr, dlen+pLen+1);
        char *cd = Jsi_DSValue(&dStr);
        memmove(cd+pLen, cd, dlen+1);
        memcpy(cd, cp, pLen);
    }
    cp = Jsi_DSValue(&dStr);

    rc = SysPutsCmd_(interp, NULL, _this, ret, funcPtr, 1, &interp->logOpts, cp);
    Jsi_DSFree(&dStr);
    return rc;
}

static Jsi_RC consolePutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    jsi_LogOptions lo = {};
    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, (interp->tracePuts?&interp->logOpts:&lo), NULL);
}

#define FN_puts JSI_INFO("\
Each argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.")
static Jsi_RC SysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    jsi_LogOptions lo = {};
    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, (interp->tracePuts?&interp->logOpts:&lo), NULL);
}

static Jsi_RC SysLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, &interp->logOpts, NULL);
}

typedef struct {
    jsi_AssertMode mode;
    bool noStderr;
} AssertData;

static Jsi_OptionSpec AssertOptions[] = {
    JSI_OPT(CUSTOM, AssertData, mode,     .help="Action when assertion is false. Default from Interp.assertMode", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),
    JSI_OPT(BOOL,   AssertData, noStderr, .help="Logged msg to stdout. Default from Interp.noStderr" ),
    JSI_OPT_END(AssertData, .help="Options for assert command")
};

static char *jsi_GetCurPSLine(Jsi_Interp *interp) {
    char *cp = NULL;
    int line = interp->curIp->Line;
    if (interp->framePtr->ps &&  (cp=interp->framePtr->ps->lexer->d.str))
        while (line-- > 1)
            if ((cp = Jsi_Strchr(cp, '\n'))) cp++;
    return cp;
}
    
#define FN_assert JSI_INFO("\
Assert does nothing by default, but can be \
enabled with \"use asserts\" or setting Interp.asserts.")
Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (!interp->asserts)
        return JSI_OK;
    int rc = 0;
    Jsi_RC rv = JSI_OK;
    Jsi_Number d;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *msg = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);
    //int hasopts = 0;
    bool b;
    AssertData udata = {
        .mode=interp->assertMode,
        .noStderr=interp->noStderr
    };
    
    if (opts != NULL) {
        if (opts->vt == JSI_VT_OBJECT) {
            //hasopts = 1;
            if (Jsi_OptionsProcess(interp, AssertOptions, &udata, opts, 0) < 0) {
                return JSI_ERROR;
            }
        } else //if (opts->vt != JSI_VT_NULL)
            return Jsi_LogError("arg 3: expected object assert options");
    }

    if (Jsi_ValueGetNumber(interp,v, &d) == JSI_OK)
        rc = (int)d;
    else if (Jsi_ValueGetBoolean(interp,v, &b) == JSI_OK)
        rc = b;
    else if (Jsi_ValueIsFunction(interp, v)) {
        if (!msg) {
        }
        Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, v, vpargs, ret, NULL);
        Jsi_DecrRefCount(interp, vpargs);
        bool b;
        if (Jsi_ValueGetNumber(interp, *ret, &d) == JSI_OK)
            rc = (int)d;
        else if (Jsi_ValueGetBoolean(interp, *ret, &b) == JSI_OK)
            rc = b;
        else 
            return Jsi_LogError("invalid function assert");
    } else 
        return Jsi_LogError("invalid assert");
    if (rc == 0) {
        char mbuf[1024];
        mbuf[0] = 0;
        if (!msg) {
            char *ce, *cp = jsi_GetCurPSLine(interp);
            if (cp) {
                cp = Jsi_Strstr(cp, "assert(");
                while (cp && *cp && isspace(*cp)) cp++;
                if (cp) {
                    Jsi_Strncpy(mbuf, cp, sizeof(mbuf)-1);
                    mbuf[sizeof(mbuf)-1] = 0;
                    ce=Jsi_Strstr(mbuf, ");");
                    if (ce) {
                        ce[1] = 0;
                        msg = mbuf;
                    }
                }
            }
            if (!msg)
                msg = "ASSERT";
        }
        //Jsi_ValueDup2(interp, ret, v);
        if (udata.mode != jsi_AssertModeThrow) {
            Jsi_DString dStr;
            jsi_LogOptions lo = {}, *loPtr = ((udata.mode==jsi_AssertModeLog || interp->tracePuts)?&interp->logOpts:&lo);
            Jsi_DSInit(&dStr);
            const char *imsg = Jsi_DSAppend(&dStr, msg, NULL);
            SysPutsCmd_(interp, NULL, _this, ret, funcPtr, !udata.noStderr, loPtr, imsg);
            Jsi_DSFree(&dStr);
        } else
            rv = Jsi_LogError("%s", msg);
    }
    Jsi_ValueMakeUndef(interp, ret);
    return rv;
}

typedef struct {
    bool utc;
    const char *fmt;
} DateOpts;

static Jsi_OptionSpec DateOptions[] = {
    JSI_OPT(BOOL,   DateOpts, utc, .help="time is in utc" ),
    JSI_OPT(STRKEY, DateOpts, fmt, .help="format string for time" ),
    {JSI_OPTION_END}
};

static const char *timeFmts[] = {
    "%Y-%m-%d %H:%M:%S",
    "%Y-%m-%dT%H:%M:%S",
    "%Y-%m-%d %H:%M:%S",
    "%Y-%m-%d %H:%M",
    "%Y-%m-%dT%H:%M",
    "%Y-%m-%d",
    "%H:%M:%S",
    "%H:%M",
    "%c",
    NULL
};

Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr)
{
    char fmt1[BUFSIZ];
    const char *rv = NULL;
    Jsi_Wide n = -1;
    int j = 0, tofs = 0;
    Jsi_RC rc = JSI_OK;
    Jsi_Number ms = 0;
    struct tm tm = {};
    time_t t;
    if (!Jsi_Strcmp("now", str)) {
        struct timeval tv;
        struct timezone tz;
        gettimeofday(&tv, &tz);
        n = tv.tv_sec*1000LL + ((Jsi_Wide)tv.tv_usec)/1000LL;
        if (isUtc) {
            n += 60 * tz.tz_minuteswest;
        }
        if (datePtr)
            *datePtr = (Jsi_Number)n;
        return rc;
    }
    if (fmt && fmt[0]) {
        const char *efp = Jsi_Strstr(fmt, "%f");
        if (efp && efp > fmt && efp[-1] != '%' && (Jsi_Strlen(fmt)+10)<(int)sizeof(fmt1)) {
            snprintf(fmt1, sizeof(fmt1), "%.*s:%%S.", (int)(efp-fmt), fmt);
            fmt = fmt1;
        }
        rv = strptime(str, fmt, &tm);
    } else {
        if (fmt) j++;
        while (timeFmts[j]) {
            rv = strptime(str, timeFmts[j], &tm);
            if (rv != NULL)
                break;
            j++;
        }
    }
    if (!rv)
        rc = Jsi_LogError("parse failed");
    else {
        if (*rv == '.' && isdigit(rv[1]) && isdigit(rv[2]) && isdigit(rv[3])) {
            ms = atof(rv+1);
            rv += 4;
        }
        if (isUtc) {
#ifdef __WIN32
#ifdef JSI_IS64BIT
            t = internal_timegm(&tm);
#else
            t = _mkgmtime(&tm); // TODO: undefined in mingw 64
#endif
#else
            t = timegm(&tm);
#endif
        } else {
            int th, ts;
            char ss[3];
            t = mktime(&tm);
            //TODO: dst
            /*if (tm.tm_isdst)
                t -= 3600;*/
            if (rv[0] == ' ') rv++;
            if (sscanf(rv, "%[+-]%2d:%2d", ss, &th, &ts) == 3) {
                int sign = (rv[0] == '-' ? 1 : -1);
                tofs = (3600*th+60*ts)*sign;
            }
        }
        if (t==-1)
            rc = Jsi_LogError("mktime failed");
        n = (Jsi_Number)(t+tofs)*1000 + ms;
    }
    if (rc == JSI_OK && datePtr)
        *datePtr = (Jsi_Number)n;
    return rc;
}

Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number num, const char *fmt, int isUtc, Jsi_DString *dStr)
{
    char buf[BUFSIZ], fmt1[BUFSIZ], fmt2[BUFSIZ];
    time_t tt;
    Jsi_RC rc = JSI_OK;
    fmt2[0] = 0;
    
    tt = (time_t)(num/1000);
    if (fmt==NULL)
        fmt = timeFmts[0];
    else if (*fmt == 0) {
        if (!isUtc)
            fmt = timeFmts[1];
        else
            fmt = timeFmts[2];
    }
    
    const char *efp = Jsi_Strstr(fmt, "%f");
    if (efp && efp > fmt && efp[-1] != '%' && ((efp-fmt)+10)<(int)sizeof(fmt1)) {
        int elen = (efp-fmt)+1;
        Jsi_Strncpy(fmt1, fmt, elen);
        Jsi_Strcpy(fmt1+elen, "%S.");
        Jsi_Strcpy(fmt2, efp+2);
        fmt = fmt1;
    } else
        efp = NULL;
    struct tm tm, *tmp=&tm;
#ifdef __WIN32
    if (isUtc)
        tmp = gmtime(&tt);
    else
        tmp = localtime(&tt);
#else
    if (isUtc)
        gmtime_r(&tt, &tm);
    else
        localtime_r(&tt, &tm);
#endif
    buf[0] = 0;
    int rr = strftime(buf, sizeof(buf), fmt, tmp);
       
    if (rr<=0)
        rc = Jsi_LogError("time format error: %d", (int)tt);
    else {
        Jsi_DSAppendLen(dStr, buf, -1);
        if (efp) {
            snprintf(buf, sizeof(buf), "%3.3d", (int)(((Jsi_Wide)num)%1000));
            Jsi_DSAppendLen(dStr, buf[1]=='.'?buf+2:buf, -1);
        }
    }
    if (rc == JSI_OK && fmt2[0]) {
        buf[0] = 0;
        int rr = strftime(buf, sizeof(buf), fmt2, tmp);
           
        if (rr<=0)
            rc = Jsi_LogError("time format error");
        else
            Jsi_DSAppendLen(dStr, buf, -1);
    }
    return rc;
}

/* Get time in milliseconds since Jan 1, 1970 */
Jsi_Number Jsi_DateTime(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    Jsi_Number num = ((Jsi_Number)tv.tv_sec*1000.0 + (Jsi_Number)tv.tv_usec/1000.0);
    return num;
}

double jsi_GetTimestamp(void) {
#ifdef __WIN32
    return Jsi_DateTime()/1000;
#else
    struct timespec tv;
    clock_gettime(CLOCK_MONOTONIC, &tv);
    return (double)tv.tv_sec + (double)tv.tv_nsec/1000000000.0;
#endif
}


static Jsi_RC DateStrptimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number w = 0;
    int isOpt = 0;
    DateOpts opts = {};
    const char *fmt = NULL;
    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {
        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {
            return JSI_ERROR;
        }
        isOpt = 1;
        fmt = opts.fmt;
    }
    if (!str)
        str = "now";
    Jsi_RC rc = Jsi_DatetimeParse(interp, str, fmt, opts.utc, &w);
    if (rc != JSI_OK) {
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
        rc = JSI_ERROR;
    } else
        Jsi_ValueMakeNumber(interp, ret, w);
    if (isOpt)
        Jsi_OptionsFree(interp, DateOptions, &opts, 0);
    return rc;
}

#define FN_strftime JSI_INFO("\
Null or no value will use current time.")
static Jsi_RC DateStrftimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* opt = Jsi_ValueArrayIndex(interp, args, 1);
    const char *fmt = NULL;//, *cp = NULL;
    DateOpts opts = {};
    Jsi_Number num;
    int isOpt = 0;
    Jsi_RC rc = JSI_OK;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    
    if (val==NULL || Jsi_ValueIsNull(interp, val)) {
        num = 1000.0 * (Jsi_Number)time(NULL);
   /* } else if ((cp=Jsi_ValueString(interp, val, NULL))) {*/
        /* Handle below */
    } else if (Jsi_GetDoubleFromValue(interp, val, &num) != JSI_OK)
        return JSI_ERROR;
        
    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {
        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {
            return JSI_ERROR;
        }
        isOpt = 1;
        fmt = opts.fmt;
    }
    const char *errMsg = "time format error";
/*    if (cp) {
        if (isdigit(*cp))
            rc = Jsi_GetDouble(interp, cp, &num);
        else {
            if (Jsi_Strcmp(cp,"now")==0) {
                num = Jsi_DateTime();
            } else {
                rc = JSI_ERROR;
                errMsg = "allowable strings are 'now' or digits";
            }
        }
    }*/
    if (rc == JSI_OK)
        rc = Jsi_DatetimeFormat(interp, num, fmt, opts.utc, &dStr);
    if (rc != JSI_OK)
        Jsi_LogError("%s", errMsg);
    else
        Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    if (isOpt)
        Jsi_OptionsFree(interp, DateOptions, &opts, 0);
    Jsi_DSFree(&dStr);
    return rc;
}

#define FN_infovars JSI_INFO("\
Returns all values, data or function.")
static Jsi_RC InfoVarsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *key;
    int n, curlen = 0, isreg = 0, isobj = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Value *v;
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    const char *name = NULL;

    if (arg) {
        if (arg->vt == JSI_VT_STRING)
            name = arg->d.s.str;
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_FUNCTION:
                case JSI_OT_OBJECT: isobj = 1; break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    if (!name)
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    if (isobj) {
        Jsi_TreeEntry* tPtr;
        Jsi_TreeSearch search;
        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);
            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
            v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
            if (v==NULL || Jsi_ValueIsFunction(interp, v)) continue;
    
            n = curlen++;
            key = (char*)Jsi_TreeKeyGet(tPtr);
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
        }
        Jsi_TreeSearchDone(&search);
        return JSI_OK;
    }
    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        if (Jsi_HashValueGet(hPtr))
            continue;
        key = (char*)Jsi_HashKeyGet(hPtr);
        if (name) {
            if (Jsi_Strcmp(name,key))
                continue;
            Jsi_ValueMakeObject(interp, ret, nobj);
            v = Jsi_VarLookup(interp, key);
            Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp,Jsi_ValueTypeStr(interp, v)),0);
            Jsi_ValueMakeObject(interp, ret, nobj);
            return JSI_OK;
        }
        if (isreg) {
            int ismat;
            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
            if (!ismat)
                continue;
        }
        n = curlen++;
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
    }
    return JSI_OK;
}

static Jsi_Value *jsiNewConcatValue(Jsi_Interp *interp, const char *c1, const char *c2)
{
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppend(&dStr, c1, c2, NULL);
    Jsi_Value *val = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return val;
}

static Jsi_RC InfoFuncDataSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int flags, Jsi_Obj *nobj)
{
    const char *key, *name = NULL, *ename;
    int n, curlen = 0, isreg = 0, isobj = 0, isglob = 0, nLen = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_FuncObj *fo;
    Jsi_Func *func;
    Jsi_Obj *fobj;
    Jsi_Value *val, *nval;
    int isfunc = (flags&1);
    int isdata = (flags&2);
    int addPre = (flags&4);
    Jsi_DString dPre = {};
    
    if (!nobj) {
        nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    }
    
    if (!arg)
        name = "*";
    else {
        if (arg->vt == JSI_VT_STRING)
            name = Jsi_ValueString(interp, arg, &nLen);
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = Jsi_ValueString(interp, arg, &nLen); break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_OBJECT: isobj = 1; break;
                case JSI_OT_FUNCTION:
                    fo = arg->d.obj->d.fobj;
                    if (fo->func->type&FC_BUILDIN)
                        return JSI_OK;
                    goto dumpfunc;
                break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    ename = name;
    if (isobj) {
        Jsi_TreeEntry* tPtr;
        Jsi_TreeSearch search;

dumpobj:
        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);
            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
            Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
            key = (char*)Jsi_TreeKeyGet(tPtr);
            if (v==NULL) continue;
            if (Jsi_ValueIsFunction(interp, v)) {
                if (!isfunc) continue;
            } else {
                if (!isdata) continue;
            }
            if (isreg) {
                int ismat;
                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
                if (!ismat)
                    continue;
            } else if (ename) {
                if (isglob) {
                    if (!Jsi_GlobMatch(ename, key, 0))
                        continue;
                } else {
                    if (Jsi_Strcmp(ename, key))
                        continue;
                }
            }
    
            n = curlen++;
            nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):""), key);
            Jsi_ObjArraySet(interp, nobj, nval, n);
        }
        Jsi_TreeSearchDone(&search);
        Jsi_DSFree(&dPre);
        return JSI_OK;
    }
    
    Jsi_ScopeStrs *sstrs;            
    const char *gs, *gb, *dotStr;
    
    if (name) {
        val = Jsi_NameLookup(interp, name);
        if (val)
            goto dumpvar;
        gs=Jsi_Strchr(name,'*');
        gb=Jsi_Strchr(name,'[');
        dotStr = Jsi_Strrchr(name, '.');
        if (dotStr && ((gs && gs < dotStr) || (gb && gb < dotStr))) 
            return Jsi_LogError("glob must be after last dot");
        isglob = (gs || gb);
        if (!isglob)
            return JSI_OK;
        if (dotStr) {
            if (addPre)
                Jsi_DSAppendLen(&dPre, name, dotStr-ename+1);
            ename = dotStr+1;
            Jsi_DString pStr = {};
            Jsi_DSAppendLen(&pStr, name, dotStr-name);
            val = Jsi_NameLookup(interp, Jsi_DSValue(&pStr));
            Jsi_DSFree(&pStr);
            if (!val)
                return JSI_OK;
            if (Jsi_ValueIsObjType(interp, val, JSI_OT_OBJECT)) {
                arg = val;
                goto dumpobj;
            }
            return JSI_OK;
        } 
    }
        
    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        key = (char*)Jsi_HashKeyGet(hPtr);
        if (!isfunc)
            goto doreg;
        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))
            continue;
        if (isfunc && name && isreg==0 && isglob==0) {

            if (Jsi_Strcmp(key, name))
                continue;
            /* Fill object with args and locals of func. */
            fo = fobj->d.fobj; 
            goto dumpfunc;
        }
doreg:
        if (isreg) {
            int ismat;
            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
            if (!ismat)
                continue;
        } else if (name) {
            if (isglob) {
                if (!Jsi_GlobMatch(name, key, 0))
                    continue;
            } else {
                if (Jsi_Strcmp(name, key))
                    continue;
            }
        }
        n = curlen++;
        nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):""), key);
        Jsi_ObjArraySet(interp, nobj, nval, n);
    }
    Jsi_DSFree(&dPre);
    return JSI_OK;

dumpfunc:
{
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    func = fo->func;
    sstrs = func->argnames;
    int sscnt = (sstrs?sstrs->count:0);
    const char *strs[sscnt+1];
    int i;
    for (i=0; i<sscnt; i++)
        strs[i] = sstrs->args[i].name;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_Value *aval = Jsi_ValueNewArray(interp, strs, sscnt);
    Jsi_ObjInsert(interp, nobj, "argList", aval, 0);
    sstrs = func->localnames;
    Jsi_Value *lval = Jsi_ValueNewArray(interp, strs, sscnt);
    Jsi_ObjInsert(interp, nobj, "locals", lval, 0);
    jsi_FuncArgsToString(interp, func, &dStr, 1);
    lval = Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr));
    Jsi_ObjInsert(interp, nobj, "args", lval, 0);
    Jsi_DSFree(&dStr);
    if (func->retType)
        Jsi_ObjInsert(interp, nobj, "retType", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, func->retType, &dStr)), 0);
    Jsi_DSFree(&dStr);
    if (func->script) {
        lval = Jsi_ValueNewStringKey(interp, func->script);
        Jsi_ObjInsert(interp, nobj, "script", lval, 0);
        int l1 = func->opcodes->codes->Line;
        int l2 = func->bodyline.last_line;
        if (l1>l2) { int lt = l1; l1 = l2; l2 = lt; }
        lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l1);
        Jsi_ObjInsert(interp, nobj, "lineStart", lval, 0);
        lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l2);
        Jsi_ObjInsert(interp, nobj, "lineEnd", lval, 0);
    }
    return JSI_OK;
}
dumpvar:
    if (isfunc && Jsi_ValueIsFunction(interp, val)) {
        fo = val->d.obj->d.fobj;
        goto dumpfunc;
    }
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    Jsi_Value *aval = Jsi_ValueNewStringDup(interp, ename);
    Jsi_ObjInsert(interp, nobj, "name", aval, 0);
    aval = Jsi_ValueNewStringDup(interp, jsi_ValueTypeName(interp, val));
    Jsi_ObjInsert(interp, nobj, "type", aval, 0);
    return JSI_OK;
}

static Jsi_RC InfoLookupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!str)
        return JSI_OK;
    Jsi_Value *val = Jsi_NameLookup(interp, str);
    if (!val)
        return JSI_OK;
    Jsi_ValueDup2(interp, ret, val);
    return JSI_OK;
}


#define FN_infolevel JSI_INFO("\
With no arg, returns the number of the current stack frame level.\
Otherwise returns details on the specified level. \
The topmost level is 1, and 0 is the current level, \
and a negative level translates as relative to the current level.")
static Jsi_RC InfoLevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    uint argc =  Jsi_ValueGetLength(interp, args);
    if (argc<=0) {
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)interp->framePtr->level);
        return JSI_OK;
    }
    Jsi_Number num = 0;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    jsi_Frame *f = interp->framePtr;
    if (Jsi_GetNumberFromValue(interp, arg, &num) != JSI_OK)
        return JSI_ERROR;
    int lev = (int)num;
    if (lev <= 0)
        lev = f->level+lev;
    if (lev <= 0 || lev > f->level) 
        return Jsi_LogError("level %d not between 1 and %d", (int)num, f->level);
    while (f->level != lev  && f->parent)
        f = f->parent;
    char buf[BUFSIZ];
    //int line = (f != interp->framePtr ? f->line : (interp->curIp ? interp->curIp->Line : 0));
    int line = (f->line ? f->line : (interp->curIp ? interp->curIp->Line : 0));
    snprintf(buf, sizeof(buf), "{funcName:\"%s\", fileName:\"%s\", line:%d, level:%d, tryDepth:%d, withDepth:%d}",
        f->funcName?f->funcName:"", f->fileName?f->fileName:"", line, f->level, f->tryDepth, f->withDepth
        );
    
    Jsi_RC rc = Jsi_JSONParse(interp, buf, ret, 0);
    if (rc != JSI_OK)
        return rc;
    Jsi_Func *who = f->evalFuncPtr;
    Jsi_Obj *obj = Jsi_ObjNewArray(interp, NULL, 0, 0);
    Jsi_Value *val = Jsi_ValueMakeArrayObject(interp, NULL, obj);
    if (who && who->localnames) {
        int i;
        for (i = 0; i < who->localnames->count; ++i) {
            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);
            Jsi_Value *v = Jsi_ValueMakeStringKey(interp, NULL, argkey);
            Jsi_ObjArrayAdd(interp, obj, v);

        }
    }
    Jsi_ValueInsert(interp, *ret, "locals", val, 0);
    Jsi_ValueInsert(interp, *ret, "scope", f->incsc, 0);
    Jsi_ValueInsert(interp, *ret, "inthis", f->inthis, 0);
    return rc;
}

static Jsi_RC InfoFilesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return Jsi_HashKeysDump(interp, interp->fileTbl, ret, 0);
}

static Jsi_RC InfoFuncsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);
}

#define FN_infodata JSI_INFO("\
Like info.vars(), but does not return function values.")
static Jsi_RC InfoDataCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 2, NULL);
}

static Jsi_RC InfoKeywordsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->lexkeyTbl) {
        Jsi_HashKeysDump(interp, interp->lexkeyTbl, ret, 0);
        Jsi_ValueArraySort(interp, *ret, 0);
    }
    return JSI_OK;
}

static Jsi_RC InfoOptionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    uint i, argc =  Jsi_ValueGetLength(interp, args);
    Jsi_DString dStr = {};
    const char *str;
    bool bv = 0;
    if (argc && Jsi_GetBoolFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &bv) != JSI_OK)
        return JSI_ERROR;
    Jsi_DSAppend(&dStr, "[", NULL);
    for (i=1; (str = jsi_OptionTypeStr((Jsi_OptionId)i, bv));i++)
        Jsi_DSAppend(&dStr, (i>1?", ":""), "\"", str, "\"", NULL);
    Jsi_DSAppend(&dStr, "]", NULL);
    Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    return JSI_OK;
}
static Jsi_RC InfoVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char buf[BUFSIZ];
    const char *cp;
    if (!arg)
        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());
    else if ((cp=Jsi_ValueString(interp, arg, NULL))) {
        snprintf(buf, sizeof(buf), "%d%s%d%s%d",
            JSI_VERSION_MAJOR, cp, JSI_VERSION_MINOR, cp, JSI_VERSION_RELEASE);
        Jsi_ValueMakeStringDup(interp, ret, buf);
    } else if (!Jsi_ValueIsTrue(interp, arg))
        return Jsi_LogError("expected string or bool");
    else {
        snprintf(buf, sizeof(buf),
            "{major:%d, minor:%d, release:%d}",
            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);
        
        return Jsi_JSONParse(interp, buf, ret, 0);
    }
    return JSI_OK;
}


static Jsi_RC InfoIsMainCmd (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int isi = (interp->isMain);
    if (isi == 0) {
        const char *c2 = interp->curFile;
        Jsi_Value *v1 = interp->argv0;
        if (c2 && v1 && Jsi_ValueIsString(interp, v1)) {
            char *c1 = Jsi_ValueString(interp, v1, NULL);
            isi = (c1 && !Jsi_Strcmp(c1,c2));
        }
    }
    //if (interp->noIsMain)
        //isi = 0;
    Jsi_ValueMakeBool(interp, ret, isi);
    return JSI_OK;
}

static Jsi_RC InfoArgv0Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->argv0)
        Jsi_ValueDup2(interp, ret, interp->argv0);
     return JSI_OK;
}

static Jsi_RC InfoExecZipCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->execZip)
        Jsi_ValueDup2(interp, ret, interp->execZip);
     return JSI_OK;
}

#ifndef JSI_OMIT_DEBUG
static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (!interp->breakpointHash)
        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);
    int argc = Jsi_ValueGetLength(interp, args);
    jsi_BreakPoint *bptr, bp = {};
    Jsi_Number vnum;
    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) 
        return Jsi_LogError("bad boolean");
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {
        bp.line = (int)vnum;
        bp.file = interp->curFile;
    } else {
        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
        const char *cp;
        
        if (isdigit(val[0])) {
            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) 
                return Jsi_LogError("bad number");
            bp.file = interp->curFile;
        } else if ((cp = Jsi_Strchr(val, ':'))) {
            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) 
                return Jsi_LogError("bad number");
            Jsi_DString dStr = {};
            Jsi_DSAppendLen(&dStr, val, cp-val);
            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));
            Jsi_DSFree(&dStr);
        } else {
            bp.func = Jsi_KeyAdd(interp, val);
        }
    }
    if (bp.line<=0 && !bp.func) 
        return Jsi_LogError("bad number");
    char nbuf[100];
    bp.id = ++interp->debugOpts.breakIdx;
    bp.enabled = 1;
    snprintf(nbuf, sizeof(nbuf), "%d", bp.id);
    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));
    *bptr = bp;
    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);
    return JSI_OK;
}

static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int op)
{
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    if (interp->breakpointHash)
    {
        int num;
        char nbuf[100];
        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) 
            return Jsi_LogError("bad number");
        
        snprintf(nbuf, sizeof(nbuf), "%d", num);
        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);
        jsi_BreakPoint* bptr;
        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {
            switch (op) {
                case 1: bptr->enabled = 0; break;
                case 2: bptr->enabled = 1; break;
                default:
                    Jsi_HashEntryDelete(hPtr);
            }
            return JSI_OK;
        }
    }
    return Jsi_LogError("unknown breakpoint");
}

static Jsi_RC DebugRemoveCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, 0);
}

static Jsi_RC DebugEnableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 1);
    bool bval;
    if (Jsi_ValueGetBoolean(interp, val, &bval) != JSI_OK)
        return JSI_ERROR;
    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, bval ? 2 : 1);
}

static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (!interp->breakpointHash) {
        Jsi_ValueMakeArrayObject(interp, ret, NULL);
        return JSI_OK;
    }
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0)
        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    int num;
    char nbuf[100];
    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) 
        return Jsi_LogError("bad number");
    
    snprintf(nbuf, sizeof(nbuf), "%d", num);
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);
    if (!hPtr) 
        return Jsi_LogError("unknown breakpoint");
    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);
    if (!bp) return JSI_ERROR;
    Jsi_DString dStr = {};
    if (bp->func)
        Jsi_DSPrintf(&dStr, "{id:%d, type:\"func\", func:\"%s\", hits:%d, enabled:%s, temporary:%s}",
         bp->id, bp->func, bp->hits, bp->enabled?"true":"false", bp->temp?"true":"false");
    else
        Jsi_DSPrintf(&dStr, "{id:%d, type:\"line\", file:\"%s\", line:%d, hits:%d, enabled:%s}",
            bp->id, bp->file?bp->file:"", bp->line, bp->hits, bp->enabled?"true":"false");
    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}
#endif

static Jsi_RC InfoScriptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    int isreg = 0;
    const char *name = NULL;

    if (!arg) {
        name = jsi_GetCurFile(interp);
    } else {
        if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_FUNCTION: name = arg->d.obj->d.fobj->func->script; break;
                case JSI_OT_REGEXP: isreg = 1; break;
                default: break;
            }
        } else
            return JSI_OK;
    }
    if (isreg) {
        Jsi_HashEntry *hPtr;
        Jsi_HashSearch search;
        int curlen = 0, n;
        const char *key;
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
        for (hPtr = Jsi_HashSearchFirst(interp->fileTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            key = (const char*)Jsi_HashKeyGet(hPtr);
            if (isreg) {
                int ismat;
                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
                if (!ismat)
                    continue;
            }
            n = curlen++;
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
        }
        return JSI_OK;
    }
    if (name)
        Jsi_ValueMakeStringDup(interp, ret, name);
    return JSI_OK;
}

static Jsi_RC InfoScriptDirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = interp->curDir;
    if (path)
        Jsi_ValueMakeString(interp, ret, Jsi_Strdup(path));
    return JSI_OK;
}

static int isBigEndian()
{
    union { unsigned short s; unsigned char c[2]; } uval = {0x0102};
    return uval.c[0] == 1;
}

static Jsi_RC InfoPlatformCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[BUFSIZ];
    size_t crcSizes[] = { sizeof(int), sizeof(void*), sizeof(time_t), sizeof(Jsi_Number), (size_t)isBigEndian() };
#ifdef __WIN32
    const char *os="win", *platform = "win";
#elif defined(__FreeBSD__)
    const char *os="freebsd", *platform = "unix";
#else
    const char *os="linux", *platform = "unix";
#endif
#ifndef JSI_OMIT_THREADS
    int thrd = 1;
#else
    int thrd = 0;
#endif
    if (Jsi_FunctionReturnIgnored(interp, funcPtr))
        return JSI_OK;
    snprintf(buf, sizeof(buf),
        "{os:\"%s\", platform:\"%s\", hasThreads:%s, pointerSize:%zu, timeSize:%zu "
        "intSize:%zu, wideSize:%zu, numberSize:%zu, crc:%x, isBigEndian:%s, confArgs:\"%s\"}",
        os, platform, thrd?"true":"false", sizeof(void*), sizeof(time_t), sizeof(int),
        sizeof(Jsi_Wide), sizeof(Jsi_Number), Jsi_Crc32(0, (uchar*)crcSizes, sizeof(crcSizes)),
        isBigEndian()? "true" : "false", interp->confArgs);
        
    return Jsi_JSONParse(interp, buf, ret, 0);
}

static Jsi_RC InfoNamedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj;
    char *argStr = NULL;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg  && (argStr = (char*)Jsi_ValueString(interp, arg, NULL)) == NULL) 
        return Jsi_LogError("expected string");
    if (argStr && argStr[0] == '#') {
        Jsi_Obj *obj = jsi_UserObjFromName(interp, argStr);
        if (!obj) 
            return Jsi_LogError("Unknown object: %s", argStr);
        Jsi_ValueMakeObject(interp, ret, obj);
        return JSI_OK;
    }
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return jsi_UserObjDump(interp, argStr, nobj);
}


const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema) {
    const Jsi_OptionSpec *send;
    for (send = specs; send->id>=JSI_OPTION_BOOL && send->id<JSI_OPTION_END; send++) ;
    if (!send)
        return NULL;
    if (schema) {
        char tbuf[100];
        int i = 0;
        if (send->name)
            Jsi_DSAppend(dStr, "  -- '", send->name, "\': ", NULL);
        if (send->help)
            Jsi_DSAppend(dStr,  send->help, NULL);
        Jsi_DSAppend(dStr, "\n", NULL);
        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {
            const char *tstr = NULL;
            if (specs->flags&JSI_OPT_DB_DIRTY)
                continue;
            if (!Jsi_Strcmp(specs->name, "rowid"))
                continue;
            switch(specs->id) {
            case JSI_OPTION_BOOL: tstr = "BOOLEAN"; break;
            case JSI_OPTION_TIME_T: tstr = "TIMESTAMP"; break;
            case JSI_OPTION_TIME_D:
            case JSI_OPTION_TIME_W:
                if (specs->flags & JSI_OPT_TIME_TIMEONLY)
                    tstr = "TIME";
                else if (specs->flags & JSI_OPT_TIME_TIMEONLY)
                    tstr = "DATE";
                else
                    tstr = "DATETIME";
                break;
            case JSI_OPTION_SIZE_T:
            case JSI_OPTION_SSIZE_T:
            case JSI_OPTION_INTPTR_T:
            case JSI_OPTION_UINTPTR_T:
            case JSI_OPTION_UINT:
            case JSI_OPTION_INT:
            case JSI_OPTION_ULONG:
            case JSI_OPTION_LONG:
            case JSI_OPTION_USHORT:
            case JSI_OPTION_SHORT:
            case JSI_OPTION_UINT8:
            case JSI_OPTION_UINT16:
            case JSI_OPTION_UINT32:
            case JSI_OPTION_UINT64:
            case JSI_OPTION_INT8:
            case JSI_OPTION_INT16:
            case JSI_OPTION_INT32:
            case JSI_OPTION_INT64: tstr = "INT"; break;
            case JSI_OPTION_FLOAT:
            case JSI_OPTION_NUMBER:
            case JSI_OPTION_LDOUBLE:
            case JSI_OPTION_DOUBLE: tstr = "FLOAT"; break;
            
            case JSI_OPTION_STRBUF:
                tstr = tbuf;
                snprintf(tbuf, sizeof(tbuf), "VARCHAR(%d)", specs->size);;
                break;
            case JSI_OPTION_DSTRING: 
            case JSI_OPTION_STRKEY:
            case JSI_OPTION_STRING:
                tstr = "TEXT";
                break;
            case JSI_OPTION_CUSTOM:
                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {
                    if (specs->flags&JSI_OPT_FORCE_INT)
                        tstr = "INT";
                    else
                        tstr = "TEXT";
                } else
                    tstr = "";
                break;
            case JSI_OPTION_VALUE: /* Unsupported. */
            case JSI_OPTION_VAR:
            case JSI_OPTION_OBJ:
            case JSI_OPTION_ARRAY:
            case JSI_OPTION_FUNC:
            case JSI_OPTION_USEROBJ:
            case JSI_OPTION_REGEXP:
                break;
#ifdef __cplusplus
            case JSI_OPTION_END:
#else
            default:
#endif
                Jsi_LogBug("invalid option type: %d", specs->id);
            }
            
            if (!tstr) continue;
            Jsi_DSAppend(dStr, (i?"\n ,":"  "), specs->name, " ", (tstr[0]?tstr:specs->tname), NULL);

            const char *cp;
            if ((cp=specs->userData)) {
                const char *udrest = NULL;
                if (!Jsi_Strcmp(cp, "DEFAULT")) {
                    if ((specs->id == JSI_OPTION_TIME_D || specs->id <= JSI_OPTION_TIME_T)) {
                        if (specs->flags & JSI_OPT_TIME_DATEONLY)
                            udrest = "(round((julianday('now') - 2440587.5)*86400000))";
                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)
                            udrest = "(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400000))";
                        else
                            udrest = "(round((julianday('now') - 2440587.5)*86400000.0))";
                    } else if (specs->id <= JSI_OPTION_TIME_T) {
                        if (specs->flags & JSI_OPT_TIME_DATEONLY)
                            udrest = "(round((julianday('now') - 2440587.5)*86400))";
                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)
                            udrest = "(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400))";
                        else
                            udrest = "(round((julianday('now') - 2440587.5)*86400.0))";
                    }
                }
                Jsi_DSAppend(dStr, " ", cp, udrest, NULL);
            }
            if (specs->help)
                Jsi_DSAppend(dStr, " -- ", specs->help, NULL);
            if (specs->id==JSI_OPTION_END)
                break;
            i++;
        }
        if (send->userData)
            Jsi_DSAppend(dStr,  send->userData, NULL);
        Jsi_DSAppend(dStr, "\n  -- MD5=", NULL);

    } else {
        int i = 0;
        Jsi_DSAppend(dStr, "\n/* ", send->name, ": ", NULL);
        if (send->help)
            Jsi_DSAppend(dStr,  send->help, NULL);
        Jsi_DSAppend(dStr, " */\ntypedef struct ",  send->name, " {", NULL);
        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {
            int nsz = 0;
            const char *tstr = NULL;
            switch(specs->id) {
            case JSI_OPTION_STRBUF: nsz=1;
            case JSI_OPTION_BOOL:
            case JSI_OPTION_TIME_T:
            case JSI_OPTION_TIME_W:
            case JSI_OPTION_TIME_D:;
            case JSI_OPTION_SIZE_T:
            case JSI_OPTION_SSIZE_T:
            case JSI_OPTION_INTPTR_T:
            case JSI_OPTION_UINTPTR_T:
            case JSI_OPTION_INT:
            case JSI_OPTION_UINT:
            case JSI_OPTION_LONG:
            case JSI_OPTION_ULONG:
            case JSI_OPTION_SHORT:
            case JSI_OPTION_USHORT:
            case JSI_OPTION_UINT8:
            case JSI_OPTION_UINT16:
            case JSI_OPTION_UINT32:
            case JSI_OPTION_UINT64:
            case JSI_OPTION_INT8:
            case JSI_OPTION_INT16:
            case JSI_OPTION_INT32:
            case JSI_OPTION_INT64:
            case JSI_OPTION_FLOAT:
            case JSI_OPTION_DOUBLE:
            case JSI_OPTION_LDOUBLE:
            case JSI_OPTION_NUMBER:
            case JSI_OPTION_DSTRING:
            case JSI_OPTION_STRKEY: 
            case JSI_OPTION_STRING:
                tstr = jsi_OptionTypeStr(specs->id, 1); 
                break;
            case JSI_OPTION_CUSTOM:
                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {
                    tstr = "int";
                } else {
                    tstr = "char";
                    nsz = 1;
                }
                break;
            case JSI_OPTION_VALUE: /* Unsupported. */
            case JSI_OPTION_VAR:
            case JSI_OPTION_OBJ:
            case JSI_OPTION_ARRAY:
            case JSI_OPTION_REGEXP:
            case JSI_OPTION_FUNC:
            case JSI_OPTION_USEROBJ:
                break;
#ifdef __cplusplus
            case JSI_OPTION_END:
#else
            default:
#endif
                Jsi_LogBug("invalid option type: %d", specs->id);
            }
            
            if (!tstr) continue;
            Jsi_DSAppend(dStr, "\n    ", tstr, " ", specs->name, NULL);
            if (nsz) {
                Jsi_DSPrintf(dStr, "[%d]", specs->size);
            }
            Jsi_DSAppend(dStr, ";", NULL);
            if (specs->help)
                Jsi_DSAppend(dStr, " /* ", specs->help, " */", NULL);
            if (specs->id==JSI_OPTION_END)
                break;
            i++;
        }
        Jsi_DSAppend(dStr, "\n};\n// MD5=", NULL);

    }
    char buf[33];
    Jsi_CryptoHash(buf, Jsi_DSValue(dStr), Jsi_DSLength(dStr), Jsi_CHash_MD5, 0, 0);
    //Jsi_Md5Str(buf, Jsi_DSValue(dStr), -1);
    Jsi_DSAppend(dStr, buf, NULL);

    return Jsi_DSValue(dStr);
}

static Jsi_RC InfoExecutableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (jsi_execName == NULL)
        Jsi_ValueMakeNull(interp, ret);
    else
        Jsi_ValueMakeStringKey(interp, ret, jsi_execName);
    return JSI_OK;
}

#define FN_infoevent JSI_INFO("\
With no args, returns list of all outstanding events.  With one arg, returns info\
for the given event id.")

#ifndef JSI_OMIT_EVENT
static Jsi_RC InfoEventCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    uint n = 0;
    int nid;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Obj *nobj;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    if (arg && Jsi_GetIntFromValue(interp, arg, &nid) != JSI_OK)
        return JSI_ERROR;
    if (!arg) {
        nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    }

    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        uintptr_t id;
        id = (uintptr_t)Jsi_HashKeyGet(hPtr);
        if (!arg) {
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewNumber(interp, (Jsi_Number)id), n);
            n++;
        } else if (id == (uint)nid) {
            Jsi_Event *evPtr = (Jsi_Event *)Jsi_HashValueGet(hPtr);
            Jsi_DString dStr;
            if (!evPtr) return JSI_ERROR;
            Jsi_DSInit(&dStr);
            switch (evPtr->evType) {
                case JSI_EVENT_SIGNAL:
                    Jsi_DSPrintf(&dStr, "{ type:\"signal\", sigNum:%d, count:%u, builtin:%s }", 
                        evPtr->sigNum, evPtr->count, (evPtr->handler?"true":"false") );
                    break;
                case JSI_EVENT_TIMER: {
             
                    long cur_sec, cur_ms;
                    uint64_t ms;
                    jsiGetTime(&cur_sec, &cur_ms);
                    ms = (evPtr->when_sec*1000LL + evPtr->when_ms) - (cur_sec * 1000LL + cur_ms);
                    Jsi_DSPrintf(&dStr, "{ type:\"timer\", once:%s, when:%" PRId64 ", count:%u, initial:%" PRId64 ", builtin:%s }",
                        evPtr->once?"true":"false", (Jsi_Wide)ms, evPtr->count, (Jsi_Wide)evPtr->initialms, (evPtr->handler?"true":"false") );
                    break;
                }
                case JSI_EVENT_ALWAYS:
                    Jsi_DSPrintf(&dStr, "{ type:\"always\", count:%u, builtin:%s }", 
                        evPtr->count, (evPtr->handler?"true":"false") );
                    break;
            }
            Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
            Jsi_DSFree(&dStr);
            return rc;
        }
    }
    return JSI_OK;
}

static Jsi_RC eventInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return InfoEventCmd(interp, args, _this, ret, funcPtr);
}
#endif

static Jsi_RC InfoErrorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    Jsi_ValueInsert( interp, *ret, "file", Jsi_ValueNewStringKey(interp, interp->errFile?interp->errFile:""), 0);
    Jsi_ValueInsert(interp, *ret, "line", Jsi_ValueNewNumber(interp, interp->errLine), 0);
    return JSI_OK;
}

void jsi_DumpCmdSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpec* spec, const char *name)
{
    Jsi_ObjInsert(interp, nobj, "minArgs", Jsi_ValueNewNumber(interp, spec->minArgs),0);
    Jsi_ObjInsert(interp, nobj, "maxArgs", Jsi_ValueNewNumber(interp, spec->maxArgs),0);
    if (spec->help)
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, spec->help),0);
    if (spec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, spec->info),0);
    Jsi_ObjInsert(interp, nobj, "args", Jsi_ValueNewStringKey(interp, spec->argStr?spec->argStr:""),0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_ObjInsert(interp, nobj, "retType", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, spec->retType, &dStr)), 0);
    Jsi_DSFree(&dStr);
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, name?name:spec->name),0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, "command"),0);
    Jsi_ObjInsert(interp, nobj, "flags", Jsi_ValueNewNumber(interp, spec->flags),0);
    if (spec->opts) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, spec->opts);
        Jsi_ObjInsert(interp, nobj, "options", svalue, 0);
    }
}
void jsi_DumpCmdItem(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpecItem* csi, const char *name)
{
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, name), 0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, "object"),0);
    Jsi_ObjInsert(interp, nobj, "constructor", Jsi_ValueNewBoolean(interp, csi && csi->isCons), 0);
    if (csi && csi->help)
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringDup(interp, csi->help),0);
    if (csi && csi->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringDup(interp, csi->info),0);
    if (csi && csi->isCons && csi->spec->argStr)
        Jsi_ObjInsert(interp, nobj, "args", Jsi_ValueNewStringDup(interp, csi->spec->argStr),0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_ObjInsert(interp, nobj, "retType", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, csi->spec->retType, &dStr)), 0);
    Jsi_DSFree(&dStr);
    if (csi && csi->isCons && csi->spec->opts) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, csi->spec->opts);
        Jsi_ObjInsert(interp, nobj, "options", svalue, 0);
    }
}


typedef struct {
    bool full;
    bool constructor;
} InfoCmdsData;

static Jsi_OptionSpec InfoCmdsOptions[] = {
    JSI_OPT(BOOL,   InfoCmdsData, full,  .help="Return full path" ),
    JSI_OPT(BOOL,   InfoCmdsData, constructor, .help="Do not exclude constructor" ),
    JSI_OPT_END(InfoCmdsData, .help="Options for Info.cmds")
};

static Jsi_RC InfoCmdsCmdSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int all, int sort, Jsi_Obj *nobj, int add)
{
    const char *key, *name = NULL, *cp;
    int tail = (add&2);
    int curlen = 0, icnt = 0, isglob = 0, dots = 0, gotFirst = 0, ninc;
    Jsi_MapEntry *hPtr = NULL;
    Jsi_MapSearch search;
    Jsi_CmdSpecItem *csi = NULL;
    Jsi_DString dStr;
    const char *skey;
    Jsi_CmdSpec *spec = NULL;
    
    Jsi_DSInit(&dStr);
    int isreg = 0;

    if (!arg)
        name = "*";
    else {
        if (arg->vt == JSI_VT_STRING)
            name = arg->d.s.str;
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_FUNCTION:
                    spec = arg->d.obj->d.fobj->func->cmdSpec;
                    if (!spec)
                        return JSI_OK;
                    skey = spec->name;
                    goto dumpfunc;
                    break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    ninc = 0;
    isglob = (isreg == 0 && name && (Jsi_Strchr(name,'*') || Jsi_Strchr(name,'[')));
    if (isglob) {
        cp = name;
        while (*cp) { if (*cp == '.') dots++; cp++; }
    }
    while (1) {
        if (++icnt == 1) {
           /* if (0 && name)
                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, "");
            else */ {
                hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);
                gotFirst = 1;
            }
        } else if (icnt == 2 && name && !gotFirst)
            hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);
        else
            hPtr = Jsi_MapSearchNext(&search);
        if (!hPtr)
            break;
        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);
        key = (const char *)Jsi_MapKeyGet(hPtr, 0);
        if (isglob && dots == 0 && *key && Jsi_GlobMatch(name, key, 0) && !Jsi_Strchr(key, '.')) {
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), curlen++);
                ninc++;
        }
        if (isglob == 0 && name && key[0] && Jsi_Strcmp(name, key)==0) {
            skey = (char*)name;
            spec = NULL;
            goto dumpfunc;
        }
        assert(csi);
        do {
            int i;
            for (i=0; csi->spec[i].name; i++) {
                Jsi_DSSetLength(&dStr, 0);
                spec = csi->spec+i;
                if (i==0 && spec->flags&JSI_CMD_IS_CONSTRUCTOR && !all) /* ignore constructor name. */
                    continue;
                if (key[0])
                    Jsi_DSAppend(&dStr, key, ".", NULL);
                Jsi_DSAppend(&dStr, spec->name, NULL);
                skey = Jsi_DSValue(&dStr);
                if (isglob) {
                    if (!(((key[0]==0 && dots == 0) || (key[0] && dots == 1)) &&
                        Jsi_GlobMatch(name, skey, 0)))
                    continue;
                }
                if (name && isglob == 0 && Jsi_Strcmp(name,skey) == 0) {
dumpfunc:
                    nobj = Jsi_ObjNew(interp);
                    Jsi_ValueMakeObject(interp, ret, nobj);
                    if (spec == NULL)
                        jsi_DumpCmdItem(interp, nobj, csi, skey);
                    else
                        jsi_DumpCmdSpec(interp, nobj, spec, skey);
                    Jsi_DSFree(&dStr);
                    return JSI_OK;
                    
                } else if (isglob == 0 && isreg == 0)
                    continue;
                if (isreg) {
                    int ismat;
                    Jsi_RegExpMatch(interp, arg, skey, &ismat, NULL);
                    if (!ismat)
                        continue;
                }
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, tail?spec->name:skey), curlen++);
                ninc++;
            }
            csi = csi->next;
        } while (csi);
    }
    Jsi_DSFree(&dStr);
    if (sort && (*ret)->vt != JSI_VT_UNDEF)
        Jsi_ValueArraySort(interp, *ret, 0);
    return JSI_OK;    
}

// TODO: does not show loaded commands.
static Jsi_RC InfoCmdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InfoCmdsData data = {};
    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);
    if (vo) {
        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) /* Future options. */
            return Jsi_LogError("expected options object");
        if (Jsi_OptionsProcess(interp, InfoCmdsOptions, &data, vo, 0) < 0) {
            return JSI_ERROR;
        }
    }

    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    int ff = (data.full ? 0 : 2);
    return InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, data.constructor, 1, nobj, ff);
}


static Jsi_RC InfoMethodsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_RC rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);
    if (rc == JSI_OK && Jsi_ValueIsArray(interp, *ret)) {
        Jsi_Obj *nobj = (*ret)->d.obj;
        InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 1, nobj, 3);
    }
    return rc;
}

static Jsi_RC InfoCompletionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int slen, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);
    char *key, *substr, *str = Jsi_ValueString(interp, arg1, &slen);
    int start = 0, end = slen-1;
    if (!str)
        return JSI_ERROR;
    if (argc>1) {
        Jsi_Number n1;
        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n1) != JSI_OK)
            return JSI_ERROR;
        start = (int)n1;
        if (start<0) start = 0;
        if (start>=slen) start=slen-1;
    }
    if (argc>2) {
        Jsi_Number n2;
        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 2), &n2) != JSI_OK)
            return JSI_ERROR;
        end = (int)n2;
        if (end<0) end = slen-1;
        if (end>=slen) end=slen-1;
    }

    Jsi_DString dStr = {};
    Jsi_DSAppendLen(&dStr, str?str+start:"", end-start+1);
    Jsi_DSAppend(&dStr, "*", NULL);
    substr = Jsi_DSValue(&dStr);
    Jsi_Value *arg = Jsi_ValueNewStringDup(interp, substr);
    Jsi_IncrRefCount(interp, arg);
    
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);

    Jsi_RC rc = InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 0, nobj, 0);
    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))
        goto done;
    rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 0x7, nobj);
    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))
        goto done;
    if (str) {
        substr[end-start+1] = 0;
        slen = Jsi_Strlen(substr);
    }
    if (str == NULL || !Jsi_Strchr(substr, '.')) {
        Jsi_HashEntry *hPtr;
        Jsi_HashSearch search;
        int n = Jsi_ValueGetLength(interp, *ret);
        for (hPtr = Jsi_HashSearchFirst(interp->lexkeyTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            key = (char*)Jsi_HashKeyGet(hPtr);
            if (str == NULL || !Jsi_Strncmp(substr, key, slen))
                Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, key), n++);
        }
    }
    Jsi_ValueArraySort(interp, *ret, 0);
done:
    Jsi_DSFree(&dStr);
    Jsi_DecrRefCount(interp, arg);
    return rc;
}

Jsi_Value * Jsi_LookupCS(Jsi_Interp *interp, const char *name, int *ofs)
{
    const char *csdot = Jsi_Strrchr(name, '.');
    int len;
    *ofs = 0;
    if (csdot == name)
        return NULL;
    if (!csdot)
        return interp->csc;
    if (!csdot[1])
        return NULL;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppendLen(&dStr, name, len=csdot-name);
    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    *ofs = len+1;
    return cs;
}

static void ValueObjDeleteStr(Jsi_Interp *interp, Jsi_Value *target, const char *key, int force)
{
    const char *kstr = key;
    if (target->vt != JSI_VT_OBJECT) return;

    Jsi_TreeEntry *hPtr;
    Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, key);
    if (hePtr)
        kstr = (const char*)Jsi_MapKeyGet(hePtr, 0);
    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);
    if (hPtr == NULL || ( hPtr->f.bits.dontdel && !force))
        return;
    Jsi_TreeEntryDelete(hPtr);
}

Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name) {
    int ofs;
    Jsi_Value *fv = Jsi_NameLookup(interp, name);
    Jsi_Value *cs = Jsi_LookupCS(interp, name, &ofs);
    if (cs) {
        const char *key = name + ofs;
        ValueObjDeleteStr(interp, cs, key, 1);
    }
    if (fv)
        Jsi_DecrRefCount(interp, fv);
    return JSI_OK;
}


Jsi_Value * jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec)
{
    Jsi_Value *n = NULL;
    const char *csdot = Jsi_Strrchr(name, '.');
    if (0 && csdot) {
        Jsi_LogBug("commands with dot unsupported: %s", name);
        return NULL;
    }
    if (csdot == name) {
        name = csdot+1;
        csdot = NULL;
    }
    if (!csdot) {
        n = jsi_MakeFuncValue(interp, cmdProc, name, NULL, cspec);
        Jsi_IncrRefCount(interp, n);
        Jsi_ObjDecrRefCount(interp, n->d.obj);
        Jsi_Func *f = n->d.obj->d.fobj->func;
        f->privData = privData;
        f->name = Jsi_KeyAdd(interp, name);
        Jsi_ValueInsertFixed(interp, interp->csc, f->name, n);
        return n;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppendLen(&dStr, name, csdot-name);
    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    if (cs) {
    
        n = jsi_MakeFuncValue(interp, cmdProc, csdot+1, NULL, cspec);
        Jsi_IncrRefCount(interp, n);
        Jsi_ObjDecrRefCount(interp, n->d.obj);
        Jsi_Func *f = n->d.obj->d.fobj->func;
        
        f->name = Jsi_KeyAdd(interp, csdot+1);
        f->privData = privData;
        Jsi_ValueInsertFixed(interp, cs, f->name, n);
        //Jsi_ObjDecrRefCount(interp, n->d.obj);
    }
    return n;
}

Jsi_Value * Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData)
{
    Jsi_Value *v = jsi_CommandCreate(interp, name, cmdProc, privData, 1, 0);
    if (v)
        Jsi_HashSet(interp->genValueTbl, v, v);
    return v;
}

// Sanity check builtin args signature.
bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent)
{
    bool rc = 1;
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, cmdSpec->argStr, NULL);
    const char *elips = Jsi_Strstr(cmdSpec->argStr, "...");
    if (cmdSpec->maxArgs<0 && !elips)
        Jsi_DSAppend(&dStr, ", ...", NULL);
    int aCnt = 0, i = -1;
    char *cp = Jsi_DSValue(&dStr);
    while (cp[++i]) if (cp[i]==',') aCnt++;
    
    if (cmdSpec->maxArgs>=0) {
        aCnt++;
        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>cmdSpec->maxArgs || 
            cmdSpec->minArgs>aCnt || cmdSpec->maxArgs>aCnt || elips) {
            rc = 0;
        }                    
    } else {
        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>aCnt) {
            rc = 0;
        }                    
    }
    Jsi_DSFree(&dStr);
    if (!rc) {
        jsi_TypeMismatch(interp);
        Jsi_LogWarn("inconsistent arg string for \"%s.%s(%s)\" [%d,%d]",
            parent, cmdSpec->name, cmdSpec->argStr, cmdSpec->minArgs, cmdSpec->maxArgs);
    }
    if (f->argnames==NULL && cmdSpec->argStr) {
        // At least give a clue where the problem is.
        const char *ocfile = interp->curFile;
        jsi_Pline *opl = interp->parseLine, pline;
        interp->parseLine = &pline;
        pline.first_line = 1;
        interp->curFile = cmdSpec->name;
        f->argnames = jsi_ParseArgStr(interp, cmdSpec->argStr);
        interp->curFile = ocfile;
        interp->parseLine = opl;
    }
    return rc;
}

static Jsi_Value *CommandCreateWithSpec(Jsi_Interp *interp, Jsi_CmdSpec *cSpec, int idx, Jsi_Value *proto, void *privData, const char *parent)
{
    Jsi_CmdSpec *cmdSpec = cSpec+idx;
    int iscons = (cmdSpec->flags&JSI_CMD_IS_CONSTRUCTOR);
    Jsi_Value *func = NULL;
    Jsi_Func *f;
    if (cmdSpec->name)
        Jsi_KeyAdd(interp, cmdSpec->name);
    if (cmdSpec->proc == NULL)
    {
        func = jsi_ProtoObjValueNew1(interp, cmdSpec->name);
        Jsi_ValueInsertFixed(interp, NULL, cmdSpec->name, func);
        f = func->d.obj->d.fobj->func;
    } else {
    
        func = jsi_MakeFuncValueSpec(interp, cmdSpec, privData);
    #ifdef JSI_MEM_DEBUG
        func->VD.label = "CMDspec";
        func->VD.label2 = cmdSpec->name;
    #endif
        //Jsi_IncrRefCount(interp, func);
        //Jsi_HashSet(interp->genValueTbl, func, func);
        Jsi_ValueInsertFixed(interp, (iscons?NULL:proto), cmdSpec->name, func);
        f = func->d.obj->d.fobj->func;
    
        if (cmdSpec->name)
            f->name = cmdSpec->name;
        f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);
        f->f.bits.hasattr = 1;
        if (iscons) {
            f->f.bits.iscons = 1;
            Jsi_ValueInsertFixed(interp, func, "prototype", proto);
            Jsi_PrototypeObjSet(interp, "Function", Jsi_ValueGetObj(interp, func));
        }
    }
    func->d.obj->d.fobj->func->parent = parent;
    if (cmdSpec->argStr && interp->typeCheck.all)
        jsi_CommandArgCheck(interp, cmdSpec, f, parent);

    f->retType = cmdSpec->retType;
    return func;
}


Jsi_Value *Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs,
    void *privData, int flags)
{
    int i = 0;
    Jsi_Value *proto;
    if (!cmdSpecs[0].name)
        return NULL;
    if (!name)
        name = cmdSpecs[0].name;
    name = Jsi_KeyAdd(interp, name);
    if (flags & JSI_CMDSPEC_PROTO) {
        proto = (Jsi_Value*)privData;
        privData = NULL;
        i++;
    } else if (name[0] == 0)
        proto = NULL;
    else {
        if (!(flags & JSI_CMDSPEC_ISOBJ)) {
            proto = jsi_CommandCreate(interp, name, NULL, privData, 0, cmdSpecs);
        } else {
            proto = jsi_ProtoValueNew(interp, name, NULL);
        }
    }
    for (; cmdSpecs[i].name; i++)
        CommandCreateWithSpec(interp,  cmdSpecs, i, proto, privData, name);

    bool isNew;
    Jsi_MapEntry *hPtr = Jsi_MapEntryNew(interp->cmdSpecTbl, name, &isNew);
    if (!hPtr || !isNew) {
        Jsi_LogBug("failed cmdspec register: %s", name);
        return NULL;
    }
    Jsi_CmdSpecItem *op, *p = (Jsi_CmdSpecItem*)Jsi_Calloc(1,sizeof(*p));
    SIGINIT(p,CMDSPECITEM);
    p->spec = cmdSpecs;
    p->flags = flags;
    p->proto = proto;
    p->privData = privData;
    p->name = (const char*)Jsi_MapKeyGet(hPtr, 0);
    p->hPtr = hPtr;
    Jsi_CmdSpec *csi = cmdSpecs;
    p->isCons = (csi && csi->flags&JSI_CMD_IS_CONSTRUCTOR);
    while (csi->name)
        csi++;
    p->help = csi->help;
    p->info = csi->info;
    if (!isNew) {
        op = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);
        p->next = op;
    }
    Jsi_MapValueSet(hPtr, p);
    return proto;
}

void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr)
{
    Jsi_CmdSpecItem *cs = (Jsi_CmdSpecItem*)ptr;
    Jsi_CmdSpec *p;
    SIGASSERT(cs,CMDSPECITEM);
    //return;
    while (cs) {
        p = cs->spec;
        Jsi_Value *proto = cs->proto;
        if (proto)
            Jsi_DecrRefCount(interp, proto);
        while (0 && p && p->name) {
            /*Jsi_Value *proto = p->proto;
            if (proto)
                Jsi_DecrRefCount(interp, proto);*/
            p++;
        }
        ptr = cs;
        cs = cs->next;
        Jsi_Free(ptr);
    }
}

static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc = JSI_OK;
    int i, n=1, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Wide diff, start, end;
    if(!Jsi_ValueIsFunction(interp, func))
        return Jsi_LogError("expected function");
    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)
        return JSI_ERROR;
    if (n<=0) 
        return Jsi_LogError("count not > 0: %d", n);
    struct timeval tv;
    gettimeofday(&tv, NULL);
    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;
    for (i=0; i<n; i++) {
        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);
    }
    gettimeofday(&tv, NULL);
    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;
    diff = (end - start);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);
    return rc;
}

static Jsi_RC SysFormatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_DString dStr;
    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);
    if (rc != JSI_OK)
        return rc;
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static Jsi_RC quoteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_DString dStr = {};
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str = Jsi_ValueGetDString(interp, arg, &dStr, 1);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(str));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}
// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len)
{
    static const uint32_t s_crc32[16] = {
        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
    };
    uint32_t crcu32 = (uint32_t)crc;
    uchar *uptr = (uchar *)ptr;
    if (!uptr) return 0;
    crcu32 = ~crcu32;
    while (buf_len--) {
        uchar b = *uptr++;
        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
    }
    return ~crcu32;
}

static Jsi_RC SysCrc32Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int ilen;
    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    Jsi_Number crc = 0;
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc>1)
        Jsi_ValueGetNumber(interp, Jsi_ValueArrayIndex(interp, args, 1), &crc);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)Jsi_Crc32((uint32_t)crc, (uchar*)inbuffer, ilen));
    return JSI_OK;
}

#ifndef JSI_OMIT_BASE64
static const char b64ev[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static int atend;

static int
b64getidx(const char *buffer, int len, int *posn) {
    char c;
    char *idx;
    if (atend) return -1;
    do {
    if ((*posn)>=len) {
        atend = 1;
        return -1;
    }
    c = buffer[(*posn)++];
    if (c<0 || c=='=') {
        atend = 1;
        return -1;
    }
    idx = Jsi_Strchr(b64ev, c);
    } while (!idx);
    return idx - b64ev; 
} 

static void B64DecodeDStr(const char *inbuffer, int ilen, Jsi_DString *dStr)
{
    int olen, pos;
    char outbuffer[3];
    int c[4];
    
    pos = 0; 
    atend = 0;
    while (!atend) {
        if (inbuffer[pos]=='\n' ||inbuffer[pos]=='\r') { pos++; continue; }
        c[0] = b64getidx(inbuffer, ilen, &pos);
        c[1] = b64getidx(inbuffer, ilen, &pos);
        c[2] = b64getidx(inbuffer, ilen, &pos);
        c[3] = b64getidx(inbuffer, ilen, &pos);

        olen = 0;
        if (c[0]>=0 && c[1]>=0) {
            outbuffer[0] = ((c[0]<<2)&0xfc)|((c[1]>>4)&0x03);
            olen++;
            if (c[2]>=0) {
                outbuffer[1] = ((c[1]<<4)&0xf0)|((c[2]>>2)&0x0f);
                olen++;
                if (c[3]>=0) {
                    outbuffer[2] = ((c[2]<<6)&0xc0)|((c[3])&0x3f);
                    olen++;
                }
            }
        }

        if (olen>0)
            Jsi_DSAppendLen(dStr, outbuffer, olen);
        olen = 0;
    }
    if (olen>0)
        Jsi_DSAppendLen(dStr, outbuffer, olen);
}

static Jsi_RC B64Decode(Jsi_Interp *interp, char *inbuffer, int ilen, Jsi_Value **ret)
{
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    B64DecodeDStr(inbuffer, ilen, &dStr);
    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    return JSI_OK;
}

static Jsi_RC
B64EncodeDStr(const char *ib, int ilen, Jsi_DString *dStr)
{
    int i=0, pos=0;
    char c[74];
    
    while (pos<ilen) {
#define P(n,s) ((pos+n)>ilen?'=':b64ev[s])
        c[i++]=b64ev[(ib[pos]>>2)&0x3f];
        c[i++]=P(1,((ib[pos]<<4)&0x30)|((ib[pos+1]>>4)&0x0f));
        c[i++]=P(2,((ib[pos+1]<<2)&0x3c)|((ib[pos+2]>>6)&0x03));
        c[i++]=P(3,ib[pos+2]&0x3f);
        if (i>=72) {
            c[i++]='\n';
            c[i]=0;
            Jsi_DSAppendLen(dStr, c, i);
            i=0;
        }
        pos+=3;
    }
    if (i) {
        /*    c[i++]='\n';*/
        c[i]=0;
        Jsi_DSAppendLen(dStr, c, i);
        i=0;
    }
    return JSI_OK;
}

static Jsi_RC
B64Encode(Jsi_Interp *interp, char *ib, int ilen, Jsi_Value **ret)
{
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    B64EncodeDStr(ib, ilen, &dStr);
    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    return JSI_OK;
}

Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *dStr, bool decode)
{
    if (len<0)
        len = Jsi_Strlen(str);
    if (decode)
        B64DecodeDStr(str, len, dStr);
    else
        B64EncodeDStr(str, len, dStr);
    return JSI_OK;
}

static Jsi_RC B64DecodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int ilen;
    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    return B64Decode(interp, inbuffer, ilen, ret);
}

static Jsi_RC B64EncodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int ilen;
    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    return B64Encode(interp, inbuffer, ilen, ret);
}

static Jsi_RC SysBase64Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    bool dec = 0;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) 
        return Jsi_LogError("expected bool");
    if (dec)
        return B64DecodeCmd(interp, args, _this, ret, funcPtr);
    else
        return B64EncodeCmd(interp, args, _this, ret, funcPtr);
}

static Jsi_RC SysHexStrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    bool dec = 0;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) 
        return Jsi_LogError("expected bool");
    int len;
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &len);
    if (!str || len<=0)
        return Jsi_LogError("expected string");
    char *dest = (char*)Jsi_Malloc(dec?(len/2+1):(len*2+1));
    if (dec)
        Jsi_ToHexStr((const uchar*)str, len, dest);
    else
        Jsi_FromHexStr(str, (uchar*)dest);
    Jsi_ValueMakeString(interp, ret, dest);
    return JSI_OK;
}
#endif


static const char *hashTypeStrs[] = { "sha256", "sha1", "md5", "sha3_224", "sha3_384", "sha3_512", "sha3_256", NULL };

typedef struct {
    uint hashcash;
    Jsi_Value *file;
    Jsi_CryptoHashType type;
    bool noHex;
} HashOpts;


static Jsi_OptionSpec HashOptions[] = {
    JSI_OPT(STRING,  HashOpts, file,      .help="Read data from file and append to str" ),
    JSI_OPT(UINT,    HashOpts, hashcash,  .help="Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work)" ),
    JSI_OPT(BOOL,    HashOpts, noHex,     .help="Return binary digest, without conversion to hex chars" ),
    JSI_OPT(CUSTOM,  HashOpts, type,      .help="Type of hash", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=hashTypeStrs ),
    {JSI_OPTION_END}
};

static Jsi_RC SysHashCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n, hasopts = 0;
    const char *cp = NULL;
    Jsi_RC rc = JSI_OK;
    Jsi_DString dStr = {};
    HashOpts edata = {};
    char zbuf[1024];
    
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (!arg || !Jsi_ValueIsString(interp, arg))
        return Jsi_LogError("arg 1: expected string");
        
    cp=Jsi_ValueString(interp, arg, &n);
    Jsi_DSAppendLen(&dStr, cp, n);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    if (opt) {
        if (opt->vt != JSI_VT_OBJECT || opt->d.obj->ot != JSI_OT_OBJECT)
            return Jsi_LogError("expected options object");
        if (Jsi_OptionsProcess(interp, HashOptions, &edata, opt, 0) < 0)
            return JSI_ERROR;
        hasopts = 1;
    }
    
    if (edata.file) {
        Jsi_Channel in = Jsi_Open(interp, edata.file, "rb");
        
        if( in==0 ) {
            rc = Jsi_LogError("unable to open file");
            goto done;
        }
        for(;;) {
            int n;
            n = Jsi_Read(in, zbuf, sizeof(zbuf));
            if( n<=0 ) break;
            Jsi_DSAppendLen(&dStr, zbuf, n);;
        }
        Jsi_Close(in);
    }
    cp = Jsi_DSValue(&dStr);
    n = Jsi_DSLength(&dStr);
    zbuf[0] = 0;
    Jsi_CryptoHash(zbuf, cp, n, edata.type, edata.hashcash, edata.noHex);
        
done:
    Jsi_DSFree(&dStr);
    if (hasopts)
        Jsi_OptionsFree(interp, HashOptions, &edata, 0);
    if (rc == JSI_OK)
        Jsi_ValueMakeStringDup(interp, ret, zbuf);
    return rc;

}


#ifndef JSI_OMIT_ENCRYPT

#define FN_encrypt JSI_INFO("\
Keys that are not 16 bytes use the MD5 hash of the key.")
static Jsi_RC SysEncryptCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, bool decrypt)
{
    int ilen, klen;
    Jsi_RC rc = JSI_OK;
    const char *key, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    Jsi_DString dStr = {};
    if (!str || !ilen) 
        return Jsi_LogError("data must be a non-empty string");
    if (decrypt && (ilen%4) != 1) {
        rc = Jsi_LogError("data length incorrect and can not be decrypted");
        goto done;
    }
    key = Jsi_ValueArrayIndexToStr(interp, args, 1, &klen);
    Jsi_DSAppendLen(&dStr, str, ilen);
    rc = Jsi_Encrypt(interp, &dStr, key, klen, decrypt);

    if (rc == JSI_OK)
        Jsi_ValueMakeDStringObject(interp, ret, &dStr);
done:
    return rc;
}
static Jsi_RC SysEncryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 0);
}
static Jsi_RC SysDecryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 1);
}
#endif

#ifndef JSI_OMIT_MARKDOWN

Jsi_OptionSpec MarkdownCmdsOptions[] = {
    JSI_OPT(STRKEY, jsi_MarkdownOpts, topLink, "Web server root url" ),
    JSI_OPT(BOOL,   jsi_MarkdownOpts, returnStr,  "Return just HTML string instead of an object" ),
    JSI_OPT(BOOL,   jsi_MarkdownOpts, getTitle, "Extract title from first H1 in page" ),
    JSI_OPT_END(jsi_MarkdownOpts, .help="Options for markdown command")
};

Jsi_RC jsi_SysMarkdownCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int blen;
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &blen);
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_DString bStr = {};
    Jsi_DString rStr = {};
    jsi_MarkdownOpts data = {};
    if (str)
        Jsi_DSAppendLen(&bStr, str, blen);
    if (opts && Jsi_OptionsProcess(interp, MarkdownCmdsOptions, &data, opts, 0) < 0)
        return JSI_ERROR;
    jsi_markdown_to_html(&bStr, &rStr, &data);
    if (data.returnStr)
        Jsi_ValueMakeDStringObject(interp, ret, &rStr);
    else {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, nobj);
        Jsi_Value *cval = Jsi_ValueNew(interp);
        Jsi_ValueFromDS(interp, &data.titleStr, &cval);
        Jsi_ObjInsert(interp, nobj, "title", cval, 0);
        Jsi_ValueFromDS(interp, &rStr, &cval);
        Jsi_ObjInsert(interp, nobj, "data", cval, 0);
    }
    Jsi_DSFree(&bStr);
    return JSI_OK;
}
#endif

static Jsi_RC SysFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char unibuf[BUFSIZ+1];
    int i = 1;    
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (!v) return Jsi_LogError("expected number");

    Jsi_ValueToNumber(interp, v);
#if JSI_UTF8
    i = Jsi_UniCharToUtf(v->d.num, unibuf);
#else
    unibuf[0] = (char) v->d.num;
#endif
    unibuf[i] = 0;
    Jsi_ValueMakeStringDup(interp, ret, unibuf);
    return JSI_OK;
}
/* Commands visible at the toplevel. */

static Jsi_CmdSpec consoleCmds[] = {
    { "assert", jsi_AssertCmd,      1,  3, "expr:boolean|number|function, msg:string=void, options:object=void",  .help="Same as System.assert()", .retType=(uint)JSI_TT_VOID, .flags=0, .info=0, .opts=AssertOptions},
    { "input",  consoleInputCmd,    0,  0, "", .help="Read input from the console", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },
    { "log",    consoleLogCmd,      1, -1, "val, ...", .help="Same as puts, but goes to stderr and includes file:line", .retType=(uint)JSI_TT_VOID, .flags=0 },
    { "logf",   consoleLogfCmd,     1, -1, "format:string, ...", .help="Same as printf, but goes to stderr and includes file:line and newline", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_consolelogf },
    { "puts",   consolePutsCmd,     1, -1, "val, ...", .help="Output one or more values to stderr", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_puts },
    { NULL, 0,0,0,0,  .help="Console input and output" }
};

#ifndef JSI_OMIT_EVENT
static Jsi_CmdSpec eventCmds[] = {
    { "clearInterval",clearIntervalCmd, 1,  1, "id:number", .help="Delete an event (created with setInterval/setTimeout)", .retType=(uint)JSI_TT_VOID },
    { "info",       eventInfoCmd,       1,  1, "id:number", .help="Return info for the given event id", .retType=(uint)JSI_TT_OBJECT },
    { "names",      eventInfoCmd,       0,  0, "", .help="Return list event ids (created with setTimeout/setInterval)", .retType=(uint)JSI_TT_ARRAY },
    { "setInterval",setIntervalCmd,     2,  2, "callback:function, millisecs:number", .help="Setup recurring function to run every given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "setTimeout", setTimeoutCmd,      2,  2, "callback:function, millisecs:number", .help="Setup function to run after given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "update",     SysUpdateCmd,    0,  1, "options:number|object=void", .help="Service all events, eg. setInterval/setTimeout", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=UpdateOptions },
    { NULL, 0,0,0,0,  .help="Event management" }
};
#endif

#ifndef JSI_OMIT_DEBUG
static Jsi_CmdSpec debugCmds[] = {
    { "add",        DebugAddCmd,    1,  2, "val:string|number, temp:boolean=false", .help="Add a breakpoint for line, file:line or func", .retType=(uint)JSI_TT_NUMBER },
    { "remove",     DebugRemoveCmd, 1,  1, "id:number", .help="Remove breakpoint", .retType=(uint)JSI_TT_VOID },
    { "enable",     DebugEnableCmd, 2,  2, "id:number, on:boolean", .help="Enable/disable breakpoint", .retType=(uint)JSI_TT_VOID },
    { "info",       DebugInfoCmd,   0,  1, "id:number=void", .help="Return info about one breakpoint, or list of bp numbers", .retType=(uint)JSI_TT_OBJECT|JSI_TT_ARRAY },
    { NULL, 0,0,0,0,  .help="Debugging management" }
};
#endif

static Jsi_CmdSpec infoCmds[] = {
    { "argv0",      InfoArgv0Cmd,       0,  0, "", .help="Return initial start script file name", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },
    { "cmds",       InfoCmdsCmd,        0,  2, "val:string|regexp='*', options:object=void", .help="Return details or list of matching commands", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=0, .opts=InfoCmdsOptions },
    { "completions",InfoCompletionsCmd,  1,  3, "str:string, start:number=0, end:number=void", .help="Return command completions on portion of string from start to end", .retType=(uint)JSI_TT_ARRAY },
    { "data",       InfoDataCmd,        0,  1, "val:string|regexp|object=void", .help="Return list of matching data (non-functions)", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=FN_infodata },
    { "error",      InfoErrorCmd,       0,  0, "", .help="Return file and line number of error (used inside catch)", .retType=(uint)JSI_TT_OBJECT },
#ifndef JSI_OMIT_EVENT
    { "event",      InfoEventCmd,       0,  1, "id:number=void", .help="List events or info for 1 event (setTimeout/setInterval)", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infoevent },
#endif
    { "executable", InfoExecutableCmd,  0,  0, "", .help="Return name of executable", .retType=(uint)JSI_TT_STRING },
    { "execZip",    InfoExecZipCmd,     0,  0, "", .help="If executing a .zip file, return file name", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },
    { "files",      InfoFilesCmd,       0,  0, "", .help="Return list of all sourced files", .retType=(uint)JSI_TT_ARRAY },
    { "funcs",      InfoFuncsCmd,       0,  1, "string|regexp|object=void", .help="Return details or list of matching functions", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "interp",     jsi_InterpInfo,     0,  1, "interp:userobj=void", .help="Return info on given or current interp", .retType=(uint)JSI_TT_OBJECT },
    { "isMain",     InfoIsMainCmd,      0,  0, "", .help="Return true if current script was the main script invoked from command-line", .retType=(uint)JSI_TT_BOOLEAN },
    { "keywords",   InfoKeywordsCmd,    0,  0, "", .help="Return list of reserved jsi keywords", .retType=(uint)JSI_TT_ARRAY },
    { "level",      InfoLevelCmd,       0,  1, "level:number=void", .help="Return current level or details of a call-stack frame", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NUMBER, .flags=0, .info=FN_infolevel },
    { "lookup",     InfoLookupCmd,      1,  1, "name:string", .help="Given string name, lookup and return value (eg. function)", .retType=(uint)JSI_TT_ANY },
    { "methods",    InfoMethodsCmd,     1,  1, "val:string|regexp", .help="Return functions and commands", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "named",      InfoNamedCmd,       0,  1, "name:string=void", .help="Returns command names for builtin Objects (eg. 'File', 'Interp'), sub-Object names, or the named object", .retType=(uint)JSI_TT_ARRAY|JSI_TT_USEROBJ },
    { "options",    InfoOptionsCmd,     0,  1, "ctype:boolean=false", .help="Return Option type name, or with true the C type)", .retType=(uint)JSI_TT_ARRAY },
    { "platform",   InfoPlatformCmd,    0,  0, "", .help="N/A. Returns general platform information for JSI", .retType=(uint)JSI_TT_OBJECT  },
    { "script",     InfoScriptCmd,      0,  1, "func:function|regexp=void", .help="Get current script file name, or file containing function", .retType=(uint)JSI_TT_STRING|JSI_TT_ARRAY|JSI_TT_VOID },
    { "scriptDir",  InfoScriptDirCmd,   0,  0, "", .help="Get directory of current script", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },
    { "vars",       InfoVarsCmd,        0,  1, "val:string|regexp|object=void", .help="Return details or list of matching variables", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infovars },
    { "version",    InfoVersionCmd,     0,  1, "boolStr:string|boolean=false", .help="Return JSI version double, string or object when boolStr==true", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT|JSI_TT_STRING  },
    { NULL, 0,0,0,0, .help="Commands for inspecting internal state information in JSI"  }
};

static Jsi_CmdSpec utilCmds[] = {
#ifndef JSI_OMIT_BASE64
    { "base64",     SysBase64Cmd,    1,  2, "val:string, decode:boolean=false",.help="Base64 encode/decode a string", .retType=(uint)JSI_TT_STRING },
    { "hexStr",     SysHexStrCmd,    1,  2, "val:string, decode:boolean=false",.help="Hex encode/decode a string", .retType=(uint)JSI_TT_STRING },
#endif
    { "crc32",      SysCrc32Cmd,     1,  2, "val:string, crcSeed=0",.help="Calculate 32-bit CRC", .retType=(uint)JSI_TT_NUMBER },
#ifndef JSI_OMIT_ENCRYPT
    { "decrypt",    SysDecryptCmd,   2,  2, "val:string, key:string", .help="Decrypt data using BTEA encryption", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },
    { "encrypt",    SysEncryptCmd,   2,  2, "val:string, key:string", .help="Encrypt data using BTEA encryption", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },
#endif
    { "fromCharCode",SysFromCharCodeCmd, 1, 1, "code:number", .help="Return char with given character code", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMDSPEC_NONTHIS},
    { "getenv",     SysGetEnvCmd,    0,  1, "name:string=void", .help="Get one or all environment", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT|JSI_TT_VOID  },
    { "getpid",     SysGetPidCmd,    0,  1, "parent:boolean=false", .help="Get process/parent id", .retType=(uint)JSI_TT_NUMBER },
#ifndef JSI_OMIT_MARKDOWN
    { "markdown",   jsi_SysMarkdownCmd,  1,  2, "val:string, options:object=void",.help="Render markdown", .retType=(uint)(JSI_TT_STRING|JSI_TT_OBJECT), .flags=0, .info=0, .opts=MarkdownCmdsOptions },
#endif
    { "setenv",     SysSetEnvCmd,    1,  2, "name:string, value:string=void", .help="Set/get an environment var"  },
    { "hash",       SysHashCmd,      1,  2, "val:string, options|object=void", .help="Return hash (default SHA256) of string/file", .retType=(uint)JSI_TT_STRING, .flags=0, .info=0, .opts=HashOptions},
    { "times",      SysTimesCmd,     1,  2, "callback:function, count:number=1", .help="Call function count times and return execution time in microseconds", .retType=(uint)JSI_TT_NUMBER },
    { NULL, 0,0,0,0, .help="Utilities commands"  }
};

static Jsi_CmdSpec sysCmds[] = {
    { "assert", jsi_AssertCmd,       1,  3, "expr:boolean|number|function, msg:string=void, options:object=void",  .help="Throw or output msg if expr is false", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_assert, .opts=AssertOptions },
#ifndef JSI_OMIT_EVENT
    { "clearInterval",clearIntervalCmd,1,1, "id:number", .help="Delete event id returned from setInterval/setTimeout/info.events()", .retType=(uint)JSI_TT_VOID },
#endif
    { "decodeURI",  DecodeURICmd,    1,  1, "val:string", .help="Decode an HTTP URL", .retType=(uint)JSI_TT_STRING },
    { "encodeURI",  EncodeURICmd,    1,  1, "val:string", .help="Encode an HTTP URL", .retType=(uint)JSI_TT_STRING },
    { "exec",       SysExecCmd,      1,  2, "val:string, options:string|object=void", .help="Execute an OS command", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_exec, .opts=ExecOptions},
    { "exit",       SysExitCmd,      0,  1, "code:number=0", .help="Exit the current interpreter", .retType=(uint)JSI_TT_VOID },
    { "format",     SysFormatCmd,    1, -1, "format:string, ...", .help="Printf style formatting: adds %q and %S", .retType=(uint)JSI_TT_STRING },
    { "isFinite",   isFiniteCmd,     1,  1, "val", .help="Return true if is a finite number", .retType=(uint)JSI_TT_BOOLEAN },
    { "isNaN",      isNaNCmd,        1,  1, "val", .help="Return true if not a number", .retType=(uint)JSI_TT_BOOLEAN },
#ifndef JSI_OMIT_LOAD
    { "load",       jsi_LoadLoadCmd, 1,  1, "shlib:string", .help="Load a shared executable and invoke its _Init call", .retType=(uint)JSI_TT_VOID },
#endif
    { "log",        SysLogCmd,       1, -1, "val, ...", .help="Same as puts, but includes file:line", .retType=(uint)JSI_TT_VOID, .flags=0 },
    { "noOp",       jsi_NoOpCmd,     0, -1, "", .help="A No-Op. A zero overhead command call that is useful for debugging" },
    { "parseInt",   parseIntCmd,     1,  2, "val:any, base:number=10", .help="Convert string to an integer", .retType=(uint)JSI_TT_NUMBER },
    { "parseFloat", parseFloatCmd,   1,  1, "val", .help="Convert string to a double", .retType=(uint)JSI_TT_NUMBER },
    { "printf",     SysPrintfCmd,    1, -1, "format:string, ...", .help="Formatted output to stdout", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_puts },
    { "provide",    SysProvideCmd,   1,  2, "name:string, version:number=1", .help="Provide a package for use with require", .retType=(uint)JSI_TT_VOID },
    { "puts",       SysPutsCmd,      1, -1, "val, ...", .help="Output one or more values to stdout", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_puts },
    { "quote",      quoteCmd,        1,  1, "val:string", .help="Return quoted string", .retType=(uint)JSI_TT_STRING },
    { "require",    SysRequireCmd,   0,  2, "name:string=void, version:number=1", .help="Load/query packages", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT|JSI_TT_ARRAY, .flags=0, .info=FN_require },
    { "sleep",      SysSleepCmd,     0,  1, "secs:number=1.0",  .help="sleep for N milliseconds, minimum .001", .retType=(uint)JSI_TT_VOID },
#ifndef JSI_OMIT_EVENT
    { "setInterval",setIntervalCmd,  2,  2, "callback:function, ms:number", .help="Setup recurring function to run every given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "setTimeout", setTimeoutCmd,   2,  2, "callback:function, ms:number", .help="Setup function to run after given millisecs", .retType=(uint)JSI_TT_NUMBER },
#endif
    { "source",     SysSourceCmd,    1,  2, "val:string|array, options:object=void",  .help="Load and evaluate source files", .retType=(uint)JSI_TT_VOID, .flags=0, .info=0, .opts=SourceOptions},
    { "strftime",   DateStrftimeCmd, 0,  2, "num:number=null, options:string|object=void",  .help="Format numeric time (in ms) to a string", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strftime, .opts=DateOptions },
    { "strptime",   DateStrptimeCmd, 0,  2, "val:string=void, options:string|object=void",  .help="Parse time from string and return time (in ms) since 1970", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=0, .opts=DateOptions },
#ifndef JSI_OMIT_LOAD
    { "unload",     jsi_LoadUnloadCmd, 1, 1,  "shlib:string", .help="Unload a shared executable and invoke its _Done call", .retType=(uint)JSI_TT_VOID },
#endif
#ifndef JSI_OMIT_EVENT
    { "update",     SysUpdateCmd,    0,  1, "options:number|object=void", .help="Service all events, eg. setInterval/setTimeout", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=UpdateOptions },
#endif
    { NULL, 0,0,0,0, .help="Builtin system commands. All are callable from the either the top level or as System.XXX()" }
};

Jsi_RC jsi_InitCmds(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    interp->console = Jsi_CommandCreateSpecs(interp, "console", consoleCmds, NULL, 0);
    Jsi_IncrRefCount(interp, interp->console);
    Jsi_ValueInsertFixed(interp, interp->console, "args", interp->args);
        
    Jsi_CommandCreateSpecs(interp, "",       sysCmds,    NULL, 0);
    Jsi_CommandCreateSpecs(interp, "System", sysCmds,    NULL, 0);
    Jsi_CommandCreateSpecs(interp, "Info",   infoCmds,   NULL, 0);
    Jsi_CommandCreateSpecs(interp, "Util",   utilCmds,   NULL, 0);
#ifndef JSI_OMIT_EVENT
    Jsi_CommandCreateSpecs(interp, "Event",  eventCmds,  NULL, 0);
#endif
#ifndef JSI_OMIT_DEBUG
    Jsi_CommandCreateSpecs(interp, "Debug",  debugCmds,  NULL, 0);
#endif
    return JSI_OK;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#if JSI__FILESYS==1
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <dirent.h>
#include <signal.h>
#include <unistd.h>
#ifndef __WIN32
#include <pwd.h>
#else
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <fcntl.h>
#endif
#include <limits.h>

#define HAVE_UNISTD_H
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#elif defined(_MSC_VER)
#include <direct.h>
#define F_OK 0
#define W_OK 2
#define R_OK 4
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#define GSVal(s) GetStringVal(interp, s)
static const char *GetStringVal(Jsi_Interp *interp, Jsi_Value *s) {
    const char *cp = Jsi_ValueString(interp, s, 0);
    return cp ? cp : "";
}

#define SAFEACCESS(fname, writ)  \
if (interp->isSafe && Jsi_InterpAccess(interp, fname, writ) != JSI_OK) \
        return Jsi_LogError("%s access denied", writ?"write":"read");

Jsi_RC jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat)
{
    int rc;
    Jsi_StatBuf st;
    SAFEACCESS(fnam, 0)
    if (islstat)
        rc = Jsi_Lstat(interp, fnam, &st);
    else
        rc = Jsi_Stat(interp, fnam, &st);
    if (rc != 0) 
        return Jsi_LogError("file not found: %s", GSVal(fnam));
   /* Single object containing result members. */
    Jsi_Value *vres;
    Jsi_Obj  *ores;
    Jsi_Value *nnv;
    vres = Jsi_ValueMakeObject(interp, NULL, ores = Jsi_ObjNew(interp));
    Jsi_IncrRefCount(interp, vres);
#define MKDBL(nam,val) \
    nnv = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)val); \
    Jsi_ObjInsert(interp, ores, nam, nnv, 0);
    
    MKDBL("dev",st.st_dev); MKDBL("ino",st.st_ino); MKDBL("mode",st. st_mode);
    MKDBL("nlink",st.st_nlink); MKDBL("uid",st.st_uid); MKDBL("gid",st.st_gid);
    MKDBL("rdev",st.st_rdev);
#ifndef __WIN32
    MKDBL("blksize",st.st_blksize); MKDBL("blocks",st.st_blocks);
#endif
    MKDBL("atime",st.st_atime); MKDBL("mtime",st.st_mtime); MKDBL("ctime",st.st_ctime);    
    MKDBL("size",st.st_size);
    Jsi_ValueDup2(interp, ret, vres);
    Jsi_DecrRefCount(interp, vres);
    return JSI_OK;
}


static Jsi_RC FileStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_FileStatCmd(interp, Jsi_ValueArrayIndex(interp, args, 0), _this, ret, funcPtr, 0);
}

static Jsi_RC FileLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_FileStatCmd(interp, Jsi_ValueArrayIndex(interp, args, 0), _this, ret, funcPtr, 1);
}

static const char *getFileType(int mode, int lmode)
{
#ifdef S_ISLNK
    if (S_ISLNK(mode) || S_ISLNK(lmode)) {
        return "link";
    }
#endif
    if (S_ISDIR(mode)) {
        return "directory";
    }
#ifdef S_ISCHR
    else if (S_ISCHR(mode)) {
        return "characterSpecial";
    }
#endif
#ifdef S_ISBLK
    else if (S_ISBLK(mode)) {
        return "blockSpecial";
    }
#endif
#ifdef S_ISFIFO
    else if (S_ISFIFO(mode)) {
        return "fifo";
    }
#endif
#ifdef S_ISSOCK
    else if (S_ISSOCK(mode)) {
        return "socket";
    }
#endif
    else if (S_ISREG(mode)) {
        return "file";
    }
    return "unknown";
}

enum { FSS_Exists, FSS_Atime, FSS_Mtime, FSS_Writable, FSS_Readable, FSS_Executable, FSS_Type, 
FSS_Owned, FSS_Isdir, FSS_Isfile };

static Jsi_RC _FileSubstat(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int sub)
{
    Jsi_Value *fnam = Jsi_ValueArrayIndex(interp, args, 0);
    int rc;
    Jsi_StatBuf st, lst;
    rc = Jsi_Stat(interp, fnam, &st) | Jsi_Lstat(interp, fnam, &lst);
    if (rc != 0 && sub != FSS_Exists && sub != FSS_Writable && sub != FSS_Readable && sub != FSS_Isdir && sub != FSS_Isfile) {
        if (!interp->fileStrict)
            return JSI_OK;
        return Jsi_LogError("file not found: %s", GSVal(fnam));
    }
    switch (sub) {
        case FSS_Exists: Jsi_ValueMakeBool(interp, ret, (rc == 0)); break;
        case FSS_Atime: Jsi_ValueMakeNumber(interp, ret, st.st_atime); break;
        case FSS_Mtime: Jsi_ValueMakeNumber(interp, ret, st.st_mtime); break;
        case FSS_Writable: Jsi_ValueMakeBool(interp, ret, (Jsi_Access(interp, fnam, W_OK) != -1));  break;
        case FSS_Readable: Jsi_ValueMakeBool(interp, ret, (Jsi_Access(interp, fnam, R_OK) != -1));  break;
        case FSS_Executable:
#ifdef X_OK
            Jsi_ValueMakeBool(interp, ret, Jsi_Access(interp, fnam, X_OK) != -1);
#else
            Jsi_ValueMakeBool(interp, ret, 1);
#endif
            break;
        case FSS_Type: Jsi_ValueMakeStringKey(interp, ret, (char*)getFileType((int)st.st_mode, (int)lst.st_mode)); break;
        case FSS_Owned:
#ifndef __WIN32
            Jsi_ValueMakeBool(interp, ret, rc == 0 && geteuid() == st.st_uid);
#endif
            break;
        case FSS_Isdir: Jsi_ValueMakeBool(interp, ret, rc == 0 && S_ISDIR(st.st_mode));  break;
        case FSS_Isfile: Jsi_ValueMakeBool(interp, ret, rc == 0 && S_ISREG(st.st_mode));  break;
#ifndef __cplusplus
        default:
            assert(0);
#endif
    }
    return JSI_OK;
}
#define MAKE_FSS_SUB(nam) \
static Jsi_RC File##nam##Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, \
    Jsi_Value **ret, Jsi_Func *funcPtr) \
{\
    return _FileSubstat(interp, args, _this, ret, funcPtr, FSS_##nam);\
}
MAKE_FSS_SUB(Exists) MAKE_FSS_SUB(Atime) MAKE_FSS_SUB(Writable) MAKE_FSS_SUB(Readable)
MAKE_FSS_SUB(Executable) MAKE_FSS_SUB(Type) MAKE_FSS_SUB(Owned)
MAKE_FSS_SUB(Isdir) MAKE_FSS_SUB(Isfile) MAKE_FSS_SUB(Mtime)
#ifndef __WIN32
#define MKDIR_DEFAULT(PATHNAME) mkdir(PATHNAME, 0755)
#else
#define MKDIR_DEFAULT(PATHNAME) mkdir(PATHNAME)
#endif

static int mkdir_all(Jsi_Interp *interp, Jsi_Value *file)
{
    int ok = 1;
    char *path = Jsi_ValueString(interp, file, NULL);
    if (!path) {
        Jsi_LogError("expected string");
        return -1;
    }

    /* First time just try to make the dir */
    goto first;

    while (ok--) {
        /* Must have failed the first time, so recursively make the parent and try again */
        {
            char *slash = Jsi_Strrchr(path, '/');

            if (slash && slash != path) {
                *slash = 0;
                if (mkdir_all(interp, file) != 0) {
                    return -1;
                }
                *slash = '/';
            }
        }
      first:
        if (MKDIR_DEFAULT(path) == 0) {
            return 0;
        }
        if (errno == ENOENT) {
            /* Create the parent and try again */
            continue;
        }
        /* Maybe it already exists as a directory */
        if (errno == EEXIST) {
            Jsi_StatBuf sb;

            if (Jsi_Stat(interp, file, &sb) == 0 && S_ISDIR(sb.st_mode)) {
                return 0;
            }
            /* Restore errno */
            errno = EEXIST;
        }
        /* Failed */
        break;
    }
    return -1;
}

static Jsi_RC FilePwdCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_DString dStr = {};
    Jsi_ValueMakeStringDup(interp, ret, Jsi_GetCwd(interp, &dStr));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static Jsi_RC FileChdirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    if (!path) 
        return Jsi_LogError("expected string");
    int rc = Jsi_Chdir(interp, path);
    if (rc != 0) 
        return Jsi_LogError("can't change to directory \"%s\": %s", GSVal(path), strerror(errno));    
    return JSI_OK;
}

static Jsi_RC FileMkdirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 1);
    char *spath =  Jsi_ValueString(interp, path,0);
    int rc, force = 0; 

    if (!spath) 
        return Jsi_LogError("expected string");
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) 
        return Jsi_LogError("expected boolean");
    if (vf)
        force = vf->d.val;
    if (force==0)
        rc = MKDIR_DEFAULT(spath);
    else {
        Jsi_Value *npath = Jsi_ValueNewStringDup(interp, spath);
        rc = mkdir_all(interp, npath);
        Jsi_ValueFree(interp, npath);
    }
    if (rc != 0) 
        return Jsi_LogError("can't create directory \"%s\": %s", spath, strerror(errno));    
    return JSI_OK;
}

static Jsi_RC FileTempfileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *filename;
#ifndef __WIN32
    Jsi_Value *vt = Jsi_ValueArrayIndex(interp, args, 0);
    const char *tp, *templ = "/tmp/jsiXXXXXX";

    if (vt && (tp = Jsi_ValueString(interp, vt, NULL))) {
        templ = tp;
    }
    filename = Jsi_Strdup(templ);
    int fd = mkstemp(filename);
    if (fd < 0)
        goto fail;
    close(fd);
#else
#ifndef MAX_PATH
#define MAX_PATH 1024
#endif
    char name[MAX_PATH];

    if (!GetTempPath(MAX_PATH, name) || !GetTempFileName(name, "JSI", 0, name)) 
        return Jsi_LogError("failed to get temp file");
    filename = Jsi_Strdup(name);
#endif
    Jsi_ValueMakeString(interp, ret, filename);
    return JSI_OK;
    
#ifndef __WIN32
fail:
    Jsi_LogError("Failed to create tempfile");
    Jsi_Free(filename);
    return JSI_ERROR;
#endif
}

static Jsi_RC FileTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    Jsi_RC rc;
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sizv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number siz;
    if (Jsi_GetNumberFromValue(interp, sizv, &siz) != JSI_OK)
        return JSI_ERROR;
    SAFEACCESS(fname, 1)
    Jsi_Channel ch = Jsi_Open(interp, fname, "rb+");
    if (!ch)
        return JSI_ERROR;
    rc = (Jsi_Truncate(ch, (unsigned int)siz) == 0 ? JSI_OK : JSI_ERROR);
    Jsi_Close(ch);
    return rc;
}

static Jsi_RC FileChmodCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *modv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number fmod;
    if (Jsi_GetNumberFromValue(interp, modv, &fmod) != JSI_OK)
        return JSI_ERROR;
    SAFEACCESS(fname, 1)
    return (Jsi_Chmod(interp, fname, (unsigned int)fmod) == 0 ? JSI_OK : JSI_ERROR);
}

static Jsi_RC FileReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) /* TODO limit. */
{   
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);
    const char *mode = (vmode ? Jsi_ValueString(interp, vmode, NULL) : NULL);
    SAFEACCESS(fname, 0)

    Jsi_Channel chan = Jsi_Open(interp, fname, (mode ? mode : "rb"));
    int n, sum = 0;
    if (!chan) 
        return Jsi_LogError("failed open for read: %s", GSVal(fname));
    Jsi_DString dStr = {};
    char buf[BUFSIZ];
    while (sum < MAX_LOOP_COUNT && (n = Jsi_Read(chan, buf, sizeof(buf))) > 0) {
        Jsi_DSAppendLen(&dStr, buf, n);
        sum += n;
    }
    Jsi_Close(chan);
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
    return JSI_OK;
}


static Jsi_RC FileWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    const char *data;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 2);
    const char *mode = (vmode ? Jsi_ValueString(interp, vmode, NULL) : NULL);
    Jsi_Channel chan;
    int n, len, cnt = 0, sum = 0;
    SAFEACCESS(fname, 1)
    if (!(data = Jsi_ValueGetStringLen(interp, v, &len))) {
        return JSI_ERROR;
    }
    chan = Jsi_Open(interp, fname, (mode ? mode : "wb+"));
    if (!chan) 
        return Jsi_LogError("failed open for write: %s", GSVal(fname));
    while (cnt < MAX_LOOP_COUNT && len > 0 && (n = Jsi_Write(chan, data, len)) > 0) {
        len -= n;
        sum += n;
        cnt++;
    }
    Jsi_Close(chan);
    /* TODO: handle nulls. */
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);
    return JSI_OK;
}

static Jsi_RC FileRenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int force = 0; 

    SAFEACCESS(source, 1)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) 
        return Jsi_LogError("expected boolean");
    if (vf)
        force = vf->d.val;
    if (force==0 && Jsi_Access(interp, dest, F_OK) == 0) 
        return Jsi_LogError("error renaming \"%s\" to \"%s\": target exists", GSVal(source), GSVal(dest));

    if (Jsi_Rename(interp, source, dest) != 0) 
        return Jsi_LogError( "error renaming \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
    return JSI_OK;
}

static int FileCopy(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value* dest, int force) {
    Jsi_Channel ich = Jsi_Open(interp, src, "rb");
    if (!ich)
        return -1;
    if (force && Jsi_Access(interp, dest, F_OK) == 0) {
        Jsi_Remove(interp, dest, 0);
    }
    Jsi_Channel och = Jsi_Open(interp, dest, "wb+");
    if (!och)
        return -1;
    while (1) {
        char buf[BUFSIZ];
        int n;
        n = Jsi_Read(ich, buf, BUFSIZ);
        if (n<=0)
            break;
        if (Jsi_Write(och, buf, n) != n) {
            Jsi_Close(ich);
            Jsi_Close(och);
            return -1;
        }
    }
    /* TODO: set perms. */
#ifndef __WIN32
    Jsi_StatBuf sb;
    Jsi_Stat(interp, src, &sb);
    Jsi_Chmod(interp, dest, sb.st_mode);
#endif
    Jsi_Close(ich);
    Jsi_Close(och);
    return 0;
}

#define FN_copy JSI_INFO("\
Directories are not handled. \
The third argument if given is a boolean force value \
which if true allows overwrite of an existing file. ")
static Jsi_RC FileCopyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int force = 0; 
    SAFEACCESS(source, 0)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) 
        return Jsi_LogError("expected boolean");
    if (vf)
        force = vf->d.val;
    if (force==0 && Jsi_Access(interp, dest, F_OK) == 0) 
        return Jsi_LogError("error copying \"%s\" to \"%s\": target exists", GSVal(source), GSVal(dest));

    if (FileCopy(interp, source, dest, force) != 0) 
        return Jsi_LogError( "error copying \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
    return JSI_OK;
}

#define FN_link JSI_INFO("\
The second argument is the destination file to be created. "\
"If a third bool argument is true, a hard link is created.")
static Jsi_RC FileLinkCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int hard = 0; 
    SAFEACCESS(source, 1)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) 
        return Jsi_LogError("expected boolean");
    if (vf)
        hard = vf->d.val;

    if (Jsi_Link(interp, source, dest, hard) != 0) 
        return Jsi_LogError( "error linking \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
    return JSI_OK;
}

/* TODO: switch to MatchesInDir */
static Jsi_RC RmdirAll(Jsi_Interp *interp, Jsi_Value *path, int force)
{
    DIR *dir;
    struct dirent *entry;
    char spath[PATH_MAX];
    Jsi_RC erc = JSI_OK;
    char *dirname = Jsi_ValueString(interp, path, 0);
    if (!dirname) 
        return Jsi_LogError("expected string");

    /* TODO: change to Jsi_Scandir */
    dir = opendir(dirname);
    if (dir == NULL) {
        if (force)
            return JSI_OK;
        return Jsi_LogError("opening directory: %s", dirname);
    }

    while ((entry = readdir(dir)) != NULL) {
        if (Jsi_Strcmp(entry->d_name, ".") && Jsi_Strcmp(entry->d_name, "..")) {
            snprintf(spath, (size_t) PATH_MAX, "%s/%s", dirname, entry->d_name);
            Jsi_Value *tpPtr = Jsi_ValueNew1(interp);
            Jsi_ValueMakeStringDup(interp, &tpPtr, spath);
#ifndef __WIN32
            if (entry->d_type == DT_DIR) {
                Jsi_RC rc = RmdirAll(interp, tpPtr, force);
                if (rc != JSI_OK)
                    erc = rc;
            } else 
#endif
            {
                if (Jsi_Remove(interp, tpPtr, force) != 0) {
                    if (force)
                        Jsi_LogError("deleting file: %s", GSVal(tpPtr));
                    erc = JSI_ERROR;
                }
            }
            Jsi_DecrRefCount(interp, tpPtr);
        }
    }
    closedir(dir);
    Jsi_Remove(interp, path, force);
    return erc;
}

static Jsi_RC FileRemoveCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 1);
    const char *spath = GSVal(source);
    int rc, force = 0; 
    SAFEACCESS(source, 1)

    Jsi_StatBuf st;
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) 
        return Jsi_LogError("expected boolean");
    if (vf)
        force = vf->d.val;
    rc = Jsi_Stat(interp, source, &st);
    if (Jsi_Strcmp(spath,"/")==0)
        return JSI_ERROR;
    if (rc != 0) {
        if (force)
            return JSI_OK;
        return Jsi_LogError("error deleting \"%s\": target not found", spath);
    }

    if (Jsi_Remove(interp, source, force) != 0) {
        if (!S_ISDIR(st.st_mode)) {
            if (force)
                return JSI_OK;
            return Jsi_LogError("error deleting \"%s\"", spath);
        }
        if (force==0) 
            return Jsi_LogError("error deleting \"%s\": directory not empty", spath);
        return RmdirAll(interp, source, force);
    }
    return JSI_OK;
}

static Jsi_RC FileReadlinkCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    SAFEACCESS(path, 1)

    char *linkValue = (char*)Jsi_Malloc(MAXPATHLEN + 1);

    int linkLength = Jsi_Readlink(interp, path, linkValue, MAXPATHLEN);

    if (linkLength == -1) {
        Jsi_Free(linkValue);
        return Jsi_LogError("couldn't readlink \"%s\": %s", GSVal(path), strerror(errno));
    }
    linkValue[linkLength] = 0;
    Jsi_ValueMakeString(interp, ret, linkValue);
    return JSI_OK;
}

static Jsi_RC FileIsRelativeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    if (path == NULL) 
        return Jsi_LogError("expected string");
    bool isRel = 1;
#if defined(__MINGW32__) || defined(_MSC_VER)
    if ((path[0] && path[1] == ':') || (path[0] == '\\'))
        isRel = 0;
    else
#endif
        isRel = (path[0] != '/');
    Jsi_ValueMakeBool(interp, ret, isRel);
    return JSI_OK;
}

static Jsi_RC FileDirnameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    const char *path = Jsi_ValueString(interp, val, NULL);
    if (!path) 
        return Jsi_LogError("expected string");
    const char *p = Jsi_Strrchr(path, '/');

    if (!p && path[0] == '.' && path[1] == '.' && path[2] == '\0') {
        Jsi_ValueMakeStringKey(interp, ret, "..");
    } else if (!p) {
        Jsi_ValueMakeStringKey(interp, ret, ".");
    }
    else if (p == path) {
        Jsi_ValueMakeStringKey(interp, ret, "/");
    }
#if defined(__MINGW32__) || defined(_MSC_VER)
    else if (p[-1] == ':') {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path, 0, p-path+1));
    }
#endif
    else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path, 0, p-path));
    }
    return JSI_OK;
}

static Jsi_RC FileRootnameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    if (path == NULL) 
        return Jsi_LogError("expected string");
    const char *lastSlash = Jsi_Strrchr(path, '/');
    const char *p = Jsi_Strrchr(path, '.');

    if (p == NULL || (lastSlash != NULL && lastSlash > p)) {
        Jsi_ValueMakeStringDup(interp, ret, path);
    }
    else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path,0, p-path));
    }
    return JSI_OK;
}
static Jsi_RC FileExtensionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    if (path == NULL) 
        return Jsi_LogError("expected string");

    const char *lastSlash = Jsi_Strrchr(path, '/');
    const char *p = Jsi_Strrchr(path, '.');

    if (p == NULL || (lastSlash != NULL && lastSlash >= p)) {
        p = "";
    }
    Jsi_ValueMakeStringDup(interp, ret, p);
    return JSI_OK;

}
static Jsi_RC FileTailCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    if (path == NULL) 
        return Jsi_LogError("expected string");
    const char *lastSlash = Jsi_Strrchr(path, '/');

    if (lastSlash) {
        Jsi_ValueMakeStringDup(interp, ret, lastSlash+1);
    }
    else {
        Jsi_ValueMakeStringDup(interp, ret, path);
    }
    return JSI_OK;
}

static Jsi_RC FileRealpathCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    char *newname = Jsi_FileRealpath(interp, path, NULL);
    if (newname)
        Jsi_ValueMakeString(interp, ret, (char*)newname);
    return JSI_OK;

}

static Jsi_RC FileJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *p2 = Jsi_ValueArrayIndex(interp, args, 1);
    const char *path1 = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    const char *path2 = Jsi_ValueString(interp, p2, NULL);
    if (path1 == NULL || path2 == NULL) 
        return Jsi_LogError("expected string");

    char *newname;
    if (*path2 == '/' || *path2 == '~')
        newname = Jsi_FileRealpath(interp, p2, NULL);
    else {
        Jsi_DString dStr = {};
        Jsi_DSAppend(&dStr, path1, "/", path2, NULL);
        Jsi_Value *tpPtr = Jsi_ValueNew1(interp);
        Jsi_ValueMakeString(interp, &tpPtr, Jsi_DSFreeDup(&dStr));
        newname = Jsi_FileRealpath(interp, tpPtr, NULL);
        Jsi_DecrRefCount(interp, tpPtr);
    }
    if (newname ==  NULL)
        return JSI_ERROR;
    Jsi_ValueMakeString(interp, ret, (char*)newname);
    return JSI_OK;
}

static Jsi_RC FileSizeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    int rc;
    Jsi_StatBuf st;
    SAFEACCESS(path, 0)
    if (Jsi_ValueArrayIndex(interp, args, 1))
        rc = Jsi_Lstat(interp, path, &st);
    else
        rc = Jsi_Stat(interp, path, &st);
    if (rc != 0) 
        return Jsi_LogError("bad file");
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)st.st_size);
    return JSI_OK;
}

typedef struct {
    int limit;            /* Max number of results to return. */
    bool recurse;        /* Recurse into directories. */
    bool tails;          /* Return tail of path. */
    int maxDepth;       /* For recursive */
    int flags;
    bool retCount;
    int cnt;            /* Actual count. */
    int discardCnt;
    int maxDiscard;
    const char *types;   /* File types to include */
    const char *noTypes; /* File types to exclude */
    Jsi_Value *filter;    /* Function that returns true to keep. */
    Jsi_Value *dirFilter; /* Function that returns true to recurse into dir. */
    Jsi_Value *dir;
    const char *dirStr;
    int dirLen;
    const char *prefix;
} GlobData;

const char *globRetValues[] = { "file", "dir", "both", "count" };
static Jsi_OptionSpec GlobOptions[] = {
    JSI_OPT(VALUE,  GlobData, dir,      .help="The start directory: this path will not be prepended to results"),
    JSI_OPT(INT,    GlobData, maxDepth, .help="Maximum directory depth to recurse into"),
    JSI_OPT(INT,    GlobData, maxDiscard,.help="Maximum number of items to discard before giving up"),
    JSI_OPT(FUNC,   GlobData, dirFilter,.help="Filter function for directories, returning false to discard", .flags=0, .custom=0, .data=(void*)"dir:string"),
    JSI_OPT(FUNC,   GlobData, filter,   .help="Filter function to call with each file, returning false to discard", .flags=0, .custom=0, .data=(void*)"file:string"),
    JSI_OPT(INT,    GlobData, limit,    .help="The maximum number of results to return/count"),
    JSI_OPT(STRKEY, GlobData, noTypes,  .help="Filter files to exclude these \"types\""),
    JSI_OPT(STRKEY, GlobData, prefix,   .help="String prefix to add to each file in list"),
    JSI_OPT(BOOL,   GlobData, recurse,  .help="Recurse into sub-directories"),
    JSI_OPT(BOOL,   GlobData, retCount, .help="Return only the count of matches"),
    JSI_OPT(BOOL,   GlobData, tails,    .help="Returned only tail of path"),
    JSI_OPT(STRKEY, GlobData, types,    .help="Filter files to include type: one or more of chars 'fdlpsbc' for file, directory, link, etc"),
    JSI_OPT_END(GlobData)
};

static Jsi_RC SubGlobDirectory(Jsi_Interp *interp, Jsi_Obj *obj, char *zPattern, Jsi_Value *pattern,
  int isreg, const char *path, GlobData *opts, int deep)
{
    struct dirent **namelist;
    Jsi_RC rc = JSI_OK;
    int i, n, flags = opts->flags;
    bool bres = 0;
    Jsi_DString tStr = {};
    Jsi_Value *rpPath = Jsi_ValueNew1(interp);
    const char *spath = path;
    if (!spath || !spath[0])
        spath = ".";
    Jsi_ValueMakeStringDup(interp, &rpPath, spath);
    
    if ((n=Jsi_Scandir(interp, rpPath, &namelist, 0, 0)) < 0) {
        if (opts->recurse && deep) return JSI_OK;
        Jsi_LogError("bad directory");
        Jsi_DecrRefCount(interp, rpPath);
        return JSI_ERROR;
    }

    for (i=0; i<n && rc == JSI_OK; i++)
    {
        int ftyp;
        const char *z = namelist[i]->d_name;
        if (*z == '.') {
            if (!(flags&JSI_FILE_TYPE_HIDDEN))
                continue;
            else if ((z[1] == 0 || (z[1] == '.' && z[2] == 0)))
                continue;
        }
#ifdef __WIN32
        /* HACK in scandir(): if is directory then inode set to 1. */
        ftyp = (namelist[i]->d_ino? DT_DIR : DT_REG);
#else
        ftyp = namelist[i]->d_type;
#endif
        if (ftyp == DT_DIR) {
            if (opts->recurse && (opts->maxDepth<=0 || (deep+1) <= opts->maxDepth)) {
                const char *zz;
                Jsi_DString sStr = {};
                Jsi_DSAppend(&sStr, path, "/",  z, NULL);
                if (opts->dirFilter && Jsi_ValueIsFunction(interp, opts->dirFilter)) {
                    if (!(bres=Jsi_FunctionInvokeBool(interp, opts->dirFilter,
                        Jsi_ValueNewStringDup(interp, Jsi_DSValue(&sStr)))))
                        continue;
                    else if (bres!=0 && bres!=1)
                        rc = JSI_ERROR;
                }
                if (opts->types && Jsi_Strchr(opts->types, 'd')) {
                    opts->cnt++;
                    if (!opts->retCount) {
                        Jsi_DString pStr;
                        Jsi_DSInit(&pStr);
                        if (opts->prefix)
                            Jsi_DSAppend(&pStr, opts->prefix, z, NULL);
                        if (!opts->tails)
                            Jsi_DSAppend(&pStr, path, (path[0]?"/":""), NULL);
                        Jsi_DSAppend(&pStr, z, NULL);
                        zz = Jsi_DSValue(&pStr);
                        if (opts->dirLen && Jsi_Strlen(zz)>=(uint)opts->dirLen) {
                            zz += opts->dirLen;
                            if (zz[0] == '/') zz++;
                        }
                        Jsi_ObjArrayAdd(interp, obj, Jsi_ValueNewStringDup(interp, zz));
                        Jsi_DSFree(&pStr);
                    }
                }
                zz = Jsi_DSValue(&sStr);
                rc = SubGlobDirectory(interp, obj, zPattern, pattern,
                    isreg, zz, opts, deep+1);
                Jsi_DSFree(&sStr);
                if (opts->limit>0 && opts->cnt >= opts->limit)
                    goto done;
                if (opts->maxDiscard>0 && opts->discardCnt >= opts->maxDiscard)
                    goto done;
                if (rc != JSI_OK)
                    goto done;
            }
            if (opts->types==0 && opts->noTypes && (!(flags&JSI_FILE_TYPE_DIRS)))
                continue;
        } else {
            if (!(flags&JSI_FILE_TYPE_FILES))
                continue;
        }
        // TODO: sanity check types/noTypes.
        if (opts->types) {
            const char *cp = opts->types;
            int mat = 0;
            while (cp && *cp && !mat) {
                mat = 0;
                switch (*cp) {
                    case 'd': mat = (ftyp == DT_DIR); break;
                    case 'f': mat = (ftyp == DT_REG); break;
#ifndef __WIN32
                    case 'p': mat = (ftyp == DT_FIFO); break;
                    case 's': mat = (ftyp == DT_SOCK); break;
                    case 'l': mat = (ftyp == DT_LNK); break;
                    case 'c': mat = (ftyp == DT_CHR); break;
                    case 'b': mat = (ftyp == DT_BLK); break;
#endif
                }
                cp++;
            }
            if (!mat)
                continue;
        }
        if (opts->noTypes) {
            const char *cp = opts->noTypes;
            int mat = 0;
            while (cp && *cp && !mat) {
                mat = 0;
                switch (*cp) {
                    case 'd': mat = (ftyp == DT_DIR); break;
                    case 'f': mat = (ftyp == DT_REG); break;
#ifndef __WIN32
                    case 'p': mat = (ftyp == DT_FIFO); break;
                    case 's': mat = (ftyp == DT_SOCK); break;
                    case 'l': mat = (ftyp == DT_LNK); break;
                    case 'c': mat = (ftyp == DT_CHR); break;
                    case 'b': mat = (ftyp == DT_BLK); break;
#endif
                }
                cp++;
            }
            if (mat)
                continue;
        }

        if (isreg) {
           int ismat;
            Jsi_RegExpMatch(interp, pattern, z, &ismat, NULL);
            if (!ismat)
                continue;
        } else if (zPattern != NULL && Jsi_GlobMatch(zPattern, z, 0) == 0)
            continue;
        if (opts->filter && Jsi_ValueIsFunction(interp, opts->filter)) {
            if (!(bres=Jsi_FunctionInvokeBool(interp, opts->filter,
                Jsi_ValueNewStringDup(interp, z)))) {
                opts->discardCnt++;
                continue;
            } else if (bres!=0 && bres!=1)
                rc = JSI_ERROR;
        }
        opts->cnt++;
        if (!opts->retCount) {
            Jsi_DSInit(&tStr);
            if (opts->prefix)
                Jsi_DSAppend(&tStr, opts->prefix, z, NULL);
            if (!opts->tails)
                Jsi_DSAppend(&tStr, path, (path[0]?"/":""), NULL);
            Jsi_DSAppend(&tStr, z, NULL);
            z = Jsi_DSValue(&tStr);
            if (opts->dirLen && Jsi_Strlen(z)>=(uint)opts->dirLen) {
                z += opts->dirLen;
                if (z[0] == '/') z++;
            }
            rc = Jsi_ObjArrayAdd(interp, obj, Jsi_ValueNewStringDup(interp, z));
            Jsi_DSFree(&tStr);
        }
        if (opts->limit>0 && opts->cnt >= opts->limit)
            break;
        if (opts->maxDiscard>0 && opts->discardCnt >= opts->maxDiscard)
            break;
            
    }

done:
    if (rpPath)
        Jsi_DecrRefCount(interp, rpPath);
    if (namelist) {
        while (--n >= 0)
            Jsi_Free(namelist[n]);
        Jsi_Free(namelist);
    }
    return rc;     
}
#define FN_glob JSI_INFO("\
With no arguments (or null) returns all files/directories in current directory. \
The first argument can be a pattern (either a glob or regexp) of the files to return. \
When the second argument is a function, it is called with each path, and filter on false. \
Otherwise second arugment must be a set of options.")
static Jsi_RC FileGlobCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int fo = 1, isOpts = 0;
    Jsi_RC rc = JSI_OK;
    Jsi_Value *pat = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *dir = NULL;
    Jsi_Value *tvPtr = Jsi_ValueNew1(interp);
    Jsi_Value *pvPtr = Jsi_ValueNew1(interp);
    GlobData Data = {};
    Jsi_Obj *obj = NULL;
    int len, isreg = 0;
    char *zPattern = NULL;
    const char *dcp;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    
    Data.flags = JSI_FILE_TYPE_FILES;

    if (arg)
        switch (arg->vt) {
        case JSI_VT_NULL: break;
        case JSI_VT_OBJECT:
        {
            Jsi_Obj *sobj = arg->d.obj;
            switch (sobj->ot) {
                case JSI_OT_OBJECT:
                    if (Jsi_ValueIsFunction(interp, arg)) {
                        Data.filter = arg;
                        break;
                    } else if (!sobj->isarrlist) {
                        isOpts = 1;
                        break;
                    }
                default: fo = 0;
            }
            if (fo) break;
        }
        default:
            rc = Jsi_LogError("arg2 must be a function, options or null");
            goto done;
    }
    if (isOpts && Jsi_OptionsProcess(interp, GlobOptions, &Data, arg, 0) < 0) {
        rc = JSI_ERROR;
        goto done;
    }
    if (Data.dir) {
        dcp = Data.dirStr = Jsi_ValueString(interp, Data.dir, &Data.dirLen);
        if (*dcp == '~') {
            dcp = Jsi_FileRealpath(interp, Data.dir, NULL);
            if (!dcp)
                dcp = Data.dirStr;
            else
                Data.dirLen = Jsi_Strlen(dcp);
        }
        Jsi_DSAppend(&dStr, dcp, NULL);
    }
    
    if (pat == NULL || Jsi_ValueIsNull(interp, pat)) {
        Jsi_ValueMakeStringKey(interp, &pvPtr, "*");
        pat = pvPtr;
        Data.flags = JSI_FILE_TYPE_DIRS|JSI_FILE_TYPE_FILES;
    } else if (Jsi_ValueIsString(interp, pat)) {
        char *cpp, *pstr = Jsi_ValueString(interp, pat, NULL);
        if (pstr && ((cpp=Jsi_Strrchr(pstr, '/')))) {
            Jsi_DString tStr = {};
            Jsi_DSAppend(&tStr, cpp+1, NULL);
            Jsi_ValueMakeStringKey(interp,  &pvPtr, Jsi_DSValue(&tStr));
            pat = pvPtr;
            Jsi_DSFree(&tStr);

            if (Jsi_DSLength(&dStr))
                Jsi_DSAppend(&tStr, "/", NULL);
            Jsi_DSAppendLen(&dStr, pstr, (cpp-pstr));
        }
    }

    dcp = Jsi_DSValue(&dStr);
    
    Jsi_ValueString(interp, dir, NULL);
    if (*dcp == '~') {
        dcp = Jsi_FileRealpath(interp, dir, NULL);
        if (dcp) {
            Jsi_ValueMakeString(interp, &tvPtr, dcp);
            dir = tvPtr;
        }
    }
    
    if (interp->isSafe) {

        if (Data.dir && Jsi_DSLength(&dStr)<=0)
            dir = Data.dir;
        else if (Jsi_DSLength(&dStr)<=0)
            Jsi_DSAppend(&dStr, ".", NULL);
        
        if (!dir) {
            Jsi_ValueMakeStringKey(interp, &tvPtr, Jsi_DSValue(&dStr));
            dir = tvPtr;
        }

        if (Jsi_InterpAccess(interp, dir, 0) != JSI_OK) {
            rc = Jsi_LogError("read access denied");
            goto done;
        }
    }
   // if (!Data.dir && Jsi_DSLength(&dStr)<=0)
    //    Jsi_DSAppend(&dStr, ".", NULL);
    if (!(isreg=Jsi_ValueIsObjType(interp, pat, JSI_OT_REGEXP)))
        zPattern = Jsi_ValueString(interp, pat, &len);
 /*   pathPtr = Jsi_ValueString(interp, dir, &len);
    if (!pathPtr) { rc = JSI_ERROR; goto done; }
    if (len && pathPtr[len-1] == '/')
        len--; */
        
    if (!Data.retCount) {
        obj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, obj);
    }
    rc = SubGlobDirectory(interp, obj, zPattern, pat, isreg, Jsi_DSValue(&dStr), &Data, 0);
    if (rc != JSI_OK)
        Jsi_ValueMakeUndef(interp, ret);   
    else if (Data.retCount)
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)Data.cnt);

done:
    if (pvPtr)
        Jsi_DecrRefCount(interp, pvPtr);
    if (tvPtr)
        Jsi_DecrRefCount(interp, tvPtr);
    if (isOpts)
        Jsi_OptionsFree(interp, GlobOptions, &Data, 0);
    return rc;
}

static Jsi_CmdSpec fileCmds[] = {
    { "atime",      FileAtimeCmd,       1,  1, "file:string",  .help="Return file Jsi_Access time", .retType=(uint)JSI_TT_NUMBER },
    { "chdir",      FileChdirCmd,       1,  1, "file:string",  .help="Change current directory" },
    { "chmod",      FileChmodCmd,       2,  2, "file:string, mode:string",  .help="Set file permissions" },
    { "copy",       FileCopyCmd,        2,  3, "src:string, dest:string, force:boolean=false",  .help="Copy a file to destination", .retType=0, .flags=0, .info=FN_copy },
    { "dirname",    FileDirnameCmd,     1,  1, "file:string",  .help="Return directory path", .retType=(uint)JSI_TT_STRING },
    { "executable", FileExecutableCmd,  1,  1, "file:string",  .help="Return true if file is executable", .retType=(uint)JSI_TT_BOOLEAN },
    { "exists",     FileExistsCmd,      1,  1, "file:string",  .help="Return true if file exists", .retType=(uint)JSI_TT_BOOLEAN },
    { "extension",  FileExtensionCmd,   1,  1, "file:string",  .help="Return file extension", .retType=(uint)JSI_TT_STRING },
    { "join",       FileJoinCmd,        2,  2, "path:string, path:string",  .help="Join two file realpaths, or just second if an absolute path", .retType=(uint)JSI_TT_STRING },
    { "isdir",      FileIsdirCmd,       1,  1, "file:string",  .help="Return true if file is a directory", .retType=(uint)JSI_TT_BOOLEAN },
    { "isfile",     FileIsfileCmd,      1,  1, "file:string",  .help="Return true if file is a normal file", .retType=(uint)JSI_TT_BOOLEAN },
    { "isrelative", FileIsRelativeCmd,  1,  1, "file:string",  .help="Return true if file path is relative", .retType=(uint)JSI_TT_BOOLEAN },
    { "glob",       FileGlobCmd,        0,  2, "pattern:regexp|string|null='*', options:function|object|null=void", .help="Return list of files in dir with optional pattern match", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=FN_glob, .opts=GlobOptions },
    { "link",       FileLinkCmd,        2,  3, "src:string, dest:string, ishard:boolean=false",  .help="Link a file", .retType=0, .flags=0, .info=FN_link },
    { "lstat",      FileLstatCmd,       1,  1, "file:string",  .help="Return status info for file", .retType=(uint)JSI_TT_OBJECT },
    { "mkdir",      FileMkdirCmd,       1,  1, "file:string",  .help="Create a directory" },
    { "mtime",      FileMtimeCmd,       1,  1, "file:string",  .help="Return file modified time", .retType=(uint)JSI_TT_NUMBER },
    { "owned",      FileOwnedCmd,       1,  1, "file:string",  .help="Return true if file is owned by user", .retType=(uint)JSI_TT_BOOLEAN },
    { "pwd",        FilePwdCmd,         0,  0, "",  .help="Return current directory", .retType=(uint)JSI_TT_STRING },
    { "remove",     FileRemoveCmd,      1,  2, "file:string, force:boolean=false",  .help="Delete a file or direcotry" },
    { "rename",     FileRenameCmd,      2,  3, "src:string, dest:string, force:boolean=false",  .help="Rename a file, with possible overwrite" },
    { "read",       FileReadCmd,        1,  2, "file:string, mode:string='rb'",  .help="Read a file", .retType=(uint)JSI_TT_STRING },
    { "readable",   FileReadableCmd,    1,  1, "file:string",  .help="Return true if file is readable", .retType=(uint)JSI_TT_BOOLEAN },
    { "readlink",   FileReadlinkCmd,    1,  1, "file:string",  .help="Read file link destination", .retType=(uint)JSI_TT_STRING },
    { "realpath",   FileRealpathCmd,    1,  1, "file:string",  .help="Return absolute file name minus .., ./ etc", .retType=(uint)JSI_TT_STRING },
    { "rootname",   FileRootnameCmd,    1,  1, "file:string",  .help="Return file name minus extension", .retType=(uint)JSI_TT_STRING },
    { "size",       FileSizeCmd,        1,  1, "file:string",  .help="Return size for file", .retType=(uint)JSI_TT_NUMBER },
    { "stat",       FileStatCmd,        1,  1, "file:string",  .help="Return status info for file", .retType=(uint)JSI_TT_OBJECT },
    { "tail",       FileTailCmd,        1,  1, "file:string",  .help="Return file name minus dirname", .retType=(uint)JSI_TT_STRING },
    { "tempfile",   FileTempfileCmd,    1,  1, "file:string",  .help="Create a temp file", .retType=(uint)JSI_TT_ANY },
    { "truncate",   FileTruncateCmd,    2,  2, "file:string, size:number",  .help="Truncate file" },
    { "type",       FileTypeCmd,        1,  1, "file:string",  .help="Return type of file", .retType=(uint)JSI_TT_STRING },
    { "write",      FileWriteCmd,       2,  3, "file:string, str:string, mode:string='wb+'",  .help="Write a file", .retType=(uint)JSI_TT_NUMBER },
    { "writable",   FileWritableCmd,    1,  1, "file:string",  .help="Return true if file is writable", .retType=(uint)JSI_TT_BOOLEAN },
    { NULL, 0,0,0,0, .help="Commands for accessing the filesystem" }
};

Jsi_RC jsi_InitFileCmds(Jsi_Interp *interp, int release)
{
    if (!release)
        Jsi_CommandCreateSpecs(interp, "File",   fileCmds,   NULL, 0);
    return JSI_OK;
}
#endif
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/******************* TREE ACCESS **********************/

Jsi_Value *Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey) {
    Jsi_Tree *treePtr = obj->tree;
    
    if (!isstrkey) {
        Jsi_MapEntry *hPtr = Jsi_MapEntryFind(treePtr->opts.interp->strKeyTbl, key);
        if (!hPtr)
            return NULL;
        key = (const char*)Jsi_MapKeyGet(hPtr, 0);
    }
    Jsi_Value *v = (Jsi_Value*)Jsi_TreeGet(treePtr, (void*)key, 0);
    return v;
}

Jsi_TreeEntry *Jsi_TreeObjSetValue(Jsi_Obj *obj, const char *key, Jsi_Value *val, int isstrkey) {
    Jsi_Tree *treePtr = obj->tree;
    bool isNew;
    Jsi_TreeEntry *hPtr;
    Jsi_Interp *interp = treePtr->opts.interp;
    if (!isstrkey) {
        const char *okey = key;
        Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, key, &isNew);
        key = (const char*)Jsi_MapKeyGet(hePtr, 0);
        if (!key) {
            Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, okey, &isNew);
            key = (const char*)Jsi_MapKeyGet(hePtr, 0);
        }
    }
    //return Jsi_TreeSet(treePtr, key, val);
    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);
    if (!hPtr)
        return NULL;
    if (val)
        SIGASSERT(val,VALUE);
    if (!isNew)
        Jsi_ValueReplace(interp, (Jsi_Value**)&(hPtr->value), val);
    else {
        hPtr->value = val;
        if (val)
            Jsi_IncrRefCount(interp, val);
    }
//    Jsi_Value *oldVal;  /* FYI: This let kitty.breed() work in tests/proto2.js */
//    Assert(val->refCnt>0);
//    if (!isNew) {
//        oldVal = Jsi_TreeValueGet(hPtr);
//        if (oldVal) {
//            Jsi_ValueReset(interp, &oldVal);
//            Jsi_ValueCopy(interp, oldVal, val);
//        }
//    }
//    else
//        hPtr->value = val;

    return hPtr;
}

/*****************************************/

bool Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o)  {
    return ((o)->ot == JSI_OT_OBJECT && o->isarrlist);
}

static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_Interp *interp = tree->opts.interp;
    Jsi_Obj *obj = (Jsi_Obj*)data;
    int n;
    if (!hPtr->f.bits.dontenum) {
        char *cp = (char*)Jsi_TreeKeyGet(hPtr), *ocp = cp;
        /* TODO: accept hex??? */
        while (*cp && isdigit(*cp))
            cp++;
        if (*cp)
            return JSI_OK;
        n = atoi(ocp);
        if (n >= interp->maxArrayList)
            return JSI_OK;
        hPtr->f.bits.isarrlist = 1;
        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) 
            return Jsi_LogError("too long");
        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
       // obj->arrCnt++;
    }
    return JSI_OK;
}

static Jsi_RC ObjListifyArrayCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    if (hPtr->f.bits.isarrlist) {
        Jsi_TreeEntryDelete(hPtr);
        tree->opts.interp->delRBCnt++;
        return JSI_ERROR;
    }
    return JSI_OK;
}

void Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj)
{
    if (!obj->isarrlist) {
        Jsi_LogBug("Can not listify a non-array");
        return;
    }
    if (obj->arr) return;
    Jsi_TreeWalk(obj->tree, ObjListifyCallback, obj, 0);

    do {
        interp->delRBCnt = 0;
        Jsi_TreeWalk(obj->tree, ObjListifyArrayCallback, obj, 0);
    } while (interp->delRBCnt);
}

void jsi_IterObjFree(Jsi_IterObj *iobj)
{
    if (!iobj->isArrayList) {
        uint i;
        for (i = 0; i < iobj->count; i++) {
            if (iobj->keys[i]) {
                /*Jsi_TreeDecrRef(iobj->keys[i]); TODO: ??? */
            }
        }
        Jsi_Free(iobj->keys);
    }
    Jsi_Free(iobj);
}

Jsi_IterObj *jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterCmd)
{
    Jsi_IterObj *o = (Jsi_IterObj*)Jsi_Calloc(1,sizeof(Jsi_IterObj));
    o->interp = interp;
    SIGINIT(o,OBJ);
    o->iterCmd = iterCmd;
    return o;
}

static Jsi_RC DeleteTreeValue(Jsi_Interp *interp, Jsi_TreeEntry *ti, void *p) {
    /* Cleanup tree value. */
    SIGASSERT(ti,TREEENTRY);
    Jsi_Value *v = (Jsi_Value*)p;
    SIGASSERT(v,VALUE);
    Jsi_DecrRefCount(interp, v);
    ti->value = NULL;
    return JSI_OK;
}

Jsi_Obj *jsi_ObjNew_(Jsi_Interp *interp)
{
    Jsi_Obj *obj = (Jsi_Obj*)Jsi_Calloc(1,sizeof(*obj));
    SIGINIT(obj,OBJ);
    jsi_DebugObj(obj,"New", jsi_DebugValueCallIdx(), interp);
    obj->ot = JSI_OT_OBJECT;
    obj->tree = Jsi_TreeNew(interp, JSI_KEYS_STRINGKEY, NULL);
    obj->tree->opts.freeTreeProc = DeleteTreeValue;
    obj->tree->flags.valuesonly = 1;
    obj->__proto__ = interp->Object_prototype;
    interp->dbPtr->objCnt++;
    interp->dbPtr->objAllocCnt++;
   return obj;
}

#ifndef JSI_MEM_DEBUG
Jsi_Obj * Jsi_ObjNew(Jsi_Interp *interp) {
    return jsi_ObjNew_(interp);
}
#else
Jsi_Obj * jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Obj *obj = jsi_ObjNew_(interp);
    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, fname, line, func);
    return obj;
}

#ifndef JSI_OMIT_STUBS
#undef Jsi_ObjNew
Jsi_Obj *Jsi_ObjNew(Jsi_Interp *interp) { return jsi_ObjNew_(interp); }
#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#endif

#endif

Jsi_Obj *Jsi_ObjNewType(Jsi_Interp *interp, Jsi_otype otype)
{
    Jsi_Obj *obj = Jsi_ObjNew(interp);
    obj->ot = (otype==JSI_OT_ARRAY?JSI_OT_OBJECT:otype);
    switch (otype) {
        case JSI_OT_OBJECT: obj->__proto__ = interp->Object_prototype; break;
        case JSI_OT_BOOL:   obj->__proto__ = interp->Boolean_prototype; break;
        case JSI_OT_NUMBER: obj->__proto__ = interp->Number_prototype; break;
        case JSI_OT_STRING: obj->__proto__ = interp->String_prototype; break;
        case JSI_OT_FUNCTION:obj->__proto__ = interp->Function_prototype; break;
        case JSI_OT_REGEXP: obj->__proto__ = interp->RegExp_prototype; break;
        case JSI_OT_ARRAY:  obj->__proto__ = interp->Array_prototype;
            obj->isarrlist = 1;
            break;
        default: assert(0); break;
    }
    if (interp->protoInit)
        assert(obj->__proto__);
    return obj;
}

void Jsi_ObjFree(Jsi_Interp *interp, Jsi_Obj *obj)
{
    interp->dbPtr->objCnt--;
    //assert(obj->refcnt == 0);
#ifdef JSI_MEM_DEBUG
    jsi_DebugObj(obj,"Free", jsi_DebugValueCallIdx(), interp);
    if (obj->VD.hPtr)
        Jsi_HashEntryDelete(obj->VD.hPtr);
#endif
    /* printf("Free obj: %x\n", (int)obj); */
    switch (obj->ot) {
        case JSI_OT_STRING:
            if (!obj->isstrkey)
                Jsi_Free(obj->d.s.str);
            obj->d.s.str = 0;
            obj->isstrkey = 0;
            break;
        case JSI_OT_FUNCTION:
            jsi_FuncObjFree(obj->d.fobj);
            break;
        case JSI_OT_ITER:
            jsi_IterObjFree(obj->d.iobj);
            break;
        case JSI_OT_USEROBJ:
            jsi_UserObjFree(interp, obj->d.uobj);
            break;
        case JSI_OT_REGEXP:
            if ((obj->d.robj->eflags&JSI_REG_STATIC)==0) {
                regfree(&obj->d.robj->reg);
                Jsi_Free(obj->d.robj);
            }
            break;
        default:
            break;
    }
    if (obj->tree)
        Jsi_TreeDelete(obj->tree);
    if (obj->arr) {
        int i = -1;
        while (++i < (int)obj->arrCnt)
            if (obj->arr[i])
                Jsi_DecrRefCount(interp, obj->arr[i]);
        Jsi_Free(obj->arr);
        obj->arr = NULL;
    }
    obj->tree = NULL;
    if (obj->clearProto)
        Jsi_DecrRefCount(interp, obj->__proto__);
    _JSI_MEMCLEAR(obj);
    Jsi_Free(obj);
}


/**************************** ARRAY ******************************/

Jsi_Value *jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key) {
    const char *cp = key;
    int n;
    /* TODO: accept hex??? */
    if (!obj->arr)
        return NULL;
    while (*cp && isdigit(*cp))
        cp++;
    if (*cp)
        return NULL;
    n = atoi(key);
    if (n >= (int)obj->arrCnt)
        return NULL;
    Jsi_Value *v = obj->arr[n];
    return v;
}

Jsi_RC Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v)
{
    if (o->isarrlist == 0)
        return JSI_ERROR;
    if (!o->arr)
        Jsi_ObjListifyArray(interp, o);
    int len = o->arrCnt;
    if (Jsi_ObjArraySizer(interp, o, len+1) <= 0)
        return JSI_ERROR;
    o->arr[len] = v;
    if (v)
        Jsi_IncrRefCount(interp, v);
    assert(o->arrCnt<=o->arrMaxSize);
    return JSI_OK;
}

Jsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)
{
    int m, n = arrayindex;
    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
        return JSI_ERROR;
    if (obj->arr[n] == value)
        return JSI_OK;
    if (obj->arr[n])
        Jsi_DecrRefCount(interp, obj->arr[n]);
    Assert(obj->arrCnt<=obj->arrMaxSize);
    obj->arr[n] = value;
    if (value)
        Jsi_IncrRefCount(interp, value);
    m = Jsi_ObjGetLength(interp, obj);
    if ((n+1) > m)
       Jsi_ObjSetLength(interp, obj, n+1);
    return JSI_OK;
}

// Copying version of above.
Jsi_Value *jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int n)
{
    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
        return NULL;
    if (obj->arr[n])
    {
        Jsi_ValueCopy(interp, obj->arr[n], value);
        return obj->arr[n];
    }
    Assert(obj->arrCnt<=obj->arrMaxSize);
    Jsi_Value *v = Jsi_ValueNew1(interp);
    int m;
    Jsi_ValueCopy(interp,v, value);
    obj->arr[n] = v;
    m = Jsi_ObjGetLength(interp, obj);
    if ((n+1) > m)
       Jsi_ObjSetLength(interp, obj, n+1);
    return v;
}

int Jsi_ObjIncrRefCount(Jsi_Interp *interp, Jsi_Obj *obj) {
    jsi_DebugObj(obj,"Incr", jsi_DebugValueCallIdx(), interp);
    SIGASSERT(obj,OBJ);
    Assert(obj->refcnt>=0);
    return ++obj->refcnt;
}

int Jsi_ObjDecrRefCount(Jsi_Interp *interp, Jsi_Obj *obj)  {
    SIGASSERT(obj,OBJ);
    if (obj->refcnt<=0) {
#ifdef JSI_MEM_DEBUG
        Jsi_LogBug("Obj double free: %p", obj);
#endif
        return -2;
    }
    jsi_DebugObj(obj,"Decr", jsi_DebugValueCallIdx(), interp);
    int nref;
    if ((nref = --obj->refcnt) <= 0) {
        obj->refcnt = -1;
        Jsi_ObjFree(interp, obj);
    }
    return nref;
}


int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)
{
    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;
    assert(obj->isarrlist);
    if (mod>1)
        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);
    if (nsiz > MAX_ARRAY_LIST) {
        Jsi_LogError("array size too large");
        return 0;
    }
    if (len >= obj->arrMaxSize) {
        int oldsz = (nsiz-obj->arrMaxSize);
        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));
        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));
        obj->arrMaxSize = nsiz;
    }
    if (len>obj->arrCnt)
        obj->arrCnt = len;
    return nsiz;
}

Jsi_Obj *Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copyflag)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    if (count>=0) {
        int i;
        if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {
            Jsi_ObjFree(interp, obj);
            return NULL;
        }
        for (i = 0; i < count; ++i) {
            if (!copyflag) {
                obj->arr[i] = items[i];
                Jsi_IncrRefCount(interp, items[i]);
            } else {
                obj->arr[i] = Jsi_ValueNew1(interp);
                Jsi_ValueCopy(interp, obj->arr[i], items[i]);
            }
        }
    }
    obj->arrCnt = count;
    assert(obj->arrCnt<=obj->arrMaxSize);
    return obj;
}

/****** END ARRAY ************/

static Jsi_TreeEntry* ObjInsertFromValue(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *keyVal, Jsi_Value *nv)
{
    const char *key = NULL;
    int flags = 0;
    Jsi_DString dStr = {};
    if (keyVal->vt == JSI_VT_STRING) {
        flags = (keyVal->f.bits.isstrkey ? JSI_OM_ISSTRKEY : 0);
        key = keyVal->d.s.str;
    } else if (keyVal->vt == JSI_VT_OBJECT && keyVal->d.obj->ot == JSI_OT_STRING) {
        Jsi_Obj *o = keyVal->d.obj;
        flags = (o->isstrkey ? JSI_OM_ISSTRKEY : 0);
        key = o->d.s.str;
    }
    if (key == NULL)
        key = Jsi_ValueGetDString(interp, keyVal, &dStr, 0);
    return Jsi_ObjInsert(interp, obj, key, nv, flags);
}

Jsi_Obj *Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    int i;
    for (i = 0; i < count; i += 2) {
        Jsi_Value *v = Jsi_ValueDup(interp, items[i+1]);
        ObjInsertFromValue(interp, obj, items[i], v);
        Jsi_DecrRefCount(interp, v);
    }
    return obj;
}

void Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len)
{
    if (obj->isarrlist) {
        assert(len<=obj->arrMaxSize);
        obj->arrCnt = len;
        return;
    }
    Jsi_Value *r = Jsi_TreeObjGetValue(obj,"length", 0);
    if (!r) {
        Jsi_Value *n = Jsi_ValueMakeNumber(interp, NULL, len);
        Jsi_ObjInsert(interp, obj, "length", n, JSI_OM_DONTDEL | JSI_OM_DONTENUM | JSI_OM_READONLY);
    } else {
        Jsi_ValueReset(interp, &r);
        Jsi_ValueMakeNumber(interp, &r, len);
    }
}

int Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj)
{
    if (obj->tree && obj->tree->numEntries) {
        Jsi_Value *r = Jsi_TreeObjGetValue(obj, "length", 0);
        Jsi_Number nr;
        if (r && Jsi_GetNumberFromValue(interp,r, &nr) == JSI_OK) {
            if (Jsi_NumberIsInteger(nr))
                return nr;
        }
    }
    if (obj->arr)
        return obj->arrCnt;

    return 0;
}

Jsi_Value *jsi_ObjValueNew(Jsi_Interp *interp)
{
    return Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNew(interp));
}


/* Set result string into obj. */
void Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj) {
    int len = Jsi_DSLength(dsPtr);
    if (obj->ot == JSI_OT_STRING && obj->d.s.str && !obj->isstrkey)
        Jsi_Free(obj->d.s.str);
    if (!(obj->d.s.str = (char*)dsPtr->strA)) {
        obj->d.s.str = (char*)Jsi_Malloc(len+1);
        memcpy(obj->d.s.str, dsPtr->Str, len+1);
    }
    obj->d.s.len = len;
    dsPtr->strA = NULL;
    dsPtr->Str[0] = 0;
    dsPtr->len = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
}
#endif
#ifndef JSI_LITE_ONLY
#include <signal.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#ifndef JSI_AMALGAMATION
/* Adapted to update so "signal.handle(func) gets called back like setInterval/setTimeout */
#include "jsiInt.h"
#endif
#if JSI__SIGNAL==1


enum { SIGNAL_ACTION_IGNORE=-1,  SIGNAL_ACTION_DEFAULT=0, SIGNAL_ACTION_HANDLE=1, MAX_SIGNALS = (sizeof(Jsi_Wide) * 8)};

static Jsi_Wide *sigloc;
static Jsi_Wide sigsblocked;
static struct sigaction *saOldPtr[MAX_SIGNALS] = {NULL};
static struct sigaction saOld[MAX_SIGNALS];
static int signal_handling[MAX_SIGNALS] = {0};

/* Make sure to do this as a wide, not int */
#define sig_to_bit(SIG) ((Jsi_Wide)1 << (SIG))

static void signal_handler(int sig)
{
    /* We just remember which signals occurred. Jsi_Eval() will
     * notice this as soon as it can and throw an error
     */
    *sigloc |= sig_to_bit(sig);
}

static void signal_ignorer(int sig)
{
    /* We just remember which signals occurred */
    sigsblocked |= sig_to_bit(sig);
}

#define CASESIGNAL(name) case SIG##name: return "SIG" #name;

const char *Jsi_SignalId(int sig)
{
    switch (sig) {
    CASESIGNAL(ABRT); CASESIGNAL(ALRM); CASESIGNAL(BUS);  CASESIGNAL(CONT);   CASESIGNAL(FPE);
    CASESIGNAL(HUP);  CASESIGNAL(ILL);  CASESIGNAL(INT);  CASESIGNAL(KILL);   CASESIGNAL(PIPE);
    CASESIGNAL(PROF); CASESIGNAL(QUIT); CASESIGNAL(SEGV); CASESIGNAL(STOP);   CASESIGNAL(SYS);
    CASESIGNAL(TERM); CASESIGNAL(TRAP); CASESIGNAL(TSTP); CASESIGNAL(TTIN);   CASESIGNAL(TTOU);
    CASESIGNAL(URG);  CASESIGNAL(USR1); CASESIGNAL(USR2); CASESIGNAL(VTALRM); CASESIGNAL(WINCH);
    CASESIGNAL(XCPU);
    CASESIGNAL(XFSZ);
#ifdef SIGPWR
    CASESIGNAL(PWR);
#endif
#ifdef SIGCLD
    CASESIGNAL(CLD);
#endif
#ifdef SIGEMT
    CASESIGNAL(EMT);
#endif
#ifdef SIGLOST
    CASESIGNAL(LOST);
#endif
#ifdef SIGIO
    CASESIGNAL(IO);
#endif
#if defined(SIGPOLL) && (SIGPOLL != SIGIO)
    CASESIGNAL(POLL);
#endif
#ifdef SIGINFO
    CASESIGNAL(INFO);
#endif
    }
    return NULL;
}

const char *Jsi_SignalName(int sig)
{
    const char *cp;
#ifdef HAVE_SYS_SIGLIST
    if (sig >= 0 && sig < NSIG) {
        return sys_siglist[sig];
    }
#endif
    cp = Jsi_SignalId(sig);
    if (cp == NULL)
        cp = "unknown signal";
    return cp;
}

/**
 * Given the name of a signal, returns the signal value if found,
 * or returns -1 (and sets an error) if not found.
 * We accept -SIGINT, SIGINT, INT or any lowercase version or a number,
 * either positive or negative.
 */
static int find_signal_by_name(Jsi_Interp *interp, const char *name)
{
    int i;
    const char *pt = name;

    /* Remove optional - and SIG from the front of the name */
    if (*pt == '-') {
        pt++;
    }
    if (Jsi_Strncasecmp(name, "sig", 3) == 0) {
        pt += 3;
    }
    if (isdigit(UCHAR(pt[0]))) {
        i = atoi(pt);
        if (i > 0 && i < MAX_SIGNALS) {
            return i;
        }
    }
    else {
        for (i = 1; i < MAX_SIGNALS; i++) {
            /* Jsi_SignalId() returns names such as SIGINT, and
             * returns "unknown signal id" if unknown, so this will work
             */
            if (Jsi_Strncasecmp(Jsi_SignalName(i) + 3, pt, -1) == 0) {
                return i;
            }
        }
    }
    return -1;
}

void jsi_SignalClear(Jsi_Interp *interp, int sigNum) {
    Jsi_Wide nsig = sig_to_bit(sigNum);
    (*sigloc) &= ~nsig;
}

bool jsi_SignalIsSet(Jsi_Interp *interp, int sigNum) {
    return (((*sigloc) & sig_to_bit(sigNum)) != 0);
}

static void jsi_SignalSet(Jsi_Interp *interp, int sig) {
    struct sigaction sa;

    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = signal_handler;

    if (SIGNAL_ACTION_HANDLE != signal_handling[sig]) {

        if (signal_handling[sig] == SIGNAL_ACTION_DEFAULT) {
            saOldPtr[sig] = &saOld[sig];
            sigaction(sig, &sa, saOldPtr[sig]);
        }
        else {
            sigaction(sig, &sa, 0);
        }
        signal_handling[sig] = SIGNAL_ACTION_HANDLE;
    }
}

static Jsi_RC SignalSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int action)
{

    struct sigaction sa;
    int i, argc = Jsi_ValueGetLength(interp, args);
    
    if (&interp->sigmask != sigloc) {
        Jsi_LogWarn("not primary interp");
        return JSI_OK;
    }
    
    if (argc == 0) {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        int m;
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
        for (i = 0, m = 0; i < MAX_SIGNALS; i++) {
            if (signal_handling[i] == action) {
                /* Add signal name to the list  */
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, Jsi_SignalName(i)), m++);
            }
        }
        return JSI_OK;
    }

    /* Catch all the signals we care about */
    if (action != SIGNAL_ACTION_DEFAULT) {
        sa.sa_flags = 0;
        sigemptyset(&sa.sa_mask);
        if (action == SIGNAL_ACTION_HANDLE) {
            sa.sa_handler = signal_handler;
        }
        else {
            sa.sa_handler = signal_ignorer;
        }
    }

    /* Iterate through the provided signals */
    for (i = 0; i < argc; i++) {
        char *sstr;
        int sig = find_signal_by_name(interp, sstr=Jsi_ValueArrayIndexToStr(interp,args,i, NULL));

        if (sig < 0) 
            return Jsi_LogError("unknown signal: %s", sstr);
        if (action != signal_handling[sig]) {
            /* Need to change the action for this signal */
            switch (action) {
                case SIGNAL_ACTION_HANDLE:
                case SIGNAL_ACTION_IGNORE:
                    if (signal_handling[sig] == SIGNAL_ACTION_DEFAULT) {
                        saOldPtr[sig] = &saOld[sig];
                        sigaction(sig, &sa, saOldPtr[sig]);
                    }
                    else {
                        sigaction(sig, &sa, 0);
                    }
                    break;

                case SIGNAL_ACTION_DEFAULT:
                    /* Restore old handler */
                    sigaction(sig, saOldPtr[sig], NULL);
            }
            signal_handling[sig] = action;
        }
    }

    return JSI_OK;
}

static Jsi_RC SignalHandleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_HANDLE);
}

static Jsi_RC SignalIgnoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_IGNORE);
}

static Jsi_RC SignalResetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_DEFAULT);
}

static Jsi_RC SignalNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    int i, m;
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (i=0, m=0; i<MAX_SIGNALS; i++) {
        const char *nam;
        nam = Jsi_SignalId(i);
        if (nam)
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, nam), m++);
    }
    return JSI_OK;
}

static Jsi_RC SignalAlarmCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 0);
    uint rc;
    Jsi_Number dtim;
    
    if (Jsi_GetNumberFromValue(interp, sv, &dtim) != JSI_OK) 
        return Jsi_LogError("bad time");
    if (dtim<1)
        rc = ualarm(dtim * 1e6, 0);
    else
        rc = alarm((uint)dtim);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rc);
    return JSI_OK;
}

static Jsi_RC SignalKillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *vpid = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number npid;
    int rc, sigNum = SIGTERM;
    if (Jsi_GetNumberFromValue(interp, vpid, &npid) != JSI_OK) 
        return Jsi_LogError("bad pid");
    if (sv) {
        if (sv->vt == JSI_VT_NUMBER)
            sigNum = (int)sv->d.num;
        else {
            char *ts = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
            if ((sigNum = find_signal_by_name(interp, ts)) < 0) 
                return Jsi_LogError("bad signal: %s", ts);
        }
    }
    if (sigNum < 0 || sigNum >= MAX_SIGNALS) 
        return Jsi_LogError("bad signal: %d", sigNum);
    rc = kill((int)npid, sigNum);
    if (rc != 0) 
        return Jsi_LogError("kill failure");
    return JSI_OK;
}

static Jsi_RC SignalCallbackCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    bool isNew;
    Jsi_Event *ev;
    long id;
    int sigNum;
    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 1);
    
    if (!Jsi_ValueIsFunction(interp, fv)) 
        return Jsi_LogError("expected function");
    if (sv && sv->vt == JSI_VT_NUMBER)
        sigNum = (int)sv->d.num;
    else {
        char *ts = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
        if ((sigNum = find_signal_by_name(interp, ts)) < 0) 
            return Jsi_LogError("expected signal");
    }
    if (sigNum < 0 || sigNum >= MAX_SIGNALS) 
        return Jsi_LogError("unknown signal: %d", sigNum);
    while (1) {
        id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->funcVal = fv;
        Jsi_IncrRefCount(interp, fv);
        ev->hPtr = hPtr;
        ev->sigNum = sigNum;
        ev->evType = JSI_EVENT_SIGNAL;
        Jsi_HashValueSet(hPtr, ev);
        break;
    }
    jsi_SignalSet(interp, sigNum);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);
    return JSI_OK;
}


static Jsi_CmdSpec signalCmds[] = {
    { "alarm",      SignalAlarmCmd,       1, 1, "secs", .help="Setup alarm in seconds", .retType=(uint)JSI_TT_NUMBER },
    { "callback",   SignalCallbackCmd,    2, 2, "func:function, sig:number|string",  .help="Setup callback handler for signal", .retType=(uint)JSI_TT_NUMBER },
    { "handle",     SignalHandleCmd,      0,-1, "sig:number|string=void, ...", .help="Set named signals to handle action", .retType=(uint)JSI_TT_ANY },
    { "ignore",     SignalIgnoreCmd,      0,-1, "sig:number|string=void, ...", .help="Set named signals to ignore action", .retType=(uint)JSI_TT_ANY },
    { "kill",       SignalKillCmd,        1, 2, "pid:number, sig:number|string='SIGTERM'", .help="Send signal to process id", .retType=(uint)JSI_TT_VOID },
    { "names",      SignalNamesCmd,       0, 0, "", .help="Return names of all signals", .retType=(uint)JSI_TT_ARRAY },
    { "reset",      SignalResetCmd,       0,-1, "sig:number|string=void, ...", .help="Set named signals to default action", .retType=(uint)JSI_TT_ARRAY },
    { NULL, 0,0,0,0, .help="Commands for handling unix signals" }
};

Jsi_RC jsi_InitSignal(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    static int isinit = 0;
    if (!isinit) {
        sigloc = &interp->sigmask;
        isinit = 1;
    }
    Jsi_CommandCreateSpecs(interp, "Signal",    signalCmds,    NULL, 0);
    return JSI_OK;
}

#endif
#endif
/* An implementation of Red-Black Trees with invariant node pointers. 
 * Nodes are allocated using single malloc that includes the key. 
 * This means that string/struct keys (which are of varying length) can not be copied between nodes.
 * So instead of swapping node key/values, positions are swapped when balancing the tree. */

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

enum {_JSI_TREE_RED=0, _JSI_TREE_BLACK=1};

/********************** _JSI_TREE_RED/_JSI_TREE_BLACK HELPERS **************************/

static Jsi_TreeEntry* grandparent(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    Assert (n->parent->parent != NULL);
    return n->parent->parent;
}

static Jsi_TreeEntry* sibling(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    return (n == n->parent->left ? n->parent->right : n->parent->left);
}

static Jsi_TreeEntry* uncle(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    Assert (n->parent->parent != NULL);
    return sibling(n->parent);
}

static int node_color(Jsi_TreeEntry* n) {
    return n == NULL ? _JSI_TREE_BLACK : n->f.bits.color;
}

static void set_color(Jsi_TreeEntry* n, int color) {
    if (color == _JSI_TREE_BLACK && n == NULL) return;
    n->f.bits.color = color;
}

static void replace_node(Jsi_TreeEntry* oldn, Jsi_TreeEntry* newn) {
    Assert(oldn);
    Jsi_Tree* t = oldn->treePtr;
    if (oldn->parent == NULL) {
        t->root = newn;
    } else {
        if (oldn == oldn->parent->left)
            oldn->parent->left = newn;
        else
            oldn->parent->right = newn;
    }
    if (newn != NULL) {
        newn->parent = oldn->parent;
    }
}

static void rotate_left(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* r;
    Assert(n);
    r = n->right;
    replace_node(n, r);
    n->right = r->left;
    if (r->left != NULL) {
        r->left->parent = n;
    }
    r->left = n;
    n->parent = r;
}

static void rotate_right(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* l;
    Assert(n);
    l = n->left;
    replace_node(n, l);
    n->left = l->right;
    if (l->right != NULL) {
        l->right->parent = n;
    }
    l->right = n;
    n->parent = l;
}

static void insert_case5(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* g = grandparent(n);
    set_color(n->parent, _JSI_TREE_BLACK);
    set_color(g, _JSI_TREE_RED);
    if (n == n->parent->left) {
        rotate_right(g);
    } else {
        Assert (n == n->parent->right);
        rotate_left(g);
    }
}

static void insert_case4(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* g = grandparent(n);
    if (n == n->parent->right && n->parent == g->left) {
        rotate_left(n->parent);
        n = n->left;
    } else if (n == n->parent->left && n->parent == g->right) {
        rotate_right(n->parent);
        n = n->right;
    }
    insert_case5(n);
}

static void insert_case1(Jsi_TreeEntry* n);

static void insert_case3(Jsi_TreeEntry* n) {
    Jsi_TreeEntry *g, *u = uncle(n);
    if (node_color(u) == _JSI_TREE_RED) {
        set_color(n->parent, _JSI_TREE_BLACK);
        set_color(u, _JSI_TREE_BLACK);
        g = grandparent(n);
        set_color(g, _JSI_TREE_RED);
        insert_case1(g);
    } else {
        insert_case4(n);
    }
}

static void insert_case2(Jsi_TreeEntry* n) {
    if (node_color(n->parent) == _JSI_TREE_BLACK)
        return;
    insert_case3(n);
}

static void insert_case1(Jsi_TreeEntry* n) {
    if (n->parent == NULL)
        set_color(n, _JSI_TREE_BLACK);
    else
        insert_case2(n);
}

static Jsi_TreeEntry* maximum_node(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    while (n->right != NULL) {
        n = n->right;
    }
    return n;
}

static void delete_case6(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    set_color(s, node_color(n->parent));
    set_color(n->parent, _JSI_TREE_BLACK);
    if (n == n->parent->left) {
        Assert (node_color(s->right) == _JSI_TREE_RED);
        set_color(s->right, _JSI_TREE_BLACK);
        rotate_left(n->parent);
    }
    else
    {
        //Assert (node_color(s->left) == _JSI_TREE_RED);
        set_color(s->left, _JSI_TREE_BLACK);
        rotate_right(n->parent);
    }
}

static void delete_case5(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(s) == _JSI_TREE_BLACK ) {
        if (n == n->parent->left &&
                node_color(s->right) == _JSI_TREE_BLACK &&
                node_color(s->left) == _JSI_TREE_RED)
        {
            set_color(s, _JSI_TREE_RED);
            set_color(s->left, _JSI_TREE_BLACK);
            rotate_right(s);
        }
        else if (n == n->parent->right &&
                 node_color(s->right) == _JSI_TREE_RED &&
                 node_color(s->left) == _JSI_TREE_BLACK)
        {
            set_color(s, _JSI_TREE_RED);
            set_color(s->right, _JSI_TREE_BLACK);
            rotate_left(s);
        }
    }
    delete_case6(n);
}

static void delete_case4(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(n->parent) == _JSI_TREE_RED &&
            node_color(s) == _JSI_TREE_BLACK &&
            node_color(s->left) == _JSI_TREE_BLACK &&
            node_color(s->right) == _JSI_TREE_BLACK)
    {
        set_color(s, _JSI_TREE_RED);
        set_color(n->parent, _JSI_TREE_BLACK);
    }
    else
        delete_case5(n);
}

static void delete_case1(Jsi_TreeEntry* n);

static void delete_case3(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s  = sibling(n);
    if (node_color(n->parent) == _JSI_TREE_BLACK &&
        node_color(s) == _JSI_TREE_BLACK &&
        node_color(s->left) == _JSI_TREE_BLACK &&
        node_color(s->right) == _JSI_TREE_BLACK)
    {
        set_color(s, _JSI_TREE_RED);
        delete_case1(n->parent);
    } else
        delete_case4(n);
}

static void delete_case2(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(s) == _JSI_TREE_RED) {
        set_color(n->parent, _JSI_TREE_RED);
        set_color(s, _JSI_TREE_BLACK);
        if (n == n->parent->left)
            rotate_left(n->parent);
        else
            rotate_right(n->parent);
    }
    delete_case3(n);
}

static void delete_case1(Jsi_TreeEntry* n) {
    if (n->parent != NULL)
        delete_case2(n);
}

/***********************************************************/

int jsi_treeHeight(Jsi_TreeEntry* hPtr, int n)
{
    int l = -1, r = -1;
    if (hPtr->right == NULL && hPtr->right == NULL )
        return n;
    if (hPtr->left)
        l = jsi_treeHeight(hPtr->left, n+1);
    if (hPtr->right)
        r = jsi_treeHeight(hPtr->right, n+1);
    return (r > l ? r : l);
}

int jsi_nodeDepth(Jsi_TreeEntry* hPtr) {
    int d = 0;
    while (hPtr->parent != NULL) {
        d++;
        hPtr = hPtr->parent;
    }
    return d;
}


static int StringPtrCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    //return (key1 - key2);
    if (key1 == key2) return 0;
    //return Jsi_DictionaryCompare((char*)key1, (char*)key2);
    return Jsi_Strcmp((char*)key1, (char*)key2);
}


static int StringCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return Jsi_DictionaryCompare((char*)key1, (char*)key2);
    //return Jsi_Strcmp((char*)key1, (char*)key2);
}

static int OneWordCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return ((uintptr_t )key1 - (uintptr_t)key2);
}

static int TreeArrayCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return memcmp(key1, key2, treePtr->keyType);
}


static Jsi_TreeEntry *TreeStringCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;

    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry) + Jsi_Strlen((char*)key) /*- sizeof(jsi_TreeKey)*/ + 1;
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    Jsi_Strcpy(hPtr->key.string, (char*)key);
    treePtr->numEntries++;
    return hPtr;
}

static Jsi_TreeEntry *TreeArrayCreate(Jsi_Tree *treePtr, const void *key, bool *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;

    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry) + treePtr->keyType; /*- sizeof(jsi_TreeKey);*/
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    memcpy(hPtr->key.string, key, treePtr->keyType);
    treePtr->numEntries++;
    return hPtr;
}

static Jsi_TreeEntry *OneWordCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;
    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry);
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    hPtr->key.oneWordValue = (void *)key;
    treePtr->numEntries++;
    return hPtr;
}


static Jsi_TreeEntry *StringPtrCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)
{
    return OneWordCreate(treePtr, key, newPtr);
}

void *Jsi_TreeValueGet(Jsi_TreeEntry *hPtr)
{
    return hPtr->value;
}

void *Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr)
{
    Jsi_Tree *t = hPtr->treePtr;
    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);
}


Jsi_TreeEntry *Jsi_TreeEntryFind (Jsi_Tree *treePtr, const void *key)
{
    Jsi_TreeEntry* hPtr = treePtr->root;
    int rc;
    if (treePtr->flags.destroyed)
        return NULL;
    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)
        return NULL;
    while (hPtr != NULL) {
        rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(hPtr), key);
        if (rc == 0) {
            break;
        }
        hPtr = (rc < 0 ? hPtr->left : hPtr->right);
    }
    if (treePtr->opts.lockTreeProc)
        (*treePtr->opts.lockTreeProc)(treePtr, 0);
    return hPtr;
}

Jsi_TreeEntry *Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew)
{
    Jsi_TreeEntry* hPtr;
    bool isn;
    if (treePtr->flags.destroyed)
        return NULL;
    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)
        return NULL;
    treePtr->flags.inserting=1;
    if (treePtr->flags.internstr) {
        Assert(treePtr->keyType == JSI_KEYS_STRINGKEY);
        if (!treePtr->strHash)
            treePtr->strHash = Jsi_HashNew(treePtr->opts.interp, JSI_KEYS_STRING, NULL);
        key = Jsi_HashEntryNew(treePtr->strHash, key, NULL);
    }
    hPtr = treePtr->createProc(treePtr, key, &isn);
    if (isNew)
        *isNew = isn;
    if (isn == 0 || treePtr->flags.nonredblack == 1 || !hPtr) {
        treePtr->flags.inserting=0;
        goto done;
    }
    treePtr->epoch++;
    hPtr->f.bits.color = _JSI_TREE_RED;
    if (treePtr->root == NULL) {
        treePtr->root = hPtr;
    } else {
        Jsi_TreeEntry* n = treePtr->root;
        while (1) {
            int rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(n) , key);
            if (rc == 0) {
                Assert(0);
            } else if (rc < 0) {
                if (n->left == NULL) {
                    n->left = hPtr;
                    break;
                } else {
                    n = n->left;
                }
            } else {
                if (n->right == NULL) {
                    n->right = hPtr;
                    break;
                } else {
                    n = n->right;
                }
            }
        }
        hPtr->parent = n;
    }
    insert_case1(hPtr);
    treePtr->flags.inserting = 0;
done:
    if (treePtr->opts.lockTreeProc)
        (*treePtr->opts.lockTreeProc)(treePtr, 0);
    return hPtr;
}

Jsi_Tree *Jsi_TreeNew(Jsi_Interp *interp, unsigned int keyType, Jsi_TreeDeleteProc *freeProc)
{
    Jsi_Tree* treePtr = (Jsi_Tree*)Jsi_Calloc(1,sizeof(Jsi_Tree));
    SIGINIT(treePtr,TREE);
    treePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_TREE;
    treePtr->typ = (Jsi_Map_Type)JSI_MAP_TREE;
    treePtr->root = NULL;
    treePtr->opts.interp = interp;
    treePtr->numEntries = 0;
    treePtr->epoch = 0;
    treePtr->opts.keyType = (Jsi_Key_Type)keyType;
    treePtr->keyType = (Jsi_Key_Type)keyType;
    treePtr->opts.freeTreeProc = freeProc;

    switch (keyType) {
    case JSI_KEYS_STRING:   /* NULL terminated string keys. */
        treePtr->opts.compareTreeProc = StringCompare;
        treePtr->createProc = TreeStringCreate;
        break;

    case JSI_KEYS_STRINGKEY: /*  */
        treePtr->opts.compareTreeProc = StringPtrCompare;
        treePtr->createProc = StringPtrCreate;
        break;
        
    case JSI_KEYS_ONEWORD: /* 32 or 64 bit atomic keys. */
        treePtr->opts.compareTreeProc = OneWordCompare;
        treePtr->createProc = OneWordCreate;
        break;


    default:            /* Struct. */
        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {
            Jsi_LogError("Jsi_TreeNew: Key size can't be %d, must be > %d", keyType, JSI_KEYS_STRUCT_MINSIZE);
            Jsi_Free(treePtr);
            return NULL;
        }
        treePtr->opts.compareTreeProc = TreeArrayCompare;
        treePtr->createProc = TreeArrayCreate;
        break;
    }
    return treePtr;
}

static void destroy_node(Jsi_Interp *interp, Jsi_TreeEntry* n)
{
    if (n == NULL) return;
    if (n->right != NULL) destroy_node(interp, n->right);
    if (n->left != NULL) destroy_node(interp, n->left);
    n->left = n->right = NULL;
    Jsi_TreeEntryDelete(n);
}

void Jsi_TreeClear (Jsi_Tree *treePtr)
{
    SIGASSERT(treePtr, TREE);
    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)
        return;
    destroy_node(treePtr->opts.interp, treePtr->root);
    treePtr->root = NULL;
    if (treePtr->opts.lockTreeProc)
        (*treePtr->opts.lockTreeProc)(treePtr, 0);
}

void Jsi_TreeDelete (Jsi_Tree *treePtr)
{
    SIGASSERT(treePtr, TREE);
    if (treePtr->flags.destroyed)
        return;
    //Jsi_TreeClear(treePtr);
    treePtr->flags.destroyed = 1;
    destroy_node(treePtr->opts.interp, treePtr->root);
    _JSI_MEMCLEAR(treePtr);
    Jsi_Free(treePtr);
}

/* Swap positions of nodes in tree.  This avoids moving the value, which we can't do for strings/structs. */
static void SwapNodes(Jsi_TreeEntry* n, Jsi_TreeEntry* m)
{
    Jsi_Tree* t = n->treePtr;
    Jsi_TreeEntry *np, *nl, *nr, *mp, *ml, *mr;
    int mpc = 0, npc = 0, col = n->f.bits.color;
    n->f.bits.color = m->f.bits.color;  m->f.bits.color = col;
    np = n->parent; nl = n->left; nr = n->right;
    mp = m->parent; ml = m->left; mr = m->right;
    if (mp) mpc = (mp->left == m ?1 : 2);
    if (np) npc = (np->left == n ?1 : 2);

    n->parent = mp; n->left = ml; n->right = mr;
    m->parent = np; m->left = nl; m->right = nr;
    
    if (np == m) {
        m->parent = n;
        if (mr == n) n->right = m; else n->left = m;
    } else if (mp == n) {
        n->parent = m;
        if (nr == m) m->right = n; else m->left = n;
    }
    /* Fixup back pointers. */
    if (m->left)  m->left->parent  = m;
    if (m->right) m->right->parent = m;
    if (n->left)  n->left->parent  = n;
    if (n->right) n->right->parent = n;
    if (mpc) { if (mpc==1) n->parent->left = n; else  n->parent->right = n;}
    if (npc) { if (npc==1) m->parent->left = m; else  m->parent->right = m; }
    if (n->parent == NULL) {
        t->root = n;
    } else if (m->parent == NULL) {
        t->root = m;
    }
}

static void delete_one_child(Jsi_TreeEntry*n)
{
    Jsi_TreeEntry *child;
    Assert(n->left == NULL || n->right == NULL);
    child = n->right == NULL ? n->left  : n->right;
#if 1
    if (node_color(n) == _JSI_TREE_BLACK) {
        set_color(n, node_color(child));
        delete_case1(n);
    }
    replace_node(n, child);
    if (n->parent == NULL && child != NULL)
        set_color(child, _JSI_TREE_BLACK);
    
#else
    replace_node(n, child);
    if (node_color(n) == _JSI_TREE_BLACK) {
        if (node_color(child) == _JSI_TREE_RED)
            child->f.bits.color = _JSI_TREE_BLACK;
        else
            delete_case1(n);
    }
#endif
}

int Jsi_TreeEntryDelete (Jsi_TreeEntry *entryPtr)
{
    int cnt = 0;
    Jsi_TreeEntry* n = entryPtr;
    Jsi_Tree* treePtr = n->treePtr;

    if (treePtr->flags.destroyed  || treePtr->flags.nonredblack == 1 /* || entryPtr->f.bits.deletesub */) {
        goto dodel;
    }
    /*printf("DEL(tree=%p,root=%p): (%p)%s\n", treePtr, treePtr->root, entryPtr,(char*)entryPtr->key.string);*/
    /*dumpTree(treePtr);*/
    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)
        return -1;
    entryPtr->treePtr->epoch++;
    if (n->left != NULL && n->right != NULL) {
        /* swap key/values delete pred instead */
        Jsi_TreeEntry* pred = maximum_node(n->left);
        switch (treePtr->keyType) {
        case JSI_KEYS_STRINGKEY:
        case JSI_KEYS_ONEWORD: {
            void *nv = n->value;
            n->value = pred->value;
            pred->value = nv;
            nv = n->key.oneWordValue;
            n->key.oneWordValue = pred->key.oneWordValue;
            pred->key.oneWordValue = nv;
            n = pred;
            break;
        }
        case JSI_KEYS_STRING:
            SwapNodes(n,pred);
            break;
        default: { // Struct keys have the same length so we swap bytes.
            uint i;
            void *nv = n->value;
            n->value = pred->value;
            pred->value = nv;
            char ct, *cs = (char*)(n->key.string), *cd = (char*)(pred->key.string);
            for (i=0; i<treePtr->keyType; i++, cs++, cd++) {
                ct = *cd;
                *cd = *cs;
                *cs = ct;
            }
        }
                
        }
    }
    delete_one_child(n);
    cnt++;
    /*dumpTree(treePtr);*/
dodel:
    treePtr->numEntries--;
    n->treePtr = NULL;
    if (treePtr->opts.freeTreeProc && n && n->value)
        (treePtr->opts.freeTreeProc)(treePtr->opts.interp, n, n->value);
    Jsi_Free(n);
    if (treePtr->opts.lockTreeProc)
        (*treePtr->opts.lockTreeProc)(treePtr, 0);
    return cnt;
}

static void searchSpace(Jsi_TreeSearch *searchPtr, int n)
{
    if ((searchPtr->top+n) >= searchPtr->max) {
        int i, cnt = (searchPtr->max *= 2);
        if (searchPtr->Ptrs == searchPtr->staticPtrs)
            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Calloc(cnt, sizeof(Jsi_TreeEntry*));
        else
            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Realloc(searchPtr->Ptrs, cnt* sizeof(Jsi_TreeEntry*));
        for (i=0; i<cnt; i++)
            SIGINIT((searchPtr->Ptrs[i]),TREEENTRY);

    }
}

static Jsi_TreeEntry *searchAdd(Jsi_TreeSearch *searchPtr,  Jsi_TreeEntry *hPtr)
{
    int order = (searchPtr->flags & JSI_TREE_ORDER_MASK);
    searchSpace(searchPtr, 2);
    switch (order) {
        case JSI_TREE_ORDER_LEVEL:
            if (hPtr) {
                if (hPtr->right)
                    searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
                if (hPtr->left)
                    searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
                return hPtr;
            }
            if (searchPtr->top<=0)
                return NULL;
            hPtr = searchPtr->Ptrs[0];
            searchPtr->top--;
            if (searchPtr->top > 0) {
                /* Not very efficient way to implement a queue, but works for now. */
                memmove(searchPtr->Ptrs, searchPtr->Ptrs+1, sizeof(Jsi_TreeEntry*)*searchPtr->top);
            }
            if (hPtr->right)
                searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
            if (hPtr->left)
                searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
            return hPtr;
            break;
            
        case JSI_TREE_ORDER_POST:
            if (hPtr)
                searchPtr->Ptrs[searchPtr->top++] = searchPtr->current = hPtr;
            while (searchPtr->top>0) {
                hPtr = searchPtr->Ptrs[searchPtr->top-1];
                if (hPtr->right == searchPtr->current || hPtr->left == searchPtr->current ||
                    (hPtr->left == NULL && hPtr->right == NULL)) {
                    searchPtr->top--;
                    searchPtr->current = hPtr;
                    return hPtr;
                } else {
                    searchSpace(searchPtr, 2);
                    if (hPtr->left)
                        searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
                    if (hPtr->right)
                        searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
                }
            }
            return NULL;
            break;
            
        case JSI_TREE_ORDER_PRE:
            if (!hPtr) {
                if (searchPtr->top<=0) return NULL;
                hPtr = searchPtr->Ptrs[--searchPtr->top];
            }
            searchPtr->Ptrs[searchPtr->top++] = hPtr;
            if (hPtr->left) searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
            if (hPtr->right) searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
            break;
            
        case JSI_TREE_ORDER_IN:
            while (1) {
                searchSpace(searchPtr, 2);
                if (searchPtr->current) {
                    searchPtr->Ptrs[searchPtr->top++] = searchPtr->current;
                    searchPtr->current = searchPtr->current->right;
                } else {
                    if (searchPtr->top<=0)
                        return NULL;
                    hPtr = searchPtr->Ptrs[--searchPtr->top] ;
                    searchPtr->current = hPtr->left;
                    return hPtr;
                }
            }
            break;
            
        default:
            if (hPtr) {
                Jsi_Interp *interp = hPtr->treePtr->opts.interp;
                JSI_NOTUSED(interp);
                Jsi_LogError("Invalid order: %d", order);    
            }    
    }
    return searchPtr->Ptrs[--searchPtr->top];
}

Jsi_TreeEntry *Jsi_TreeSearchFirst (Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey)
{
    Jsi_TreeEntry *hPtr = NULL, *hPtr2 = NULL;
    if (!treePtr) return NULL;
    memset(searchPtr, 0, sizeof(*searchPtr));
    searchPtr->treePtr = treePtr;
    searchPtr->flags = flags;
    searchPtr->Ptrs = searchPtr->staticPtrs;
    searchPtr->max = sizeof(searchPtr->staticPtrs)/sizeof(searchPtr->staticPtrs[0]);
    searchPtr->epoch = treePtr->epoch;
    if (startKey || (flags & JSI_TREE_SEARCH_KEY))
        hPtr2 = Jsi_TreeEntryFind(treePtr, startKey);;
    searchPtr->current = treePtr->root;
    hPtr = searchAdd(searchPtr, treePtr->root);
    if (hPtr2 && hPtr && hPtr2 != hPtr)
        while (hPtr && hPtr2 != hPtr) // TODO: need a more efficient way to do this...
            hPtr = Jsi_TreeSearchNext(searchPtr);
    return hPtr;
}

void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value)
{
    Jsi_Value *v = (Jsi_Value*)value;
#if JSI__MEMDEBUG
    SIGASSERT(hPtr, TREEENTRY);
    if (hPtr->treePtr->flags.valuesonly)
        SIGASSERT(v,VALUE);
#endif
    hPtr->value = v;
}

#ifndef JSI_LITE_ONLY

Jsi_Tree *Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v)
{
    if (!Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT))
        return NULL;
    return v->d.obj->tree;
}

#endif 

Jsi_TreeEntry *Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr)
{
    Jsi_TreeEntry *hPtr = NULL;
    if (searchPtr->epoch == searchPtr->treePtr->epoch)
        hPtr = searchAdd(searchPtr, NULL);
    if (!hPtr)
        Jsi_TreeSearchDone(searchPtr);
    return hPtr;
}

void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr)
{
    if (searchPtr->Ptrs != searchPtr->staticPtrs)
        Jsi_Free(searchPtr->Ptrs);
    searchPtr->Ptrs = searchPtr->staticPtrs;
    searchPtr->top = 0;
}

Jsi_TreeEntry *Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value)
{
    Jsi_TreeEntry *hPtr;
    bool isNew;
    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);
    if (!hPtr) return hPtr;
    Jsi_TreeValueSet(hPtr, value);
    return hPtr;
}

void *Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags)
{
    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);
    if (!hPtr)
        return NULL;
    return Jsi_TreeValueGet(hPtr);
}

// Delete entry, and invoke freeProc.
bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key) {
    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);
    if (!hPtr)
        return false;
    Jsi_TreeEntryDelete(hPtr);
    return true;
}

static int tree_inorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (hPtr->right != NULL) {
        if (tree_inorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    Assert(hPtr->treePtr);
    if (hPtr->left != NULL) {
        if (tree_inorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


static int tree_preorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    if (hPtr->right != NULL) {
        if (tree_preorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_preorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


static int tree_postorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (hPtr->right != NULL) {
        if (tree_postorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_postorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    return JSI_OK;
}


static int tree_levelorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback,
    void *data, int curlev, int level, int *cnt) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (curlev > level) return JSI_OK;
    if (curlev == level) {
        if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
        (*cnt)++;
    }
    if (hPtr->right != NULL) {
        if (tree_levelorder(treePtr, hPtr->right, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_levelorder(treePtr, hPtr->left, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags) {
    Jsi_Interp *interp = treePtr->opts.interp;
    JSI_NOTUSED(interp);
    int n = 0, m = -1, lastm, order;
    order = flags & JSI_TREE_ORDER_MASK;
    switch (order) {
    case JSI_TREE_ORDER_PRE:
        return tree_preorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_ORDER_POST:
        return tree_postorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_ORDER_IN:
        return tree_inorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_ORDER_LEVEL:
        while (1) {
            lastm = m;
            if (tree_levelorder(treePtr, treePtr->root, callback, data, 0, n, &m) != JSI_OK)
                return JSI_ERROR;
            if (lastm == m)
                return JSI_OK;
            n++;
        }
            
    default:
        Jsi_LogError("Invalid order: %d", order);
    }
    return JSI_ERROR;
}

#ifdef JSI_TEST_RBTREE

JSI_RC mycall(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data)
{
    printf("CALL: %s(%d) : %d\n", (char*)Jsi_TreeKeyGet(hPtr), jsi_nodeDepth(hPtr), (int)Jsi_TreeValueGet(hPtr));
    return JSI_OK;
}

static void TreeTest(Jsi_Interp* interp) {
    Jsi_Tree *st, *wt, *mt;
    Jsi_TreeEntry *hPtr, *hPtr2;
    bool isNew, i;
    Jsi_TreeSearch srch;
    struct tdata {
        int n;
        int m;
    } t1, t2;
    char nbuf[100];
    
    wt = Jsi_TreeNew(interp, JSI_KEYS_ONEWORD, NULL);
    mt = Jsi_TreeNew(interp, sizeof(struct tdata), NULL);

    Jsi_TreeSet(wt, wt,(void*)0x88);
    Jsi_TreeSet(wt, mt,(void*)0x99);
    printf("WT: %p\n", Jsi_TreeGet(wt, mt));
    printf("WT2: %p\n", Jsi_TreeGet(wt, wt));
    Jsi_TreeDelete(wt);

    t1.n = 0; t1.m = 1;
    t2.n = 1; t2.m = 2;
    Jsi_TreeSet(mt, &t1,(void*)0x88);
    Jsi_TreeSet(mt, &t2,(void*)0x99);
    Jsi_TreeSet(mt, &t2,(void*)0x98);
    printf("CT: %p\n", Jsi_TreeGet(mt, &t1));
    printf("CT2: %p\n", Jsi_TreeGet(mt, &t2));
    Jsi_TreeDelete(mt);

    st = Jsi_TreeNew(interp, JSI_KEYS_STRING, NULL);
    hPtr = Jsi_TreeEntryNew(st, "bob", &isNew);
    Jsi_TreeValueSet(hPtr, (void*)99);
    Jsi_TreeSet(st, "zoe",(void*)77);
    hPtr2 = Jsi_TreeSet(st, "ted",(void*)55);
    Jsi_TreeSet(st, "philip",(void*)66);
    Jsi_TreeSet(st, "alice",(void*)77);
    puts("SRCH");
    for (hPtr=Jsi_TreeSearchFirst(st,&srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch))
        mycall(st, hPtr, NULL);
    Jsi_TreeSearchDone(&srch);
    puts("IN");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_IN);
    puts("PRE");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_PRE);
    puts("POST");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_POST);
    puts("LEVEL");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_LEVEL);
    Jsi_TreeEntryDelete(hPtr2);
    puts("INDEL");
    Jsi_TreeWalk(st, mycall, NULL, 0);

    for (i=0; i<1000; i++) {
        snprintf(nbuf, sizeof(nbuf), "name%d", i);
        Jsi_TreeSet(st, nbuf,(void*)i);
    }
    Jsi_TreeWalk(st, mycall, NULL, 0);
    for (i=0; i<1000; i++) {
        Jsi_TreeEntryDelete(st->root);
    }
    puts("OK");
    Jsi_TreeWalk(st, mycall, NULL, 0);
    Jsi_TreeDelete(st);

}

int jsi_InitTree(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    TreeTest(interp);
    return JSI_OK;
}

#else

Jsi_RC jsi_InitTree(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    /* TODO: maintain hash table of trees created per interp? */
    return JSI_OK;
}
#endif
uint Jsi_TreeSize(Jsi_Tree *treePtr) { return treePtr->numEntries; }

Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set)
{
    if (set)
        treePtr->opts = *opts;
    else
        *opts = treePtr->opts;
    return JSI_OK;
}

#ifndef JSI_LITE_ONLY

static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)
{
    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;
    void *key = Jsi_TreeKeyGet(hPtr);
    if (opts->keyType == JSI_KEYS_ONEWORD)
        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);
    char nbuf[100];
    snprintf(nbuf, sizeof(nbuf), "%p", key);
    return Jsi_ValueNewStringDup(opts->interp, nbuf);
}

Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *tablePtr, Jsi_Value **ret, int flags) {
    char *key;
    int n = 0;
    Jsi_TreeEntry *hPtr;
    Jsi_TreeSearch search;
    Jsi_Obj *nobj;
    Jsi_MapFmtKeyProc* fmtKeyProc = tablePtr->opts.fmtKeyProc;
    
    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )
        fmtKeyProc = jsi_treeFmtKey;
        
    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) 
        return Jsi_LogError("Can not dump struct tree");
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (hPtr = Jsi_TreeSearchFirst(tablePtr, &search, flags, NULL);
        hPtr != NULL; hPtr = Jsi_TreeSearchNext(&search)) {
        key = (char*)Jsi_TreeKeyGet(hPtr);
        Jsi_Value *val;
        if (fmtKeyProc) {
            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);
            if (!val) {
                Jsi_LogError("key format failed");
                Jsi_ValueMakeUndef(interp, ret);
                return JSI_ERROR;
            }
        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)
            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);
        else
            val = Jsi_ValueNewStringKey(interp, key);
        Jsi_ObjArraySet(interp, nobj, val, n++);
        if (fmtKeyProc && val->refCnt>1) //TODO: Hmmm. for StructKey Jsi_OptionsDump() returns refCnt=1
            Jsi_DecrRefCount(interp, val);
    }
    Jsi_TreeSearchDone(&search);
    return JSI_OK;
}
#endif

#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#include <string.h>
#include <stdlib.h>
#include <memory.h>
#include <stddef.h>
#include <stdint.h>


#ifndef JSI_OMIT_MD5
// Source from Sqlite
struct jsi_MD5_Context {
    uint buf[4];
    uint bits[2];
    unsigned char in[64];
};
typedef char jsi_MD5Context[88];

/*
 * Note: this code is harmless on little-endian machines.
 */
static void jsi_MD5_byteReverse (unsigned char *buf, unsigned longs) {
    uint t;
    do {
        t = (uint)((unsigned)buf[3]<<8 | buf[2]) << 16 |
            ((unsigned)buf[1]<<8 | buf[0]);
        *(uint *)buf = t;
        buf += 4;
    } while (--longs);
}
/* The four core functions - _JSI_F1 is optimized somewhat */

/* #define _JSI_F1(x, y, z) (x & y | ~x & z) */
#define _JSI_F1(x, y, z) (z ^ (x & (y ^ z)))
#define _JSI_F2(x, y, z) _JSI_F1(z, x, y)
#define _JSI_F3(x, y, z) (x ^ y ^ z)
#define _JSI_F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define _JSI_MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  jsi_MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void jsi_MD5Transform(uint buf[4], const uint in[16]) {
    register uint a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[ 2]+0x242070db, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[ 6]+0xa8304613, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[ 7]+0xfd469501, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 8]+0x698098d8,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[10]+0xffff5bb1, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[11]+0x895cd7be, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[12]+0x6b901122,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[13]+0xfd987193, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[14]+0xa679438e, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[15]+0x49b40821, 22);

    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[ 6]+0xc040b340,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[11]+0x265e5a51, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[10]+0x02441453,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[15]+0xd8a1e681, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[14]+0xc33707d6,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[13]+0xa9e3e905,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);

    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 8]+0x8771f681, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[11]+0x6d9d6122, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[14]+0xfde5380c, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[10]+0xbebfbc70, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[13]+0x289b7ec6,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[ 6]+0x04881d05, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[12]+0xe6db99e5, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);

    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 0]+0xf4292244,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[ 7]+0x432aff97, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[14]+0xab9423a7, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[12]+0x655b59c3,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[10]+0xffeff47d, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[ 6]+0xa3014314, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[13]+0x4e0811a1, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[11]+0xbd3af235, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 9]+0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
static void jsi_MD5Init(jsi_MD5Context *pCtx) {
    struct jsi_MD5_Context *ctx = (struct jsi_MD5_Context *)pCtx;
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;
    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
static
void jsi_MD5Update(jsi_MD5Context *pCtx, const unsigned char *buf, unsigned int len) {
    struct jsi_MD5_Context *ctx = (struct jsi_MD5_Context *)pCtx;
    uint t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint)len << 3)) < t)
        ctx->bits[1]++; /* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if ( t ) {
        unsigned char *p = (unsigned char *)ctx->in + t;

        t = 64-t;
        if (len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        jsi_MD5_byteReverse(ctx->in, 16);
        jsi_MD5Transform(ctx->buf, (uint *)ctx->in);
        buf += t;
        len -= t;
    }

    /* Process data in 64-byte chunks */

    while (len >= 64) {
        memcpy(ctx->in, buf, 64);
        jsi_MD5_byteReverse(ctx->in, 16);
        jsi_MD5Transform(ctx->buf, (uint *)ctx->in);
        buf += 64;
        len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
static void MD5Final(unsigned char digest[16], jsi_MD5Context *pCtx) {
    struct jsi_MD5_Context *ctx = (struct jsi_MD5_Context *)pCtx;
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        jsi_MD5_byteReverse(ctx->in, 16);
        jsi_MD5Transform(ctx->buf, (uint *)ctx->in);

        /* Now fill the next block with 56 bytes */
        memset(ctx->in, 0, 56);
    } else {
        /* Pad block to 56 bytes */
        memset(p, 0, count-8);
    }
    jsi_MD5_byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint *)ctx->in)[ 14 ] = ctx->bits[0];
    ((uint *)ctx->in)[ 15 ] = ctx->bits[1];

    jsi_MD5Transform(ctx->buf, (uint *)ctx->in);
    jsi_MD5_byteReverse((unsigned char *)ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(*ctx));    /* In case it's sensitive */
}

int jsi_Md5Digest(unsigned char digest[16], const char *str, int len)
{
    jsi_MD5Context ctx;
    jsi_MD5Init(&ctx);
    if (len<0)
        len = Jsi_Strlen(str);
    jsi_MD5Update(&ctx, (unsigned char*)str, len);
    MD5Final(digest, &ctx);
    return 16;
}
#endif

#ifndef JSI_OMIT_SHA1

/*********************************************************************
* Author:     Brad Conte (brad AT bradconte.com) (copyright AS-IS)
* Source:     https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c
*********************************************************************/

typedef struct {
    uchar data[64];
    uint datalen;
    unsigned long long bitlen;
    uint state[5];
    uint k[4];
} jsi_SHA1_CTX;


/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

/*********************** FUNCTION DEFINITIONS ***********************/
void sha1_transform(jsi_SHA1_CTX *ctx, const uchar data[])
{
    uint a, b, c, d, e, i, j, t, m[80];

    for (i = 0, j = 0; i < 16; ++i, j += 4)
        m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 8) + (data[j + 3]);
    for ( ; i < 80; ++i) {
        m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]);
        m[i] = (m[i] << 1) | (m[i] >> 31);
    }

    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];

    for (i = 0; i < 20; ++i) {
        t = ROTLEFT(a, 5) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 40; ++i) {
        t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[1] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 60; ++i) {
        t = ROTLEFT(a, 5) + ((b & c) ^ (b & d) ^ (c & d))  + e + ctx->k[2] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 80; ++i) {
        t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[3] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }

    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
}

void sha1_init(jsi_SHA1_CTX *ctx)
{
    ctx->datalen = 0;
    ctx->bitlen = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
    ctx->state[4] = 0xc3d2e1f0;
    ctx->k[0] = 0x5a827999;
    ctx->k[1] = 0x6ed9eba1;
    ctx->k[2] = 0x8f1bbcdc;
    ctx->k[3] = 0xca62c1d6;
}

void sha1_update(jsi_SHA1_CTX *ctx, const uchar data[], size_t len)
{
    size_t i;

    for (i = 0; i < len; ++i) {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;
        if (ctx->datalen == 64) {
            sha1_transform(ctx, ctx->data);
            ctx->bitlen += 512;
            ctx->datalen = 0;
        }
    }
}

void sha1_final(jsi_SHA1_CTX *ctx, uchar hash[])
{
    uint i;

    i = ctx->datalen;

    // Pad whatever data is left in the buffer.
    if (ctx->datalen < 56) {
        ctx->data[i++] = 0x80;
        while (i < 56)
            ctx->data[i++] = 0x00;
    }
    else {
        ctx->data[i++] = 0x80;
        while (i < 64)
            ctx->data[i++] = 0x00;
        sha1_transform(ctx, ctx->data);
        memset(ctx->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[63] = ctx->bitlen;
    ctx->data[62] = ctx->bitlen >> 8;
    ctx->data[61] = ctx->bitlen >> 16;
    ctx->data[60] = ctx->bitlen >> 24;
    ctx->data[59] = ctx->bitlen >> 32;
    ctx->data[58] = ctx->bitlen >> 40;
    ctx->data[57] = ctx->bitlen >> 48;
    ctx->data[56] = ctx->bitlen >> 56;
    sha1_transform(ctx, ctx->data);

    // Since this implementation uses little endian byte ordering and MD uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    }
}
#endif

#ifndef JSI_OMIT_SHA1
static int jsi_Sha1Digest(unsigned char *digest, const char *str, int len)
{
    jsi_SHA1_CTX ctx;
    sha1_init(&ctx);
    if (len<0)
        len = Jsi_Strlen(str);
    sha1_update(&ctx, (unsigned char*)str, len);
    sha1_final(&ctx, digest);
    return 20;
}
#endif


#ifndef JSI_OMIT_SHA256

typedef struct {
    uchar data[64];
    uint datalen;
    unsigned long long bitlen;
    uint state[8];
} jsi_SHA256_CTX;

/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

/**************************** VARIABLES *****************************/
static const uint k[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
static void sha256_transform(jsi_SHA256_CTX *ctx, const uchar data[])
{
    uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i < 16; ++i, j += 4)
        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    for ( ; i < 64; ++i)
        m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];
    f = ctx->state[5];
    g = ctx->state[6];
    h = ctx->state[7];

    for (i = 0; i < 64; ++i) {
        t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
        t2 = EP0(a) + MAJ(a,b,c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
    ctx->state[5] += f;
    ctx->state[6] += g;
    ctx->state[7] += h;
}

static void sha256_init(jsi_SHA256_CTX *ctx)
{
    ctx->datalen = 0;
    ctx->bitlen = 0;
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
}

static void sha256_update(jsi_SHA256_CTX *ctx, const uchar data[], size_t len)
{
    uint i;

    for (i = 0; i < len; ++i) {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;
        if (ctx->datalen == 64) {
            sha256_transform(ctx, ctx->data);
            ctx->bitlen += 512;
            ctx->datalen = 0;
        }
    }
}

static void sha256_final(jsi_SHA256_CTX *ctx, uchar hash[])
{
    uint i;

    i = ctx->datalen;

    // Pad whatever data is left in the buffer.
    if (ctx->datalen < 56) {
        ctx->data[i++] = 0x80;
        while (i < 56)
            ctx->data[i++] = 0x00;
    }
    else {
        ctx->data[i++] = 0x80;
        while (i < 64)
            ctx->data[i++] = 0x00;
        sha256_transform(ctx, ctx->data);
        memset(ctx->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[63] = ctx->bitlen;
    ctx->data[62] = ctx->bitlen >> 8;
    ctx->data[61] = ctx->bitlen >> 16;
    ctx->data[60] = ctx->bitlen >> 24;
    ctx->data[59] = ctx->bitlen >> 32;
    ctx->data[58] = ctx->bitlen >> 40;
    ctx->data[57] = ctx->bitlen >> 48;
    ctx->data[56] = ctx->bitlen >> 56;
    sha256_transform(ctx, ctx->data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    }
}
#undef ROTLEFT
#undef ROTRIGHT
#undef CH
#undef MAJ
#undef EP0
#undef EP1
#undef SIG0
#undef SIG1

// https://github.com/mpancorbo/sha3

#define SHA3_ROUNDS       24
#define SHA3_STATE_LEN    25

#define SHA3_224                 0
#define SHA3_224_DIGEST_LENGTH  28
#define SHA3_224_CBLOCK        144

#define SHA3_256                 1
#define SHA3_256_DIGEST_LENGTH  32
#define SHA3_256_CBLOCK        136

#define SHA3_384                 2
#define SHA3_384_DIGEST_LENGTH  48
#define SHA3_384_CBLOCK        104

#define SHA3_512                3
#define SHA3_512_DIGEST_LENGTH 64
#define SHA3_512_CBLOCK        72

//#pragma pack(push, 1)
typedef struct {
  uint64_t state[SHA3_STATE_LEN];
  uint32_t index;
  size_t   dgstlen;
  uint32_t rounds;
  size_t   blklen;
  uint8_t  blk[256];
} SHA3_CTX;
//#pragma pack(pop)


static void SHA3_Init (SHA3_CTX *ctx, int type)
{
  memset (ctx, 0, sizeof (SHA3_CTX));
  ctx->rounds = SHA3_ROUNDS;
  
  switch (type)
  {
  case SHA3_224:
    ctx->blklen  = SHA3_224_CBLOCK;
    ctx->dgstlen = SHA3_224_DIGEST_LENGTH;
    break;
  case SHA3_384:
    ctx->blklen  = SHA3_384_CBLOCK;
    ctx->dgstlen = SHA3_384_DIGEST_LENGTH;
    break;
  case SHA3_512:
    ctx->blklen  = SHA3_512_CBLOCK;
    ctx->dgstlen = SHA3_512_DIGEST_LENGTH;
    break;
  default:
    ctx->blklen  = SHA3_256_CBLOCK;
    ctx->dgstlen = SHA3_256_DIGEST_LENGTH;
    break;
  }   
}
static const uint64_t keccakf_rndc[24] = 
{
  0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
  0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
  0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
  0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
  0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
  0x8000000000008003, 0x8000000000008002, 0x8000000000000080, 
  0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
  0x8000000000008080, 0x0000000080000001, 0x8000000080008008
};

static const int keccakf_rotc[24] = 
{
  1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14, 
  27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44
};

static const int keccakf_piln[24] = 
{
  10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
  15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1 
};

#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))

static void SHA3_Transform (SHA3_CTX *ctx)
{
  uint32_t i, j, round;
  uint64_t t, bc[5];
  uint64_t *st=ctx->state;
  uint64_t *p=(uint64_t*)ctx->blk;
  
  // xor block with state
  for (i=0; i<ctx->blklen/8; i++) st[i] ^= p[i];
  
  for (round = 0; round < ctx->rounds; round++) 
  {
    // Theta
    for (i = 0; i < 5; i++)     
    bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];

    for (i = 0; i < 5; i++) {
      t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);
      for (j = 0; j < 25; j += 5)
      st[j + i] ^= t;
    }

    // Rho Pi
    t = st[1];
    for (i = 0; i < 24; i++) {
      j = keccakf_piln[i];
      bc[0] = st[j];
      st[j] = ROTL64(t, keccakf_rotc[i]);
      t = bc[0];
    }

    //  Chi
    for (j = 0; j < 25; j += 5) {
      for (i = 0; i < 5; i++)
      bc[i] = st[j + i];
      for (i = 0; i < 5; i++)
      st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
    }
    
    //  Iota
    st[0] ^= keccakf_rndc[round];
  }
}

static void SHA3_Update (SHA3_CTX* ctx, void *in, size_t len) {
  uint8_t *p;
  size_t  r, idx;

  p   = (uint8_t*)in;
  idx = ctx->index;
  
  do {
    r = ctx->blklen - idx;
    if (len<r)
        r = len;
    memcpy ((void*)&ctx->blk[idx], p, r);
    if ((idx + r) < ctx->blklen) {
      idx += r;
      break;
    }
    SHA3_Transform (ctx);
    len -= r;
    idx = 0;
    p += r;
  } while (1);
  ctx->index=idx;
}

static void SHA3_Final (void* dgst, SHA3_CTX* ctx)
{
  // add 3 bits, Keccak uses 1
  // a lot of online implementations are using 1 instead of 6
  // since the NIST specifications haven't been finalized.
  ctx->blk[ctx->index] = 6;
  // or the end bit
  ctx->blk[ctx->blklen-1] |= 0x80;
  // update context
  SHA3_Transform (ctx);
  // copy digest to buffer
  memcpy (dgst, (uint8_t*)ctx->state, ctx->dgstlen);
}

#endif

#ifndef JSI_OMIT_SHA256
static int jsi_Sha256Digest(unsigned char *digest, const char *str, int len)
{
    jsi_SHA256_CTX ctx;
    sha256_init(&ctx);
    if (len<0)
        len = Jsi_Strlen(str);
    sha256_update(&ctx, (unsigned char*)str, len);
    sha256_final(&ctx, digest);
    return 32;
}

static int jsi_Sha3Digest(unsigned char *digest, const char *str, int len, int type)
{
    SHA3_CTX ctx;
    SHA3_Init(&ctx, type);
    if (len<0)
        len = Jsi_Strlen(str);
    SHA3_Update(&ctx, (unsigned char*)str, len);
    SHA3_Final(digest, &ctx);
    return 64;
}
#endif


static int jsi_CryptoHash(unsigned char *digest, const char *str, int len, Jsi_CryptoHashType type)
{
    switch (type) {
        case Jsi_CHash_SHA1:
    #ifndef JSI_OMIT_SHA1
            return jsi_Sha1Digest(digest, str, len);
    #endif
            break;
        case Jsi_CHash_SHA2_256:
    #ifndef JSI_OMIT_SHA256
            return jsi_Sha256Digest(digest, str, len);
    #endif
            break;
        case Jsi_CHash_MD5:
    #ifndef JSI_OMIT_MD5
            return jsi_Md5Digest(digest, str, len);
    #endif
            break;
        case Jsi_CHash_SHA3_224:
        case Jsi_CHash_SHA3_384:
        case Jsi_CHash_SHA3_512:
        case Jsi_CHash_SHA3_256:
    #ifndef JSI_OMIT_SHA1
            return jsi_Sha3Digest(digest, str, len, type-Jsi_CHash_SHA3_224);
    #endif
            break;
    }
    return -1;
}

Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex)
{
    unsigned char digest[1024];
    int dsiz = jsi_CryptoHash(digest, str, len, type);
    if (dsiz<0)
        return JSI_ERROR;
    if (noHex)
        memcpy(outbuf, digest, dsiz);
    else
        Jsi_ToHexStr(digest, dsiz, outbuf);
    return JSI_OK;
}

int jsi_CashHash(unsigned char digest[32], const uchar *data, int len, uint strength, int *noncePtr, Jsi_CryptoHashType type)
{
    char *str = (char*)data;
    int nonce = 0;
    if (len<0)
        len = Jsi_Strlen(str);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppendLen(&dStr, str, len);
    uint i, slen = Jsi_DSLength(&dStr);
    slen += 1+8;
    Jsi_DSSetLength(&dStr, slen);
    char *astr = Jsi_DSValue(&dStr);
    char *estr = astr + len;
    uint smask = 0, sbytes = (strength/8);
    uint sbits = (strength - sbytes*8);
    for (i=0; i<sbits; i++)
        smask = (smask>>1)|0x80;
    while (1) {
        snprintf(estr, 9, ":%08x", nonce);
        jsi_CryptoHash(digest, astr, slen, type);
       /* jsi_SHA256_CTX ctx;
        sha256_init(&ctx);
        sha256_update(&ctx, (unsigned char*)astr, slen);
        sha256_final(&ctx, digest);*/
        i = 0;
        if (sbytes) {
            for (i=0; i<sbytes; i++)
                if (digest[i]) break;
            if (i<sbytes) { nonce++; continue; }
        }
        if (!smask || !(digest[i]&smask))
            break;
        //if (i>2)
        //    printf("STRENGTH of %d = %d\n", nonce, i);
        nonce++;
    }
    *noncePtr = nonce;
    return 32;
}


#ifndef JSI_OMIT_ENCRYPT
/* XXTEA encryption. Source the Wikipedia page. Key modified to use 32 byte SHA256 instead of 16 byte MD5*/
#define _JSI_XXTEA_MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&7)^e] ^ z)))

static void jsi_btea(uint32_t *v, int n, uint32_t const key[8]) {
    const uint32_t DELTA = 0x9e3779b9;
    uint32_t y, z, sum;
    uint p, rounds, e;
    if (n > 1) {          /* Coding Part */
        rounds = 6 + 52/n;
        sum = 0;
        z = v[n-1];
        do {
            sum += DELTA;
            e = (sum >> 2) & 7;
            for (p=0; p<(uint)(n-1); p++) {
                y = v[p+1];
                z = v[p] += _JSI_XXTEA_MX;
            }
            y = v[0];
            z = v[n-1] += _JSI_XXTEA_MX;
        } while (--rounds);
    } else if (n < -1) {  /* Decoding Part */
        n = -n;
        rounds = 6 + 52/n;
        sum = rounds*DELTA;
        y = v[0];
        do {
            e = (sum >> 2) & 7;
            for (p=n-1; p>0; p--) {
                z = v[p-1];
                y = v[p] -= _JSI_XXTEA_MX;
            }
            z = v[n-1];
            y = v[0] -= _JSI_XXTEA_MX;
            sum -= DELTA;
        } while (--rounds);
    }
}

/* Encrypt/decrypt string using key. */
Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt)
{
    unsigned char digest[32];
    int nlen = Jsi_DSLength(inout);
    char *buf = Jsi_DSValue(inout);
    uint pad = 0;
    if (nlen<2)
        goto badlen;
    if (decrypt) {
        pad = (uint)buf[--nlen];
        Jsi_DSSetLength(inout, nlen);
    } else {
        while (nlen%4) {
            Jsi_DSAppendLen(inout, "\0", 1);
            nlen++;
            pad++;
        }
    }

    if (nlen%4) {
badlen:
        return Jsi_LogError("length must be a multiple of 4: %d, %d", nlen, nlen%4);
    }
    nlen /= 4;
    if (keyLen==sizeof(digest))
        memcpy(digest, key, sizeof(digest));
    else
        jsi_Sha256Digest(digest, key, keyLen);
    jsi_btea((uint32_t*)buf, (decrypt ? -nlen : nlen), (uint32_t*)digest);
    if (decrypt) {
        buf = Jsi_DSValue(inout);
        nlen = Jsi_DSLength(inout);
        if (nlen<4 || (buf[nlen-1]<1 && buf[nlen-1]>4))
            return JSI_OK; // quietly fail
        Jsi_DSSetLength(inout, nlen-pad);
    } else {
        char spad = pad;
        Jsi_DSAppendLen(inout, &spad, 1);
    }
    return JSI_OK;
}

#else
Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt)
{
    return Jsi_LogError("Jsi_Encrypt unsupported");
}
#endif

#endif
/* Support for Jsi_DString: Dynamic Strings in C */
/* Can be used either within Jsi or standalone by including jsi.h */

#ifndef JSI_AMALGAMATION
#ifndef JSI_STANDALONE
#include "jsiInt.h"
#else
/* Not being used within JSI */
#include "jsi.h"
#ifndef JSI_MAX_ALLOC_BUF
#define JSI_MAX_ALLOC_BUF 100000000
#endif
#define Jsi_Realloc realloc
#define Jsi_Free free
#define Jsi_Strdup strdup
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#endif /* JSI_STANDALONE */
#endif /* !JSI_AMALGAMATION */

#ifndef LogError
#define LogError(fmt,...) fprintf(stderr, fmt "%s %s:%d\n", __VA_ARGS__, __FUNCTION__, __FILE__, __LINE__)
#endif

#define jsi_DSValue(dsPtr) (char*)(dsPtr->strA?dsPtr->strA:dsPtr->Str)

/* Initialization for a string that was declared with "= {}". */
#define jsi_DsCheckInit(dsPtr) if  (dsPtr->staticSize==0) jsi_DsDoInit(dsPtr);

static void jsi_DsDoInit(Jsi_DString *dsPtr) {
#ifdef JSI_MEM_DEBUG
    assert(dsPtr->len<JSI_MAX_ALLOC_BUF && dsPtr->spaceAvl<JSI_MAX_ALLOC_BUF );
#endif
    dsPtr->spaceAvl = dsPtr->staticSize = sizeof(dsPtr->Str);
    if (dsPtr->strA) {
        if ((dsPtr->len = Jsi_Strlen(dsPtr->strA))<dsPtr->spaceAvl)
            Jsi_Strcpy(dsPtr->Str, dsPtr->strA);
        else
            dsPtr->strA = Jsi_Strdup(dsPtr->strA);
        dsPtr->strA = NULL;
    } else 
        dsPtr->len = Jsi_Strlen(dsPtr->Str);
}

/* RETURNS: string value. */
char* Jsi_DSValue(Jsi_DString *dsPtr)  {
    jsi_DsCheckInit(dsPtr);
    return jsi_DSValue(dsPtr);
}

/* RETURNS: string length. */
uint Jsi_DSLength(Jsi_DString *dsPtr) {
    jsi_DsCheckInit(dsPtr);
    return dsPtr->len;
}

/* Initialize string. */
void Jsi_DSInit(Jsi_DString *dsPtr)
{
    dsPtr->spaceAvl = dsPtr->staticSize = sizeof(dsPtr->Str);
    dsPtr->Str[0] = 0;
    dsPtr->strA = NULL;
    dsPtr->len = 0;
}

/* 
 * Frees any allocated space and sets the DString back to empty such that it is safe to exit the scope
 * or the DString may be reused.
 */
void
Jsi_DSFree(Jsi_DString *dsPtr)
{
    jsi_DsCheckInit(dsPtr);
    if (dsPtr->strA)
        Jsi_Free((char*)dsPtr->strA);
    dsPtr->strA = NULL;
    dsPtr->Str[0] = 0;
    dsPtr->len = 0;
    if (dsPtr->staticSize<=0)
        dsPtr->staticSize = sizeof(dsPtr->Str);
    dsPtr->spaceAvl = dsPtr->staticSize;
}

/* 
 * Append length bytes to the string. If length is less than 0,
 * the value of Jsi_Strlen is used.  If required, the DString is realloced to
 * be large enough to contain bytes, plus an extra null byte that is added to the end.
 * RETURNS: The the current string.
*/
char *Jsi_DSAppendLen(Jsi_DString *dsPtr, const char *string, int length)
{
    jsi_DsCheckInit(dsPtr)
    int len = dsPtr->len;
    if (string) {
        if (length < 0)
            length = Jsi_Strlen(string);
        uint nsiz = length + len+1;
    
        if (nsiz >= dsPtr->spaceAvl) {
            if (nsiz < dsPtr->spaceAvl*2)
                nsiz = dsPtr->spaceAvl*2;
            if (Jsi_DSSetLength(dsPtr, nsiz) < nsiz)
                return jsi_DSValue(dsPtr);
        }
        char * dst = jsi_DSValue(dsPtr) + dsPtr->len;
        memcpy(dst, string, length);
        dst[length] = 0;
        dsPtr->len += length;
    }
    return jsi_DSValue(dsPtr);
}

/* 
 * Calls Jsi_DSAppendLen for each string value argument, passing in -1 for the length.
 * Each string is assumed to be null terminated and the final argument must be a NULL.
 * RETURNS: The the current string.
*/
char *
Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)
{
    va_list argList;
    char *elem;
    jsi_DsCheckInit(dsPtr)
    if (!str)
        return jsi_DSValue(dsPtr);
    Jsi_DSAppendLen(dsPtr, str, -1);
    va_start(argList, str);
    while ((elem = va_arg(argList, char *)) != NULL) {
        Jsi_DSAppendLen(dsPtr, elem, -1);
    }
    va_end(argList);
    return jsi_DSValue(dsPtr);
}

/*
 * Format output and append to the end of dsPtr.
 * RETURNS: The current string.
 */
char *
Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)
{
    va_list argList;
#ifndef JSI_PRINTF_BUFSIZ
#define JSI_PRINTF_BUFSIZ BUFSIZ
#endif
    char buf[JSI_PRINTF_BUFSIZ], *bPtr = buf;
    uint n, bsiz = sizeof(buf), needAppend = 1;
    jsi_DsCheckInit(dsPtr)
    int len = dsPtr->len;
    uint avail = (dsPtr->spaceAvl - len);
    char *dstr = jsi_DSValue(dsPtr);
    if (avail >= sizeof(buf)) { /* Format directly into string. */
        bPtr = dstr+len;
        bsiz = avail;
        needAppend = 0;
    }
    va_start(argList, fmt);
    n = vsnprintf(bPtr, bsiz, fmt, argList);
    if ((n+len)>JSI_MAX_ALLOC_BUF) {
        LogError("vsnprintf error: rc=%d, len=%d", n, len);
        va_end(argList);
        return dstr;
    }
    if (n >= bsiz) {
        uint m = len+n+1;
        if (Jsi_DSSetLength(dsPtr, m) < m) {
            va_end(argList);
            return jsi_DSValue(dsPtr);
        }
        dstr = jsi_DSValue(dsPtr);
        m = vsnprintf(dstr+len, len+1, fmt, argList);
        if (m != n) {
            LogError("len mismatch: %d != %d",  m, n);
            va_end(argList);
            return dstr;
        }
    } else if (needAppend) {
        Jsi_DSAppendLen(dsPtr, buf, n);
    }
    va_end(argList);
    return jsi_DSValue(dsPtr);
}

/* 
 * Set the minimum allocated space and/or the maximum string length.
 * If length < current dsPtr->len truncates string, else sets minimum allocated space.
 * RETURNS: currently allocated space. 
 */
uint Jsi_DSSetLength(Jsi_DString *dsPtr, uint length)
{
    jsi_DsCheckInit(dsPtr)
    if (length >= JSI_MAX_ALLOC_BUF) {
        LogError("max alloc exceeded %d", length);
        length = JSI_MAX_ALLOC_BUF-1;
    }
    char *dstr = jsi_DSValue(dsPtr);
    if (length >= dsPtr->spaceAvl) {
        int isStatic = (dsPtr->strA == NULL);

        dsPtr->spaceAvl = length;
        if (isStatic == 0 || length >= dsPtr->staticSize) {
            char *newString = (char *) Jsi_Realloc((isStatic?NULL:(char*)dsPtr->strA), (unsigned) (dsPtr->spaceAvl+1));
            if (!newString) {
                LogError("malloc failed %d", dsPtr->spaceAvl+1);
                return -1;
            }
            dsPtr->strA = newString;
            if (isStatic && dsPtr->len>0)
                memcpy((char*)dsPtr->strA, dsPtr->Str, (size_t) (dsPtr->len+1));
        }
    }
    if (length < dsPtr->len) {
        dstr = jsi_DSValue(dsPtr);
        dstr[length] = 0;
        dsPtr->len = length;
    }
    return dsPtr->spaceAvl;
}

char *
Jsi_DSSet(Jsi_DString *dsPtr, const char *str)
{
    Jsi_DSSetLength(dsPtr, 0);
    if (str)
        Jsi_DSAppendLen(dsPtr, str, -1);
    return jsi_DSValue(dsPtr);
}

/*
 * Returns the strdup of the string value and resets the DString in the same way as Jsi_DSFree.
 * This just avoids the user having to do an extra malloc/free when the DString was already malloced.
 * It is the responsibility of the caller to free the returned value.
 * RETURNS: previous string value malloced.
 */
char*  Jsi_DSFreeDup(Jsi_DString *dsPtr)
{
    char *cp;
    jsi_DsCheckInit(dsPtr)
    if (!dsPtr->strA) {
        cp = Jsi_Strdup(dsPtr->Str);
        Jsi_DSSetLength(dsPtr, 0);
        return cp;
    }
    cp = (char*)dsPtr->strA;
    dsPtr->strA = NULL;
    dsPtr->Str[0] = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
    dsPtr->len = 0;
    return cp;
}

#ifdef JSI_DSTRING_SELFTEST

void Jsi_DString_SelfTest() {
    {
        Jsi_DString d1 = {}, d2 = {"Here is"};
        Jsi_DSAppend(&d2 ," your score: ", NULL);
        Jsi_DSPrintf(&d2, " -> %d/%d", 99, 100);
        char *cp = jsi_DSValue(&d2);
        puts(cp);     // "Here is your score: -> 99/100"
        Jsi_DSAppend(&d1, cp, NULL);
        Jsi_DSFree(&d1);  Jsi_DSFree(&d2);
    }
    {
        Jsi_DString d = {};;
        Jsi_DSPrintf(&d , "%0300d", 1); // Malloc
        Jsi_DSSetLength(&d, 0);
        Jsi_DSPrintf(&d , "%0300d", 1); // No-malloc
        Jsi_DSFree(&d);
        Jsi_DSPrintf(&d , "%0300d", 1); // Malloc
        Jsi_DSFree(&d);
    }
    {
        Jsi_DString d;
        Jsi_DSInit(&d);
        Jsi_DSAppend(&d , " some stuff: ", NULL);
        Jsi_DSFree(&d);
    }
    {
        JSI_DSTRING_VAR(dPtr,301);
        Jsi_DSPrintf(dPtr , "%0300d", 1); // No-malloc
        Jsi_DSSetLength(dPtr, 0);
        Jsi_DSPrintf(dPtr , "%0300d", 1); // No-malloc
        Jsi_DSFree(dPtr);
        Jsi_DSPrintf(dPtr , "%0400d", 1); // Malloc
        Jsi_DSFree(dPtr);
    }
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#ifndef JSI_OMIT_MATH
#include <math.h>

#define MFUNC1(fname, func)  \
static Jsi_RC fname (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\
    Jsi_Value **ret, Jsi_Func *funcPtr)\
{\
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\
    Jsi_Number num;\
    if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_ValueMakeNumber(interp, ret, func (num));\
    return JSI_OK;\
}

#define MFUNC2(fname, func)  \
static Jsi_RC fname (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\
    Jsi_Value **ret, Jsi_Func *funcPtr)\
{\
    Jsi_Value *val1 = Jsi_ValueArrayIndex(interp, args, 0);\
    Jsi_Number num1;\
    if (Jsi_GetNumberFromValue(interp, val1, &num1) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_Value *val2 = Jsi_ValueArrayIndex(interp, args, 1);\
    Jsi_Number num2;\
    if (Jsi_GetNumberFromValue(interp, val2, &num2) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_ValueMakeNumber(interp, ret, func (num1,num2));\
    return JSI_OK;\
}

static Jsi_RC MathMinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int i, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *val;
    Jsi_Number n = 0, num;
    if (argc<=0)
        return JSI_OK;
    for (i=0; i<argc; i++) {
        val = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)
            return JSI_ERROR;
        if (i==0)
            n = num;
        else
            n =  (num>n ? n : num);
    }
    Jsi_ValueMakeNumber(interp, ret, n);
    return JSI_OK;
}


static Jsi_RC MathMaxCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int i, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *val;
    Jsi_Number n = 0, num;
    if (argc<=0)
        return JSI_OK;
    for (i=0; i<argc; i++) {
        val = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)
            return JSI_ERROR;
        if (i==0)
            n = num;
        else
            n =  (num<n ? n : num);
    }
    Jsi_ValueMakeNumber(interp, ret, n);
    return JSI_OK;
}

static Jsi_RC MathRandomCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef __WIN32
    static int init = 0;
    if (!init) {
        init = 1;
        srand48((long)time(NULL));
    }
    Jsi_ValueMakeNumber(interp, ret, drand48());
#else
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rand());
#endif
    return JSI_OK;
}

MFUNC1(MathAbsCmd,  fabs)
MFUNC1(MathAcosCmd, acos)
MFUNC1(MathAsinCmd, asin)
MFUNC1(MathAtanCmd, atan)
MFUNC1(MathCeilCmd, ceil)
MFUNC1(MathCosCmd,  cos)
MFUNC1(MathExpCmd,  exp)
MFUNC1(MathFloorCmd,floor)
MFUNC1(MathLogCmd,  log)
MFUNC1(MathRoundCmd,round)
MFUNC1(MathSinCmd,  sin)
MFUNC1(MathSqrtCmd, sqrt)
MFUNC1(MathTanCmd,  tan)
MFUNC2(MathAtan2Cmd,atan2)
MFUNC2(MathPowCmd,  pow)

static Jsi_CmdSpec mathCmds[] = {
    { "abs",    MathAbsCmd,     1, 1, "num:number", .help="Returns the absolute value of x", .retType=(uint)JSI_TT_NUMBER },
    { "acos",   MathAcosCmd,    1, 1, "num:number", .help="Returns the arccosine of x, in radians", .retType=(uint)JSI_TT_NUMBER },
    { "asin",   MathAsinCmd,    1, 1, "num:number", .help="Returns the arcsine of x, in radians", .retType=(uint)JSI_TT_NUMBER },
    { "atan",   MathAtanCmd,    1, 1, "num:number", .help="Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians", .retType=(uint)JSI_TT_NUMBER },
    { "atan2",  MathAtan2Cmd,   2, 2, "x:number, y:number", .help="Returns the arctangent of the quotient of its arguments", .retType=(uint)JSI_TT_NUMBER },
    { "ceil",   MathCeilCmd,    1, 1, "num:number", .help="Returns x, rounded upwards to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "cos",    MathCosCmd,     1, 1, "num:number", .help="Returns the cosine of x (x is in radians)", .retType=(uint)JSI_TT_NUMBER },
    { "exp",    MathExpCmd,     1, 1, "num:number", .help="Returns the value of Ex", .retType=(uint)JSI_TT_NUMBER },
    { "floor",  MathFloorCmd,   1, 1, "num:number", .help="Returns x, rounded downwards to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "log",    MathLogCmd,     1, 1, "num:number", .help="Returns the natural logarithm (base E) of x", .retType=(uint)JSI_TT_NUMBER },
    { "max",    MathMaxCmd,     2,-1, "x:number, y:number, ...", .help="Returns the number with the highest value", .retType=(uint)JSI_TT_NUMBER },
    { "min",    MathMinCmd,     2,-1, "x:number, y:number, ...", .help="Returns the number with the lowest value", .retType=(uint)JSI_TT_NUMBER },
    { "pow",    MathPowCmd,     2, 2, "x:number, y:number", .help="Returns the value of x to the power of y", .retType=(uint)JSI_TT_NUMBER },
    { "random", MathRandomCmd,  0, 0, "", .help="Returns a random number between 0 and 1", .retType=(uint)JSI_TT_NUMBER },
    { "round",  MathRoundCmd,   1, 1, "num:number", .help="Rounds x to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "sin",    MathSinCmd,     1, 1, "num:number", .help="Returns the sine of x (x is in radians)", .retType=(uint)JSI_TT_NUMBER },
    { "sqrt",   MathSqrtCmd,    1, 1, "num:number", .help="Returns the square root of x", .retType=(uint)JSI_TT_NUMBER },
    { "tan",    MathTanCmd,     1, 1, "num:number", .help="Returns the tangent of an angle", .retType=(uint)JSI_TT_NUMBER },
    { NULL, 0,0,0,0, .help="Commands performing math operations on numbers" }
};

    
Jsi_RC jsi_InitMath(Jsi_Interp *interp, int release)
{
    if (release) return JSI_OK;
    Jsi_Value *val = Jsi_CommandCreateSpecs(interp, "Math",    mathCmds,    NULL, 0);
#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)
    MCONST("PI", M_PI);
    MCONST("LN2", M_LN2);
    MCONST("LN10", M_LN10);
    MCONST("LOG2E", M_LOG2E);
    MCONST("LOG10E", M_LOG10E);
    MCONST("SQRT2", M_SQRT2);
    MCONST("SQRT1_2", M_SQRT1_2);
    MCONST("E", M_E);
    return JSI_OK;
}
#endif
#endif
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#ifndef JSMN_FREE
#define JSMN_FREE(p) free(p)
#define JSMN_MALLOC(l) malloc(l)
#define JSMN_REALLOC(p,l) realloc(p,l)
#endif
static Jsi_JsonErrEnum jsmn_error(Jsi_JsonParser *parser, Jsi_JsonErrEnum err, const char *str) {
    switch (err) {
        case JSI_JSON_ERR_NOMEM: str = "out of memory"; break;
        case JSI_JSON_ERR_PART: str = "expected more bytes"; break;
        default: break;
    }
    parser->errStr = str;
    return err;
}
/**
 * Allocates a fresh unused token from the token pull.
 */
static Jsi_JsonTok *jsmn_alloc_token(Jsi_JsonParser *parser, int *indexPtr) {
    Jsi_JsonTok *tok;
    uint index, oldsz;
    if (parser->toknext >= parser->num_tokens) {
        if (parser->no_malloc) return NULL;
        oldsz = parser->num_tokens;
        parser->num_tokens *= 2;
        if (parser->tokens != parser->static_tokens || parser->static_tokens == NULL)
            parser->tokens = (Jsi_JsonTok*)JSMN_REALLOC(parser->tokens, sizeof(Jsi_JsonTok)*parser->num_tokens);
        else {
            parser->tokens = (Jsi_JsonTok*)JSMN_MALLOC(sizeof(Jsi_JsonTok)*parser->num_tokens);
            memcpy(parser->tokens, parser->static_tokens, sizeof(Jsi_JsonTok)*oldsz);
        }
    }
    index = parser->toknext++;
    tok = &parser->tokens[index];
    tok->start = tok->end = -1;
    tok->size = 0;
    if (indexPtr) *indexPtr = index;
    tok->parent = -1;
    return tok;
}

void Jsi_JsonFree(Jsi_JsonParser* parser) {
    if (parser->tokens != parser->static_tokens && parser->tokens) 
        JSMN_FREE(parser->tokens);
    parser->tokens = NULL;
}

/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(Jsi_JsonTok *token, Jsi_JsonTypeEnum type, 
                            int start, int end) {
    token->type = type;
    token->start = start;
    token->end = end;
    token->size = 0;
}

/**
 * Fills next available token with JSON primitive.
 */
static Jsi_JsonErrEnum Jsi_JsonParse_primitive(Jsi_JsonParser *parser, const char *js) {
    Jsi_JsonTok *token;
    int start, index;

    start = parser->pos;

    for (; js[parser->pos] != '\0'; parser->pos++) {
        switch (js[parser->pos]) {
            /* In strict mode primitive must be followed by "," or "}" or "]" */
            case ':':
                if (parser->strict) break;
            case '\t' : case '\r' : case '\n' : case ' ' :
            case ','  : case ']'  : case '}' :
                goto found;
        }
        if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
            parser->pos = start;
            return jsmn_error(parser,JSI_JSON_ERR_INVAL, "invalid char");
        }
    }
    if (parser->strict) {
        /* In strict mode primitive must be followed by a comma/object/array */
        parser->pos = start;
        return jsmn_error(parser,JSI_JSON_ERR_PART, "expected comma/object/array");
    }

found:
    token = jsmn_alloc_token(parser, &index);
    if (token == NULL) {
        parser->pos = start;
        return jsmn_error(parser,JSI_JSON_ERR_NOMEM, "");
    }
    jsmn_fill_token(token, JSI_JTYPE_PRIMITIVE, start, parser->pos);
    token->parent = parser->toksuper;
    parser->pos--;
    return JSI_JSON_ERR_NONE;
}

/**
 * Fills next token with JSON string.
 */
static Jsi_JsonErrEnum Jsi_JsonParse_string(Jsi_JsonParser *parser, const char *js) {
    Jsi_JsonTok *token;

    int index, start = parser->pos;

    parser->pos++;

    /* Skip starting quote */
    for (; js[parser->pos] != '\0'; parser->pos++) {
        char c = js[parser->pos];

        /* Quote: end of string */
        if (c == '\"') {
            token = jsmn_alloc_token(parser, &index);
            if (token == NULL) {
                parser->pos = start;
                return jsmn_error(parser,JSI_JSON_ERR_NOMEM, "");
            }
            jsmn_fill_token(token, JSI_JTYPE_STRING, start+1, parser->pos);
            token->parent = parser->toksuper;
            return JSI_JSON_ERR_NONE;
        }

        /* Backslash: Quoted symbol expected */
        if (c == '\\') {
            parser->pos++;
            switch (js[parser->pos]) {
                /* Allowed escaped symbols */
                case '\"': case '/' : case '\\' : case 'b' :
                case 'f' : case 'r' : case 'n'  : case 't' :
                    break;
                /* Allows escaped symbol \uXXXX */
                case 'u':
                    if (!(isxdigit(js[parser->pos+1]) && isxdigit(js[parser->pos+2]) &&
                    isxdigit(js[parser->pos+3]) && isxdigit(js[parser->pos+4]))) {
                        parser->pos = start;
                        return jsmn_error(parser,JSI_JSON_ERR_INVAL,"expected X digit in \\uXXXX escape");
                    }
                    break;
                /* Unexpected symbol */
                default:
                    parser->pos = start;
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL, "unexpected symbol");
            }
        }
    }
    parser->pos = start;
    return jsmn_error(parser,JSI_JSON_ERR_PART,"");
}

/**
 * Parse JSON string and fill tokens.
 */
Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js) {
    Jsi_JsonErrEnum r;
    int i, index = -1;
    Jsi_JsonTok *token = NULL;

    for (; js[parser->pos] != '\0'; parser->pos++) {
        char c;
        int match;
        Jsi_JsonTypeEnum type;

        c = js[parser->pos];
        match = 0;
        switch (c) {
            case '{': case '[':
                token = jsmn_alloc_token(parser, &index);
                if (token == NULL)
                    return jsmn_error(parser,JSI_JSON_ERR_NOMEM,"");
                if (parser->toksuper != -1) {
                    parser->tokens[parser->toksuper].size++;
                    token->parent = parser->toksuper;
                }
                token->type = (c == '{' ? JSI_JTYPE_OBJECT : JSI_JTYPE_ARRAY);
                token->start = parser->pos;
                parser->toksuper = parser->toknext - 1;
                break;
            case '}': case ']':
                type = (c == '}' ? JSI_JTYPE_OBJECT : JSI_JTYPE_ARRAY);
#ifdef JSMN_PARENT_LINKS
                if (parser->toknext < 1) {
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL,"expected more");
                }
                token = &tokens[parser->toknext - 1];
                for (;;) {
                    if (token->start != -1 && token->end == -1) {
                        if (token->type != type) {
                            return jsmn_error(parser,JSI_JSON_ERR_INVAL,"type mismatch");
                        }
                        token->end = parser->pos + 1;
                        parser->toksuper = token->parent;
                        break;
                    }
                    if (token->parent == -1) {
                        break;
                    }
                    token = &parser->tokens[token->parent];
                }
#else
                for (i = parser->toknext - 1; i >= 0; i--) {
                    token = &parser->tokens[i];
                    if (token->start != -1 && token->end == -1) {
                        if (token->type != type) {
                            return jsmn_error(parser,JSI_JSON_ERR_INVAL,"type mismatch");
                        }
                        parser->toksuper = -1;
                        token->end = parser->pos + 1;
                        break;
                    }
                }
                /* Error if unmatched closing bracket */
                if (i == -1)
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL, "unmatched closing bracket");
                for (; i >= 0; i--) {
                    token = &parser->tokens[i];
                    if (token->start != -1 && token->end == -1) {
                        parser->toksuper = i;
                        break;
                    }
                }
#endif
                break;
            case '\"':
                r = Jsi_JsonParse_string(parser, js);
                if (r < 0) return r;
                if (index>=0) token = &parser->tokens[index];
                if (parser->toksuper != -1)
                    parser->tokens[parser->toksuper].size++;
                else if (js[0] == '\"')
                    parser->tokens[0].size++;
                break;
            case ':' :
                if (!token)
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL,"null token");
                if (parser->strict && token->type != JSI_JTYPE_OBJECT)
                    if (parser->toksuper<0 || parser->tokens[parser->toksuper].type != JSI_JTYPE_OBJECT)
                        return jsmn_error(parser,JSI_JSON_ERR_INVAL,"got ':' in a non-object");
            case ',': 
                if (parser->strict == 0 || (token && token->type == JSI_JTYPE_ARRAY))
                    break;
                if (!token || token->type != JSI_JTYPE_OBJECT)
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL,"expected object");
            case '\t' : case '\r' : case '\n' : case ' ': 
                break;

            /* In strict mode primitives are: numbers and booleans */
            case '-': case '0': case '1' : case '2': case '3' : case '4':
            case '5': case '6': case '7' : case '8': case '9':
            case 't': case 'f': case 'n' :
                match = 1;
                
            default:
                if (parser->strict && !match)   /* Unexpected char in strict mode */
                    return jsmn_error(parser,JSI_JSON_ERR_INVAL, "unexpected char in strict mode");
                r = Jsi_JsonParse_primitive(parser, js);
                if (r < 0) return r;
                if (index>=0) token = &parser->tokens[index];
                if (parser->toksuper != -1)
                    parser->tokens[parser->toksuper].size++;
                break;

        }
    }

    for (i = parser->toknext - 1; i >= 0; i--) {
        /* Unmatched opened object or array */
        if (parser->tokens[i].start != -1 && parser->tokens[i].end == -1) {
            return jsmn_error(parser,JSI_JSON_ERR_PART,"");
        }
    }

    return JSI_JSON_ERR_NONE;
}

/**
 * Initialize parser based over a given  buffer with an array of tokens 
 * available.
 */
void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *tokens, 
        unsigned int num_tokens) {
    parser->pos = 0;
    parser->toknext = 0;
    parser->toksuper = -1;
    parser->tokens = parser->static_tokens = tokens;
    if (tokens == NULL && num_tokens==0)
        num_tokens = 100;
    if (tokens == NULL)
        parser->tokens = (Jsi_JsonTok*)malloc(sizeof(Jsi_JsonTok)*num_tokens);
    parser->num_tokens = num_tokens;
    parser->no_malloc = 0;  /* Can set this to zero after call to suppress malloc. */
}

void Jsi_JsonReset(Jsi_JsonParser* parser) {
    parser->pos = 0;
    parser->toknext = 0;
    parser->toksuper = -1;
}

/* Helper functions */

void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js) {
    uint i;
    for (i=0; i<parser->toknext; i++)
        fprintf(stderr, "TOK(%s): %.*s\n", Jsi_JsonGetTypename(parser->tokens[i].type),
            (parser->tokens[i].end-parser->tokens[i].start),
            js+parser->tokens[i].start);
}
Jsi_JsonTok *Jsi_JsonGetToken(Jsi_JsonParser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return NULL;
    return parser->tokens+index;
}

Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return JSI_JTYPE_INVALID;
    return parser->tokens[index].type;
}

int Jsi_JsonTokLen(Jsi_JsonParser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return -1;
    return (parser->tokens[index].end-parser->tokens[index].start);
}

const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *lenPtr) {
    int len;
    if (index>=parser->toknext)
        return NULL;
    len = (parser->tokens[index].end-parser->tokens[index].start);
    if (lenPtr)
        *lenPtr = len;
    return (js + parser->tokens[index].start);
}

const char* Jsi_JsonGetTypename(int type) {
    static const char *types[] = { "JSI_JTYPE_PRIMITIVE", "OBJECT", "ARRAY", "STRING", "<INVALID>" };
    if (type < JSI_JTYPE_PRIMITIVE || type > JSI_JTYPE_STRING)
        type = JSI_JTYPE_STRING+1;
    return types[type];
}

const char* Jsi_JsonGetErrname(int code) {
    static const char *codes[] = { "SUCCESS", "NOMEM", "INVAL", "PART", "<BADCODE>" };
    code = -code;
    if (code < 0 || code > 3)
        code = 4;
    return codes[code];
}
#ifndef JSI_LITE_ONLY
#ifndef JSI_OMIT_ZVFS
/*
** Copyright (c) 2000 D. Richard Hipp
** Copyright (c) 2007 Peter MacDonald
**
** This file is now released under the BSD style license
** outlined in the included file COPYING.
**
*************************************************************************
** A ZIP archive virtual filesystem for Jsi.
**
** This package of routines enables Jsi to use a Zip file as
** a virtual file system.  Each of the content files of the Zip
** archive appears as a real file to Jsi.
**
** NOTE: could be compiled without jsiInt.h
*/
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifdef __FreeBSD__
typedef int(* __compar_fn_t) (const void *, const void *);
#endif
#include <ctype.h>
#ifndef USE_MINIZ
#include <zlib.h>
#else
#ifndef JSI_AMALGAMATION
#include "miniz/zlib.h"
#endif
#endif
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#define StrnCpy(d,s) Jsi_Strncpy(d,s,sizeof(d)), d[sizeof(d)-1] = 0

#define SS(s) Jsi_ValueString(interp, s, 0)

/*
** Size of the decompression input buffer
*/
#define COMPR_BUF_SIZE   8192

#ifdef __WIN32
static int maptolower=0;
#endif

typedef enum { ZVFS_SIG_PINFO = 0xbeefbeed, ZVFS_SIG_ARCHIVE, ZVFS_SIG_FILE, ZVFS_SIG_ZFILE } ZVFS_Sig;
#define ZVFSSIGASSERT(s,n) assert((s)->sig == ZVFS_SIG_##n)
/*
** All static variables are collected into a structure named "zvfslocal".
** That way, it is clear in the code when we are using a static
** variable because its name begins with "zvfslocal.".
*/
static struct {
    Jsi_Hash* fileHash;     /* One entry for each file in the ZVFS.  The
                              ** The key is the virtual filename.  The data
                              ** an an instance of the ZvfsFile structure. */
    Jsi_Hash *archiveHash;  /* One entry for each archive.  Key is the name.
                              ** data is the ZvfsArchive structure */
    int isInit;                 /* True after initialization */
    Jsi_Interp *interp;
} zvfslocal;

/*
** Each ZIP archive file that is mounted is recorded as an instance
** of this structure
*/
typedef struct ZvfsArchive {
    Jsi_Value *Name;           /* Name of the archive */
    Jsi_Value *MountPoint;     /* Where this archive is mounted */
    struct ZvfsFile *pFiles;  /* List of files in that archive */
    Jsi_HashEntry *pEntry;
    Jsi_Channel chan;
} ZvfsArchive;

/*
** Particulars about each virtual file are recorded in an instance
** of the following structure.
*/
typedef struct ZvfsFile {
    char *zName;              /* The full pathname of the virtual file */
    ZvfsArchive *pArchive;    /* The ZIP archive holding this file data */
    int iOffset;              /* Offset into the ZIP archive of the data */
    int nByte;                /* Uncompressed size of the virtual file */
    int nByteCompr;           /* Compressed size of the virtual file */
    time_t timestamp;            /* Modification time */
    int isdir;            /* Set to 2 if directory, or 1 if mount */
    int depth;            /* Number of slashes in path. */
    int permissions;          /* File permissions. */
    struct ZvfsFile *pNext;      /* Next file in the same archive */
    struct ZvfsFile *pNextName;  /* A doubly-linked list of files with the same */
    struct ZvfsFile *pPrevName;  /*  name.  Only the first is in zvfslocal.fileHash */
} ZvfsFile;

/*
** Information about each file within a ZIP archive is stored in
** an instance of the following structure.  A list of these structures
** forms a table of contents for the archive.
*/
typedef struct ZFile {
    char *zName;         /* Name of the file */
    int isSpecial;       /* Not really a file in the ZIP archive */
    int dosTime;         /* Modification time (DOS format) */
    int dosDate;         /* Modification date (DOS format) */
    int iOffset;         /* Offset into the ZIP archive of the data */
    int nByte;           /* Uncompressed size of the virtual file */
    int nByteCompr;      /* Compressed size of the virtual file */
    int nExtra;          /* Extra space in the TOC header */
    int iCRC;            /* Cyclic Redundancy Check of the data */
    int permissions;     /* File permissions. */
    int flags;            /* Deletion = bit 0. */
    struct ZFile *pNext;        /* Next file in the same archive */
} ZFile;

/*
** Whenever a ZVFS file is opened, an instance of this structure is
** attached to the open channel where it will be available to the
** ZVFS I/O routines below.  All state information about an open
** ZVFS file is held in this structure.
*/
typedef struct ZvfsChannelInfo {
    ZVFS_Sig sig;
    unsigned int nByte;       /* number of bytes of read uncompressed data */
    unsigned int nByteCompr;  /* number of bytes of unread compressed data */
    unsigned int nData;       /* total number of bytes of compressed data */
    int readSoFar;            /* Number of bytes read so far */
    long startOfData;         /* File position of start of data in ZIP archive */
    int isCompressed;         /* True -> data is compressed */
    int curPos;               /* Current pos. */
    Jsi_Channel chan;         /* Open to the archive file */
    unsigned char *zBuf;      /* buffer used by the decompressor */
    z_stream stream;          /* state of the decompressor */
    ZvfsFile *pFile;
    int bpos;
    int bsiz;                 /* Amount of data in buf. */
    char buf[COMPR_BUF_SIZE];
    int iCRC;            /* Cyclic Redundancy Check of the data */
    char emuGzip;
    char useGzip;
} ZvfsChannelInfo;


/*
** Macros to read 16-bit and 32-bit big-endian integers into the
** native format of this local processor.  B is an array of
** characters and the integer begins at the N-th character of
** the array.
*/
#define INT16(B, N) (B[N] + (B[N+1]<<8))
#define INT32(B, N) (INT16(B,N) + (B[N+2]<<16) + (B[N+3]<<24))


/*
** Make a new ZFile structure with space to hold a name of the number of
** characters given.  Return a pointer to the new structure.
*/
static ZFile *newZFile(int nName, ZFile **ppList) {
    ZFile *pNew;

    pNew = (ZFile*)Jsi_Calloc(1, sizeof(*pNew) + nName + 1 );
    pNew->zName = (char*)&pNew[1];
    pNew->pNext = *ppList;
    *ppList = pNew;
    return pNew;
}

/*
** Delete an entire list of ZFile structures
*/
static void deleteZFileList(ZFile *pList) {
    ZFile *pNext;
    while( pList ) {
        pNext = pList->pNext;
        Jsi_Free((char*)pList);
        pList = pNext;
    }
}

/* Convert DOS time to unix time. */
static void UnixTimeDate(struct tm *tm, int *dosDate, int *dosTime) {
    *dosDate = ((((tm->tm_year-80)<<9)&0xfe00) | (((tm->tm_mon+1)<<5)&0x1e0) | (tm->tm_mday&0x1f));
    *dosTime = (((tm->tm_hour<<11)&0xf800) | ((tm->tm_min<<5)&0x7e0) | (tm->tm_sec&0x1f));
}

/* Convert DOS time to unix time. */
static time_t DosTimeDate(int dosDate, int dosTime) {
    time_t now;
    struct tm *tm;
    now=time(NULL);
    tm = localtime(&now);
    tm->tm_year=(((dosDate&0xfe00)>>9) + 80);
    tm->tm_mon=((dosDate&0x1e0)>>5);
    tm->tm_mday=(dosDate & 0x1f);
    tm->tm_hour=(dosTime&0xf800)>>11;
    tm->tm_min=(dosTime&0x7e0)>>5;
    tm->tm_sec=(dosTime&0x1f);
    return mktime(tm);
}

/* Return count of char ch in str */
static int strchrcnt(char *str, char ch) {
    int cnt=0;
    char *cp=str;
    while ((cp=Jsi_Strchr(cp,ch))) {
        cp++;
        cnt++;
    }
    return cnt;
}


/* TODO: merge back into jsiFilesys.c
** Concatenate zTail onto zRoot to form a pathname.  zRoot will begin
** with "/".  After concatenation, simplify the pathname be removing
** unnecessary ".." and "." directories.  Under windows, make all
** characters lower case.
**
** Resulting pathname is returned.  Space to hold the returned path is
** obtained form Jsi_Alloc() and should be freed by the calling function.
*/
static char *CanonicalPath(const char *zRoot, const char *zTail) {
    char *zPath;
    int i, j, c;

#ifdef __WIN32__
    if( isalpha(zTail[0]) && zTail[1]==':' ) {
        zTail += 2;
    }
    if( zTail[0]=='\\' ) {
        zRoot = "";
        zTail++;
    }
#endif
    if( zTail[0]=='/' ) {
        zRoot = "";
        zTail++;
    }
    zPath = (char*)Jsi_Malloc( Jsi_Strlen(zRoot) + Jsi_Strlen(zTail) + 2 );
    if( zPath==0 ) return 0;
    if (zTail[0]) {
        sprintf(zPath, "%s/%s", zRoot, zTail);
    } else {
        Jsi_Strcpy(zPath, zRoot);
    }
    for(i=j=0; (c = zPath[i])!=0; i++) {
#ifdef __WIN32__
        if( isupper(c) ) {
            if (maptolower) c = tolower(c);
        }
        else if( c=='\\' ) c = '/';
#endif
        if( c=='/' ) {
            int c2 = zPath[i+1];
            if( c2=='/' ) continue;
            if( c2=='.' ) {
                int c3 = zPath[i+2];
                if( c3=='/' || c3==0 ) {
                    i++;
                    continue;
                }
                if( c3=='.' && (zPath[i+3]=='.' || zPath[i+3]==0) ) {
                    i += 2;
                    while( j>0 && zPath[j-1]!='/' ) {
                        j--;
                    }
                    continue;
                }
            }
        }
        zPath[j++] = c;
    }
    if( j==0 ) {
        zPath[j++] = '/';
    }

    zPath[j] = 0;
    return zPath;
}

static Jsi_RC ZvfsReadTOCStart(
    Jsi_Interp *interp,    /* Leave error messages in this interpreter */
    Jsi_Channel chan,
    ZFile **pList,
    int *iStart
) {
// char *zArchiveName = 0;    /* A copy of zArchive */
    int nFile;                 /* Number of files in the archive */
    int iPos;                  /* Current position in the archive file */
    //ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    //Jsi_HashEntry *pEntry;     /* Hash table entry */
    //bool isNew;                 /* Flag to tell use when a hash entry is new */
    unsigned char zBuf[100];   /* Space into which to read from the ZIP archive */
    //Jsi_HashSearch zSearch;   /* Search all mount points */
    ZFile *p;
    int zipStart;

    if (!chan) {
        return JSI_ERROR;
    }
    /* TODO: if we ever support utf8 properly, these might do something. */
    if (Jsi_SetChannelOption(interp, chan, "-translation", "binary") != JSI_OK) {
        return JSI_ERROR;
    }
    if (Jsi_SetChannelOption(interp, chan, "-encoding", "binary") != JSI_OK) {
        return JSI_ERROR;
    }

    /* Read the "End Of Central Directory" record from the end of the
    ** ZIP archive.
    */
    Jsi_Seek(chan, -22, SEEK_END);
    iPos = Jsi_Tell(chan);
    Jsi_Read(chan, (char*)zBuf, 22);
    if (memcmp(zBuf, "\120\113\05\06", 4)) {
        /* Jsi_LogError("not a ZIP archive"); */
        return JSI_BREAK;
    }

    /* Compute the starting location of the directory for the ZIP archive
    ** in iPos then seek to that location.
    */
    zipStart = iPos;
    nFile = INT16(zBuf,8);
    iPos -= INT32(zBuf,12);
    Jsi_Seek(chan, iPos, SEEK_SET);

    while(1) {
        int lenName;            /* Length of the next filename */
        int lenExtra;           /* Length of "extra" data for next file */
        int iData;              /* Offset to start of file data */
        // int dosTime;
        //int dosDate;
        //int isdir;
        //ZvfsFile *pZvfs;        /* A new virtual file */
        // char *zFullPath;        /* Full pathname of the virtual file */
        //char zName[1024];       /* Space to hold the filename */

        if (nFile-- <= 0 ) {
            break;
        }
        /* Read the next directory entry.  Extract the size of the filename,
        ** the size of the "extra" information, and the offset into the archive
        ** file of the file data.
        */
        Jsi_Read(chan, (char*)zBuf, 46);
        if (memcmp(zBuf, "\120\113\01\02", 4)) 
            return Jsi_LogError("ill-formed central directory entry");
        lenName = INT16(zBuf,28);
        lenExtra = INT16(zBuf,30) + INT16(zBuf,32);
        iData = INT32(zBuf,42);
        if (iData<zipStart) {
            zipStart = iData;
        }

        p = newZFile(lenName, pList);
        if (!p) break;

        Jsi_Read(chan, p->zName, lenName);
        p->zName[lenName] = 0;
        if (lenName>0 && p->zName[lenName-1] == '/') {
            p->isSpecial = 1;
        }
        p->dosDate = INT16(zBuf, 14);
        p->dosTime = INT16(zBuf, 12);
        p->nByteCompr = INT32(zBuf, 20);
        p->nByte = INT32(zBuf, 24);
        p->nExtra = INT32(zBuf, 28);
        p->iCRC = INT32(zBuf, 32);

        if (nFile < 0)
            break;

        /* Skip over the extra information so that the next read will be from
        ** the beginning of the next directory entry.
        */
        Jsi_Seek(chan, lenExtra, SEEK_CUR);
    }
    *iStart = zipStart;
    return JSI_OK;
}

static Jsi_RC ZvfsReadTOC(
    Jsi_Interp *interp,    /* Leave error messages in this interpreter */
    Jsi_Channel chan,
    ZFile **pList
) {
    int iStart;
    return ZvfsReadTOCStart( interp, chan, pList, &iStart);
}


static ZvfsArchive* ZvfsLookupMount(Jsi_Interp *interp, const char *path) {
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */

    ZvfsArchive* match=0;
    if( zvfslocal.isInit==0 || path==0) return 0;
    pEntry=Jsi_HashSearchFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
            const char *zpath = Jsi_ValueToString(interp, pArchive->MountPoint, NULL);
            if (!Jsi_Strcmp(zpath, path)) {
                match=(ZvfsArchive*)Jsi_HashValueGet(pEntry);
                break;
            }
        }
        pEntry=Jsi_HashSearchNext(&zSearch);
    }

    return match;
}

#define FN_info JSI_INFO("\
Given an mount point argument, returns the archive for it. \
Otherwise, returns an array of mount points")

static Jsi_RC ZvfsNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                       Jsi_Value **ret, Jsi_Func *funcPtr)
{
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    Jsi_DString pStr, mStr;
    Jsi_Value *mount = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_RC rc = JSI_OK;
    
    Jsi_DSInit(&pStr);
    Jsi_DSInit(&mStr);
    if( !zvfslocal.isInit ) return JSI_ERROR;
    /* If null archive name, return all current mounts. */
    if (!mount) {
        if (!ret)
            return JSI_OK;
        Jsi_Obj* obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        pEntry=Jsi_HashSearchFirst(zvfslocal.archiveHash,&zSearch);
        while (pEntry) {
            if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
                Jsi_ObjArrayAdd(interp, obj, pArchive->MountPoint);
            }
            pEntry=Jsi_HashSearchNext(&zSearch);
        }
        Jsi_ValueMakeObject(interp, ret, obj);
        return JSI_OK;
    }
    const char *zMountPoint = Jsi_ValueToString(interp, mount, NULL);

    pArchive = ZvfsLookupMount(interp, zMountPoint);
    if (pArchive) {
        if (ret)
            Jsi_ValueDup2(interp, ret, pArchive->Name);
        else
            rc = JSI_ERROR;
    }
    Jsi_DSFree(&pStr);
    return rc;
}

#define FN_mount JSI_INFO("\
Read a ZIP archive and make entries in the virutal file hash table for all \
files contained therein.")
Jsi_RC Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)
{
    Jsi_Channel chan;          /* Used for reading the ZIP archive file */
    char *zArchiveName = 0;    /* A copy of zArchive */
    int nFile;                 /* Number of files in the archive */
    int iPos;                  /* Current position in the archive file */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    bool isNew;                 /* Flag to tell use when a hash entry is new */
    unsigned char zBuf[100];   /* Space into which to read from the ZIP archive */
    unsigned int startZip;
    Jsi_DString pStr, mStr;
    const char *zMountPoint;
    char mbuf[100];

    Jsi_DSInit(&pStr);
    Jsi_DSInit(&mStr);
    if( !zvfslocal.isInit ) return JSI_ERROR;
    /* If NULL mount, generate a mount point. */
    // TODO: cleanup allocations of Absolute() path.
    if (mount == NULL || Jsi_ValueIsNull(interp, mount)) {
        int n = 0;
        while (n++ < 1000) {
            snprintf(mbuf, sizeof(mbuf), "%s%d", JSI_ZVFS_DIR, n);
            if (!ZvfsLookupMount(interp, mbuf))
                break;
        }
        zMountPoint = mbuf;
    } else {
        zMountPoint = Jsi_ValueToString(interp, mount, NULL);
    }
    chan = Jsi_Open(interp, archive, "rb");
    if (!chan) {
        return JSI_ERROR;
    }
    /* Read the "End Of Central Directory" record from the end of the
    ** ZIP archive.
    */
    if (Jsi_Seek(chan, -22, SEEK_END) != 0) {
        if (ret && *ret)
            Jsi_LogError("not a ZIP archive");
        goto bail;
    }
    iPos = Jsi_Tell(chan);
    Jsi_Read(chan, (char*)zBuf, 22);
    if (memcmp(zBuf, "\120\113\05\06", 4)) {
        if (ret && *ret)
            Jsi_LogError("not a ZIP archive");
        goto bail;
    }

    /* Construct the archive record
    */
    zArchiveName = Jsi_ValueNormalPath(interp, archive, &pStr);
    pEntry = Jsi_HashEntryNew(zvfslocal.archiveHash, zArchiveName, &isNew);
    if( !isNew ) {
        pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry);
        Jsi_LogError("already mounted at %s", SS(pArchive->MountPoint));
        Jsi_DSFree(&pStr);
        goto bail;
    }
    if (!*zMountPoint) {
        /* Empty string is the special case of mounting on itself. */
        zMountPoint = Jsi_ValueNormalPath(interp, archive, &mStr);
    } else if (zMountPoint != mbuf) {
        zMountPoint = Jsi_ValueNormalPath(interp, mount, &mStr);
    }
    pArchive = (ZvfsArchive*)Jsi_Calloc(1, sizeof(*pArchive));
    pArchive->Name = Jsi_ValueNewStringDup(interp, zArchiveName);
    Jsi_IncrRefCount(interp, pArchive->Name);
    Jsi_DSFree(&pStr);
    pArchive->MountPoint = Jsi_ValueNewStringDup(interp, zMountPoint);
    Jsi_IncrRefCount(interp, pArchive->MountPoint);
    pArchive->pFiles = 0;
    Jsi_HashValueSet(pEntry, pArchive);
    pArchive->pEntry = pEntry;

    /* Compute the starting location of the directory for the ZIP archive
    ** in iPos then seek to that location.
    */
    nFile = INT16(zBuf,8);
    iPos -= INT32(zBuf,12);
    Jsi_Seek(chan, iPos, SEEK_SET);
    startZip = iPos;

    while(1) {
        int lenName;            /* Length of the next filename */
        int lenExtra = 0;           /* Length of "extra" data for next file */
        int iData;              /* Offset to start of file data */
        int dosTime;
        int dosDate;
        int isdir;
        int rb;
        ZvfsFile *pZvfs;        /* A new virtual file */
        char *zFullPath;        /* Full pathname of the virtual file */
        char zName[1024];       /* Space to hold the filename */

        if (nFile-- <= 0 ) {
            isdir = 1;
            zFullPath = CanonicalPath(zMountPoint, "");
            iData = startZip;
            goto addentry;
        }
        /* Read the next directory entry.  Extract the size of the filename,
        ** the size of the "extra" information, and the offset into the archive
        ** file of the file data.
        */
        Jsi_Read(chan, (char*)zBuf, 46);
        if (memcmp(zBuf, "\120\113\01\02", 4)) {
            Jsi_LogError("ill-formed central directory entry");
            //TODO: cleanup.
            goto bail;
        }
        lenName = INT16(zBuf,28);
        lenExtra = INT16(zBuf,30) + INT16(zBuf,32);
        iData = INT32(zBuf,42);


        /* If the virtual filename is too big to fit in zName[], then skip
        ** this file
        */
        if( lenName >= (int)sizeof(zName) ) {
            Jsi_Seek(chan, lenName + lenExtra, SEEK_CUR);
            continue;
        }

        /* Construct an entry in zvfslocal.fileHash for this virtual file.
        */
        rb = Jsi_Read(chan, zName, lenName);
        if (rb != lenName)
            goto bail;
        isdir=0;
        if (lenName>0 && zName[lenName-1] == '/') {
            lenName--;
            isdir=2;
        }
        zName[lenName] = 0;
        zFullPath = CanonicalPath(zMountPoint, zName);
addentry:
        pZvfs = (ZvfsFile*)Jsi_Calloc(1, sizeof(*pZvfs) );
        pZvfs->zName = zFullPath;
        pZvfs->pArchive = pArchive;
        pZvfs->isdir = isdir;
        pZvfs->depth=strchrcnt(zFullPath,'/');
        pZvfs->iOffset = iData;
        if (iData<(int)startZip) {
            startZip = iData;
        }
        dosDate = INT16(zBuf, 14);
        dosTime = INT16(zBuf, 12);
        pZvfs->timestamp = DosTimeDate(dosDate, dosTime);
        pZvfs->nByte = INT32(zBuf, 24);
        pZvfs->nByteCompr = INT32(zBuf, 20);
        pZvfs->pNext = pArchive->pFiles;
        pZvfs->permissions = (0xffff&(INT32(zBuf, 38) >> 16));
        pArchive->pFiles = pZvfs;
        pEntry = Jsi_HashEntryNew(zvfslocal.fileHash, zFullPath, &isNew);
        if( isNew ) {
            pZvfs->pNextName = 0;
        } else {
            ZvfsFile *pOld = (ZvfsFile*)Jsi_HashValueGet(pEntry);
            pOld->pPrevName = pZvfs;
            pZvfs->pNextName = pOld;
        }
        pZvfs->pPrevName = 0;
        Jsi_HashValueSet(pEntry, (void*) pZvfs);

        if (nFile < 0)
            break;

        /* Skip over the extra information so that the next read will be from
        ** the beginning of the next directory entry.
        */
        Jsi_Seek(chan, lenExtra, SEEK_CUR);
    }
    pArchive->chan = chan;

    if (ret && *ret)
        Jsi_ValueMakeStringDup(interp, ret, zMountPoint);
    Jsi_DSFree(&mStr);
    Jsi_DSFree(&pStr);
    interp->mountCnt++;
//done:
    return JSI_OK;

bail:
    if (chan)
        Jsi_Close(chan);
    return JSI_ERROR;
}

/*
** Locate the ZvfsFile structure that corresponds to the file named.
** Return NULL if there is no such ZvfsFile.
*/
static ZvfsFile *ZvfsLookup(Jsi_Interp *interp, Jsi_Value *path) {
    char *zt;
    Jsi_HashEntry *pEntry;
    ZvfsFile *pFile;
    Jsi_DString dStr = {};
    int len, isdir = 0;
    if( zvfslocal.isInit==0 ) return 0;
    zt = Jsi_ValueNormalPath(interp, path, &dStr);
    if (!zt)
        return NULL;
    len = dStr.len;
    if (len && zt[len-1] == '/') {
        isdir = 1;
        zt[len-1] = 0;
    }
    pEntry = Jsi_HashEntryFind(zvfslocal.fileHash, zt);
    pFile = (ZvfsFile*)(pEntry ? Jsi_HashValueGet(pEntry) : 0);
    Jsi_DSFree(&dStr);
    if (isdir && pFile && !pFile->isdir)
        return NULL;
    return pFile;
}

/*
** Unmount zip given its mount point.
*/
static Jsi_RC Zvfs_Unmount(Jsi_Interp *interp, Jsi_Value *path) {
    char *zPath;
    ZvfsArchive *pArchive;
    ZvfsFile *pFile, *pNextFile;
    Jsi_HashEntry *pEntry;
    Jsi_DString pStr;
    // TODO: use jsiMain interp for mount/unmount.
    // TODO: if pwd in mount, change it.
    zPath = Jsi_ValueNormalPath(interp, path, &pStr);
    if (!(pArchive = ZvfsLookupMount(interp, zPath)))
        return JSI_ERROR;

    Jsi_Close(pArchive->chan);
    if (pArchive->pEntry)
        Jsi_HashEntryDelete(pArchive->pEntry);
    Jsi_DecrRefCount(interp, pArchive->Name);
    Jsi_DecrRefCount(interp, pArchive->MountPoint);
    for(pFile=pArchive->pFiles; pFile; pFile=pNextFile) {
        pNextFile = pFile->pNext;
        if( pFile->pNextName ) {
            pFile->pNextName->pPrevName = pFile->pPrevName;
        }
        char *zName = pFile->zName;
        if( pFile->pPrevName ) {
            pFile->pPrevName->pNextName = pFile->pNextName;
        } else {
            pEntry = Jsi_HashEntryFind(zvfslocal.fileHash, pFile->zName);
            if( pEntry==0 ) {
                /* This should never happen */
            } else if( pFile->pNextName ) {
                Jsi_HashValueSet(pEntry, pFile->pNextName);
            } else {
                Jsi_HashEntryDelete(pEntry);
            }
        }
        Jsi_Free(zName);
    }
    interp->mountCnt--;
    return JSI_OK;
}

/*
** zvfs::mount  Zip-archive-name  mount-point
**
** Create a new mount point on the given ZIP archive.  After this
** command executes, files contained in the ZIP archive will appear
** to Jsi to be regular files at the mount point.
**
** With no mount-point, return mount point for archive.
** With no archive, return all archive/mount pairs.
** If mount-point is specified as an empty string, mount on file path.
**
*/
static Jsi_RC ZvfsMountCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Value* File = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* Mount = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_RC rc = Zvfs_Mount(interp, File, Mount, ret);
    if (rc != JSI_OK) {
        Jsi_LogError("mount failed for %s on %s", SS(File), SS(Mount));
    }
    return rc;
}

static Jsi_RC ZvfsUnmountCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value* Mount = Jsi_ValueArrayIndex(interp, args, 0);
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */

    if (Zvfs_Unmount(interp, Mount) == JSI_OK) {
        return JSI_OK;
    }

    if( !zvfslocal.isInit ) return JSI_ERROR;
    char *zMountPoint;
    char *zMount = SS(Mount);
    if (!zMount)
        return JSI_ERROR;
    pEntry=Jsi_HashSearchFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if (((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry)))
                && ((zMountPoint = SS(pArchive->MountPoint)))
                && zMountPoint[0]
                && (Jsi_Strcmp(zMountPoint, zMount) == 0)) {
            if (Zvfs_Unmount(interp, pArchive->Name) == JSI_OK) {
                return JSI_OK;
            }
            break;
        }
        pEntry=Jsi_HashSearchNext(&zSearch);
    }

    Jsi_LogError("unknown zvfs mount point or file: %s", zMount);
    return JSI_ERROR;
}

#define FN_stat JSI_INFO("\
Return details about the given file in the ZVFS.  The information \
consists of (1) the name of the ZIP archive that contains the file, \
(2) the size of the file after decompressions, (3) the compressed \
size of the file, and (4) the offset of the compressed data in the archive.")
static Jsi_RC ZvfsStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                       Jsi_Value **ret, Jsi_Func *funcPtr)
{
    ZvfsFile *pFile;

    Jsi_Value *Filename = Jsi_ValueArrayIndex(interp, args, 0);
    pFile = ZvfsLookup(interp, Filename);
    if (pFile) 
    {
        Jsi_Obj *sobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, sobj);
        
        Jsi_ObjInsert(interp, sobj, "archive", pFile->pArchive->Name, 0);
        Jsi_ObjInsert(interp, sobj, "offset", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->iOffset), 0);
        Jsi_ObjInsert(interp, sobj, "size", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->nByte), 0);
        Jsi_ObjInsert(interp, sobj, "compressedSize", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->nByteCompr), 0);

    }
    return JSI_OK;
}

/*
** The JSI I/O system calls this function to actually read information
** from a ZVFS file.
*/
static int vfsInput (
    ZvfsChannelInfo* pInfo,  /* The channel to read from */
    char *buf,               /* Buffer to fill */
    int toRead,              /* Requested number of bytes */
    int *pErrorCode          /* Location of error flag */
) {

    if( toRead > (int)pInfo->nByte ) {
        toRead = pInfo->nByte;
    }
    if( toRead == 0 ) {
        return 0;
    }
    Jsi_Seek(pInfo->chan, pInfo->curPos, SEEK_SET);
    if (!pInfo->isCompressed ) {
        toRead = Jsi_Read(pInfo->chan, buf, toRead);
    } else {
        int err = Z_OK;
        z_stream *stream = &pInfo->stream;
        stream->next_out = (unsigned char*)buf;
        stream->avail_out = toRead;
        while (stream->avail_out) {
            if (!stream->avail_in && pInfo->nByteCompr>0)
            {
                int len = pInfo->nByteCompr;
                if (len > COMPR_BUF_SIZE) {
                    len = COMPR_BUF_SIZE;
                }
                len = Jsi_Read(pInfo->chan, (char*)pInfo->zBuf, len);
                if (len==0) break;
                if (len<0) { err = Z_STREAM_END+1; break; }
                pInfo->nByteCompr -= len;
                stream->next_in = pInfo->zBuf;
                stream->avail_in = len;
            }
            err = inflate(stream, Z_NO_FLUSH);
            if (err) break;
        }
        if (err == Z_STREAM_END) {
            if ((stream->avail_out != 0)) {
                *pErrorCode = err; /* premature end */
                return -1;
            }
        } else if( err ) {
            *pErrorCode = err; /* some other zlib error */
            return -1;
        }
    }
    pInfo->curPos = Jsi_Tell(pInfo->chan);

    if (toRead<0)
        *pErrorCode = Z_STREAM_END;
    else {
        pInfo->nByte -= toRead;
        pInfo->readSoFar += toRead;
        *pErrorCode = 0;
    }
    return toRead;
}

/*
** Move the file pointer so that the next byte read will be "offset".
*/
static int vfsSeek(
    ZvfsChannelInfo* pInfo,    /* The file structure */
    long offset,                /* Offset to seek to */
    int mode,                   /* One of SEEK_CUR, SEEK_SET or SEEK_END */
    int *pErrorCode             /* Write the error code here */
) {
    Jsi_Seek(pInfo->chan, pInfo->curPos, SEEK_SET);
    switch( mode ) {
    case SEEK_CUR: {
        offset += pInfo->readSoFar;
        break;
    }
    case SEEK_END: {
        offset += pInfo->readSoFar + pInfo->nByte;
        break;
    }
    default: {
        /* Do nothing */
        break;
    }
    }
    if (offset < 0) offset = 0;
    if( !pInfo->isCompressed ) {
        Jsi_Seek(pInfo->chan, offset + pInfo->startOfData, SEEK_SET);
        pInfo->nByte = pInfo->nData;
        pInfo->readSoFar = offset;
    } else {
        if( offset<pInfo->readSoFar ) {
            z_stream *stream = &pInfo->stream;
            inflateEnd(stream);
            stream->zalloc = (alloc_func)0;
            stream->zfree = (free_func)0;
            stream->opaque = (voidpf)0;
            stream->avail_in = 2;
            stream->next_in = pInfo->zBuf;
            pInfo->zBuf[0] = 0x78;
            pInfo->zBuf[1] = 0x01;
            inflateInit(&pInfo->stream);
            Jsi_Seek(pInfo->chan, pInfo->startOfData, SEEK_SET);
            pInfo->nByte += pInfo->readSoFar;
            pInfo->nByteCompr = pInfo->nData;
            pInfo->readSoFar = 0;
        }
        while( pInfo->readSoFar < offset ) {
            int toRead, errCode;
            char zDiscard[100];
            toRead = offset - pInfo->readSoFar;
            if( toRead>(int)sizeof(zDiscard) ) toRead = (int)sizeof(zDiscard);
            vfsInput(pInfo, zDiscard, toRead, &errCode);
        }
    }
    pInfo->curPos = Jsi_Tell(pInfo->chan);
    return pInfo->readSoFar;
}

static void put32(char *z, int v);

/***************** Compressed files ******************/

static Jsi_Channel Jfz_FSOpenProc (Jsi_Interp *interp, Jsi_Value *path, const char *modes)
{
    ZvfsChannelInfo *pInfo;
    Jsi_Channel chan;
    int mode = 0, rc, i, n, zLevel = Z_DEFAULT_COMPRESSION, useGzip = 1;
    char Mode[JSI_FSMODESIZE];
    const char *s = (modes ? modes : "r");
    
    for (i=0, n = 0; s[i]; i++) {
        switch (s[i]) {
            case '+': Jsi_LogError("+ is unsupported with z: %s", s); return NULL; break;
            case 'b': break;
            case 'r': mode |= JSI_FS_READONLY; break;
            case 'a': mode |= (JSI_FS_APPEND|JSI_FS_WRITEONLY); break;
            case 'w': mode |= JSI_FS_WRITEONLY; break;
            case 'Z': useGzip = 0; 
            case 'z': mode |= JSI_FS_COMPRESS; continue; break;
            case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                zLevel = s[i]-'1'+1; continue; break;
            default: Jsi_LogError("unknown mode char: %c", s[i]); return NULL;
        }
        Mode[n++] = s[i];
    }
    Mode[n] = 0;
    if (mode&JSI_FS_READONLY && mode&JSI_FS_WRITEONLY) {
        Jsi_LogError("simultaneous read and write is unsupported with z mode");
        return NULL; 
    }
    Jsi_Channel achan = Jsi_Open(interp, path, Mode);
    if (!achan) {
        return NULL;
    }
    pInfo = (ZvfsChannelInfo*)Jsi_Calloc(1, sizeof(*pInfo) );
    pInfo->isCompressed = 1;
    pInfo->sig = ZVFS_SIG_PINFO;
    pInfo->pFile = NULL;
    pInfo->chan = achan;
    pInfo->useGzip = useGzip;
    //TODO: Jsi_CreateExitHandler(vfsExit, pInfo);
#ifdef MZ_DEFAULT_WINDOW_BITS
    int winBits = (useGzip?-MZ_DEFAULT_WINDOW_BITS:0);
    pInfo->emuGzip = useGzip;
#else
    int winBits = (useGzip?15+16:0);;
#endif
    z_stream *stream = &pInfo->stream;
    if (mode & JSI_FS_READONLY) {
        stream->next_in = (unsigned char *)pInfo->buf;
        Jsi_Seek(achan, 0, SEEK_END);
        pInfo->nByte = Jsi_Tell(achan);
        Jsi_Seek(achan, 0, SEEK_SET);
        if (!winBits)
            rc = inflateInit(stream);
        else
            rc = inflateInit2(stream, winBits);
    } else {
        if (mode&JSI_FS_APPEND)
            Jsi_Seek(achan, 0, SEEK_END);
        if (!winBits)
            rc = deflateInit(stream, zLevel);
        else
            rc = deflateInit2(stream, zLevel, Z_DEFLATED, winBits, 9, Z_DEFAULT_STRATEGY);
    }
    if (rc) {
        Jsi_Free(pInfo->zBuf);
        Jsi_Free(pInfo);
        Jsi_LogError("zinit failure");
        Jsi_Close(achan);
        return NULL;
    }
    
    chan = (Jsi_Chan*)Jsi_Calloc(1,sizeof(Jsi_Chan));
    chan->fname = Jsi_ValueString(interp, path, NULL);
    chan->interp = interp;
    chan->data = pInfo;
    Jsi_Strcpy(chan->modes, modes);
    chan->flags = (mode | (zLevel<<16)); 
    return chan;
}

static int Jfz_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    Jsi_Interp *interp = chan->interp;
    ZVFSSIGASSERT(pInfo, PINFO);
    char obuf[COMPR_BUF_SIZE];
    if (size<0) size = 0;
    int n, cnt = size;
    if (!buf) size = 0;
    z_stream *stream = &pInfo->stream;
    stream->next_out = (unsigned char*)obuf;
    stream->avail_out = sizeof(obuf);
    stream->next_in = (unsigned char*)buf;
    stream->avail_in = n = size;
    while (stream->avail_in > 0 || buf == NULL) {
        stream->total_out = 0;
        int status = deflate(stream, (buf?(size==0?Z_FULL_FLUSH:0):Z_FINISH));
        int out = stream->total_out;
        if (pInfo->emuGzip && buf && (status == Z_STREAM_END || status == Z_OK))
            pInfo->iCRC = crc32(pInfo->iCRC, (unsigned char*)buf, size - stream->avail_in);
        if ((status == Z_STREAM_END || status == Z_OK) && out>0)
        {
            if (pInfo->emuGzip && pInfo->readSoFar == 0 && /* Add gzip header */
                Jsi_Write(pInfo->chan, "\37\213\10\0\0\0\0\0\0\3", 10) != 10)
                goto writefail;
            if (out != Jsi_Write(pInfo->chan, obuf, out)) {
writefail:
                Jsi_LogError("write failed");
                cnt = -1;
                break;
            }
            cnt += out;
            pInfo->curPos = (pInfo->readSoFar += cnt);
            stream->next_out = (unsigned char*)(obuf+cnt);
            stream->avail_out = sizeof(obuf);
            if (pInfo->emuGzip && !buf) { /* Add gzip size and crc. */
                char psp[8];
                put32(psp, pInfo->iCRC);
                put32(psp+4, pInfo->nByte);
                if (Jsi_Write(pInfo->chan, (char*)psp, 8) != 8)
                    goto writefail;
            }
            //cnt += out;
        }
        pInfo->nByte += (size - stream->avail_in);
        if (status == Z_STREAM_END)
            break;
        if (status != Z_OK) {
            Jsi_LogError("unzip failed: %s", stream->msg);
            cnt = -1;
            break;
        }
        if (!buf)
            break;
    }
    return cnt;
    
}

static int Jfz_FSFlushProc(Jsi_Channel chan) {
    ZVFSSIGASSERT((ZvfsChannelInfo*)chan->data, PINFO);
    Jfz_FSWriteProc(chan, NULL, 0);
    return 0;
}

static int Jfz_FSStatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jsi_Stat(interp, path, buf);
}

static int Jfz_FSLstatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jsi_Lstat(interp, path, buf);
}

static int Jfz_FSTellProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return pInfo->curPos;
}

static int Jfz_FSReadProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    Jsi_Interp *interp = chan->interp;
    ZVFSSIGASSERT(pInfo, PINFO);
    z_stream *stream = &pInfo->stream;
    int cnt = 0;
    *s = 0;
    int rem = (pInfo->nByte - pInfo->readSoFar);
    int bsize = sizeof(pInfo->buf);
    stream->next_out = (unsigned char*)s;
    int oaout = stream->avail_out = size;
    if (rem <= 0)
        return 0;
    
    while (cnt<size)
    {
      int status;
      if (!stream->avail_in)
      {
        // Input buffer is empty, so read more bytes from input file.
        int n = (rem<bsize? rem : bsize);

        if (pInfo->emuGzip && pInfo->readSoFar == 0) { /* Strip gzip header */
            if (Jsi_Read(pInfo->chan, pInfo->buf, 10) != 10)
                goto readFail;
            n -= 10;
            const char *cp = pInfo->buf;
            if (cp[0] != '\37' || cp[1] != '\213' || cp[2] != '\10') {
                Jsi_LogError("not a gzip file");
                return -1;
            }
        }
            
        if (Jsi_Read(pInfo->chan, pInfo->buf, n) != n)
        {
readFail:
            Jsi_LogError("Failed reading from input file!");
            return -1;
        }
        pInfo->curPos = (pInfo->readSoFar += n);

        stream->next_in = (unsigned char*)pInfo->buf;
        stream->avail_in = n;

        rem -= n;
      }

      status = inflate(stream, Z_SYNC_FLUSH);

      if ((status == Z_STREAM_END) || (!stream->avail_out))
      {
        uint n = oaout - stream->avail_out;
        cnt += n;
        stream->next_out = (unsigned char*)(s+cnt);
        stream->avail_out = (size-cnt);
      }

      if (status == Z_STREAM_END)
        break;
      else if (status != Z_OK)
      {
        Jsi_LogError("inflate failed: %s", stream->msg);
        return -1;
      }
    }

    return cnt;
}


static int Jfz_FSCloseProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    ZVFSSIGASSERT(pInfo, PINFO);
    if( pInfo->zBuf ) {
        Jsi_Free(pInfo->zBuf);
    }
    int mode = chan->flags;
    if (mode & JSI_FS_READONLY) {
        if (inflateEnd(&pInfo->stream) != Z_OK)
        {
          fprintf(stderr, "inflateEnd() failed!\n");
          return -1;
        }
    } else {
        Jfz_FSWriteProc(chan, NULL, 0);
        if (deflateEnd(&pInfo->stream) != Z_OK)
        {
          fprintf(stderr, "deflateEnd() failed!\n");
          return -1;
        }
    }
    if (pInfo->chan)
        Jsi_Close(pInfo->chan);
    Jsi_Free((char*)pInfo);
    return 0;
}


static char * Jfz_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0;
    *s = 0;
    while (n<(size-1)) {
        int m = Jfz_FSReadProc(chan, pInfo->buf, 1);
        if (m <= 0)
            break;
        *cp = pInfo->buf[0];
        if (*cp == '\n') {
            n++;
            break;
        }
        n++;
        cp++;
    }
    if (n>0)
        s[n]=0;
    return s;
}

/************** Zip Archive filesystem ******************/

static int Jaz_FSCloseProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    if( pInfo->zBuf ) {
        Jsi_Free(pInfo->zBuf);
        inflateEnd(&pInfo->stream);
    }
    Jsi_Free((char*)pInfo);
    return 0;
}

static Jsi_Channel Jaz_FSOpenProc (Jsi_Interp *interp, Jsi_Value *path, const char *mode)
{
    ZvfsFile *pFile;
    ZvfsChannelInfo *pInfo;
    Jsi_Channel chan;
    static int count = 1;
    char zName[50];
    unsigned char zBuf[50];
    if (*mode != 'r') {
        Jsi_LogError("readonly");
        return NULL;
    }
    pFile = ZvfsLookup(interp, path);
    if (!pFile)
        return NULL;

    /*if (Jsi_SetChannelOption(interp, chan, "-translation", "binary")
            || Jsi_SetChannelOption(interp, chan, "-encoding", "binary")
      ) {
    } */
    Jsi_Channel achan;
    achan = pFile->pArchive->chan;
    if (!achan) {
        Jsi_LogError("archive not found");
        return NULL;
    }
    Jsi_Seek(achan, pFile->iOffset, SEEK_SET);
    Jsi_Read(achan, (char*)zBuf, 30);
    if( memcmp(zBuf, "\120\113\03\04", 4) ) {
        Jsi_LogError("local header mismatch: ");
        return NULL;
    }
    pInfo = (ZvfsChannelInfo*)Jsi_Calloc(1, sizeof(*pInfo) );
    pInfo->pFile = pFile;
    pInfo->chan = achan;
    //Jsi_CreateExitHandler(vfsExit, pInfo);
    pInfo->isCompressed = INT16(zBuf, 8);
    if( pInfo->isCompressed ) {
        z_stream *stream = &pInfo->stream;
        pInfo->zBuf = (unsigned char*)Jsi_Calloc(1, COMPR_BUF_SIZE);
        stream->avail_in = 2;
        stream->next_in = pInfo->zBuf;
        pInfo->zBuf[0] = 0x78;
        pInfo->zBuf[1] = 0x01;
        inflateInit(&pInfo->stream);
    } else {
        pInfo->zBuf = 0;
    }
    pInfo->nByte = INT32(zBuf,22);
    pInfo->nByteCompr = pInfo->nData = INT32(zBuf,18);
    pInfo->readSoFar = 0;
    Jsi_Seek(achan, INT16(zBuf,26)+INT16(zBuf,28), SEEK_CUR);
    pInfo->curPos = pInfo->startOfData = Jsi_Tell(achan);
    snprintf(zName, sizeof(zName), "vfs_%lx_%x",(long)(((uintptr_t)pFile)>>12),count++);
    chan = (Jsi_Channel)Jsi_Calloc(1,sizeof(Jsi_Chan));
    chan->fname = pFile->zName;
    chan->data = pInfo;
    return chan;
}

/*
** This routine does a stat() system call for a ZVFS file.
*/
static int Jaz_FSStatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    ZvfsFile *pFile;

    pFile = ZvfsLookup(zvfslocal.interp, path);
    if( pFile==0 ) {
        return -1;
    }
    memset(buf, 0, sizeof(*buf));
    if (pFile->isdir)
        buf->st_mode = 040555;
    else
        buf->st_mode = (0100000|pFile->permissions);
    buf->st_ino = 0;
    buf->st_size = pFile->nByte;
    buf->st_mtime = pFile->timestamp;
    buf->st_ctime = pFile->timestamp;
    buf->st_atime = pFile->timestamp;
    return 0;
}

/*
** This routine does an access() system call for a ZVFS file.
*/
static int Jaz_FSAccessProc(Jsi_Interp *interp, Jsi_Value *path, int mode) {
    ZvfsFile *pFile;

    if( mode & 3 ) {
        return -1;
    }
    pFile = ZvfsLookup(zvfslocal.interp, path);
    if( pFile==0 ) {
        return -1;
    }
    return 0;
}

static int Jaz_FSScandirProc(Jsi_Interp *interp, Jsi_Value *dirpath, Jsi_Dirent ***namelist,
   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))
{

    Jsi_HashEntry *pEntry;
    Jsi_HashSearch sSearch;
    int len, n = 0, rc = JSI_OK, deSpace = 0;
    Jsi_Dirent *de, dd;
    Jsi_Dirent **dep = NULL;
    *namelist = NULL;
    Jsi_DString pStr;

    const char *zp=Jsi_ValueNormalPath(interp, dirpath, &pStr);
    len = Jsi_Strlen(zp);

    for(pEntry = Jsi_HashSearchFirst(zvfslocal.fileHash, &sSearch);
            pEntry && rc == JSI_OK;
            pEntry = Jsi_HashSearchNext(&sSearch)
       ) {
        ZvfsFile *pFile = (ZvfsFile*)Jsi_HashValueGet(pEntry);
        char *z = pFile->zName;
        int zlen = Jsi_Strlen(z);
        if (zlen<len || Jsi_Strncmp(z,zp,len) || z[len] != '/' || !z[len+1])
            continue;
        z = z + len + 1;
        if (Jsi_Strchr(z,'/'))
            continue;
#ifndef __WIN32
        dd.d_type = (pFile->isdir ? DT_DIR : DT_REG);
#endif
        Jsi_Strncpy(dd.d_name,  z, sizeof(dd.d_name));
        if (filter && !(filter)(&dd))
            continue;
        if (n >= deSpace) {
            deSpace += 50;
            dep = (Jsi_Dirent**)Jsi_Realloc(dep, deSpace * sizeof(Jsi_Dirent*));
        }
        de = dep[n] = (Jsi_Dirent*)Jsi_Calloc(deSpace, sizeof(Jsi_Dirent));
        *de = dd;
        n++;
    }
    if (n>0) {
        if (compar)
            qsort(dep, n, sizeof(Jsi_Dirent*), (void*)compar);
        *namelist = dep;
    }
    Jsi_DSFree(&pStr);
    return n;
}
/*
int Jaz_FSMatchInDirectoryProc (Jsi_Interp* interp, Jsi_Value *result, Jsi_Value *path,
                                Jsi_Value *pattern, int flags, Jsi_FSGlobOpts *opts)
{
    Jsi_HashEntry *pEntry;
    Jsi_HashSearch sSearch;
    int len, isreg = 0, rc = JSI_OK;
    char *zPattern = NULL;
    char *pathPtr = Jsi_ValueString(interp, path, &len);
    if (!(isreg=Jsi_ValueIsObjType(interp, pattern, JSI_OT_REGEXP)))
        zPattern = Jsi_ValueString(interp, pattern, NULL);
    const char *zp=pathPtr;
    if (!zp) return JSI_ERROR;
    if (len && zp[len-1] == '/')
        len--;
    Jsi_Obj *obj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, result, obj);
    for(pEntry = Jsi_HashSearchFirst(zvfslocal.fileHash, &sSearch);
            pEntry && rc == JSI_OK;
            pEntry = Jsi_HashSearchNext(&sSearch)
       ) {
        ZvfsFile *pFile = Jsi_HashValueGet(pEntry);
        char *z = pFile->zName;
        int zlen = Jsi_Strlen(z);
        if (zlen<len || Jsi_Strncmp(z,zp,len) || z[len] != '/' || !z[len+1])
            continue;
        z = z + len + 1;
        if (Jsi_Strchr(z,'/'))
            continue;
        if (isreg) {
           int ismat;
            Jsi_RegExpMatch(interp, pattern, z, &ismat);
            if (!ismat)
                continue;
        } else if (zPattern != NULL && Jsi_GlobMatch(zPattern, z, 0) == 0)
            continue;
        if (pFile->isdir) {
            if (!(flags&JSI_FILE_TYPE_DIRS))
                continue;
        } else {
            if (!(flags&JSI_FILE_TYPE_FILES))
                continue;
        }
        rc = Jsi_ObjArrayAdd(interp, obj, Jsi_ValueNewStringKey(interp, z));
    }
    return JSI_OK;
}
*/

/* Functionto check whether a path is in
* this filesystem.  This is the most
* important filesystem procedure. */
static bool Jaz_FSPathInFilesystemProc (Jsi_Interp *interp, Jsi_Value *path, void* *clientDataPtr) {
    ZvfsFile *zFile;
    if (zvfslocal.archiveHash->numEntries<=0)
        return 0;
    /*if (ZvfsLookupMount(zvfslocal.interp, path)==0)
        return 0;*/
    //  TODO: also check this is the archive.
    zFile = ZvfsLookup(zvfslocal.interp, path);
    if (zFile!=NULL && Jsi_Strcmp(SS(path), SS(zFile->pArchive->Name)))
        return 1;
    return 0;
}

static Jsi_Value *Jaz_FSListVolumesProc (Jsi_Interp *interp) {
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_Value *pVols = Jsi_ValueNew(interp);
    Jsi_Obj* obj = Jsi_ObjNew(interp);
    pEntry=Jsi_HashSearchFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
            Jsi_ObjArrayAdd(interp, obj, pArchive->MountPoint);
        }
        pEntry=Jsi_HashSearchNext(&zSearch);
    }
    return pVols;
}

static int Jaz_FSLstatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jaz_FSStatProc(interp, path, buf);
}

static int Jaz_FSFlushProc(Jsi_Channel chan) {
    return 0;
}

static int Jaz_FSTellProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return pInfo->curPos;
}

static int Jaz_FSEofProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return (pInfo->curPos >= pInfo->pFile->nByte);
}

static int Jaz_FSRewindProc(Jsi_Channel chan) {
    int rc = 0;
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    vfsSeek(pInfo, 0, SEEK_SET, &rc);
    return rc;
}

static int Jaz_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) {
    int rc = 0;
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    vfsSeek(pInfo, offset, mode, &rc);
    return rc;
}

/*static int Jaz_FSWriteProc(Jsi_Channel chan, const char *buf, int size) { return -1;}*/

static int Jaz_FSReadProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0, rc = 0;
    *s = 0;
    while (n<size) {
        if (pInfo->bpos >= pInfo->bsiz) {
            if (!(pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))) {
                break;
            }
            pInfo->bpos = 0;
        }
        *cp = pInfo->buf[pInfo->bpos++];
        n++;
        cp++;
    }
    if (n>0 && n<size)
        s[n]=0;
    return n;
}

static int Jaz_FSGetcProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    int rc = 0;
    if (pInfo->bpos >= pInfo->bsiz) {
        if (!(pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))) {
            return 0;
        }
        pInfo->bpos = 0;
    }
    return pInfo->buf[pInfo->bpos++];
}

static int Jaz_FSUngetcProc(Jsi_Channel chan, int ch) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    if (pInfo->bpos > 0 && pInfo->buf[pInfo->bpos-1] == ch)
        pInfo->bpos--;
    else {
        /* TODO: go back */
        return -1;
    }
    return ch;
}

static char * Jaz_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0, rc = 0;
    *s = 0;
    while (n<(size-1)) {
        if (pInfo->bpos >= pInfo->bsiz) {
            if ((int)pInfo->stream.total_out >= pInfo->pFile->nByte)
                return NULL;
            if ((pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))<=0) {
                if (n==0)
                    return NULL;
                break;
            }
            pInfo->bpos = 0;
        }
        *cp = pInfo->buf[pInfo->bpos++];
        if (*cp == '\n') {
            n++;
            break;
        }
        n++;
        cp++;
    }
    if (n>0)
        s[n]=0;
    return s;
}



/*
** Write a 16- or 32-bit integer as little-endian into the given buffer.
*/
static void put16(char *z, int v) {
    z[0] = v & 0xff;
    z[1] = (v>>8) & 0xff;
}
static void put32(char *z, int v) {
    z[0] = v & 0xff;
    z[1] = (v>>8) & 0xff;
    z[2] = (v>>16) & 0xff;
    z[3] = (v>>24) & 0xff;
}

/*
** Translate a DOS time and date stamp into a human-readable string.
*/
static void translateDosTimeDate(char *zStr, int zsiz, int dosDate, int dosTime) {
    static const char *zMonth[] = { "nil",
                              "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
                            };

    snprintf(zStr, zsiz, "%02d-%s-%d %02d:%02d:%02d",
            dosDate & 0x1f,
            zMonth[ ((dosDate&0x1e0)>>5) ],
            ((dosDate&0xfe00)>>9) + 1980,
            (dosTime&0xf800)>>11,
            (dosTime&0x7e)>>5,
            dosTime&0x1f
           );
}


#define FN_list JSI_INFO("\
Return contents of zip directory as an array of arrays. The first element \
contains the labels, ie: \
\n\
[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] \
")
static Jsi_RC ZvfsListCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    Jsi_Obj *nobj;
    Jsi_Obj *sobj;
    Jsi_Value *sval;
 
    Jsi_Value *Filename = Jsi_ValueArrayIndex(interp, args, 0);;
    chan = Jsi_Open(interp, Filename, "rb");
    if (chan==0)
        return JSI_ERROR;
    Jsi_RC rc = ZvfsReadTOC(interp, chan, &pList);
    if( rc==JSI_ERROR ) {
        deleteZFileList(pList);
        return rc;
    }
    Jsi_Close( chan);
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    sobj = Jsi_ObjNew(interp);
    sval = Jsi_ValueNew(interp);
    Jsi_ValueMakeArrayObject(interp, &sval, sobj);
    static const char *keys[] = {"Name", "Special", "Offset", "Bytes", "BytesCompressed", 0 };
    int i;
    for (i=0; keys[i]; i++)
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringKey(interp, keys[i]));
    Jsi_ObjArrayAdd(interp, nobj, Jsi_ValueMakeObject(interp, NULL, sobj));
    while( pList ) {
        sobj = Jsi_ObjNew(interp);
        sval = Jsi_ValueMakeArrayObject(interp, NULL, sobj);
        ZFile *pNext;
        char zDateTime[100];
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringDup(interp, pList->zName));
        translateDosTimeDate(zDateTime, sizeof(zDateTime), pList->dosDate, pList->dosTime);
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringDup(interp, zDateTime));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->isSpecial));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->iOffset));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->nByte));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->nByteCompr));
        pNext = pList->pNext;
        Jsi_Free((char*)pList);
        pList = pNext;
        Jsi_ObjArrayAdd(interp, nobj, Jsi_ValueMakeObject(interp, NULL, sobj));
    }
    return JSI_OK;
}

/*
** Write a file record into a ZIP archive at the current position of
** the write cursor for channel "chan".  Add a ZFile record for the file
** to *ppList.  If an error occurs, leave an error message on interp
** and return JSI_ERROR.  Otherwise return JSI_OK.
*/

static Jsi_RC writeFile(
    Jsi_Interp *interp,     /* Leave an error message here */
    Jsi_Channel out,        /* Write the file here */
    Jsi_Channel in,         /* Read data from this file */
    Jsi_Value *Src,         /* Name of file entry */
    Jsi_Value *Dest,        /* Name of new ZIP file entry */
    ZFile **ppList          /* Put a ZFile struct for the new file here */
) {
    z_stream stream;
    ZFile *p;
    int iEndOfData;
    int nameLen;
    int skip;
    int toOut;
    char zHdr[30];
    char zInBuf[COMPR_BUF_SIZE*1];
    char zOutBuf[COMPR_BUF_SIZE*1];
    struct tm *tm;
    time_t now;
    struct stat stat;
    const char *zDest = Jsi_ValueToString(interp, Dest, NULL);
    int isdir = (in == NULL);
    nameLen = Jsi_Strlen(zDest);

    /* Create a new ZFile structure for this file.
     * TODO: fill in date/time etc.
    */
    nameLen+=isdir;
    p = newZFile(nameLen, ppList);
    Jsi_Strcpy(p->zName, zDest);
    if (isdir)
        Jsi_Strcpy(p->zName + nameLen-1, "/");
    p->isSpecial = 0;
    Jsi_Stat(interp, Src, &stat);
    now=stat.st_mtime;
    tm = localtime(&now);
    UnixTimeDate(tm, &p->dosDate, &p->dosTime);
    p->iOffset = Jsi_Tell(out);
    p->nByte = 0;
    p->nByteCompr = 0;
    p->nExtra = 0;
    p->iCRC = 0;
    p->permissions = stat.st_mode;

    /* Fill in as much of the header as we know.
    */
    put32(&zHdr[0], 0x04034b50);
    put16(&zHdr[4], 0x0014);
    put16(&zHdr[6], 0);
    put16(&zHdr[8], 8);
    put16(&zHdr[10], p->dosTime);
    put16(&zHdr[12], p->dosDate);
    put16(&zHdr[26], nameLen);
    put16(&zHdr[28], 0);

    /* Write the header and filename.
    */
    Jsi_Write(out, zHdr, 30);
    Jsi_Write(out, zDest, nameLen);

    /* The first two bytes that come out of the deflate compressor are
    ** some kind of header that ZIP does not use.  So skip the first two
    ** output bytes.
    */
    skip = 2;

    /* Write the compressed file.  Compute the CRC as we progress.
    */
    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = 0;
    stream.avail_in = 0;
    stream.next_in = (uchar*)zInBuf;
    stream.avail_out = sizeof(zOutBuf);
    stream.next_out = (uchar*)zOutBuf;
    if (in) {
#if 1
    deflateInit(&stream, Z_DEFAULT_COMPRESSION);
#else
    {
        int i, err, WSIZE = 0x8000, windowBits, level=6;
        for (i = ((unsigned)WSIZE), windowBits = 0; i != 1; i >>= 1, ++windowBits);
        err = deflateInit2(&stream, level, Z_DEFLATED, -windowBits, 8, 0);

    }
#endif
        p->iCRC = crc32(0, 0, 0);
        while(!Jsi_Eof(in) ) {
            if( stream.avail_in==0 ) {
                int amt = Jsi_Read(in, zInBuf, sizeof(zInBuf));
                if( amt<=0 ) break;
                p->iCRC = crc32(p->iCRC, (uchar*)zInBuf, amt);
                stream.avail_in = amt;
                stream.next_in = (uchar*)zInBuf;
            }
            deflate(&stream, 0);
            toOut = sizeof(zOutBuf) - stream.avail_out;
            if( toOut>skip ) {
                Jsi_Write(out, &zOutBuf[skip], toOut - skip);
                skip = 0;
            } else {
                skip -= toOut;
            }
            stream.avail_out = sizeof(zOutBuf);
            stream.next_out = (uchar*)zOutBuf;
        }
        do {
            stream.avail_out = sizeof(zOutBuf);
            stream.next_out = (uchar*)zOutBuf;
            deflate(&stream, Z_FINISH);
            toOut = sizeof(zOutBuf) - stream.avail_out;
            if( toOut>skip ) {
                Jsi_Write(out, &zOutBuf[skip], toOut - skip);
                skip = 0;
            } else {
                skip -= toOut;
            }
        } while( stream.avail_out==0 );
        p->nByte = stream.total_in;
        p->nByteCompr = stream.total_out - 2;
        deflateEnd(&stream);
        Jsi_Flush(out);
    }

    /* Remember were we are in the file.  Then go back and write the
    ** header, now that we know the compressed file size.
    */
    iEndOfData = Jsi_Tell(out);
    Jsi_Seek(out, p->iOffset, SEEK_SET);
    put32(&zHdr[14], p->iCRC);
    put32(&zHdr[18], p->nByteCompr);
    put32(&zHdr[22], p->nByte);
    Jsi_Write(out, zHdr, 30);
    Jsi_Seek(out, iEndOfData, SEEK_SET);

    /* Close the input file.
    */
    if (in)
        Jsi_Close(in);

    /* Finished!
    */
    return JSI_OK;
}

/*
** The arguments are two lists of ZFile structures sorted by iOffset.
** Either or both list may be empty.  This routine merges the two
** lists together into a single sorted list and returns a pointer
** to the head of the unified list.
**
** This is part of the merge-sort algorithm.
*/
static ZFile *mergeZFiles(ZFile *pLeft, ZFile *pRight) {
    ZFile fakeHead;
    ZFile *pTail;

    pTail = &fakeHead;
    while( pLeft && pRight ) {
        ZFile *p;
        if( pLeft->iOffset <= pRight->iOffset ) {
            p = pLeft;
            pLeft = p->pNext;
        } else {
            p = pRight;
            pRight = p->pNext;
        }
        pTail->pNext = p;
        pTail = p;
    }
    if( pLeft ) {
        pTail->pNext = pLeft;
    } else if( pRight ) {
        pTail->pNext = pRight;
    } else {
        pTail->pNext = 0;
    }
    return fakeHead.pNext;
}

/*
** Sort a ZFile list so in accending order by iOffset.
*/
static ZFile *sortZFiles(ZFile *pList) {
# define NBIN 30
    int i;
    ZFile *p;
    ZFile *aBin[NBIN+1];

    for(i=0; i<=NBIN; i++) aBin[i] = 0;
    while( pList ) {
        p = pList;
        pList = p->pNext;
        p->pNext = 0;
        for(i=0; i<NBIN && aBin[i]; i++) {
            p = mergeZFiles(aBin[i],p);
            aBin[i] = 0;
        }
        aBin[i] = aBin[i] ? mergeZFiles(aBin[i], p) : p;
    }
    p = 0;
    for(i=0; i<=NBIN; i++) {
        if( aBin[i]==0 ) continue;
        p = mergeZFiles(p, aBin[i]);
    }
    return p;
}

/*
** Write a ZIP archive table of contents to the given
** channel.
*/
static void writeTOC(Jsi_Channel chan, ZFile *pList) {
    int iTocStart, iTocEnd;
    int nEntry = 0;
    int i;
    char zBuf[100];

    iTocStart = Jsi_Tell(chan);
    for(; pList; pList=pList->pNext) {
        if( pList->isSpecial ) continue;
        put32(&zBuf[0], 0x02014b50);
        put16(&zBuf[4], 0x0317);
        put16(&zBuf[6], 0x0014);
        put16(&zBuf[8], 0);
        put16(&zBuf[10], pList->nByte>pList->nByteCompr ? 0x0008 : 0x0000);
        put16(&zBuf[12], pList->dosTime);
        put16(&zBuf[14], pList->dosDate);
        put32(&zBuf[16], pList->iCRC);
        put32(&zBuf[20], pList->nByteCompr);
        put32(&zBuf[24], pList->nByte);
        put16(&zBuf[28], Jsi_Strlen(pList->zName));
        put16(&zBuf[30], 0);
        put16(&zBuf[32], pList->nExtra);
        put16(&zBuf[34], 1);
        put16(&zBuf[36], 0);
        put32(&zBuf[38], pList->permissions<<16);
        put32(&zBuf[42], pList->iOffset);
        Jsi_Write(chan, zBuf, 46);
        Jsi_Write(chan, pList->zName, Jsi_Strlen(pList->zName));
        for(i=pList->nExtra; i>0; i-=40) {
            int toWrite = i<40 ? i : 40;
            Jsi_Write(chan,"                                             ",toWrite);
        }
        nEntry++;
    }
    iTocEnd = Jsi_Tell(chan);
    put32(&zBuf[0], 0x06054b50);
    put16(&zBuf[4], 0);
    put16(&zBuf[6], 0);
    put16(&zBuf[8], nEntry);
    put16(&zBuf[10], nEntry);
    put32(&zBuf[12], iTocEnd - iTocStart);
    put32(&zBuf[16], iTocStart);
    put16(&zBuf[20], 0);
    Jsi_Write(chan, zBuf, 22);
    Jsi_Flush(chan);
}

static const char *
GetExtension( const char *name)
{
    const char *p, *lastSep;
#ifdef __WIN32__
    lastSep = NULL;
    for (p = name; *p != '\0'; p++) {
        if (Jsi_Strchr("/\\:", *p) != NULL) {
            lastSep = p;
        }
    }
#else
    lastSep = Jsi_Strrchr(name, '/');
#endif
    p = Jsi_Strrchr(name, '.');
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
        p = NULL;
    }
    return p;
}

static Jsi_RC CreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr, int append)
{
    Jsi_Value *Archive;
    Jsi_Channel chan = 0;
    ZFile *pList = NULL, *pToc;
    Jsi_RC rc = JSI_OK;
    int i, k, create = 0, argc, alen = Jsi_ValueGetLength(interp, args);
    Jsi_Value *flist = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *prefix, *nSrc = NULL;
    const char *ext;
    Jsi_DString dStr = {};

    for (i=1; i<alen; i++) {
        flist = Jsi_ValueArrayIndex(interp, args, i);
        if (!Jsi_ValueIsArray(interp, flist)) 
            return Jsi_LogError("expected array of files");
        if (++i<alen) {
            prefix = Jsi_ValueArrayIndex(interp, args, i);
            if (Jsi_ValueIsString(interp, prefix)==0 && Jsi_ValueIsNull(interp, prefix)==0) 
                return Jsi_LogError("expected string or null");
        }
                
    }
    
    /* Open the archive and read the table of contents
    */

    Archive = Jsi_ValueArrayIndex(interp, args, 0);
    chan = Jsi_Open(interp, Archive, "rb+");
    if (chan==0 ) {
        if (append) {
            Jsi_LogError("archive must exists: %s", SS(Archive));
            rc = JSI_ERROR;
            goto doexit;
        }
        chan = Jsi_Open(interp, Archive, "wb+");
        create = 1;
    }
    if (chan==0 ) {
        rc = Jsi_LogError("archive create failed for: %s", SS(Archive));
        goto doexit;
    }
    Jsi_Seek(chan, 0, SEEK_END);

    if (Jsi_Tell(chan) != 0) {
        /* Null file is ok, we're creating new one. */
        Jsi_Seek(chan, 0, SEEK_SET);
        rc = ZvfsReadTOC(interp, chan, &pList);
        if( rc==JSI_ERROR ) {
            goto doexit;
        } else rc=JSI_OK;
    }

    /* Find TOC */
    for(pToc=pList; pToc; pToc=pToc->pNext) {
        if( pToc->isSpecial && Jsi_Strcmp(pToc->zName,"*TOC*")==0 ) break;
    }
    if( pToc ) {
        Jsi_Seek(chan, pToc->iOffset, SEEK_SET);
    } else {
        Jsi_Seek(chan, 0, SEEK_END);
    }
    if (pToc && !append) {
        rc = Jsi_LogError("already an archive: use zvfs.truncate() first or zvfs.append().");
        goto doexit;
    }
    Jsi_Seek(chan, 0, SEEK_END);
    /* Add new files to the end of the archive. */
    for (k=1; k<alen; k++) {
        flist = Jsi_ValueArrayIndex(interp, args, k);
        argc = Jsi_ValueGetLength(interp, flist);
        prefix = NULL;
        if (++k<alen)
            prefix = Jsi_ValueArrayIndex(interp, args, k);
        
        for(i=0; rc==JSI_OK && i<argc; i++) {
            Jsi_Value *Src = Jsi_ValueArrayIndex(interp, flist, i), *fSrc = Src;
            Jsi_Channel in;
            char *fname = Jsi_ValueString(interp, Src, 0);
            
            ext = (fname?GetExtension(fname):NULL);
            if (ext && *ext == '.' && (ext[1] == 0 || (ext[1] == '.' && ext[2] == 0)))
                continue;
            if (prefix && !Jsi_ValueIsNull(interp, prefix)) {
                char *pstr = SS(prefix);
                if (*pstr) {
                    Jsi_DSSetLength(&dStr, 0);
                    Jsi_DSAppend(&dStr, pstr, "/", SS(Src), NULL);
                    fSrc = nSrc = Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr));
                    Jsi_IncrRefCount(interp, nSrc);
                }
            }
            /* Open the file that is to be added to the ZIP archive
             */
            in = NULL;
            Jsi_StatBuf sb;
            if (Jsi_Stat(interp, fSrc, &sb) == 0 && S_ISDIR(sb.st_mode)) {
            } else {
                in = Jsi_Open(interp, fSrc, "rb");
                if( in==0 ) {
                    rc = Jsi_LogError("open failed on: %s", SS(fSrc));
                    break;
                }
            }
            if (rc == JSI_OK) {
                rc = writeFile(interp, chan, in, fSrc, Src, &pList);
                if (rc != JSI_OK)
                    Jsi_LogError("write failed on: %s", SS(Src));
            }
            if (nSrc) {
                Jsi_DecrRefCount(interp, nSrc);
                nSrc = NULL;
            }
        }
    }
    /* Write the table of contents at the end of the archive.
    */
    if (rc == JSI_OK) {
        pList = sortZFiles(pList);
        writeTOC(chan, pList);
    }
doexit:
    /* Close the channel and exit */
    if (pList)
        deleteZFileList(pList);
    if (chan)
        Jsi_Close(chan);
    if (nSrc)
        Jsi_DecrRefCount(interp, nSrc);
    Jsi_DSFree(&dStr);
    if (rc != JSI_OK && create)
        Jsi_Remove(interp, Archive, 0);

    return rc;
}

#define FN_create JSI_INFO("\
This command creates a zip archive and adds files to it. Files are relative \
the given 'path', or the current directory. \
If the destignation file already exist but is not an archive (eg. an executable), \
zip data is appended to the end of the file. \
If the existing file is already an archive, an error will be thrown. \
To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \
\n\
   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');")

static Jsi_RC ZvfsCreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return CreateCmd(interp, args, _this, ret, funcPtr, 0);
}

static Jsi_RC ZvfsAppendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return CreateCmd(interp, args, _this, ret, funcPtr, 1);
}

#define FN_truncate JSI_INFO("\
Opens and scans the file to determine start of zip data \
and truncate this off the end of the file.  \
For ordinary zip archives, the resulting truncated file will be of zero length. \
If an optional bool argument can disable errors. \
In any case, the start offset of zip data (or 0) is returned.")

static Jsi_RC ZvfsTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    int rc = JSI_OK;
    bool noerror = 1; 
    int zipStart;

    Jsi_Value *Archive = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vbool = Jsi_ValueArrayIndex(interp, args, 1);
    if (vbool && Jsi_ValueGetBoolean(interp, vbool, &noerror) != JSI_OK) 
        return Jsi_LogError("expected boolean");
    chan = Jsi_Open(interp, Archive, "rb+");
    if( chan==0 ) return JSI_ERROR;

    if (Jsi_Seek(chan, 0, SEEK_END) != 0) {
        Jsi_Close(chan);
        Jsi_ValueMakeNumber(interp, ret, 0.0);
        return JSI_OK;
    }
    Jsi_Seek(chan, 0, SEEK_SET);
    rc = ZvfsReadTOCStart(interp, chan, &pList, &zipStart);
    if( rc!=JSI_OK ) {
        deleteZFileList(pList);
        Jsi_Close(chan);
        if (noerror)
            return JSI_OK;
        return Jsi_LogError("not an archive");
    }

    /* Close the channel and exit */
    deleteZFileList(pList);
    Jsi_Truncate(chan, zipStart);
    Jsi_Close(chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)zipStart);
    return JSI_OK;
}

static Jsi_RC ZvfsOffsetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    int rc = JSI_OK; 
    int zipStart;

    Jsi_Value *Archive = Jsi_ValueArrayIndex(interp, args, 0);
    chan = Jsi_Open(interp, Archive, "rb");
    if( chan==0 ) return JSI_ERROR;

    if (Jsi_Seek(chan, 0, SEEK_END) != 0) {
        Jsi_Close(chan);
        Jsi_ValueMakeNumber(interp, ret, 0.0);
        return JSI_OK;
    }
    Jsi_Seek(chan, 0, SEEK_SET);
    rc = ZvfsReadTOCStart(interp, chan, &pList, &zipStart);
    if( rc!=JSI_OK ) {
        deleteZFileList(pList);
        Jsi_Close(chan);
        return Jsi_LogError("not an archive");
    }

    /* Close the channel and exit */
    deleteZFileList(pList);
    Jsi_Close(chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)zipStart);
    return JSI_OK;
}

static Jsi_Filesystem Jaz_Filesystem = {
    .typeName="jaz",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .pathInFilesystemProc=Jaz_FSPathInFilesystemProc,
    .realpathProc=0,
    .statProc=Jaz_FSStatProc,
    .lstatProc=Jaz_FSLstatProc,
    .accessProc=Jaz_FSAccessProc,
    .chmodProc=0,
    .openProc=Jaz_FSOpenProc,
    .scandirProc=Jaz_FSScandirProc,
    .readProc=Jaz_FSReadProc,
    .writeProc=0,
    .getsProc=Jaz_FSGetsProc,
    .getcProc=Jaz_FSGetcProc,
    .ungetcProc=Jaz_FSUngetcProc,
    .putsProc=0,
    
    .flushProc=Jaz_FSFlushProc,
    .seekProc=Jaz_FSSeekProc,
    .tellProc=Jaz_FSTellProc,
    .eofProc=Jaz_FSEofProc,
    .truncateProc=0,
    .rewindProc=Jaz_FSRewindProc,
    .closeProc=Jaz_FSCloseProc,
    .linkProc=0,
    .readlinkProc=0,
    .listVolumesProc=Jaz_FSListVolumesProc,
};

static Jsi_Filesystem Jfz_Filesystem = {
    .typeName="jfz",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .pathInFilesystemProc=0,
    .realpathProc=0,
    .statProc=Jfz_FSStatProc,
    .lstatProc=Jfz_FSLstatProc,
    .accessProc=0,
    .chmodProc=0,
    .openProc=Jfz_FSOpenProc,
    .scandirProc=0,
    .readProc=Jfz_FSReadProc,
    .writeProc=Jfz_FSWriteProc,
    .getsProc=Jfz_FSGetsProc,
    .getcProc=0,
    .ungetcProc=0,
    .putsProc=0,
    
    .flushProc=Jfz_FSFlushProc,
    .seekProc=0,
    .tellProc=Jfz_FSTellProc,
    .eofProc=0,
    .truncateProc=0,
    .rewindProc=0,
    .closeProc=Jfz_FSCloseProc,
    .linkProc=0,
    /*.pathInFilesystemProc=Jfz_FSPathInFilesystemProc,
    .accessProc=Jfz_FSAccessProc,
    .scandirProc=Jfz_FSScandirProc,
    .getcProc=Jfz_FSGetcProc,
    .ungetcProc=Jfz_FSUngetcProc,
    .seekProc=Jfz_FSSeekProc,
    .eofProc=Jfz_FSEofProc,
    .rewindProc=Jfz_FSRewindProc,
    .listVolumesProc=Jfz_FSListVolumesProc,*/
};

void (*Zvfs_PostInit)(Jsi_Interp *)=0;

static Jsi_CmdSpec zvfsCmds[] = {
    { "append",     ZvfsAppendCmd,      2, -1, "archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...",  .help="Like 'create()', but appends to an existing archive (with no dup checking)", .retType=(uint)JSI_TT_VOID },
    { "create",     ZvfsCreateCmd,      2, -1, "archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...",  .help="Create a zip with the given files in prefix path", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_create },
    { "list",       ZvfsListCmd,        1,  1, "archive:string",  .help="List files in archive", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=FN_list },
    { "mount",      ZvfsMountCmd,       1,  2, "archive:string, mountdir:string=void",  .help="Mount zip on mount point", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_mount },
    { "names",      ZvfsNamesCmd,       0,  1, "mountdir:string=void",  .help="Return all zvfs mounted zips, or archive for specified mount", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=FN_info },
    { "offset",     ZvfsOffsetCmd,      1,  1, "archive:string",  .help="Return the start offset of zip data", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_truncate },
    { "stat",       ZvfsStatCmd,        1,  1, "filename:string",  .help="Return details on file in zvfs mount", .retType=(uint)JSI_TT_OBJECT, .flags=0, .info=FN_stat },
    { "truncate",   ZvfsTruncateCmd,    1,  2, "archive:string, noerror:boolean=false",  .help="Truncate zip data from archive", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_truncate },
    { "unmount",    ZvfsUnmountCmd,     1,  1, "archive:string",  .help="Unmount zip", .retType=(uint)JSI_TT_VOID },
    { NULL, 0,0,0,0, .help="Commands for mounting and accessing .zip files as a filesystem" }
};

static Jsi_RC zvfsInterpDelete(Jsi_Interp *interp, void *ptr) {
    /* Unmount filesystems. */
    return JSI_OK;
}

static Jsi_RC freeFileHashTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_Free(ptr);
    return JSI_OK;
}

static Jsi_RC freeArchiveHashTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    ZvfsArchive *pArchive = (ZvfsArchive*)ptr;
    pArchive->pEntry = NULL;
    Zvfs_Unmount(interp, pArchive->MountPoint);
    Jsi_Free(pArchive);
    return JSI_OK;
}


static Jsi_RC Jsi_DoneZvfs(Jsi_Interp *interp) {
    /* TODO: cleanup on last interp. */
    if (interp == jsiMainInterp && zvfslocal.isInit)
    {
        Jsi_FSUnregister(&Jaz_Filesystem);
        Jsi_FSUnregister(&Jfz_Filesystem);
        Jsi_HashDelete(zvfslocal.archiveHash);
        Jsi_HashDelete(zvfslocal.fileHash);
        zvfslocal.isInit = 0;
    }
    return JSI_OK;
}

Jsi_RC Jsi_InitZvfs(Jsi_Interp *interp, int release) {
    if (release) return Jsi_DoneZvfs(interp);
    if( !zvfslocal.isInit ) {
        if (Jsi_FSRegister(&Jaz_Filesystem, NULL) != JSI_OK ||
            Jsi_FSRegister(&Jfz_Filesystem, NULL) != JSI_OK)
            return JSI_ERROR;
        zvfslocal.fileHash = Jsi_HashNew(interp, JSI_KEYS_STRING, freeFileHashTbl);
        zvfslocal.archiveHash = Jsi_HashNew(interp, JSI_KEYS_STRING, freeArchiveHashTbl);
        zvfslocal.isInit = 1;
        zvfslocal.interp = interp;
    }
    Jsi_CommandCreateSpecs(interp, "Zvfs",  zvfsCmds,   NULL, 0);
    if (Zvfs_PostInit) Zvfs_PostInit(interp);
    Jsi_InterpOnDelete(interp, zvfsInterpDelete, NULL);
    return JSI_OK;
}

#endif
#endif
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

// Returns length.
uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest)
{
    if (uc <= 0x7f) {
        *dest = uc;
        return 1;
    }
    if (uc <= 0x7ff) {
        *dest++ = 0xc0 | ((uc & 0x7c0) >> 6);
        *dest = 0x80 | (uc & 0x3f);
        return 2;
    }
    if (uc <= 0xffff) {
        *dest++ = 0xe0 | ((uc & 0xf000) >> 12);
        *dest++ = 0x80 | ((uc & 0xfc0) >> 6);
        *dest = 0x80 | (uc & 0x3f);
        return 3;
    }
    *dest++ = 0xf0 | ((uc & 0x1c0000) >> 18);
    *dest++ = 0x80 | ((uc & 0x3f000) >> 12);
    *dest++ = 0x80 | ((uc & 0xfc0) >> 6);
    *dest = 0x80 | (uc & 0x3f);
    return 4;
}

uint Jsi_NumUtfBytes(char c)
{
#if !JSI__UTF8
    return 1;
#else
    if ((c & 0x80) == 0) return 1;
    if ((c & 0xe0) == 0xc0) return 2;
    if ((c & 0xf0) == 0xe0) return 3;
    if ((c & 0xf8) == 0xf0) return 4;
    return -1;
#endif
}

uint Jsi_NumUtfChars(const char *s, int length) {
#if !JSI__UTF8
    uint len = Jsi_Strlen(s);
    if (length<0) return len;
    if (len>length) return length;
    return len;
#else
    uint i = 0;
    if (length<0) {
        while (*s)
            if ((*s++ & 0xc0) != 0x80)
                i++;
        return i;
    }
    const char *so = s;
    while (*s) {
        if ((*s++ & 0xc0) != 0x80)
            i++;
        if ((s-so)>=length)
            break;
    }
    return i;
#endif
}

uint Jsi_UtfGetIndex(const char *str, int index, char cbuf[5]) {
#if !JSI__UTF8
    cbuf[0] = str[index];
    cbuf[1] = 0;
    return 1;
#else
    const char *bp = Jsi_UtfAtIndex(str, index);
    int l = 0;
    if (!bp)
        cbuf[0] = 0;
    else {
        l = Jsi_NumUtfBytes(*bp);
        if (l<0) l = 0;
        else Jsi_Strncpy(cbuf, bp, l+1);
        cbuf[l] = 0;
    }
    return l;
#endif
}

char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr) {
    int ulen, ustart;
    if (n<0) {
        int lenofa = Jsi_NumUtfChars(str, -1);
        while (n < 0) n += lenofa;
    }
#if !JSI__UTF8
    ustart = n;
    ulen = len;
#else
    int m, e, l;
    ulen = ustart = 0;
    m = Jsi_UtfIndexToOffset(str, n);
    if (m>=0) {
        if (len<0) {
            ustart = m;
            ulen = Jsi_Strlen(str+m);
        } else {
            e = Jsi_UtfIndexToOffset(str+m, len);
            l = Jsi_NumUtfBytes(str[m]);
            if (l<0) l = 1;
            if (e>=0 && l>0) {
                ustart = m;
                ulen = e+l-1;
            }
        }
    }
#endif
    Jsi_DSAppendLen(dStr, str+ustart, ulen);
    return Jsi_DSValue(dStr);
}

int Jsi_UtfIndexToOffset(const char *str, int index)
{
#if !JSI__UTF8
    return index;
#else
    const char *s = str;
    while (index-- && *s) {
        int c;
        if (*s&0x80)
            s += Jsi_UtfToUniChar(s, &c);
        else
            s++;
    }
    return s - str;
#endif
}

const char* Jsi_UtfAtIndex(const char *str, int index)
{
#if !JSI__UTF8
    int slen = Jsi_Strlen(str);
    return (index<slen?str+index:NULL);
#else
    const char *s = str;
    while (index-- && *s) {
        int c;
        if (*s&0x80)
            s += Jsi_UtfToUniChar(s, &c);
        else
            s++;
    }
    return (index<0 ? s : NULL);
#endif
}

// Convert utf to unicode with optional upcase. Returns UTF size in bytes
uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *uc, int upper)
{
#if !JSI__UTF8
    *uc = (Jsi_UniChar)(upper?toupper(*utf):*utf);
    return 1;
#else
    int l = Jsi_UtfToUniChar(utf, uc);
    if (upper && *uc<0x80)
        *uc = toupper(*uc);
    return l;
#endif
}

// Convert utf to unicode.  Returns UTF size in bytes.
uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *uc)
{
#if !JSI__UTF8
    *uc = (char)*utf;
    return 1;
#else
    unsigned const char *s = (unsigned const char *)utf;

    if (s[0] < 0xc0) {
        *uc = s[0];
        return 1;
    }
    if (s[0] < 0xe0) {
        if ((s[1] & 0xc0) == 0x80) {
            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);
            return 2;
        }
    }
    else if (s[0] < 0xf0) {
        if (((utf[1] & 0xc0) == 0x80) && ((utf[2] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);
            return 3;
        }
    }
    else if (s[0] < 0xf8) {
        if (((utf[1] & 0xc0) == 0x80) && ((utf[2] & 0xc0) == 0x80) && ((utf[3] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xf0) << 18) | ((s[1] & ~0x80) << 12) | ((s[2] & ~0x80) << 6) | (s[3] & ~0x80);
            return 4;
        }
    }

    /* Invalid sequence, so just return the byte */
    *uc = *s;
    return 1;
#endif
}

// Encode UTF number to \uNNNN form.  Returns size.
uint Jsi_UtfEncode(const char *innum, char *outstr) {
    int32_t ival;
    int ilen;
    outstr[0] = '\\';
    outstr[1] = 'u';
    outstr[6] = 0;
    ilen = Jsi_UtfToUniChar((char*)innum, &ival);
    outstr[2] = jsi_toHexChar((ival&0xF000)>>12);
    outstr[3] = jsi_toHexChar((ival&0xF00)>>8);
    outstr[4] = jsi_toHexChar((ival&0xF0)>>4);
    outstr[5] = jsi_toHexChar((ival&0x0F));
    return ilen;
}

// Decode \uNNNN string to a UTF number.
uint Jsi_UtfDecode(const char *str, char* uo) {
    char c;
    uint uc = 0, len = 0;
    int pos = 0;

    while(pos<4) {
        c = str[pos];
        if(!isxdigit(c)) {
            return 0;
        }
        uc += ((uint)jsi_fromHexChar(c) << ((3-pos++)*4));
    }
    if (uc < 0x80) {
        uo[0] = uc;
        len = 1;
    } else if (uc < 0x800) {
        uo[0] = 0xc0 | (uc >> 6);
        uo[1] = 0x80 | (uc & 0x3f);
        len = 2;
    } else {
        uo[0] = 0xe0 | (uc >> 12);
        uo[1] = 0x80 | ((uc >> 6) & 0x3f);
        uo[2] = 0x80 | (uc & 0x3f);
        len = 3;
    }
    return len;
}
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

Jsi_RC Jsi_UserObjUnregister(Jsi_Interp *interp, Jsi_UserObjReg *udreg)
{
    Jsi_HashEntry *hPtr;
    if (interp->deleting) return JSI_ERROR;
    hPtr = Jsi_HashEntryFind(interp->userdataTbl, udreg->name);
    if (hPtr == NULL)
        return JSI_ERROR;
    
    Jsi_HashEntryDelete(hPtr);
    UserObjReg* ptr = (UserObjReg*)Jsi_HashValueGet(hPtr);
    SIGASSERT(ptr, USER_REG);
    Jsi_Free(ptr);
    return JSI_OK;
}

Jsi_RC jsi_UserObjDelete(Jsi_Interp *interp, void *data)
{
    UserObjReg* ptr = (UserObjReg*)data;
    SIGASSERT(ptr, USER_REG);
    Jsi_Hash *tblPtr = ptr->hashPtr;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    for (hPtr = Jsi_HashSearchFirst(tblPtr, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        void *dptr;
        Jsi_Obj *obj = (Jsi_Obj*)Jsi_HashValueGet(hPtr);
        SIGASSERT(obj, OBJ);
        assert(obj && obj->ot == JSI_OT_USEROBJ);
        Jsi_UserObj *uobj = obj->d.uobj;
        dptr = uobj->data;
        if (hPtr == uobj->hPtr)
            uobj->hPtr = NULL;
        Jsi_HashEntryDelete(hPtr);
        if (dptr && ptr->reg->freefun)
            ptr->reg->freefun(interp, dptr);
    }
    Jsi_HashDelete(tblPtr);
    Jsi_Free(ptr);
    return JSI_OK;
}

Jsi_Hash* Jsi_UserObjRegister(Jsi_Interp *interp, Jsi_UserObjReg *udreg)
{
    UserObjReg* ptr = (UserObjReg*)Jsi_Calloc(1, sizeof(*ptr));
    Jsi_HashEntry *hPtr;
    SIGINIT(ptr, USER_REG);
    bool isNew;
    ptr->reg = udreg;
    ptr->hashPtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
    //ptr->data = data;
    hPtr = Jsi_HashEntryNew(interp->userdataTbl, udreg->name, &isNew);
    if (hPtr == NULL || !isNew)
        return NULL;
    Jsi_HashValueSet(hPtr, ptr);
    
    //Jsi_InterpSetData(interp, udreg->name, ptr, UserObjDelete);
    return ptr->hashPtr;
}

void jsi_UserObjFree(Jsi_Interp *interp, Jsi_UserObj *uobj)
{
    Jsi_UserObjReg *udr =uobj->reg;
    if (interp != uobj->interp) {
        Jsi_LogError("UDID bad interp");
        return;
    }
    if (uobj->hPtr)
        Jsi_HashEntryDelete(uobj->hPtr);
    if (udr->freefun && uobj->data) {
        udr->freefun(interp, uobj->data);
        uobj->data = NULL;
    }
    _JSI_MEMCLEAR(uobj);
    Jsi_Free(uobj);
}

static Jsi_UserObj *UserObjNew(Jsi_Interp *interp, Jsi_Hash* id, void *data)
{
    Jsi_UserObj *ud = (Jsi_UserObj*)Jsi_Calloc(1,sizeof(Jsi_UserObj));
    ud->interp = interp;
    SIGINIT(ud,USERDATA);
    ud->id = id;
    ud->data = data;
    return ud;
}

int Jsi_UserObjNew(Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data)
{
    if (obj->ot != JSI_OT_OBJECT) {
        Jsi_LogBug("jsi_userdata_assign to a non raw object");
        return -1;
    }
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->userdataTbl, reg->name);
    if (!hPtr) {
        Jsi_LogBug("no such registered object");
        return -1;
    }
    UserObjReg* ureg = (UserObjReg*)Jsi_HashValueGet(hPtr);
    interp->userObjCnt++;
    Jsi_UserObj * uobj = UserObjNew(interp, ureg->hashPtr, data);
    obj->d.uobj = uobj;
    uobj->reg = reg;
    uobj->ureg = ureg;
    obj->ot = JSI_OT_USEROBJ;
    uobj->idx = ++ureg->idx;
    bool isNew;
    uobj->hPtr = Jsi_HashEntryNew(ureg->hashPtr, (void*)uobj->idx, &isNew);
    assert(uobj->hPtr && isNew==1);
    Jsi_HashValueSet(uobj->hPtr, obj);
    return uobj->idx;
}

static void *UserObjGet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Hash* id)
{
    Jsi_UserObj *ud = obj->d.uobj;
    if (!ud)
        return NULL;
    if (obj->ot != JSI_OT_USEROBJ || ud->interp != interp) {
        if (ud->interp != interp)
            Jsi_LogWarn("Jsi_Obj not userobj type");
        return NULL;
    }
    if (ud->id != id) {
        Jsi_LogWarn("Get_userdata, id not match");
        return NULL;
    }
    return ud->data;
}

void *Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr)
{
    if (value == NULL || value->vt != JSI_VT_OBJECT || value->d.obj->ot != JSI_OT_USEROBJ)
        return NULL;
    if (!funcPtr)
        return value->d.obj->d.uobj->data;
    Jsi_Obj *obj = Jsi_ValueGetObj(interp, value);
    if (!obj)
        return NULL;
    if (obj->ot != JSI_OT_USEROBJ)
        return NULL;
    void *privData = funcPtr->privData;
    return UserObjGet(interp, obj, (Jsi_Hash*)privData);
}


void *Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var) {
    Jsi_Value *vObj = Jsi_NameLookup(interp, var);
    if (!vObj)
        return NULL;
    return Jsi_UserObjGetData(interp, vObj, NULL);
}

bool jsi_UserObjIsTrue(Jsi_Interp *interp, Jsi_UserObj *uobj)
{
    Jsi_UserObjReg *udr = uobj->reg;
    if (udr->istrue) {
        return udr->istrue(uobj->data);
    }
    return 1;
}

void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr)
{
    char ubuf[50];
    Jsi_UserObjReg *reg = uobj->reg;
    const char *uname = reg->name;
    snprintf(ubuf, sizeof(ubuf), "%" PRId64, (Jsi_Wide)uobj->idx);
    Jsi_DSAppend(dStr, "#", uname, "_", ubuf, NULL);
}

Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name)
{
    if (*name != '#')
        return NULL;
    const char *cp = Jsi_Strrchr(name, '_');
    if (cp==0 || !*cp)
        return NULL;
    uintptr_t id = atoi(cp+1);
    Jsi_DString dStr = {};
    Jsi_DSAppendLen(&dStr, name+1, cp-name-1);
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->userdataTbl, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);

    UserObjReg *rdata = (UserObjReg*)Jsi_HashValueGet(hPtr);
    if (!rdata)
        return NULL;
    Jsi_Hash *tPtr = rdata->hashPtr;
    if (tPtr==0)
        return NULL;

    hPtr = Jsi_HashEntryFind(tPtr, (void*)id);
    if (!hPtr)
        return NULL;
    return (Jsi_Obj*)Jsi_HashValueGet(hPtr);
}


Jsi_RC jsi_UserObjDump(Jsi_Interp *interp, const char *argStr, Jsi_Obj *nobj)
{
    char *key;
    int n = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Hash *tPtr;
    
    if (argStr == NULL) {
        for (hPtr = Jsi_HashSearchFirst(interp->userdataTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
            key = (char*)Jsi_HashKeyGet(hPtr);
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n++);
        }
        return JSI_OK;
    }
    hPtr = Jsi_HashEntryFind(interp->userdataTbl, argStr);
    if (hPtr == NULL) 
        return Jsi_LogError("no such user object: %s", argStr);
    UserObjReg *rdata = (UserObjReg*)Jsi_HashValueGet(hPtr);
    if (!rdata)
        return JSI_OK;
    tPtr = rdata->hashPtr;
    if (tPtr==0)
        return JSI_OK;
    for (hPtr = Jsi_HashSearchFirst(tPtr, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        Jsi_Obj *fobj;
        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))
            continue;
        assert(fobj->ot == JSI_OT_USEROBJ);
        /* TODO: incr refcount??? */
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueMakeObject(interp, NULL, fobj), n++);
    }

    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY

#if (defined(JSI__SOCKET) && JSI__SOCKET==1)
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifndef __WIN32
#include <time.h>
#include <sys/time.h>
#endif /* !__WIN32 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <assert.h>

#ifdef WIN32
#define _GET_TIME_OF_DAY_H
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stddef.h>

//#include "sock-w32.h"

#else /* WIN32 */
#include <syslog.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#endif /* WIN32 */

#include <signal.h>
#include <errno.h>

typedef enum {  PSS_DEAD, PSS_HTTP, PSS_CONNECTED, PSS_RECV, PSS_SENT, PSS_SENDERR } pss_state;

typedef enum {
    SOCK_CALLBACK_RECEIVE,
    SOCK_CALLBACK_WRITEABLE,
    SOCK_CALLBACK_CLOSED,
    SOCK_CALLBACK_OPEN,
} callback_reasons;

typedef struct { /* Interp wide data. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Hash *wsTable;
    int wIdx;
} SocketObjInterpData;

//#define JSI__IPV6
typedef union {
    struct sockaddr_in sin;
#ifdef JSI__IPV6
    struct sockaddr_in6 sin6;
#endif
} SockAddrAll;

struct SocketObj;

typedef struct SocketPss { /* Per session connection to server */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    struct SocketObj *cmdPtr;
    pss_state state;
    int sentCnt, recvCnt, sentErrCnt;
    time_t sentLast, recvLast, sentErrLast;
    Jsi_HashEntry *hPtr;
    Jsi_Stack *stack;
    int id;
    int fd;
    int offset;
    SockAddrAll sa;
    SockAddrAll recvAddr;
    uint siLen;
} SocketPss;

typedef struct SockSendOpts {
    int id;
    bool noAsync;
} SockSendOpts;

typedef struct SocketObj { /* Per server (or client) data. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    SocketObjInterpData *interpData;
    Jsi_Interp *interp;
    Jsi_Hash *pssTable;
    Jsi_Value *onRecv;
    Jsi_Value *onCloseLast;
    Jsi_Value *onClose;
    Jsi_Value *onOpen;
    Jsi_Value *defaultUrl;
    Jsi_Value *interface;
    Jsi_Value *address;
    char client_name[128];
    char client_ip[128];
    int idx;
    int port;
    int srcPort;
    Jsi_Value *srcAddress;
    Jsi_Value *mcastAddMember;
    Jsi_Value *mcastInterface;
    int family;
    int saLen;
    char *iface;
    unsigned int oldus;
    bool udp;
    bool server;
    bool noUpdate;
    bool noAsync;
    bool reuse;
    bool broadcast;
    bool keepalive;
    bool mcastNoLoop;
    int hasOpts;
    int debug;
    int maxConnects;
    int deleted;
    int close_test;
    int connectCnt;
    int createCnt;
    int redirCnt;
    int ttl;
    int mcastTtl;
    uint64_t recvTimeout;
    uint64_t sendTimeout;
    int8_t tos;
    time_t createLast;
    time_t startTime;
    struct timeval tv;
    char *cmdName;

    Jsi_Event *event;
    Jsi_Obj *fobj;
    int objId;
    int rx_buffer_size;
    char *ssl_cert_filepath;
    char *ssl_private_key_filepath;
    int ws_uid;
    int ws_gid;
    char *cl_host;
    char *cl_origin;
    int maxfd;
    fd_set exceptSet, readSet, writeSet;
    int sendFlags;
    int recvFlags;
    SocketPss pss; // Server/non-async client pss.
} SocketObj;

static Jsi_RC sock_handler(SocketObj *cmdPtr, callback_reasons reason, SocketPss *pss, char *inPtr, size_t len);
static Jsi_RC sockService(SocketObj *cmdPtr);
static Jsi_RC socketObjFree(Jsi_Interp *interp, void *data);
static bool socketObjIsTrue(void *data);
static bool socketObjEqual(void *data1, void *data2);
static Jsi_RC ValueToSockAddrOpt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags);
static Jsi_RC SockAddrOptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags);

static Jsi_OptionCustom socketAddOption = {
    .name="sockAddr", .parseProc=ValueToSockAddrOpt, .formatProc=SockAddrOptToValue
};

static Jsi_OptionSpec SPSOptions[] =
{
    JSI_OPT(INT,        SocketPss, recvCnt,      .help="Number of recieves"),
    JSI_OPT(TIME_T,     SocketPss, recvLast,     .help="Time of last recv"),
    JSI_OPT(INT,        SocketPss, sentCnt,      .help="Number of sends"),
    JSI_OPT(TIME_T,     SocketPss, sentLast,     .help="Time of last send"),
    JSI_OPT(INT,        SocketPss, sentErrCnt,   .help="Number of sends"),
    JSI_OPT(TIME_T,     SocketPss, sentErrLast,  .help="Time of last sendErr"),
    JSI_OPT(CUSTOM,     SocketPss, recvAddr,     .help="Incoming port and address", .flags=0, .custom=&socketAddOption),
    JSI_OPT_END(SocketPss)
};

static Jsi_OptionSpec SockSendOptions[] =
{
    JSI_OPT(INT,    SockSendOpts, id,       .help="Id to send to, or -1 for all"),
    JSI_OPT(BOOL,   SockSendOpts, noAsync,  .help="Send is not async"),
    JSI_OPT_END(SockSendOpts)
};

static Jsi_OptionSpec SockOptions[] =
{
    JSI_OPT(VALUE,  SocketObj, address,    .help="Client destination address (127.0.0.0)", jsi_IIOF ),
    JSI_OPT(BOOL,   SocketObj, broadcast,  .help="Enable broadcast", jsi_IIOF),
    JSI_OPT(INT,    SocketObj, connectCnt, .help="Counter for number of active connections", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    SocketObj, debug,      .help="Debugging level"),
    JSI_OPT(VALUE,  SocketObj, interface,  .help="Interface for server to listen on, eg. 'eth0' or 'lo'", jsi_IIOF),
    JSI_OPT(BOOL,   SocketObj, keepalive,  .help="Enable keepalive", jsi_IIOF),
    JSI_OPT(INT,    SocketObj, maxConnects,.help="In server mode, max number of client connections accepted"),
    JSI_OPT(VALUE,  SocketObj, mcastAddMember, .help="Multicast add membership: address/interface ('127.0.0.1/0.0.0.0')", jsi_IIOF ),
    JSI_OPT(VALUE,  SocketObj, mcastInterface, .help="Multicast interface address", jsi_IIOF ),
    JSI_OPT(BOOL,   SocketObj, mcastNoLoop,  .help="Multicast loopback disable", jsi_IIOF ),
    JSI_OPT(INT,    SocketObj, mcastTtl,   .help="Multicast TTL", jsi_IIOF ),
    JSI_OPT(BOOL,   SocketObj, noAsync,    .help="Send is not async", jsi_IIOF),
    JSI_OPT(BOOL,   SocketObj, noUpdate,   .help="Stop processing update events (eg. to exit)"),
    JSI_OPT(FUNC,   SocketObj, onClose,    .help="Function to call when connection closes", .flags=0, .custom=0, .data=(void*)"id:number"),
    JSI_OPT(FUNC,   SocketObj, onCloseLast,.help="Function to call when last connection closes", .flags=0, .custom=0, .data=(void*)""),
    JSI_OPT(FUNC,   SocketObj, onOpen,     .help="Function to call when connection opens", .flags=0, .custom=0, .data=(void*)"info:object"),
    JSI_OPT(FUNC,   SocketObj, onRecv,     .help="Function to call with recieved data", .flags=0, .custom=0, .data=(void*)"id:number, data:string"),
    JSI_OPT(INT,    SocketObj, port,       .help="Port for client dest or server listen (9000)", jsi_IIOF ),
    JSI_OPT(UINT64, SocketObj, recvTimeout,.help="Timeout for receive, in microseconds", jsi_IIOF),
    JSI_OPT(UINT64, SocketObj, sendTimeout,.help="Timeout for send, in microseconds", jsi_IIOF),
    JSI_OPT(BOOL,   SocketObj, server,     .help="Enable server mode", jsi_IIOF),
    JSI_OPT(VALUE,  SocketObj, srcAddress, .help="Client source address", jsi_IIOF ),
    JSI_OPT(INT,    SocketObj, srcPort,    .help="Client source port", jsi_IIOF ),
    JSI_OPT(TIME_T, SocketObj, startTime,  .help="Time of start", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT8,   SocketObj, tos,        .help="Type of service value", jsi_IIOF ),
    JSI_OPT(INT,    SocketObj, ttl,        .help="Time to live value", jsi_IIOF ),
    JSI_OPT(TIME_T, SocketObj, createLast, .help="Time of last create", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(BOOL,   SocketObj, udp,        .help="Protocol is udp", jsi_IIOF),
    JSI_OPT_END(SocketObj)
};

/* Scanning function */
static Jsi_RC ValueToSockAddrOpt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    Jsi_LogBug("UNIMPLEMENTED"); //TODO: finish
#if 0
    int n, *s = (SockAddrAll*)(((char*)record) + spec->offset)
    //int flags = (spec->flags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (!si) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);
    if (inStr) {
        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "enum", flags, &n))
            return JSI_ERROR;
        *s = n;
        return JSI_OK;
    }
    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, "enum", flags, &n))
        return JSI_ERROR;
    *s = n;
#endif
    return JSI_OK;

}

/* Printing function. */
static Jsi_RC SockAddrOptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    SockAddrAll* sin = (SockAddrAll*)(((char*)record) + spec->offset);
    Jsi_RC rc = JSI_OK;
   /* const char **list = spec->data;
    if (!list) 
        return Jsi_LogError("custom enum spec did not set data: %s", spec->name);*/
    if (outStr) {
        /*n = *s;
        Jsi_DSAppendLen(outStr, list[i], -1);*/
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_DString dStr = {};
    Jsi_DSPrintf(&dStr, "{port: %d, address:\"%s\"}",
        ntohs(sin->sin.sin_port), inet_ntoa(sin->sin.sin_addr));
    rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), outValue, 0);
    Jsi_DSFree(&dStr);
    return rc;
#endif
    return JSI_ERROR;

}


static int sockAddrSize(SockAddrAll* sa) {
#ifdef JSI__IPV6
    if (sa->sin.sin_family == AF_INET6)
        return sizeof(sa->sin6);
#endif
    return sizeof(sa->sin);
}

static SocketPss*
sockGetPss(SocketObj *cmdPtr, int fd, int create)
{
    if (fd == cmdPtr->pss.fd)
        return &cmdPtr->pss;
    Jsi_HashEntry *hPtr;
    SocketPss* pss;
    bool isNew;
    if (create)
        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, (void*)(long)fd, &isNew);
    else
        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)(long)fd);
    if (!hPtr)
        return NULL;
    if (create == 0 || isNew == 0) {
        pss = (SocketPss*)Jsi_HashValueGet(hPtr);
        SIGASSERT(pss, SOCKETPSS);
        return pss;
    }
    pss = (SocketPss*)Jsi_Calloc(1, sizeof(*pss));
    SIGINIT(pss, SOCKETPSS);
    pss->hPtr = hPtr;
    cmdPtr->connectCnt++;
    cmdPtr->createCnt++;
    cmdPtr->createLast = time(NULL);
    Jsi_HashValueSet(hPtr, pss);
    pss->cmdPtr = cmdPtr;
    pss->fd = fd;
    pss->state = PSS_CONNECTED;
    pss->id = ++cmdPtr->idx;
    pss->stack = Jsi_StackNew();
    return pss;
}


static SocketPss *sockFindPss(SocketObj *cmdPtr, int id) {
    if (id == 0) 
        return &cmdPtr->pss;
    SocketPss *tpss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        tpss = (SocketPss*)Jsi_HashValueGet(hPtr);
        SIGASSERT(tpss, SOCKETPSS);
        if (tpss->id == id)
            return tpss;
    }
    return NULL;
}

static Jsi_RC sockFreeStackPss(Jsi_Interp *interp, void *data) {
    if (!data) return JSI_OK;
    Jsi_Value *v = (Jsi_Value*)data;
    SIGASSERT(v, VALUE);
    Jsi_DecrRefCount(interp, v);
    return JSI_OK;
}

static void
sockDeletePss(SocketPss *pss)
{
    if (pss == &pss->cmdPtr->pss)
        return;
    if (pss->hPtr) {
        Jsi_HashValueSet(pss->hPtr, NULL);
        Jsi_HashEntryDelete(pss->hPtr);
        pss->hPtr = NULL;
    }
    Jsi_StackFreeElements(pss->cmdPtr->interp, pss->stack, sockFreeStackPss);
    Jsi_StackFree(pss->stack);
    pss->cmdPtr->connectCnt--;
    pss->state = PSS_DEAD;
    Jsi_Free(pss);
}

static Jsi_RC SocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
  
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-sock object");
    return Jsi_OptionsConf(interp, SockOptions, cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);

}

static Jsi_RC sockGetPssId(SocketObj* cmdPtr, Jsi_Value* darg, int *idPtr) {
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Number dnum = 0;
    int id;
    if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK) 
        return Jsi_LogError("invalid id");
    id = (int)dnum;
    if (id < 0 && !cmdPtr->server)
        id = 0;
    if (id > 0 && !cmdPtr->server) 
        return Jsi_LogError("invalid id");
    *idPtr = id;
    return JSI_OK;
}

#define FN_socksend JSI_INFO("\
Send a message to a (or all if -1) connection.")

static Jsi_RC SocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_RC rc = JSI_OK;
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-sock object");
    SIGASSERT(cmdPtr, SOCKET);
    SocketPss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    int aLen = 0;
    char *str = Jsi_ValueString(interp, arg, &aLen);
    SockSendOpts opts = {};
    if (str == NULL || !Jsi_ValueIsString(interp, arg)) 
        return Jsi_LogError("expected string");
    
    if (str == NULL || aLen <= 0) return JSI_OK;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_DString eStr = {};
    if (argc>1) {
        Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 1);
        if (Jsi_ValueIsNumber(interp, arg1)) {
            if (sockGetPssId(cmdPtr, arg1, &opts.id) != JSI_OK)
                return JSI_ERROR;
        } else if (!Jsi_ValueIsObjType(interp, arg1, JSI_OT_OBJECT)) 
            return Jsi_LogError("expected int id or options object");
        else if (Jsi_OptionsProcess(interp, SockSendOptions, &opts, arg1, 0) < 0) {
            return JSI_ERROR;
        }
    }
   /* if (cmdPtr->udp) {
        Jsi_IncrRefCount(interp, arg);
        str = Jsi_ValueString(interp, arg, &aLen);
        int rc = sendto(cmdPtr->pss.fd, str, aLen, 0, &cmdPtr->pss.sa.sa, 0);
    }*/
    if (opts.id == 0) {
        if (!cmdPtr->pss.stack)
            cmdPtr->pss.stack = Jsi_StackNew();
        pss = &cmdPtr->pss;
        goto process;
    }
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        pss = (SocketPss *)Jsi_HashValueGet(hPtr);
        SIGASSERT(pss, SOCKETPSS);
        if ((opts.id==-1 || pss->id == opts.id) && pss->state != PSS_DEAD) {
process:
            if (cmdPtr->noAsync || opts.noAsync) {
                rc = sock_handler(cmdPtr, SOCK_CALLBACK_WRITEABLE, pss, NULL, 0);
                int n, siLen = sockAddrSize(&pss->sa);
                if (cmdPtr->udp)
                    n = sendto(pss->fd, str, aLen, cmdPtr->sendFlags, (struct sockaddr*)&cmdPtr->pss.sa.sin, siLen);
                else
                    n = send(pss->fd, str, aLen, cmdPtr->sendFlags);
                if (n != aLen)
                    rc = Jsi_LogError("wrote only %d of %d bytes", n, aLen);
            } else {
                Jsi_StackPush(pss->stack, arg);
                Jsi_IncrRefCount(interp, arg);
                if (pss->fd>=0)
                    FD_SET (pss->fd, &cmdPtr->writeSet);
            }
            if (opts.id != -1 ||  rc != JSI_OK)
                break;
        }
    }
    Jsi_DSFree(&eStr);
    return rc;
}

static Jsi_RC SocketRecvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-sock object");
    SIGASSERT(cmdPtr, SOCKET);

    SocketPss *pss = &cmdPtr->pss;
    int id = 0, argc = Jsi_ValueGetLength(interp, args);
    if (argc>1) {
        if (sockGetPssId(cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), &id) != JSI_OK)
            return JSI_ERROR;
    }
    char buf[BUFSIZ];
    int n;
    pss->siLen = sockAddrSize(&pss->recvAddr);
    if (cmdPtr->udp)
        n = recvfrom(pss->fd, buf, sizeof(buf)-1, cmdPtr->sendFlags, (struct sockaddr*)&pss->recvAddr.sin, &pss->siLen);
    else
        n = recv(pss->fd, buf, sizeof(buf)-1, cmdPtr->recvFlags);
    if (n>0)
        buf[n] = 0;
    else 
        return Jsi_LogError("read failed");
    unsigned char *uptr = (unsigned char*)Jsi_Malloc(n+1);
    memcpy(uptr, buf, n+1);
    uptr[n] = 0;
    Jsi_ValueMakeBlob(interp, ret, (unsigned char*)buf, n);
    return JSI_OK;
}

static Jsi_RC SocketCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-sock object");
    SIGASSERT(cmdPtr, SOCKET);
    SocketPss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int id = 0, argc = Jsi_ValueGetLength(interp, args);
    if (argc>1) {
        if (sockGetPssId(cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), &id) != JSI_OK)
            return JSI_ERROR;
    }
    if (id == 0) {
        if (cmdPtr->pss.fd>=0) {
            close(cmdPtr->pss.fd);
            FD_CLR(cmdPtr->pss.fd, &cmdPtr->writeSet);
            FD_CLR(cmdPtr->pss.fd, &cmdPtr->readSet);
            cmdPtr->pss.fd = -1;
        }
    } else {
        for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
            pss = (SocketPss *)Jsi_HashValueGet(hPtr);
            SIGASSERT(pss, SOCKETPSS);
            if ((id==-1 || pss->id == id) && pss->state != PSS_DEAD) {
                if (pss->fd>=0) {
                    close(pss->fd);
                    FD_CLR(pss->fd, &cmdPtr->writeSet);
                    FD_CLR(pss->fd, &cmdPtr->readSet);
                    pss->fd = -1;
                }
            }
        }
    }
    return JSI_OK;
}

static Jsi_RC SocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply to non-socket object");
    if (!cmdPtr->noUpdate)
        sockService(cmdPtr);
    return JSI_OK;
}

static Jsi_RC sockUpdate(Jsi_Interp *interp, void *data)
{
    SocketObj *cmdPtr = (SocketObj *)data;
    SIGASSERT(cmdPtr,SOCKET);
    sockService(cmdPtr);
    return JSI_OK;
}

static void socketObjErase(SocketObj *cmdPtr)
{
    if (cmdPtr->pss.fd>=0)
        close(cmdPtr->pss.fd);
    cmdPtr->pss.fd = -1;
    if (cmdPtr->interp) {
        if (cmdPtr->event)
            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);
        cmdPtr->event = NULL;
        if (cmdPtr->hasOpts)
            Jsi_OptionsFree(cmdPtr->interp, SockOptions, cmdPtr, 0);
        cmdPtr->hasOpts = 0;
        if (cmdPtr->pssTable)
            Jsi_HashDelete(cmdPtr->pssTable);
        cmdPtr->pssTable = NULL;
    }
    if (cmdPtr->pss.stack) {
        Jsi_StackFreeElements(cmdPtr->interp, cmdPtr->pss.stack, sockFreeStackPss);
        Jsi_StackFree(cmdPtr->pss.stack);
    }

    cmdPtr->interp = NULL;
}

static Jsi_RC socketObjFree(Jsi_Interp *interp, void *data)
{
    SocketObj *cmdPtr = (SocketObj *)data;
    SIGASSERT(cmdPtr,SOCKET);
    socketObjErase(cmdPtr);
    Jsi_Free(cmdPtr);
    return JSI_OK;
}

static bool socketObjIsTrue(void *data)
{
    //SocketObj *cmdPtr = data;
    return 1;
   /* if (!fo->sockname) return 0;
    else return 1;*/
}

static bool socketObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}


static Jsi_RC sockFreePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    SocketPss *pss = (SocketPss *)ptr;
    if (pss) {
        pss->hPtr = NULL;
        sockDeletePss(pss);
    }
    return JSI_OK;
}

static Jsi_RC sockParseHostname(const char *hostname, SockAddrAll *sa, int *saLen, int port) {
#ifndef WITHOUT_GETADDRINFO
    struct addrinfo req = {}, *ai;
#ifdef JSI__IPV6
    if (Jsi_Strchr(hostname, ':')) {
        if (inet_pton (AF_INET6, hostname, &sa->sin6.sin6_addr) != 1) {
            return JSI_ERROR;
        }
        sa->sin6.sin6_family = AF_INET6;
        sa->sin.sin_port = htons(port);
        *saLen = sizeof(sa->sin6);
        return JSI_OK;
    }
#endif

    req.ai_family = sa->sin.sin_family;

    if (getaddrinfo(hostname, NULL, &req, &ai))
        return JSI_ERROR;
    memcpy(&sa->sin, ai->ai_addr, ai->ai_addrlen);
    sa->sin.sin_port = htons(port);
    *saLen = ai->ai_addrlen;
    freeaddrinfo(ai);
#else
    struct hostent *he;

    if (!(he = gethostbyname(hostname)))
        return JSI_ERROR;
    if (he->h_length == sizeof(sa->sin.sin_addr)) {
        *saLen = sizeof(sa->sin);
        sa->sin.sin_family= he->h_addrtype;
        memcpy(&sa->sin.sin_addr, he->h_addr, he->h_length);
    }
#endif
    return JSI_OK;
}

static Jsi_Value*
dump_socket_info(SocketObj *cmdPtr, SocketPss *pss)
{
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Value *ret = Jsi_ValueNew(interp);
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebugLabel(ret, "socket", "dump_socket");
#endif
    Jsi_JSONParseFmt(interp, &ret, "{address:\"%s\"}", inet_ntoa(pss->sa.sin.sin_addr));
    return ret;
}


static Jsi_RC sock_handler(SocketObj *cmdPtr, callback_reasons reason, SocketPss *pss, char *inPtr, size_t len)
{
    Jsi_Interp *interp = cmdPtr->interp;
    int n;
    Jsi_RC rc = JSI_OK;
   // char buf[BUFSIZ];//, *bufPtr = buf;
    //static char *statBuf = NULL;
    //static int statSize = 0;

    SIGASSERT(cmdPtr, SOCKET);
    SIGASSERT(pss, SOCKETPSS);
    switch (reason) {
        
    case SOCK_CALLBACK_OPEN:
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:CALLBACK_OPEN: %p\n", pss);
        if (cmdPtr->onOpen) {
            int killcon = 0;
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2], *ret = Jsi_ValueNew1(interp);
            
            vargs[0] = dump_socket_info(cmdPtr, pss);
            //Jsi_IncrRefCount(interp, vargs[0]);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 1));
            Jsi_DecrRefCount(interp, vargs[0]);
            Jsi_IncrRefCount(interp, vpargs);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {
                if (cmdPtr->debug)
                    fprintf(stderr, "SOCK:KILLING CONNECTION: %p\n", pss);
                killcon = 1;
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) 
                return Jsi_LogError("socket bad rcv eval");
            if (killcon)
                return JSI_ERROR;
        }
        break;

    case SOCK_CALLBACK_CLOSED:
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:CALLBACK_CLOSE: %p\n", pss);
        if (!pss) break;
        if (cmdPtr->onClose) {
            /* Pass 1 arg: id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[1];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onClose, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) 
                return Jsi_LogError("sock bad rcv eval");
        }        
        sockDeletePss(pss);
        if (cmdPtr->connectCnt<=0 && cmdPtr->onCloseLast) {
            Jsi_FunctionInvokeBool(interp, cmdPtr->onCloseLast, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
        }
        break;
    case SOCK_CALLBACK_WRITEABLE:
        n=0;
        while (1) {
            Jsi_Value *dv = (Jsi_Value*)Jsi_StackPeek(pss->stack);
            char *data;
            int sLen;
            if (dv == NULL || (data=Jsi_ValueString(interp, dv, &sLen)) == NULL)
                break;
            pss->state = PSS_SENT;
        
            int osiz = sLen-pss->offset;
            int siLen = sockAddrSize(&pss->sa);
            if (cmdPtr->udp)
                n = sendto(pss->fd, data + pss->offset, osiz, cmdPtr->sendFlags, (struct sockaddr*)&cmdPtr->pss.sa.sin, siLen);
            else
                n = send(pss->fd, data + pss->offset, osiz, cmdPtr->sendFlags);
            if (n<=0) {
                perror("failed");
                if (cmdPtr->debug)
                    fprintf(stderr, "error on write\n");
                return JSI_ERROR;
            }
            if (n >= osiz) {
                Jsi_StackPop(pss->stack);
                pss->offset = 0;
            } else {
                if (cmdPtr->debug)
                    fprintf(stderr, "more to write: %d\n", (osiz-n));
                pss->offset += n;
            }
            if (cmdPtr->debug)
                fprintf(stderr, "SOCK:CLIENT WRITE(%d): %d=>%d: %s\n", pss->id, sLen, n, data);
            Jsi_DecrRefCount(interp, dv);                                   
            if (n >= 0) {
                pss->sentCnt++;
                pss->sentLast = time(NULL);
            } else {
                if (cmdPtr->debug)
                    fprintf(stderr, "ERROR %d writing to socket\n", n);
                pss->state = PSS_SENDERR;
                pss->sentErrCnt++;
                pss->sentErrLast = time(NULL);
                return JSI_ERROR;
            }
        }
        break;
        
    case SOCK_CALLBACK_RECEIVE:
    {
        int src;
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:RECV: %p\n", pss);

        pss->recvCnt++;
        pss->recvLast = time(NULL);

        if (cmdPtr->onRecv) {
            /* Pass 2 args: id and data. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vargs[1]  = Jsi_ValueNewString(interp, Jsi_Strdup(inPtr), len);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 2, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            src = Jsi_FunctionInvoke(interp, cmdPtr->onRecv, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
            if (src == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0) {
                /* TODO: handle callback return data??? */
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (src != JSI_OK)
                rc = Jsi_LogError("sock2 bad rcv eval");
        }

        break;
 
    }
    default:
        break;
    }
    return rc;
}


static Jsi_RC sockService(SocketObj *cmdPtr)
{
    //Jsi_Interp *interp = cmdPtr->interp;
    char buf[BUFSIZ];
    struct sockaddr_in sin;
    fd_set writeSet, readSet;
    int i, n, cnt = 0;
    readSet = cmdPtr->readSet;
    writeSet = cmdPtr->writeSet;
    int maxfd = cmdPtr->maxfd+1;
    maxfd = FD_SETSIZE;
    if (cmdPtr->debug)
        fprintf(stderr, "selecting\n");
    struct timeval tv;
    tv = cmdPtr->tv;
    if ((n=select(maxfd, &readSet, &writeSet, NULL, &tv)) < 0 && errno!=EINTR) {
        perror("Select");
        return JSI_ERROR;
    }
    if (cmdPtr->debug)
        fprintf(stderr, "select done: %d\n", n);

    for (i = 0; i < maxfd && cnt < n; ++i) {
        if (FD_ISSET (i, &readSet)) {
            cnt++;
            if (cmdPtr->server && i == cmdPtr->pss.fd && cmdPtr->udp==0) {
                uint c = sizeof(sin);
                int csock = accept(cmdPtr->pss.fd, (struct sockaddr*)&sin, &c);
                if (csock < 0) {
                    perror("accept");
                    return JSI_ERROR;
                }
                SocketPss* pss = sockGetPss(cmdPtr, csock, 1);
                pss->sa.sin = sin;
                if (sock_handler(cmdPtr, SOCK_CALLBACK_OPEN, pss, NULL, 0) != JSI_OK) {
                    close(csock);
                    sockDeletePss(pss);
                    continue;
                }
                if (cmdPtr->debug)
                    fprintf (stderr, "Server: connect %d from host %s, port %d.\n",
                        csock, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
                FD_SET(csock, &cmdPtr->readSet);
            } else {
                SocketPss* pss = sockGetPss(cmdPtr, i, 0);
                if (!pss) {
                    if (cmdPtr->debug)
                        fprintf(stderr, "no pss for %d\n", i);
                    continue;
                }
                uint siLen = sockAddrSize(&pss->recvAddr);
                if (cmdPtr->udp)
                    n = recvfrom(pss->fd, buf, sizeof(buf)-1, cmdPtr->sendFlags, (struct sockaddr*)&pss->recvAddr.sin, &siLen);
                else
                    n = recv(i, buf, sizeof(buf)-1, cmdPtr->recvFlags);
                if (n<=0) {
                    if (cmdPtr->debug)
                        fprintf(stderr, "read failed %d\n", i);
                    close(i);
                    FD_CLR(i, &cmdPtr->readSet);
                    FD_CLR(i, &cmdPtr->writeSet);
                    sock_handler(cmdPtr, SOCK_CALLBACK_CLOSED, pss, NULL, 0);
                }
                buf[sizeof(buf)-1] = 0;
                if (cmdPtr->debug)
                    fprintf(stderr, "Read data(%d): %s\n", n, buf);
                if (n>0 && sock_handler(cmdPtr, SOCK_CALLBACK_RECEIVE, pss, buf, n) != JSI_OK) {
                    sockDeletePss(pss);
                    continue;
                }
            }
        }
        if (FD_ISSET(i, &writeSet)) {
            cnt++;
            SocketPss* pss = sockGetPss(cmdPtr, i, 0);
            if (!pss) {
                if (cmdPtr->debug)
                    fprintf(stderr, "no pss for %d\n", i);
                continue;
            }
            if (sock_handler(cmdPtr, SOCK_CALLBACK_WRITEABLE, pss, NULL, 0) != JSI_OK) {
                close(pss->fd);
                FD_CLR(pss->fd, &cmdPtr->writeSet);
                FD_CLR(pss->fd, &cmdPtr->readSet);
                pss->fd = -1;
                sockDeletePss(pss);
                if (cmdPtr->udp)
                    return JSI_ERROR;
                continue;
            }
            if (Jsi_StackSize(pss->stack)==0)
                FD_CLR(i, &cmdPtr->writeSet);
        }

    }
    return JSI_OK;
}

#define FN_Socket JSI_INFO("\
Create a socket server or client object.")
static Jsi_RC SocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);

static Jsi_RC SocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-socket object");
    SocketPss *pss = &cmdPtr->pss;
    int id = 0;
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc) {
        Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 0);
        Jsi_Number vid;
        if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0) 
            return Jsi_LogError("Expected number id");
        id = (int)vid;
        pss = sockFindPss(cmdPtr, id);
    }
    if (!pss) 
        return Jsi_LogError("No such id: %d", id);
    return Jsi_OptionsConf(interp, SPSOptions, pss, Jsi_ValueArrayIndex(interp, args, 1), ret, 0);
}

static Jsi_RC SocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-socket object");
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppend(&dStr, "{", NULL);
    SocketPss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int cnt = 0;
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        pss = (SocketPss *)Jsi_HashValueGet(hPtr);
        SIGASSERT(pss, SOCKETPSS);
        if (pss->state != PSS_DEAD) {
            Jsi_DSPrintf(&dStr, "%s%d", cnt++?",":"", pss->id);
        }
    }
    Jsi_DSAppend(&dStr, "}", NULL);
    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}


static Jsi_CmdSpec sockCmds[] = {
    { "Socket",     SocketConstructor, 0,  1, "options:object=void", .help="Create socket server/client object",
            .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_Socket, .opts=SockOptions },
    { "close",      SocketCloseCmd,    0,  1, "", .help="Close socket(s)", .retType=(uint)JSI_TT_VOID },
    { "conf",       SocketConfCmd,     0,  1, "options:string|object=void",.help="Configure options", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SockOptions },
    { "names",      SocketIdsCmd,      0,  0, "", .help="Return list of active ids on server", .retType=(uint)JSI_TT_ARRAY },
    { "idconf",     SocketIdConfCmd,   0,  2, "id:number=void, options:string|object=void",.help="Configure options for a connection id, or return list of ids", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SPSOptions },
    { "recv",       SocketRecvCmd,     0,  1, "id:number=void", .help="Recieve data", .retType=(uint)JSI_TT_STRING },
    { "send",       SocketSendCmd,     1,  2, "data:string, options:number|object=void", .help="Send a socket message to id", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_socksend, .opts=SockSendOptions },
    { "update",     SocketUpdateCmd,   0,  0, "", .help="Service events for just this socket", .retType=(uint)JSI_TT_VOID },
    { NULL, 0,0,0,0, .help="Commands for managing Socket server/client connections"  }
};


static Jsi_UserObjReg sockobject = {
    "Socket",
    sockCmds,
    socketObjFree,
    socketObjIsTrue,
    socketObjEqual
};

    
static Jsi_RC SocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    cmdPtr = (SocketObj *)Jsi_Calloc(1, sizeof(*cmdPtr));
    SIGINIT(cmdPtr, SOCKET);
    SIGINIT(&cmdPtr->pss, SOCKETPSS);
    cmdPtr->pss.cmdPtr = cmdPtr;
    cmdPtr->port = 9090;
    cmdPtr->pss.fd = -1;
    cmdPtr->interp = interp;
    cmdPtr->rx_buffer_size = 50000;
    cmdPtr->ws_gid = -1;
    cmdPtr->ws_uid = -1;
    cmdPtr->startTime = time(NULL);
    cmdPtr->tv.tv_sec = 1;
    cmdPtr->tv.tv_usec = 10000;
    cmdPtr->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (cmdPtr->hasOpts && Jsi_OptionsProcess(interp, SockOptions, cmdPtr, arg, 0) < 0) {
        cmdPtr->deleted = 1;
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
#if 0
    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);
#endif

    cmdPtr->family = AF_INET;
    SockAddrAll *sap = &cmdPtr->pss.sa;
    memset(sap, 0, sizeof(*sap));
    const char *address = (cmdPtr->address ? Jsi_ValueString(interp, cmdPtr->address, NULL) : "127.0.0.1");
    sap->sin.sin_family = cmdPtr->family;
    sap->sin.sin_addr.s_addr = INADDR_ANY;
    sap->sin.sin_port = htons(cmdPtr->port); 

    if (sockParseHostname(address, sap, &cmdPtr->saLen, cmdPtr->port) != JSI_OK) {
        Jsi_LogError("hostname parse");
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
    sap->sin.sin_port = htons(cmdPtr->port); 
    FD_ZERO(&cmdPtr->readSet);
    FD_ZERO(&cmdPtr->writeSet);
    FD_ZERO(&cmdPtr->exceptSet);
    int fd;
    if ((fd = socket(cmdPtr->family, cmdPtr->udp ? SOCK_DGRAM : SOCK_STREAM, 0)) < 0) {
        Jsi_LogError("sock create failed");
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
    
    int on = 1;
    if (cmdPtr->reuse && setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on) )) {
        Jsi_LogError("sock reuse failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }
    if (cmdPtr->broadcast && setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on) )) {
        Jsi_LogError("sock broadcast failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }
    if (cmdPtr->keepalive && setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on) )) {
        Jsi_LogError("sock keepalive failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }
    if (cmdPtr->ttl && setsockopt(fd, IPPROTO_IP, IP_TTL, &cmdPtr->ttl, sizeof(cmdPtr->ttl)) < 0) {
        Jsi_LogError("sock ttl failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }

    if (cmdPtr->tos && setsockopt(fd, IPPROTO_IP, IP_TOS, &cmdPtr->tos, sizeof(cmdPtr->tos))) {
        Jsi_LogError("sock tos failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }

    if (cmdPtr->mcastTtl && setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, &cmdPtr->mcastTtl, sizeof(cmdPtr->mcastTtl)) < 0) {
        Jsi_LogError("sock mcast ttl failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }
    
    char loopch = 0;
    if (cmdPtr->mcastNoLoop && setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, &loopch, sizeof(loopch))) {
        Jsi_LogError("sock mcast loop failed");
        socketObjFree(interp, cmdPtr);
        close(fd);
        return JSI_ERROR;
    }

    if (cmdPtr->mcastInterface) {
        
        const char *saddress = (cmdPtr->mcastInterface ? Jsi_ValueString(interp, cmdPtr->mcastInterface, NULL) : NULL);
        SockAddrAll srcaddr = {};
        srcaddr.sin.sin_family = AF_INET;
        srcaddr.sin.sin_addr.s_addr = INADDR_ANY;
        srcaddr.sin.sin_port = 0;

        int srcLen;
        if (saddress && sockParseHostname(saddress, &srcaddr, &srcLen, cmdPtr->srcPort) != JSI_OK) {
            Jsi_LogError("source hostname parse");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }

        if (saddress && setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &srcaddr.sin.sin_addr.s_addr, sizeof(srcaddr.sin.sin_addr.s_addr)) < 0) {
            Jsi_LogError("sock mcast interface failed");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }
    }

    if (cmdPtr->recvTimeout) {
        struct timeval tv = {};
        tv.tv_sec = cmdPtr->recvTimeout/1000000LL;
        tv.tv_usec = cmdPtr->recvTimeout - tv.tv_sec*1000000LL;

        if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *) &tv,  sizeof(struct timeval))) {
            Jsi_LogError("sock reuse failed");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }
    }
    if (cmdPtr->sendTimeout) {
        struct timeval tv = {};
        tv.tv_sec = cmdPtr->sendTimeout/1000000LL;
        tv.tv_usec = cmdPtr->sendTimeout - tv.tv_sec*1000000LL;

        if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char *) &tv,  sizeof(struct timeval))) {
            Jsi_LogError("sock reuse failed");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }
    }
    
    if (cmdPtr->mcastAddMember) {
        const char *iaddress = NULL, *maddress = (cmdPtr->mcastAddMember ? Jsi_ValueString(interp, cmdPtr->mcastAddMember, NULL) : NULL);
        SockAddrAll maddr = {}, iaddr;
        maddr.sin.sin_family = cmdPtr->family;
        maddr.sin.sin_addr.s_addr = INADDR_ANY;
        maddr.sin.sin_port = 0; 
        iaddr = maddr;
        Jsi_DString aaStr = {};
        
        if (maddress && Jsi_Strchr(maddress, '/')) {
            char *icp;
            maddress = Jsi_DSAppend(&aaStr, maddress, NULL);
            icp = (char*)Jsi_Strchr(maddress, '/');
            iaddress = icp+1;
            *icp = 0;
        }
        int msaLen;
        if (maddress && sockParseHostname(maddress, &maddr, &msaLen, 0) != JSI_OK) {
            Jsi_LogError("mcast address parse");
            socketObjFree(interp, cmdPtr);
            close(fd);
            Jsi_DSFree(&aaStr);
            return JSI_ERROR;
        }

        struct ip_mreq receiveGroup = {};
        receiveGroup.imr_multiaddr.s_addr = maddr.sin.sin_addr.s_addr; 
        if (iaddress) {
            if (sockParseHostname(iaddress, &iaddr, &msaLen, 0) != JSI_OK) {
                Jsi_LogError("mcast interface parse");
                socketObjFree(interp, cmdPtr);
                close(fd);
                Jsi_DSFree(&aaStr);
                return JSI_ERROR;
            }
            receiveGroup.imr_interface.s_addr = iaddr.sin.sin_addr.s_addr;
        }
    
        //Set receive address
        if(setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *)&receiveGroup, sizeof(receiveGroup)) < 0)
        {
            Jsi_LogError("mcast address set failed");
            socketObjFree(interp, cmdPtr);
            close(fd);
            Jsi_DSFree(&aaStr);
            return JSI_ERROR;
        }
    }
    
    if (cmdPtr->srcAddress || cmdPtr->srcPort) {
        if (cmdPtr->server) {
            Jsi_LogError("only client mode accepts a source port/address");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }
        
        const char *saddress = (cmdPtr->srcAddress ? Jsi_ValueString(interp, cmdPtr->srcAddress, NULL) : "0.0.0.0");
        SockAddrAll srcaddr = {};
        srcaddr.sin.sin_family = AF_INET;
        srcaddr.sin.sin_addr.s_addr = INADDR_ANY;
        srcaddr.sin.sin_port = htons(cmdPtr->srcPort);

        int srcLen;
        if (sockParseHostname(saddress, &srcaddr, &srcLen, cmdPtr->srcPort) != JSI_OK) {
            Jsi_LogError("source hostname parse");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }

        if (bind(fd, (struct sockaddr *) &srcaddr.sin, sizeof(srcaddr)) < 0) {
            Jsi_LogError("sock bind failed");
            socketObjFree(interp, cmdPtr);
            close(fd);
            return JSI_ERROR;
        }
    }

    if (fd>cmdPtr->maxfd)
        cmdPtr->maxfd = fd;
    
    if (!cmdPtr->server) { // Client
        cmdPtr->pss.fd = fd;
        if (!cmdPtr->udp) {
            if (connect(fd , (struct sockaddr*)sap , sizeof(sap->sin)) < 0) {
                Jsi_LogError("sock connect failed");
                socketObjFree(interp, cmdPtr);
                return JSI_ERROR;
            }
            FD_SET(fd, &cmdPtr->readSet);
        }
    } else { // Server
        int lfd = cmdPtr->pss.fd = fd;
        if( bind(lfd, (struct sockaddr*)sap , sizeof(sap->sin)) < 0) {
            Jsi_LogError("sock bind failed");
            socketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
        if (cmdPtr->udp == 0 && listen(lfd , 3)) {
            Jsi_LogError("sock listen failed");
            socketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
        cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, sockFreePss);
        FD_SET(lfd, &cmdPtr->readSet);
    }

    cmdPtr->event = Jsi_EventNew(interp, sockUpdate, cmdPtr);
    Jsi_Value *toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Socket", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &sockobject, fobj, cmdPtr))<0) {
        socketObjFree(interp, cmdPtr);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    cmdPtr->fobj = fobj;
    return JSI_OK;
}

static Jsi_RC Jsi_DoneSocket(Jsi_Interp *interp)
{
    if (Jsi_UserObjUnregister(interp, &sockobject) != JSI_OK)
        return JSI_ERROR;
    Jsi_PkgProvide(interp, "Socket", -1, NULL);
    return JSI_OK;
}

Jsi_RC Jsi_InitSocket(Jsi_Interp *interp, int release)
{
    if (release) return Jsi_DoneSocket(interp);
    Jsi_Hash *wsys;
    if (!(wsys = Jsi_UserObjRegister(interp, &sockobject))) {
        Jsi_LogBug("Can not init socket");
        return JSI_ERROR;
    }
    if (Jsi_PkgProvide(interp, "Socket", 1, Jsi_InitSocket) != JSI_OK)
        return JSI_ERROR;

    if (!Jsi_CommandCreateSpecs(interp, sockobject.name, sockCmds, wsys, JSI_CMDSPEC_ISOBJ))
        return JSI_ERROR;
    return JSI_OK;
}

#endif
#endif //JSI_LITE_ONLY
#define JSI_SQLITE_DB_VFS "SQLITE_DB_VFS"

#ifndef JSI_AMALGAMATION
#ifdef JSI_MEM_DEBUG
#include "jsiInt.h"
#else
#include "jsi.h"
JSI_EXTENSION_INI
#endif
#endif

typedef struct jsi_DbVfs {
    int sig; 
    int (*dbcQuery)(Jsi_Db *jdb, Jsi_CDataDb *dbc, const char *query);
    void *(*dbHandle)(Jsi_Interp *interp, Jsi_Db* jdb);
    Jsi_Db* (*dbNew)(const char *zFile, int inFlags /* JSI_DBI_* */);
} jsi_DbVfs;

jsi_DbVfs SqliteDbVfs = {
    0x1234, &Jsi_DbQuery, &Jsi_DbHandle, Jsi_DbNew
};


#if JSI__SQLITE==1
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** A JSI (Javascript) Interface to SQLite.
*/
//#define SQLITE_OMIT_TRACE
//#define SQLITE_OMIT_AUTHORIZATION

typedef enum { SQLITE_SIG_DB = 0xbeefdead, SQLITE_SIG_FUNC, SQLITE_SIG_EXEC, SQLITE_SIG_STMT } Sqlite_Sig;

#define SQLSIGASSERT(s,n) assert(s->sig == SQLITE_SIG_##n)
#ifndef _JSI_MEMCLEAR
#ifndef NDEBUG
#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));
#else
#define _JSI_MEMCLEAR(s)
#endif
#endif
#ifndef JSI_DB_DSTRING_SIZE
#define JSI_DB_DSTRING_SIZE 2000
#endif

#ifndef JSI_DBQUERY_BEGIN_STR
#define JSI_DBQUERY_BEGIN_STR "BEGIN;"
#endif
#ifndef JSI_DBQUERY_ROLLBACK_STR
#define JSI_DBQUERY_ROLLBACK_STR "ROLLBACK;"
#endif
#ifndef JSI_DBQUERY_COMMIT_STR
#define JSI_DBQUERY_COMMIT_STR "COMMIT;"
#endif

#include <errno.h>

/*
** Some additional include files are needed if this file is not
** appended to the amalgamation.
*/
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <inttypes.h>

#ifndef SQLITE_AMALGAMATION
#include "sqlite3.h"
#endif


#ifndef NUM_PREPARED_STMTS
#define NUM_PREPARED_STMTS 100
#endif
#ifndef MAX_PREPARED_STMTS
#define MAX_PREPARED_STMTS 10000
#endif

#ifndef JSI_DBQUERY_PRINTF
#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#endif
/*
** When JSI uses UTF-8 and SQLite is configured to use iso8859, then we
** have to do a translation when going between the two.  Set the
** UTF_TRANSLATION_NEEDED macro to indicate that we need to do
** this translation.
*/
#if defined(JSI_UTF_MAX) && !defined(SQLITE_UTF8)
# define UTF_TRANSLATION_NEEDED 1
#endif

/*
** New SQL functions can be created as JSI scripts.  Each such function
** is described by an instance of the following structure.
*/
typedef struct SqlFunc SqlFunc;
struct SqlFunc {
    Sqlite_Sig sig;
    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */
    Jsi_Value   *tocall;    /* Callee */
    char        *pScript;   /* The char* representation of the script */
    Jsi_DString dScript;
    char        *zName;     /* Name of this function */
    SqlFunc     *pNext;     /* Next function on the list of them all */
};

/*
** New collation sequences function can be created as JSI scripts.  Each such
** function is described by an instance of the following structure.
*/
typedef struct SqlCollate SqlCollate;
struct SqlCollate {
    Sqlite_Sig sig;
    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */
    Jsi_Value   *zScript;  /* The function to be run */
    SqlCollate  *pNext;    /* Next function on the list of them all */
};

/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/
typedef struct SqlPreparedStmt SqlPreparedStmt;
struct SqlPreparedStmt {
    Sqlite_Sig sig;
    int deleting;
    SqlPreparedStmt *pNext;  /* Next in linked list */
    SqlPreparedStmt *pPrev;  /* Previous on the list */
    sqlite3_stmt    *pStmt;  /* The prepared statement */
    uint nSql;                /* chars in zSql[] */
    const char *zSql;        /* Text of the SQL statement */
    Jsi_HashEntry *entry;
    Jsi_ListEntry *elPtr;
    //int nParm;               /* Size of apParm array */
    //Jsi_Value **apParm;      /* Array of referenced object pointers */
};

static const char *execFmtStrs[] = {
    "rows", "arrays", "array1d", "list", "column", "json",
    "json2", "html", "csv", "insert", "line", "tabs", "none", NULL
};

typedef enum {
    _JSI_EF_ROWS, _JSI_EF_ARRAYS, _JSI_EF_ARRAY1D, _JSI_EF_LIST, _JSI_EF_COLUMN, _JSI_EF_JSON,
    _JSI_EF_JSON2, _JSI_EF_HTML, _JSI_EF_CSV, _JSI_EF_INSERT, _JSI_EF_LINE, _JSI_EF_TABS, _JSI_EF_NONE
} Output_Mode;

const char *dbTypeChkStrs[] = { "convert", "warn", "error", "disable", NULL };

typedef enum { dbTypeCheck_Cast, dbTypeCheck_Warn, dbTypeCheck_Error, dbTypeCheck_None } dbTypeCheck_Mode;

typedef struct QueryOpts {
    Sqlite_Sig sig;
    Jsi_Value *callback, *values;
    int limit;
    Output_Mode mode;
    dbTypeCheck_Mode typeCheck;
    bool mapundef, nocache, headers;
    const char *separator;
    const char *nullvalue;
    const char *table;
    const char *cdata; // Name of C data array to use for query.
    const char *varName;
    Jsi_Value *width;
} QueryOpts;

static const char *mtxStrs[] = { "default", "none", "full", NULL };
typedef enum { MUTEX_DEFAULT, MUTEX_NONE, MUTEX_FULL } Mutex_Type;

static const char *trcModeStrs[] = {"eval", "delete", "prepare", "step", NULL}; // Bit-set packed into an int.
enum {TMODE_EVAL=0x1, TMODE_DELETE=0x2, TMODE_PREPARE=0x4, TMODE_STEP=0x4};

/*
** There is one instance of this structure for each SQLite database
** that has been opened by the SQLite JSI interface.
*/
typedef struct Jsi_Db {
    Sqlite_Sig sig;
    sqlite3 *db;               /* The "real" database structure. MUST BE FIRST */
    Jsi_Interp *interp;        /* The interpreter used for this database */
    Jsi_Value *zBusy;               /* The busy callback routine */
    Jsi_Value *zCommit;             /* The commit hook callback routine */
    Jsi_Value *zTrace;              /* The trace callback routine */
    Jsi_Value *zProfile;            /* The profile callback routine */
    Jsi_Value *zProgress;           /* The progress callback routine */
    Jsi_Value *zAuth;               /* The authorization callback routine */
    int disableAuth;           /* Disable the authorizer if it exists */
    char *zNull;               /* Text to substitute for an SQL NULL value */
    SqlFunc *pFunc;            /* List of SQL functions */
    Jsi_Value *pUpdateHook;      /* Update hook script (if any) */
    Jsi_Value *pRollbackHook;    /* Rollback hook script (if any) */
    Jsi_Value *pWalHook;        /* Wal hook script (if any) */
    Jsi_Value *pUnlockNotify;    /* Unlock notify script (if any) */
    SqlCollate *pCollate;      /* List of SQL collation functions */
    int rc;                    /* Return code of most recent sqlite3_exec() */
    Jsi_Value *pCollateNeeded;   /* Collation needed script */
    Jsi_Hash *stmtHash;        /* Hash table for statements. */
    Jsi_List *stmtCache;
    int maxStmts;               /* The next maximum number of stmtList */
    int numStmts;                 /* Number of statements in stmtList */
    /*IncrblobChannel *pIncrblob; * Linked list of open incrblob channels */
    Jsi_Hash *strKeyTbl;       /* Used with JSI_LITE_ONLY */
    bool bindWarn;
    bool forceInt;
    bool readonly;
    bool nocreate;
    int numStep, numSort;          /* Statistics for most recent operation */
    int nTransaction;          /* Number of nested [transaction] methods */
    int errorCnt;               /* Count of errors. */
    Jsi_Value *key;             /* Key, for codec. */
    Jsi_Value *vfs;
    int hasOpts;
    Jsi_Obj *userObjPtr;
    QueryOpts queryOpts, *optPtr;
    int objId;
    Mutex_Type mutex;
    int debug;
    int version;
    //int trace;
    Jsi_DString name;
    Jsi_Hash *typeNameHash;
} Jsi_Db;

/*
** Structure used with dbEvalXXX() functions:
**
**   dbEvalInit(interp,)
**   dbEvalStep()
**   dbEvalFinalize()
**   dbEvalRowInfo()
**   dbEvalColumnValue()
*/
#define SQL_MAX_STATIC_TYPES 100
typedef struct DbEvalContext {
    Jsi_Db *jdb;                /* Database handle */
    Jsi_DString *dSql;               /* Object holding string zSql */
    const char *zSql;               /* Remaining SQL to execute */
    SqlPreparedStmt *pPreStmt;      /* Current statement */
    int nCol;                       /* Number of columns returned by pStmt */
    char **apColName;             /* Array of column names */
    int *apColType;
    char staticColNames[BUFSIZ];  /* Attempt to avoid mallocing space for name storage. */
    int staticColTypes[SQL_MAX_STATIC_TYPES];
    Jsi_Value *tocall;
    Jsi_Value *ret;
    /*OBS */
    Jsi_Value *pArray;              /* Name of array variable */
    Jsi_Value *pValVar;             /* Name of list for values. */
    int nocache;
} DbEvalContext;

#ifndef JSI_LITE_ONLY

static Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record);


static Jsi_OptionSpec ExecFmtOptions[] =
{
    JSI_OPT(FUNC,   QueryOpts, callback, .help="Function to call with each row result", .flags=0, .custom=0, .data=(void*)"values:object" ),
    JSI_OPT(STRKEY, QueryOpts, cdata, .help="Name of Cdata array object to use"),
    JSI_OPT(BOOL,   QueryOpts, headers, .help="First row returned contains column labels"),
    JSI_OPT(INT,    QueryOpts, limit, .help="Maximum number of returned values"),
    JSI_OPT(BOOL,   QueryOpts, mapundef, .help="In variable bind, map an 'undefined' var to null"),
    JSI_OPT(CUSTOM, QueryOpts, mode, .help="Set output mode of returned data", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=(void*)execFmtStrs),
    JSI_OPT(BOOL,   QueryOpts, nocache, .help="Query is not to be cached"),
    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help="Null string output (for non js/json mode)"),
    JSI_OPT(STRKEY, QueryOpts, separator, .help="Separator string (for csv and text mode)"),
    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help="Type check mode (warn)", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=(void*)dbTypeChkStrs),
    JSI_OPT(STRKEY, QueryOpts, table, .help="Table name for mode=insert"),
    JSI_OPT(ARRAY,  QueryOpts, values, .help="Values for ? bind parameters" ),
    JSI_OPT(STRKEY, QueryOpts, varName,  .help="Array var for ? bind parameters" ),
    JSI_OPT(CUSTOM, QueryOpts, width, .help="In column mode, set column widths", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)dbIsNumArray),
    JSI_OPT_END(QueryOpts, .help="Options for sqlite exec")
};

#define IIOF .flags=JSI_OPT_INIT_ONLY
static Jsi_OptionSpec SqlOptions[] =
{
    JSI_OPT(BOOL,   Jsi_Db, bindWarn, .help="Treat failed variable binds as a warning", IIOF),
    JSI_OPT(CUSTOM, Jsi_Db, debug, .help="Enable debug trace for various operations", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),
#ifdef SQLITE_HAS_CODEC
    JSI_OPT(VALUE,  Jsi_Db, key), .help="codec key", IIOF),
#endif
    JSI_OPT(INT,    Jsi_Db, errorCnt, .help="Count of errors", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(CUSTOM, Jsi_Db, queryOpts, .help="Default options for exec", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=ExecFmtOptions),
    JSI_OPT(BOOL,   Jsi_Db, forceInt, .help="Bind float as int if possible"),
    JSI_OPT(INT,    Jsi_Db, maxStmts, .help="Max cache size for compiled statements"),
    JSI_OPT(CUSTOM, Jsi_Db, mutex,    .help="Mutex type to use", IIOF, .custom=Jsi_Opt_SwitchEnum, .data=mtxStrs),
    JSI_OPT(DSTRING,Jsi_Db, name,     .help="Name for this db handle"),
    JSI_OPT(BOOL,   Jsi_Db, nocreate, .help="Database is must already exist (false)", IIOF),
    JSI_OPT(INT,    Jsi_Db, numSort,  .help="Number of sorts in most recent operation", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    Jsi_Db, numStep,  .help="Number of steps in most recent operation", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    Jsi_Db, numStmts, .help="Current size of compiled statement cache", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(BOOL,   Jsi_Db, readonly, .help="Database is readonly", IIOF),
    JSI_OPT(INT,    Jsi_Db, version,  .help="Version number compiled against", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(VALUE,  Jsi_Db, vfs,      .help="VFS to use", IIOF),
    JSI_OPT_END(Jsi_Db, .help="Options for source command")
};


#endif

void dbTypeNameHashInit(Jsi_Db *jdb) {
    Jsi_Interp *interp = jdb->interp;
    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    Jsi_HashSet(hPtr, (void*)"blob", (void*)JSI_OPTION_STRBUF);
    Jsi_HashSet(hPtr, (void*)"string", (void*)JSI_OPTION_STRING);
    Jsi_HashSet(hPtr, (void*)"double", (void*)JSI_OPTION_DOUBLE);
    Jsi_HashSet(hPtr, (void*)"integer", (void*)JSI_OPTION_INT64);
    Jsi_HashSet(hPtr, (void*)"bool", (void*)JSI_OPTION_BOOL);
    Jsi_HashSet(hPtr, (void*)"time_d", (void*)JSI_OPTION_TIME_D);
    Jsi_HashSet(hPtr, (void*)"time_w", (void*)JSI_OPTION_TIME_W);
    Jsi_HashSet(hPtr, (void*)"time_t", (void*)JSI_OPTION_TIME_T);
    Jsi_HashSet(hPtr, (void*)"date", (void*)JSI_OPTION_TIME_W);
    Jsi_HashSet(hPtr, (void*)"time", (void*)JSI_OPTION_TIME_W);
    Jsi_HashSet(hPtr, (void*)"datetime", (void*)JSI_OPTION_TIME_W);
}

#define SQLITE_OMIT_INCRBLOB

// Return 1 if ok, else return 0 and set erc to -1 or -2 for timeout.
static int dbExecCmd(Jsi_Db *jdb, const char *zQuery, int *erc)
{
    int rc = sqlite3_exec(jdb->db, zQuery, 0, 0, 0);
    if (rc == SQLITE_BUSY) {
        if (erc) *erc = -2;
    } else if (rc != SQLITE_OK) {
        if (erc) *erc = -1;
    } else
        return 1;
    return 0;
}

static void dbEvalRowInfo(
    DbEvalContext *p,               /* Evaluation context */
    int *pnCol,                     /* OUT: Number of column names */
    char ***papColName,           /* OUT: Array of column names */
    int **papColType
) {
    /* Compute column names */
    // Jsi_Interp *interp = p->jdb->interp;

    if( 0==p->apColName ) {
        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;
        uint i;                        /* Iterator variable */
        uint nCol;                     /* Number of columns returned by pStmt */
        char **apColName = 0;      /* Array of column names */
        int *apColType = 0;
        const char *zColName;         /* Column name */
        int numRid = 0;               /* Number of times rowid seen. */

        p->nCol = nCol = sqlite3_column_count(pStmt);
        if( nCol>0 && (papColName || p->pArray) ) {
            uint cnLen = sizeof(char*)*nCol, cnStart = cnLen;
            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)
                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;
            if (cnLen>=sizeof(p->staticColNames)) {
                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );
                cnStart = 0;
            } else {
                apColName = (char**)p->staticColNames;
            }
            if (papColType) {
                if (nCol < SQL_MAX_STATIC_TYPES)
                    apColType = p->staticColTypes;
                else
                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));
            }
            for(i=0; i<nCol; i++) {
                zColName = sqlite3_column_name(pStmt,i);
                if (cnStart==0)
                    apColName[i] = Jsi_Strdup(zColName);
                else {
                    apColName[i] = p->staticColNames+cnStart;
                    Jsi_Strcpy(apColName[i], zColName);
                    cnStart += Jsi_Strlen(zColName)+1;
                }
                if (apColType)
                    apColType[i] = sqlite3_column_type(pStmt,i);
                /* Check if rowid appears first, and more than once. */
                if ((i == 0 || numRid>0) &&
                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,"rowid") == 0)) {
                    numRid++;
                }
            }
            /* Change first rowid to oid. */
            if (numRid > 1) {
                if (apColName != (char**)p->staticColNames) {
                    Jsi_Free(apColName[0]);
                    apColName[0] = Jsi_Strdup("oid");
                } else {
                    Jsi_Strcpy(apColName[0], "oid");
                }
            }
            p->apColName = apColName;
            p->apColType = apColType;
        }
    }
    if( papColName ) {
        *papColName = p->apColName;
    }
    if( papColType ) {
        *papColType = p->apColType;
    }
    if( pnCol ) {
        *pnCol = p->nCol;
    }
}

#ifndef JSI_LITE_ONLY
static Jsi_RC dbPrepareAndBind( Jsi_Db *jdb, char const *zIn, char const **pzOut,  SqlPreparedStmt **ppPreStmt );
#endif
static void dbReleaseColumnNames(DbEvalContext *p);
static void dbReleaseStmt( Jsi_Db *jdb, SqlPreparedStmt *pPreStmt, int discard );


/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */
static Jsi_RC dbEvalStepSub(DbEvalContext *p, int release, int *erc) {
    int rcs;
    Jsi_Db *jdb = p->jdb;
    Jsi_Interp *interp = jdb->interp;
    JSI_NOTUSED(interp);
    SqlPreparedStmt *pPreStmt = p->pPreStmt;
    SQLSIGASSERT(pPreStmt, STMT);
    sqlite3_stmt *pStmt = pPreStmt->pStmt;

    if (jdb->debug & TMODE_STEP)
        JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", pPreStmt->zSql);
    rcs = sqlite3_step(pStmt);
    if( rcs==SQLITE_BUSY ) {
        if (erc) *erc = -2;
        return JSI_ERROR;
    }
    if( rcs==SQLITE_ROW ) {
        return JSI_OK;
    }
    if( p->pArray ) {
        dbEvalRowInfo(p, 0, 0, 0);
    }
    rcs = sqlite3_reset(pStmt);

    jdb->numStep = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_FULLSCAN_STEP,1);
    jdb->numSort = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_SORT,1);
    if (release==0 && rcs==SQLITE_OK)
        return JSI_BREAK;
    dbReleaseColumnNames(p);
    p->pPreStmt = 0;

    if( rcs!=SQLITE_OK ) {
        /* If a run-time error occurs, report the error and stop reading
        ** the SQL.  */
        Jsi_LogError("%s", sqlite3_errmsg(jdb->db));
        dbReleaseStmt(jdb, pPreStmt, 1);
        return JSI_ERROR;
    } else {
        dbReleaseStmt(jdb, pPreStmt, p->nocache);
    }
    return JSI_BREAK;
}

static Jsi_RC dbEvalInit(
    Jsi_Interp *interp,
    DbEvalContext *p,               /* Pointer to structure to initialize */
    Jsi_Db *jdb,                  /* Database handle */
    const char* zSql,                /* Value containing SQL script */
    Jsi_DString *dStr,
    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */
    Jsi_Obj *pValVar                  /* Name element in array for list. */
) {
    p->dSql = dStr;
    p->zSql = Jsi_DSAppend(p->dSql, zSql?zSql:"", NULL);
    p->jdb = jdb;
    return JSI_OK;
}

static void dbPrepStmtFree( Jsi_Db *jdb, SqlPreparedStmt *prep)
{
    if (prep->deleting)
        return;
    prep->deleting = 1;
    if (prep->pStmt)
        sqlite3_finalize( prep->pStmt );
    if (prep->entry) {
        Jsi_HashEntry *hPtr = prep->entry;
        prep->entry = NULL;
        Jsi_HashEntryDelete(hPtr);
    }
    if (prep->elPtr)
        Jsi_ListEntryDelete(prep->elPtr);
    Jsi_Free( (char*)prep );
    jdb->numStmts--;
}

/*
** Finalize and free a list of prepared statements
*/

static void dbPrepStmtLimit( Jsi_Db *jdb)
{
    while(jdb->numStmts>jdb->maxStmts ) {
        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);
        dbPrepStmtFree(jdb, (SqlPreparedStmt*)Jsi_ListValueGet(l));
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}


static Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {
    Jsi_Db *jdb = (Jsi_Db*)interp;
    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;
    SqlPreparedStmt *prep = (SqlPreparedStmt *)Jsi_ListValueGet(l);
    prep->elPtr = NULL;
    dbPrepStmtFree(jdb, prep);
    return JSI_OK;
}

#ifndef JSI_LITE_ONLY

/*
** Finalize and free a list of prepared statements
*/
static void dbFlushStmtCache( Jsi_Db *jdb ) {
    Jsi_ListClear(jdb->stmtCache);
    jdb->numStmts = 0;
}

#endif

/*
** Release a statement reference obtained by calling dbPrepareAndBind().
** There should be exactly one call to this function for each call to
** dbPrepareAndBind().
**
** If the discard parameter is non-zero, then the statement is deleted
** immediately. Otherwise it is added to the LRU list and may be returned
** by a subsequent call to dbPrepareAndBind().
*/
static void dbReleaseStmt(
    Jsi_Db *jdb,                  /* Database handle */
    SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */
    int discard                     /* True to delete (not cache) the pPreStmt */
) {
    //int i;
    //Jsi_Interp *interp = jdb->interp;

    /* Free the bound string and blob parameters */
    /*for(i=0; i<pPreStmt->nParm; i++) {
        Jsi_DecrRefCount(interp, pPreStmt->apParm[i]);
    }*/
    //pPreStmt->nParm = 0;

    if( jdb->maxStmts<=0 || discard ) {
        /* If the cache is turned off, deallocated the statement */
        dbPrepStmtFree(jdb, pPreStmt);
    } else {
        /* Add the prepared statement to the beginning of the cache list, then limit. */
        if (!pPreStmt->elPtr)
            pPreStmt->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, pPreStmt);
        else
            Jsi_ListPushFront(jdb->stmtCache, pPreStmt->elPtr);
        dbPrepStmtLimit(jdb);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}

/*
** Release any cache of column names currently held as part of
** the DbEvalContext structure passed as the first argument.
*/
static void dbReleaseColumnNames(DbEvalContext *p) {
    //Jsi_Interp *interp = p->jdb->interp;

    if( p->apColName && p->apColName != (char**)p->staticColNames) {
        int i;
        for(i=0; i<p->nCol; i++) {
            Jsi_Free(p->apColName[i]);
        }
        Jsi_Free((char *)p->apColName);
    }
    if( p->apColType && p->apColType != p->staticColTypes) {
        Jsi_Free((char *)p->apColType);
    }
    p->apColName = NULL;
    p->apColType = NULL;
    p->nCol = 0;
}

sqlite_uint64 dbLastInsertRowid(Jsi_Db* jdb)
{
    return sqlite3_last_insert_rowid(jdb->db);

}

/*
** Search the cache for a prepared-statement object that implements the
** first SQL statement in the buffer pointed to by parameter zIn. If
** no such prepared-statement can be found, allocate and prepare a new
** one. In either case, bind the current values of the relevant Jsi
** variables to any $var, :var or @var variables in the statement. Before
** returning, set *ppPreStmt to point to the prepared-statement object.
**
** Output parameter *pzOut is set to point to the next SQL statement in
** buffer zIn, or to the '\0' byte at the end of zIn if there is no
** next statement.
**
** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned
** and an error message loaded into interpreter jdb->interp.
*/
static Jsi_RC dbPrepareStmt(
    Jsi_Db *jdb,                  /* Database object */
    char const *zIn,                /* SQL to compile */
    char const **pzOut,             /* OUT: Pointer to next SQL statement */
    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */
) {
    const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */
    sqlite3_stmt *pStmt;            /* Prepared statement object */
    SqlPreparedStmt *pPreStmt = 0;  /* Pointer to cached statement */
   // int nSql;                       /* Length of zSql in bytes */
    //int nVar;                       /* Number of variables in statement */
    //int iParm = 0;                  /* Next free entry in apParm */
    Jsi_RC rc = JSI_OK;
    Jsi_Interp *interp = jdb->interp;
    JSI_NOTUSED(interp);

    *ppPreStmt = 0;

    /* Trim spaces from the start of zSql and calculate the remaining length. */
    while( isspace(zSql[0]) ) {
        zSql++;
    }
    //nSql = Jsi_Strlen(zSql);
    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);
    if (entry && ((pPreStmt = (SqlPreparedStmt*)Jsi_HashValueGet(entry)))) {
        
        if (jdb->debug & TMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare cache-hit: %s\n", zSql);
        pStmt = pPreStmt->pStmt;
        *pzOut = &zSql[pPreStmt->nSql];

        /* When a prepared statement is found, unlink it from the
        ** cache list.  It will later be added back to the beginning
        ** of the cache list in order to implement LRU replacement.
        */
        Jsi_ListPop(jdb->stmtCache, pPreStmt->elPtr);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);

    }

    /* If no prepared statement was found. Compile the SQL text. Also allocate
    ** a new SqlPreparedStmt structure.  */
    if( pPreStmt==0 ) {
        int nByte;

        if( SQLITE_OK!=sqlite3_prepare_v2(jdb->db, zSql, -1, &pStmt, pzOut) )
        
            return Jsi_LogError("PREPARE: %s", sqlite3_errmsg(jdb->db));
        if( pStmt==0 ) {
            if( SQLITE_OK!=sqlite3_errcode(jdb->db) ) {
                /* A compile-time error in the statement. */
                Jsi_LogError("PREP: %s", sqlite3_errmsg(jdb->db));
                return JSI_ERROR;
            } else {
                /* The statement was a no-op.  Continue to the next statement
                ** in the SQL string.
                */
                return JSI_OK;
            }
        }

        if (jdb->debug & TMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare new: %s\n", zSql);
        assert( pPreStmt==0 );
        //nVar = sqlite3_bind_parameter_count(pStmt);
        jdb->numStmts++;
        nByte = sizeof(SqlPreparedStmt); // + nVar*sizeof(Jsi_Obj *);
        pPreStmt = (SqlPreparedStmt*)Jsi_Calloc(1, nByte);
        pPreStmt->sig = SQLITE_SIG_STMT;

        pPreStmt->pStmt = pStmt;
        pPreStmt->nSql = (*pzOut - zSql);
        pPreStmt->zSql = sqlite3_sql(pStmt);
        bool isNew = 0;
        pPreStmt->entry = Jsi_HashEntryNew(jdb->stmtHash, zSql, &isNew);
        if (!isNew)
            JSI_DBQUERY_PRINTF( "sqlite dup stmt entry");
        Jsi_HashValueSet(pPreStmt->entry, pPreStmt);
            
        //pPreStmt->apParm = (Jsi_Value **)&pPreStmt[1];
    }
    assert( pPreStmt );
    assert( Jsi_Strlen(pPreStmt->zSql)==pPreStmt->nSql );
    assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );
    *ppPreStmt = pPreStmt;
    //pPreStmt->nParm = iParm; 
    return rc;
}


#ifndef JSI_LITE_ONLY

/*
** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is
** returned, then an error message is stored in the interpreter before
** returning.
**
** A return value of JSI_OK means there is a row of data available. The
** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
** is analogous to a return of SQLITE_ROW from sqlite3_step(). If JSI_BREAK
** is returned, then the SQL script has finished executing and there are
** no further rows available. This is similar to SQLITE_DONE.
*/
static Jsi_RC dbEvalStep(DbEvalContext *p) {
    while( p->zSql[0] || p->pPreStmt ) {
        Jsi_RC rc;
        if( p->pPreStmt==0 ) {
            rc = dbPrepareAndBind(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
            if( rc!=JSI_OK ) return rc;
        }
        rc = dbEvalStepSub(p, 1, NULL);
        if (rc != JSI_BREAK)
            return rc;
    }
    
    /* Finished */
    return JSI_BREAK;
}

static Jsi_RC dbBindStmt(Jsi_Db *jdb, SqlPreparedStmt *prep)
{
    sqlite3_stmt *pStmt = prep->pStmt;    /* Object used to cache statement */
    Jsi_Interp *interp = jdb->interp;
    int i, btype = 0, n;
    Jsi_RC rc = JSI_OK;
    Jsi_Number r;
    Jsi_Wide wv;
 
    Jsi_Value *pv = NULL, *lv = NULL, *apv = NULL;
    int nVar = sqlite3_bind_parameter_count(pStmt);
    char tname[50];
    
   /* Bind values to parameters that begin with @, $, :, or ? */
    for(i=1; i<=nVar; i++) {
        tname[0] = 0;
        int isInt = 0, isBlob = 0;
        const char *zVar = sqlite3_bind_parameter_name(pStmt, i);
        if (zVar == NULL) {
            if (!jdb->optPtr || (!jdb->optPtr->varName && !jdb->optPtr->values)) 
                return Jsi_LogError("? bind without varName/values for param %d", i);
            if (!apv) {
                if (!(apv = jdb->optPtr->values))
                    apv = Jsi_NameLookup(interp, jdb->optPtr->varName);
            }
            if (apv == NULL || !Jsi_ValueIsArray(interp, apv)) 
                return Jsi_LogError("can not find array var: %s", jdb->optPtr->varName);
            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) 
                return Jsi_LogError("array element %d missing", nVar);
        }
        else if((zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ) {
            int zvLen = Jsi_Strlen(zVar);
            char *zcp;
            if (zVar[0] =='$' && ((zcp = (char*)Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')
            {
                Jsi_DString vStr;
                Jsi_DSInit(&vStr);
                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));
                int slen = Jsi_Strlen(zcp);
                const char *ttp;
                if ((ttp = Jsi_Strchr(zVar,':'))) { // Extract bind-type.
                    Jsi_DString tStr = {};
                    int tlen = Jsi_Strlen(ttp+1);
                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);
                    if (!jdb->typeNameHash)
                        dbTypeNameHashInit(jdb);
                    Jsi_HashEntry *htPtr = Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr));
                    int rc = ( htPtr != NULL);
                    if (!htPtr) {
                        Jsi_DString eStr = {};
                        Jsi_HashSearch search;
                        Jsi_Interp *interp = jdb->interp;
                        int n = 0;
                        Jsi_HashEntry *hPtr;
                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);
                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
                            const char *key = (char*)Jsi_HashKeyGet(hPtr);
                            Jsi_DSAppend(&eStr, (n++?", ":""), key, NULL);
                        }
                        Jsi_LogWarn("bind type \"%s\" is not one of: %s", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));
                        Jsi_DSFree(&eStr);
                    }
                    Jsi_Strcpy(tname, Jsi_DSValue(&tStr));
                    Jsi_DSFree(&tStr);
                    if (!rc)
                        return JSI_ERROR;

                    btype = (uintptr_t)Jsi_HashValueGet(htPtr);
                    Jsi_DSFree(&tStr);
                    slen -= tlen;
                }

                if (isdigit(zcp[1])) {
                    Jsi_DSAppendLen(&vStr, "[", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                    Jsi_DSAppendLen(&vStr, "]", 1);
                } else {
                    if (zcp[1] != '[')
                        Jsi_DSAppendLen(&vStr, ".", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                }
                lv = pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));
                Jsi_DSFree(&vStr);
            } else
                pv = Jsi_VarLookup(interp, &zVar[1]);
        } else 
            return Jsi_LogError("can not find bind var %s", zVar);
            
        if(!pv ) {
            if (!jdb->bindWarn) {
                Jsi_LogError("unknown bind param: %s", zVar);
                rc = JSI_ERROR;
                break;
            } else
                Jsi_LogWarn("unknown bind param: %s", zVar);
        } else {
            int match = 1, cast = (jdb->optPtr->typeCheck==dbTypeCheck_Cast);
            if (btype && !Jsi_ValueIsUndef(interp, pv)) {
                switch (btype) {
                    case JSI_OPTION_STRBUF:
                        isBlob = 1;
                    case JSI_OPTION_STRING:
                        if (cast)
                            Jsi_ValueToString(interp, pv, &n);
                        else
                            match = Jsi_ValueIsString(interp, pv);
                        break;
                    case JSI_OPTION_NUMBER:
                    case JSI_OPTION_DOUBLE:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_TIME_W:
                    case JSI_OPTION_TIME_T:
                    case JSI_OPTION_INT64:
                        isInt = 1;
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_BOOL:
                        if (cast)
                            Jsi_ValueToBool(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_TIME_D:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv); //TODO: do something more for dates?
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    default:
                        Jsi_LogBug("Unhandled bind type: %s = %d", tname, btype);
                }
                if (cast == 0 && match == 0) {
                    int ltyp = (jdb->optPtr->typeCheck==dbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);
                    Jsi_LogMsg(interp, ltyp, "bind param \"%s\" type is not \"%s\"", zVar, tname);
                    if (ltyp == JSI_LOG_ERROR)
                        return JSI_ERROR;
                }
            }
            bool bn;
            if (Jsi_ValueIsBoolean(interp, pv)) {
                Jsi_GetBoolFromValue(interp, pv, &bn);
                sqlite3_bind_int(pStmt, i, bn);
            } else if (Jsi_ValueIsNumber(interp, pv)) {
                Jsi_GetNumberFromValue(interp, pv, &r);
                wv = (Jsi_Wide)r;
                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0))
                    sqlite3_bind_int64(pStmt, i,wv);
                else
                    sqlite3_bind_double(pStmt, i,(double)r);
            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->queryOpts.mapundef)) {
                sqlite3_bind_null(pStmt, i);
            } else if (Jsi_ValueIsString(interp, pv)) {
                const char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);
                if (!sstr) sstr = "";
                if (isBlob)
                    sqlite3_bind_blob(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );
                else
                    sqlite3_bind_text(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );
            } else {
                if (!jdb->bindWarn) {
                    Jsi_LogError("bind param must be string/number/bool/null: %s", zVar);
                    rc = JSI_ERROR;
                    break;
                } else
                    Jsi_LogWarn("bind param must be string/number/bool/null: %s", zVar);
                sqlite3_bind_null(pStmt, i);
            }

        }
        if (lv) {
            Jsi_DecrRefCount(interp, lv);
            lv = NULL;
        }
    }
    if (lv)
        Jsi_DecrRefCount(interp, lv);
    return rc;
}

static Jsi_RC dbPrepareAndBind(
    Jsi_Db *jdb,                  /* Database object */
    char const *zIn,                /* SQL to compile */
    char const **pzOut,             /* OUT: Pointer to next SQL statement */
    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */
) {
    if (dbPrepareStmt(jdb, zIn, pzOut, ppPreStmt) != JSI_OK)
        return JSI_ERROR;
    return dbBindStmt(jdb, *ppPreStmt);
}
#endif

/*
** Free all resources currently held by the DbEvalContext structure passed
** as the first argument. There should be exactly one call to this function
** for each call to dbEvalInit(interp,).
*/
static void dbEvalFinalize(DbEvalContext *p) {
//  Jsi_Interp *interp = p->jdb->interp;

    if( p->pPreStmt ) {
        sqlite3_reset(p->pPreStmt->pStmt);
        dbReleaseStmt(p->jdb, p->pPreStmt, p->nocache);
        p->pPreStmt = 0;
    }
    Jsi_DSFree(p->dSql);
    dbReleaseColumnNames(p);
}

static void DbClose(sqlite3 *db) {
        sqlite3_close(db);
}

#ifndef JSI_LITE_ONLY

static Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data);
static bool  sqliteObjEqual(void *data1, void *data2);
static bool  sqliteObjIsTrue(void *data);

static Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record)
{
    if (!Jsi_ValueIsArray(interp, value)) 
        return Jsi_LogError("expected array of numbers");
    int i, argc = Jsi_ValueGetLength(interp, value);
    for (i=0; i<argc; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);
        if (!Jsi_ValueIsNumber(interp, v)) 
            return Jsi_LogError("expected array of numbers");
    }
    return JSI_OK;
}


/*
** JSI calls this procedure when an sqlite3 database command is
** deleted.
*/
static void dbDeleteCmd(Jsi_Db *jdb)
{
    Jsi_Interp *interp = jdb->interp;
    if (jdb->debug & TMODE_DELETE)
        JSI_DBQUERY_PRINTF( "DEBUG: delete\n");
    dbFlushStmtCache(jdb);
    if (jdb->stmtHash)
        Jsi_HashDelete(jdb->stmtHash);
    //closeIncrblobChannels(jdb);
    if (jdb->db) {
        DbClose(jdb->db);
    }
    while( jdb->pFunc ) {
        SqlFunc *pFunc = jdb->pFunc;
        jdb->pFunc = pFunc->pNext;
        Jsi_DSFree(&pFunc->dScript);
        Jsi_DecrRefCount(interp, pFunc->tocall);
        Jsi_Free((char*)pFunc);
    }
    while( jdb->pCollate ) {
        SqlCollate *pCollate = jdb->pCollate;
        jdb->pCollate = pCollate->pNext;
        Jsi_Free((char*)pCollate);
    }
    if( jdb->zBusy ) {
        Jsi_DecrRefCount(interp, jdb->zBusy);
    }
    if( jdb->zTrace ) {
        Jsi_DecrRefCount(interp, jdb->zTrace);
    }
    if( jdb->zProfile ) {
        Jsi_DecrRefCount(interp, jdb->zProfile);
    }
    if( jdb->zAuth ) {
        Jsi_DecrRefCount(interp, jdb->zAuth);
    }
    if( jdb->zNull ) {
        Jsi_Free(jdb->zNull);
    }
    if( jdb->pUpdateHook ) {
        Jsi_DecrRefCount(interp, jdb->pUpdateHook);
    }
    if( jdb->pRollbackHook ) {
        Jsi_DecrRefCount(interp, jdb->pRollbackHook);
    }
    if( jdb->pCollateNeeded ) {
        Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
    }
    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);
    if (jdb->stmtCache)
        Jsi_ListDelete(jdb->stmtCache);
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static int dbGetIntBool(Jsi_Interp *interp, Jsi_Value* v)
{
    if (Jsi_ValueIsNumber(interp, v)) {
        Jsi_Number d;
        Jsi_ValueGetNumber(interp, v, &d);
        return (int)d;
    }
    if (Jsi_ValueIsBoolean(interp, v)) {
        bool n;
        Jsi_ValueGetBoolean(interp, v, &n);
        return n;
    }
    return 0;
}


/*
** This routine is called when a database file is locked while trying
** to execute SQL.
*/
static int dbBusyHandler(void *cd, int nTries) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[3] = {}, *ret;
    Jsi_Interp *interp = jdb->interp;

    items[0] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nTries);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zBusy, vpargs, &ret, NULL);
    if( JSI_OK!=rc ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}

/*
** This routine is invoked as the 'progress callback' for the database.
*/
static int dbProgressHandler(void *cd) {
    int rc = 0;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *ret = Jsi_ValueNew1(interp);
    assert(jdb->zProgress);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->zProgress, NULL, &ret, NULL) ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, ret);

    return rc;
}
#endif

#ifndef SQLITE_OMIT_TRACE
/*
** This routine is called by the SQLite trace handler whenever a new
** block of SQL is executed.  The JSI script in jdb->zTrace is executed.
*/
static void dbTraceHandler(void *cd, const char *zSql)
{
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[2] = {}, *ret;
    Jsi_Interp *interp = jdb->interp;
    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zSql);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zTrace, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef SQLITEN_OMIT_TRACE
/*
** This routine is called by the SQLite profile handler after a statement
** SQL has executed.  The JSI script in jdb->zProfile is evaluated.
*/
static void dbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[3] = {}, *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zSql);
    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)tm);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zProfile, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS
/*
** This routine is called when a transaction is committed.  The
** JSI script in jdb->zCommit is executed.  If it returns non-zero or
** if it throws an exception, the transaction is rolled back instead
** of being committed.
*/
static int dbCommitHandler(void *cd) {
    int rc = 0;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *ret = Jsi_ValueNew1(jdb->interp);

    assert(jdb->zCommit);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->zCommit, NULL, &ret, NULL) ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(jdb->interp, ret);
    Jsi_DecrRefCount(jdb->interp, ret);

    return rc;
}

/*
** This procedure handles wal_hook callbacks.
*/
static int dbWalHandler( void *cd, sqlite3 *db, const char *zDb, int nEntry ){
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[3] = {}, *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zDb);
    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nEntry);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pWalHook, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (rc != JSI_OK) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(jdb->interp, ret);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
 
static void dbRollbackHandler(void *cd) {
    Jsi_Db *jdb = (Jsi_Db*)cd;
    assert(jdb->pRollbackHook);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->pRollbackHook, NULL, NULL, NULL) ) {
        jdb->errorCnt++;
    }
}
#endif

#if defined(SQLITE_TEST) && defined(SQLITE_ENABLE_UNLOCK_NOTIFY)
static void dbSetTestUnlockNotifyVars(Jsi_Interp *interp, int iArg, int nArg) {
    char zBuf[64];
    snprintf(zBuf, sizeof(zBuf), "%d", iArg);
    Jsi_SetVar(interp, "sqlite_unlock_notify_arg", zBuf, JSI_GLOBAL_ONLY);
    snprintf(zBuf, sizeof(zBuf), "%d", nArg);
    Jsi_SetVar(interp, "sqlite_unlock_notify_argcount", zBuf, JSI_GLOBAL_ONLY);
}
#else
# define dbSetTestUnlockNotifyVars(x,y,z)
#endif

#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
//TODO: unimpl
static void dbUnlockNotify(void **apArg, int nArg) {
    int i;
    for(i=0; i<nArg; i++) {
        const int flags = (JSI_EVAL_GLOBAL);
        Jsi_Db *jdb = (Jsi_Db *)apArg[i];
        dbSetTestUnlockNotifyVars(jdb->interp, i, nArg);
        assert( jdb->pUnlockNotify);
        Jsi_EvalObjEx(jdb->interp, jdb->pUnlockNotify, flags);
        Jsi_ObjDecrRefCount(jdb->pUnlockNotify);
        jdb->pUnlockNotify = 0;
    }
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS
static void dbUpdateHandler(
    void *p,
    int op,
    const char *zDb,
    const char *zTbl,
    sqlite_int64 rowid
) {
    Jsi_Db *jdb = (Jsi_Db *)p;
    Jsi_Interp *interp = jdb->interp;
    int rc, i = 0;
    Jsi_Value *vpargs, *items[5] = {}, *ret;

    assert( jdb->pUpdateHook );
    assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, (op==SQLITE_INSERT)?"INSERT":(op==SQLITE_UPDATE)?"UPDATE":"DELETE");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zDb);
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zTbl);
    items[i++] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)rowid);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pUpdateHook, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef OMIT_SQLITE_COLLATION

static void dbCollateNeeded(
    void *cd,
    sqlite3 *db,
    int enc,
    const char *zName
) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[2], *ret;
    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zName);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pCollateNeeded, vpargs,& ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;

}

/*
** This routine is called to evaluate an SQL collation function implemented
** using JSI script.
*/
static int dbSqlCollate(
    void *pCtx,
    int nA,
    const void *zA,
    int nB,
    const void *zB
) {
    SqlCollate *p = (SqlCollate *)pCtx;
    Jsi_Interp *interp = p->interp;

    int rc;
    //Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[3], *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zA);
    items[1] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zB);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, p->zScript, vpargs, &ret, NULL);
    if( JSI_OK!=rc ) {
        //jdb->errorCnt++;
        rc = 0;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
#endif

static Jsi_Value* dbGetValueGet(Jsi_Interp *interp, sqlite3_value *pIn)
{
    Jsi_Value *v = Jsi_ValueNew(interp);
    switch (sqlite3_value_type(pIn)) {
    case SQLITE_BLOB: {
        int bytes;
        bytes = sqlite3_value_bytes(pIn);
        const char *zBlob = (char*) sqlite3_value_blob(pIn);
        if(!zBlob ) {
            return Jsi_ValueMakeNull(interp, &v);
        }
        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);
        memcpy(uptr, zBlob, bytes);
        uptr[bytes] = 0;
        return Jsi_ValueMakeBlob(interp, &v, uptr, bytes);
    }
    case SQLITE_INTEGER: {
        sqlite_int64 n = sqlite3_value_int64(pIn);
        if( n>=-2147483647 && n<=2147483647 ) {
            return Jsi_ValueMakeNumber(interp, &v, n);
        } else {
            return Jsi_ValueMakeNumber(interp, &v, n);
        }
    }
    case SQLITE_FLOAT: {
        return Jsi_ValueMakeNumber(interp, &v, (Jsi_Number)sqlite3_value_double(pIn));
    }
    case SQLITE_NULL: {
        return Jsi_ValueMakeNull(interp, &v);
    }
    default:
        return Jsi_ValueMakeStringDup(interp, &v, (char *)sqlite3_value_text(pIn));
    }
    return v;
}

static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {
    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);
    int i;
    int rc;
    Jsi_Interp *interp = p->interp;
    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;
    if (argc>100)
        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));

    for(i=0; i<argc; i++) {
        items[i] = dbGetValueGet(interp, argv[i]);
    }
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (items != itemsStatic)
        Jsi_Free(items);

    bool b;
    if( rc != JSI_OK) {
        char buf[250];
        snprintf(buf, sizeof(buf), "error in function: %.200s", p->zName);
        sqlite3_result_error(context, buf, -1);

    } else if (Jsi_ValueIsBoolean(interp, ret)) {
        Jsi_GetBoolFromValue(interp, ret, &b);
        sqlite3_result_int(context, b);
    } else if (Jsi_ValueIsNumber(interp, ret)) {
        Jsi_Number d;
        // if (Jsi_GetIntFromValueBase(interp, ret, &i, 0, JSI_NO_ERRMSG);
        // sqlite3_result_int64(context, v);
        Jsi_GetNumberFromValue(interp, ret, &d);
        sqlite3_result_double(context, (double)d);
    } else {
        const char * data;
        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {
            //TODO: handle objects???
            data = Jsi_ValueToString(interp, ret, NULL);
            i = Jsi_Strlen(data);
        }
        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );
    }
    Jsi_DecrRefCount(interp, ret);
}

#ifndef SQLITE_OMIT_AUTHORIZATION
/*
** This is the authentication function.  It appends the authentication
** type code and the two arguments to zCmd[] then invokes the result
** on the interpreter.  The reply is examined to determine if the
** authentication fails or succeeds.
*/
static int dbAuthCallback(
    void *pArg,
    int code,
    const char *zArg1,
    const char *zArg2,
    const char *zArg3,
    const char *zArg4
) {
    const char *zCode;
    int rc;
    const char *zReply;
    Jsi_Db *jdb = (Jsi_Db*)pArg;
    Jsi_Interp *interp = jdb->interp;
    if( jdb->disableAuth ) return SQLITE_OK;

    switch( code ) {
    case SQLITE_COPY              :
        zCode="SQLITE_COPY";
        break;
    case SQLITE_CREATE_INDEX      :
        zCode="SQLITE_CREATE_INDEX";
        break;
    case SQLITE_CREATE_TABLE      :
        zCode="SQLITE_CREATE_TABLE";
        break;
    case SQLITE_CREATE_TEMP_INDEX :
        zCode="SQLITE_CREATE_TEMP_INDEX";
        break;
    case SQLITE_CREATE_TEMP_TABLE :
        zCode="SQLITE_CREATE_TEMP_TABLE";
        break;
    case SQLITE_CREATE_TEMP_TRIGGER:
        zCode="SQLITE_CREATE_TEMP_TRIGGER";
        break;
    case SQLITE_CREATE_TEMP_VIEW  :
        zCode="SQLITE_CREATE_TEMP_VIEW";
        break;
    case SQLITE_CREATE_TRIGGER    :
        zCode="SQLITE_CREATE_TRIGGER";
        break;
    case SQLITE_CREATE_VIEW       :
        zCode="SQLITE_CREATE_VIEW";
        break;
    case SQLITE_DELETE            :
        zCode="SQLITE_DELETE";
        break;
    case SQLITE_DROP_INDEX        :
        zCode="SQLITE_DROP_INDEX";
        break;
    case SQLITE_DROP_TABLE        :
        zCode="SQLITE_DROP_TABLE";
        break;
    case SQLITE_DROP_TEMP_INDEX   :
        zCode="SQLITE_DROP_TEMP_INDEX";
        break;
    case SQLITE_DROP_TEMP_TABLE   :
        zCode="SQLITE_DROP_TEMP_TABLE";
        break;
    case SQLITE_DROP_TEMP_TRIGGER :
        zCode="SQLITE_DROP_TEMP_TRIGGER";
        break;
    case SQLITE_DROP_TEMP_VIEW    :
        zCode="SQLITE_DROP_TEMP_VIEW";
        break;
    case SQLITE_DROP_TRIGGER      :
        zCode="SQLITE_DROP_TRIGGER";
        break;
    case SQLITE_DROP_VIEW         :
        zCode="SQLITE_DROP_VIEW";
        break;
    case SQLITE_INSERT            :
        zCode="SQLITE_INSERT";
        break;
    case SQLITE_PRAGMA            :
        zCode="SQLITE_PRAGMA";
        break;
    case SQLITE_READ              :
        zCode="SQLITE_READ";
        break;
    case SQLITE_SELECT            :
        zCode="SQLITE_SELECT";
        break;
    case SQLITE_TRANSACTION       :
        zCode="SQLITE_TRANSACTION";
        break;
    case SQLITE_UPDATE            :
        zCode="SQLITE_UPDATE";
        break;
    case SQLITE_ATTACH            :
        zCode="SQLITE_ATTACH";
        break;
    case SQLITE_DETACH            :
        zCode="SQLITE_DETACH";
        break;
    case SQLITE_ALTER_TABLE       :
        zCode="SQLITE_ALTER_TABLE";
        break;
    case SQLITE_REINDEX           :
        zCode="SQLITE_REINDEX";
        break;
    case SQLITE_ANALYZE           :
        zCode="SQLITE_ANALYZE";
        break;
    case SQLITE_CREATE_VTABLE     :
        zCode="SQLITE_CREATE_VTABLE";
        break;
    case SQLITE_DROP_VTABLE       :
        zCode="SQLITE_DROP_VTABLE";
        break;
    case SQLITE_FUNCTION          :
        zCode="SQLITE_FUNCTION";
        break;
    case SQLITE_SAVEPOINT         :
        zCode="SQLITE_SAVEPOINT";
        break;
    default                       :
        zCode="????";
        break;
    }
    int i = 0;
    Jsi_Value *vpargs, *items[6] = {}, *ret;

    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zCode);
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg1 ? zArg1 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg2 ? zArg2 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg3 ? zArg3 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg4 ? zArg4 : "");
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zAuth, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);

    if (rc == JSI_OK && (zReply = Jsi_ValueGetStringLen(interp, ret, NULL)))
    {
        if( Jsi_Strcmp(zReply,"SQLITE_OK")==0 ) {
            rc = SQLITE_OK;
        } else if( Jsi_Strcmp(zReply,"SQLITE_DENY")==0 ) {
            rc = SQLITE_DENY;
        } else if( Jsi_Strcmp(zReply,"SQLITE_IGNORE")==0 ) {
            rc = SQLITE_IGNORE;
        } else {
            rc = 999;
        }
    }
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
#endif /* SQLITE_OMIT_AUTHORIZATION */

/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** The interface is like "readline" but no command-line editing
** is done.
**
** copied from shell.c from '.import' command
*/
static char *dbLocalGetline(char *zPrompt, Jsi_Channel in) {
    char *zLine;
    int nLine;
    int n;
    int eol;

    nLine = 100;
    zLine = (char*)Jsi_Malloc( nLine );
    if( zLine==0 ) return 0;
    n = 0;
    eol = 0;
    while( !eol ) {
        if( n+100>nLine ) {
            nLine = nLine*2 + 100;
            zLine = (char*)Jsi_Realloc(zLine, nLine);
            if( zLine==0 ) return 0;
        }
        if( Jsi_Gets(in, &zLine[n], nLine - n)==0 ) {
            if( n==0 ) {
                Jsi_Free(zLine);
                return 0;
            }
            zLine[n] = 0;
            eol = 1;
            break;
        }
        while( zLine[n] ) {
            n++;
        }
        if( n>0 && zLine[n-1]=='\n' ) {
            n--;
            zLine[n] = 0;
            eol = 1;
        }
    }
    zLine = (char*)Jsi_Realloc( zLine, n+1 );
    return zLine;
}


/*
** This function is part of the implementation of the command:
**
**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
**
** It is invoked after evaluating the script SCRIPT to commit or rollback
** the transaction or savepoint opened by the [transaction] command.
*/
static Jsi_RC dbTransPostCmd(
    Jsi_Db *jdb,                       /* Sqlite3Db for $db */
    Jsi_Interp *interp,                  /* Jsi interpreter */
    Jsi_RC result                           /* Result of evaluating SCRIPT */
) {
    static const char *azEnd[] = {
        "RELEASE _jsi_transaction",        /* rc==JSI_ERROR, nTransaction!=0 */
        "COMMIT",                          /* rc!=JSI_ERROR, nTransaction==0 */
        "ROLLBACK TO _jsi_transaction ; RELEASE _jsi_transaction",
        "ROLLBACK"                         /* rc==JSI_ERROR, nTransaction==0 */
    };
    Jsi_RC rc = result;
    const char *zEnd;

    jdb->nTransaction--;
    zEnd = azEnd[(rc==JSI_ERROR)*2 + (jdb->nTransaction==0)];

    jdb->disableAuth++;
    if( sqlite3_exec(jdb->db, zEnd, 0, 0, 0)) {
        /* This is a tricky scenario to handle. The most likely cause of an
        ** error is that the exec() above was an attempt to commit the
        ** top-level transaction that returned SQLITE_BUSY. Or, less likely,
        ** that an IO-error has occured. In either case, throw a Jsi exception
        ** and try to rollback the transaction.
        **
        ** But it could also be that the user executed one or more BEGIN,
        ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
        ** this method's logic. Not clear how this would be best handled.
        */
        if( rc!=JSI_ERROR ) {
            Jsi_LogError("%s", sqlite3_errmsg(jdb->db));
            rc = JSI_ERROR;
        }
        sqlite3_exec(jdb->db, "ROLLBACK", 0, 0, 0);
    }
    jdb->disableAuth--;

    return rc;
}



#if 0
static void dbEvalRowInfo(
    DbEvalContext *p,               /* Evaluation context */
    int *pnCol,                     /* OUT: Number of column names */
    char ***papColName,           /* OUT: Array of column names */
    int **papColType
) {
    /* Compute column names */
    // Jsi_Interp *interp = p->jdb->interp;

    if( 0==p->apColName ) {
        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;
        int i;                        /* Iterator variable */
        int nCol;                     /* Number of columns returned by pStmt */
        char **apColName = 0;      /* Array of column names */
        int *apColType = 0;
        const char *zColName;         /* Column name */
        int numRid = 0;               /* Number of times rowid seen. */

        p->nCol = nCol = sqlite3_column_count(pStmt);
        if( nCol>0 && (papColName || p->pArray) ) {
            int cnLen = sizeof(char*)*nCol, cnStart = cnLen;
            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)
                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;
            if (cnLen>=sizeof(p->staticColNames)) {
                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );
                cnStart = 0;
            } else {
                apColName = (char**)p->staticColNames;
            }
            if (papColType) {
                if (nCol < SQL_MAX_STATIC_TYPES)
                    apColType = p->staticColTypes;
                else
                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));
            }
            for(i=0; i<nCol; i++) {
                zColName = sqlite3_column_name(pStmt,i);
                if (cnStart==0)
                    apColName[i] = Jsi_Strdup(zColName);
                else {
                    apColName[i] = p->staticColNames+cnStart;
                    Jsi_Strcpy(apColName[i], zColName);
                    cnStart += Jsi_Strlen(zColName)+1;
                }
                if (apColType)
                    apColType[i] = sqlite3_column_type(pStmt,i);
                /* Check if rowid appears first, and more than once. */
                if ((i == 0 || numRid>0) &&
                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,"rowid") == 0)) {
                    numRid++;
                }
            }
            /* Change first rowid to oid. */
            if (numRid > 1) {
                if (apColName != (char**)p->staticColNames) {
                    Jsi_Free(apColName[0]);
                    apColName[0] = Jsi_Strdup("oid");
                } else {
                    Jsi_Strcpy(apColName[0], "oid");
                }
            }
            p->apColName = apColName;
            p->apColType = apColType;
        }
    }
    if( papColName ) {
        *papColName = p->apColName;
    }
    if( papColType ) {
        *papColType = p->apColType;
    }
    if( pnCol ) {
        *pnCol = p->nCol;
    }
}
#endif

/*
** Return a JSON formatted value for the iCol'th column of the row currently pointed to by
** the DbEvalContext structure passed as the first argument.
*/
static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {
    Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];

    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;

    switch( sqlite3_column_type(pStmt, iCol) ) {
    case SQLITE_BLOB: {
        int bytes = sqlite3_column_bytes(pStmt, iCol);
        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);
        if( !zBlob ) {
            Jsi_DSAppend(dStr, "null", NULL);
            return;
        }
        Jsi_JSONQuote(interp, zBlob, bytes, dStr);
        return;
    }
    case SQLITE_INTEGER: {
        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);
#ifdef __WIN32
        snprintf(nbuf, sizeof(nbuf), "%" PRId64, (Jsi_Wide)v);
#else
        snprintf(nbuf, sizeof(nbuf), "%lld", v);
#endif
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case SQLITE_FLOAT: {
        Jsi_NumberToString(sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case SQLITE_NULL: {
        Jsi_DSAppend(dStr, "null", NULL);
        return;
    }
    }
    const char *str = (char*)sqlite3_column_text(pStmt, iCol );
    if (!str)
        str = p->jdb->optPtr->nullvalue;
    Jsi_JSONQuote(interp, str?str:"", -1, dStr);
}

static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {
    char nbuf[200];

    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;

    switch( sqlite3_column_type(pStmt, iCol) ) {
    case SQLITE_BLOB: {
        int bytes = sqlite3_column_bytes(pStmt, iCol);
        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);
        if( !zBlob ) {
            return;
        }
        Jsi_DSAppendLen(dStr, zBlob, bytes);
        return;
    }
    case SQLITE_INTEGER: {
        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);
#ifdef __WIN32
        snprintf(nbuf, sizeof(nbuf), "%" PRId64, (Jsi_Wide)v);
#else
        snprintf(nbuf, sizeof(nbuf), "%lld", v);
#endif
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case SQLITE_FLOAT: {
        Jsi_NumberToString(sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case SQLITE_NULL: {
        return;
    }
    }
    const char *str = (char*)sqlite3_column_text(pStmt, iCol );
    if (!str)
        str = p->jdb->optPtr->nullvalue;
    Jsi_DSAppend(dStr, str?str:"", NULL);
}


static Jsi_Value* dbEvalSetColumnValue(DbEvalContext *p, int iCol, Jsi_Value **val) {
    Jsi_Interp *interp = p->jdb->interp;

    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;
    const char *str;
    
    switch( sqlite3_column_type(pStmt, iCol) ) {
    case SQLITE_BLOB: {
        int bytes = sqlite3_column_bytes(pStmt, iCol);
        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);
        if( !zBlob )
            return Jsi_ValueMakeNull(interp, val);
        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);
        memcpy(uptr, zBlob, bytes);
        uptr[bytes] = 0;
        return Jsi_ValueMakeBlob(interp, val, uptr, bytes);
        break;
    }
    case SQLITE_INTEGER: {
        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);
        if( v>=-2147483647 && v<=2147483647 ) {
            return Jsi_ValueMakeNumber(interp, val, v);
        } else {
            return Jsi_ValueMakeNumber(interp, val, v);
        }
        break;
    }
    case SQLITE_FLOAT: {
        return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)sqlite3_column_double(pStmt, iCol));
        break;
    }
    case SQLITE_NULL: {
        return Jsi_ValueMakeNull(interp, val);
        break;;
    }
    default:
        str = (char*)sqlite3_column_text(pStmt, iCol );
        if (!str)
            str = p->jdb->optPtr->nullvalue;
        return Jsi_ValueMakeStringDup(interp, val, str?str:"");
    }
    return Jsi_ValueNew1(interp);
}


# define SQLITE_JSI_NRE 0
# define DbUseNre() 0
# define Jsi_NRAddCallback(a,b,c,d,e,f) 0
# define Jsi_NREvalObj(a,b,c) 0
# define Jsi_NRCreateCommand(a,b,c,d,e,f) 0

#include <stdio.h>

static Jsi_RC dbEvalCallCmd( DbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)
{
    int cnt = 0;
    Jsi_RC rc = result;
    Jsi_Value *varg1;
    Jsi_Obj *argso;
    char **apColName = NULL;
    int *apColType = NULL;
    if (p->jdb->debug & TMODE_EVAL)
        JSI_DBQUERY_PRINTF( "DEBUG: eval\n");

    while( (rc==JSI_OK) && JSI_OK==(rc = dbEvalStep(p)) ) {
        int i;
        int nCol;

        cnt++;
        dbEvalRowInfo(p, &nCol, &apColName, &apColType);
        if (nCol<=0)
            continue;
        if (Jsi_ValueIsNull(interp,p->tocall))
            continue;
        /* Single object containing sql result members. */
        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));
        for(i=0; i<nCol; i++) {
            Jsi_Value *nnv = dbEvalSetColumnValue(p, i, NULL);
            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);
        }
        Jsi_IncrRefCount(interp, varg1);
        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);
        Jsi_DecrRefCount(interp, varg1);
        if (rb)
            break;
    }
    //dbEvalFinalize(p);

    if( rc==JSI_OK || rc==JSI_BREAK ) {
        //Jsi_ResetResult(interp);
        rc = JSI_OK;
    }
    return rc;
}

static Jsi_Db *dbGetDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb = (Jsi_Db*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!jdb) {
        Jsi_LogError("Sqlite call to a non-sqlite object");
        return NULL;
    }
    if (!jdb->db)
    {
        Jsi_LogError("Sqlite db closed");
        return NULL;
    }
    return jdb;
}

static void sqliteObjErase(Jsi_Db *jdb)
{
    dbDeleteCmd(jdb);
    jdb->db = NULL;
}

static Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data)
{
    Jsi_Db *fo = (Jsi_Db*)data;
    SQLSIGASSERT(fo,DB);
    sqliteObjErase(fo);
    _JSI_MEMCLEAR(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static bool sqliteObjIsTrue(void *data)
{
    Jsi_Db *fo = (Jsi_Db*)data;
    SQLSIGASSERT(fo,DB);
    if (!fo->db) return 0;
    else return 1;
}

static bool sqliteObjEqual(void *data1, void *data2)
{
    //SQLSIGASSERT(data1,DB);
    //SQLSIGASSERT(data2,DB);
    return (data1 == data2);
}

static Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value);

static Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr);
                             
#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_busy JSI_INFO("\
Invoke the given callback when an SQL statement attempts to open \
a locked database file. Call with null to disable, or no arguments, \
to return the current busy function. ")

static Jsi_RC SqliteBusyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zBusy ) {
            Jsi_ValueReplace(interp, ret, jdb->zBusy);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_busy_handler(jdb->db, 0, 0);
        if( jdb->zBusy ) {
            Jsi_DecrRefCount(interp, jdb->zBusy);
        }
        jdb->zBusy = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zBusy ) {
            Jsi_DecrRefCount(interp, jdb->zBusy);
        }
        jdb->zBusy = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_busy_handler(jdb->db, dbBusyHandler, jdb);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}
#endif

#ifndef OMIT_SQLITE_COLLATION
static Jsi_RC SqliteCollateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *func;

    SqlCollate *pCollate;
    char *zName;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    func = Jsi_ValueArrayIndex(interp, args, 1);
    pCollate = (SqlCollate*)Jsi_Calloc(1, sizeof(*pCollate));
    if( pCollate==0 ) return JSI_ERROR;
    pCollate->interp = interp;
    pCollate->pNext = jdb->pCollate;
    pCollate->zScript = func; /*(char*)&pCollate[1];*/
    jdb->pCollate = pCollate;

    if( sqlite3_create_collation(jdb->db, zName, SQLITE_UTF8, pCollate, dbSqlCollate) )
    
        return Jsi_LogError("%s", (char *)sqlite3_errmsg(jdb->db));
    return JSI_OK;
}

static Jsi_RC SqliteCollationNeededCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *func;
    int argc = Jsi_ValueGetLength(interp, args);

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pCollateNeeded ) {
            Jsi_ValueReplace(interp, ret, jdb->pCollateNeeded);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_collation_needed(jdb->db, 0, 0);
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
        }
        jdb->zCommit = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pCollateNeeded ) {
            Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
        }
        jdb->pCollateNeeded = func;
        Jsi_DecrRefCount(interp, func);
        sqlite3_collation_needed(jdb->db, jdb, dbCollateNeeded);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;

}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_commithook JSI_INFO("\
Invoke the given callback just before committing every SQL transaction. \
If the callback throws an exception or returns non-zero, then the \
transaction is aborted.  If CALLBACK is an empty string, the callback \
is disabled.")

static Jsi_RC SqliteCommitHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zCommit ) {
            Jsi_ValueReplace(interp, ret, jdb->zCommit);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_commit_hook(jdb->db, 0, 0);
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->zCommit);
        }
        jdb->zCommit = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->zCommit);
        }
        jdb->zCommit = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_commit_hook(jdb->db, dbCommitHandler, jdb);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}

static Jsi_RC SqliteProgressCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int n, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func, *nVal;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zProgress ) {
            Jsi_ValueReplace(interp, ret, jdb->zProgress);
        }
        return JSI_OK;
    }
    if (argc != 2) 
        return Jsi_LogError("expected 0 or 2 args");
    func = Jsi_ValueArrayIndex(interp, args, 1);
    nVal = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetIntFromValue(interp, nVal, &n) != JSI_OK)
        return JSI_ERROR;
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_progress_handler(jdb->db, 0, 0, 0);
        if( jdb->zProgress ) {
            Jsi_DecrRefCount(interp, jdb->zProgress);
        }
        jdb->zProgress = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zProgress ) {
            Jsi_DecrRefCount(interp, jdb->zProgress);
        }
        jdb->zProgress = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_progress_handler(jdb->db, n, dbProgressHandler, jdb);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}
#endif

#define FN_profile JSI_INFO("\
Make arrangements to invoke the CALLBACK routine after each SQL statement \
that has run.  The text of the SQL and the amount of elapse time are \
arguments to CALLBACK.")

static Jsi_RC SqliteProfileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zProfile ) {
            Jsi_ValueReplace(interp, ret, jdb->zProfile);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
#ifndef SQLITE_OMIT_TRACE
        sqlite3_profile(jdb->db, 0, 0 );
#endif
        if( jdb->zProfile ) {
            Jsi_DecrRefCount(interp, jdb->zProfile);
        }
        jdb->zProfile = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zProfile ) {
            Jsi_DecrRefCount(interp, jdb->zProfile);
        }
        jdb->zProfile = func;
        Jsi_IncrRefCount(interp, func);
#ifndef SQLITE_OMIT_TRACE
        sqlite3_profile(jdb->db, dbProfileHandler, jdb);
#endif
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}

static Jsi_RC SqliteRekeyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int nKey;
    Jsi_RC rc = JSI_OK;
    void *pKey = Jsi_ValueString(interp, val, &nKey);
    
    if (!pKey) 
        return Jsi_LogError("key must be a non-null string");
#ifdef SQLITE_HAS_CODEC
    rc = sqlite3_rekey(jdb->db, pKey, nKey);
    if( rc ) {
#if defined(SQLITE3_AMALGAMATION) || defined(SQLITE4_AMALGAMATION)
        Jsi_LogError("Rekey: %s", sqlite3ErrStr(rc));
#else
        Jsi_LogError("Rekey error");
#endif
        rc = JSI_ERROR;
    } else {
        Jsi_ValueMakeBool(interp, *ret, 1);
    }
#endif
    return rc;
}

#define FN_trace JSI_INFO("\
Make arrangements to invoke the callback routine for each SQL statement\
that is executed.  The text of the SQL is an argument to callback.")

static Jsi_RC SqliteTraceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zTrace ) {
            Jsi_ValueReplace(interp, ret, jdb->zTrace);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
#ifndef SQLITE_OMIT_TRACE
        sqlite3_trace(jdb->db, 0, 0 );
#endif
        if( jdb->zTrace ) {
            Jsi_DecrRefCount(interp, jdb->zTrace);
        }
        jdb->zTrace = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zTrace ) {
            Jsi_DecrRefCount(interp, jdb->zTrace);
        }
        jdb->zTrace = func;
        Jsi_IncrRefCount(interp, func);
#ifndef SQLITE_OMIT_TRACE
        sqlite3_trace(jdb->db, dbTraceHandler, jdb);
#endif
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static Jsi_RC SqliteUnlockNotifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{

#ifndef SQLITE_ENABLE_UNLOCK_NOTIFY
    Jsi_LogError("unlock_notify not available in this build");
    return JSI_ERROR;
#else
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zUnlockNotify ) {
            Jsi_ValueReplace(interp, ret, jdb->zUnlockNotify);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (func == NULL || Jsi_ValueIsNull(interp, func)) {
        sqlite3_unlock_notify(jdb->db, 0, 0);
        if( jdb->pUnlockNotify ) {
            Jsi_DecrRefCount(interp, jdb->pUnlockNotify);
        }
        jdb->pUnlockNotify = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pUnlockNotify ) {
            Jsi_DecrRefCount(interp, jdb->pUnlockNotify);
        }
        jdb->pUnlockNotify = func;
        Jsi_IncrRefCount(interp, func);
        if( sqlite3_unlock_notify(jdb->db, dbUnlockNotify, (void*)jdb)) 
            return Jsi_LogError("%s", sqlite3_errmsg(jdb->db));

    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
#endif
}

static Jsi_RC SqliteUpdateHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pUpdateHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pUpdateHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (func == NULL || Jsi_ValueIsNull(interp, func)) {
        sqlite3_update_hook(jdb->db, 0, 0);
        if( jdb->pUpdateHook ) {
            Jsi_DecrRefCount(interp, jdb->pUpdateHook);
        }
        jdb->pUpdateHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pUpdateHook ) {
            Jsi_DecrRefCount(interp, jdb->pUpdateHook);
        }
        jdb->pUpdateHook = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_update_hook(jdb->db, dbUpdateHandler, jdb);

    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}

static Jsi_RC SqliteRollbackHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pRollbackHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pRollbackHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_rollback_hook(jdb->db, 0, 0);
        if( jdb->pRollbackHook ) {
            Jsi_DecrRefCount(interp, jdb->pRollbackHook);
        }
        jdb->pRollbackHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pRollbackHook ) {
            Jsi_DecrRefCount(interp, jdb->pRollbackHook);
        }
        jdb->pRollbackHook = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_rollback_hook(jdb->db, dbRollbackHandler, jdb);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}


static Jsi_RC SqliteWalHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pWalHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pWalHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        sqlite3_rollback_hook(jdb->db, 0, 0);
        if( jdb->pWalHook ) {
            Jsi_DecrRefCount(interp, jdb->pWalHook);
        }
        jdb->pWalHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pWalHook ) {
            Jsi_DecrRefCount(interp, jdb->pWalHook);
        }
        jdb->pWalHook = func;
        Jsi_IncrRefCount(interp, func);
        sqlite3_wal_hook(jdb->db, dbWalHandler, jdb);
    } else 
        return Jsi_LogError("expected null or function");
    return JSI_OK;
}
#endif

#define FN_authorizer JSI_INFO("\
  db.authorizer(FUNC) \
\n\
Invoke the given callback to authorize each SQL operation as it is \
compiled.  5 arguments are appended to the callback before it is \
invoked: \
\n\
  (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...) \
  (2) First descriptive name (depends on authorization type) \
  (3) Second descriptive name \
  (4) Name of the database (ex: 'main', 'temp') \
  (5) Name of trigger that is doing the access \
\n\
The callback should return on of the following strings: SQLITE_OK, \
SQLITE_IGNORE, or SQLITEN_DENY.  Any other return value is an error. \
\n\
If this method is invoked with no arguments, the current authorization \
callback string is returned.")

#ifndef SQLITE_OMIT_AUTHORIZATION
static Jsi_RC SqliteAuthorizorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *auth;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    auth = Jsi_ValueArrayIndex(interp, args, 0);
    if (!auth) {
        if (jdb->zAuth)
            Jsi_ValueDup2(interp, ret, jdb->zAuth);
        return JSI_OK;
    }
    if (Jsi_ValueIsFunction(interp, auth)) {
        if (jdb->zAuth)
            Jsi_DecrRefCount(interp, jdb->zAuth);
        jdb->zAuth = auth;
        Jsi_IncrRefCount(interp, auth);
    } else if (Jsi_ValueIsUndef(interp, auth)) {
        if (jdb->zAuth)
            Jsi_DecrRefCount(interp, jdb->zAuth);
        jdb->zAuth = 0;
    } else 
        return Jsi_LogError("expected function or undefined");
    if( jdb->zAuth ) {
        jdb->interp = interp;
        sqlite3_set_authorizer(jdb->db, dbAuthCallback, jdb);
    } else {
        sqlite3_set_authorizer(jdb->db, 0, 0);
    }
    return JSI_OK;
}
#endif


static const char *copyConflictStrs[] = {
    "ROLLBACK", "ABORT", "FAIL", "IGNORE", "REPLACE", 0
};
enum { CC_ROLLBACK, CC_ABORT, CC_FAIL, CC_IGNORE, CC_REPLACE, CC__MAX };

typedef struct ImportData {
    int limit;
    int conflict;
    bool csv;
    bool headers;
    const char *separator;
    const char *nullvalue;
} ImportData;

static Jsi_OptionSpec ImportOptions[] =
{
    JSI_OPT(BOOL,   ImportData, headers, .help="First row contains column labels"),
    JSI_OPT(BOOL,   ImportData, csv, .help="Treat input values as CSV"),
    JSI_OPT(CUSTOM, ImportData, conflict, .help="Set conflict resolution", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=copyConflictStrs),
    JSI_OPT(INT,    ImportData, limit, .help="Maximum number of lines to load"),
    JSI_OPT(STRKEY, ImportData, nullvalue, .help="Null string"),
    JSI_OPT(STRKEY, ImportData, separator, .help="Separator string; default is comma if csv, else tabs"),
    JSI_OPT_END(ImportData, .help="Options for the Sqlite import command")
};

#define FN_import JSI_INFO("\
Import data from a file into table. SqlOptions include the 'separator' \
to use, which defaults to commas for csv, or tabs otherwise.\
If a column contains a null string, or the \
value of 'nullvalue', a null is inserted for the column. \
A 'conflict' is one of the sqlite conflict algorithms: \
   rollback, abort, fail, ignore, replace \
On success, return the number of lines processed, not necessarily same \
as 'db.changes' due to the conflict algorithm selected. \
")

static Jsi_RC SqliteImportCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_RC rv = JSI_OK;
    int rc;
    char *zTable;               /* Insert data into this table */
    char *zFile;                /* The file from which to extract data */
    const char *zConflict;            /* The conflict algorithm to use */
    sqlite3_stmt *pStmt;        /* A statement */
    int nCol;                   /* Number of columns in the table */
    int nByte;                  /* Number of bytes in an SQL string */
    int i, j;                   /* Loop counters */
    int nSep;                   /* Number of bytes in zSep[] */
    int nNull;                  /* Number of bytes in zNull[] */
    char *zSql;                 /* An SQL statement */
    char *zLine;                /* A single line of input from the file */
    char **azCol;               /* zLine[] broken up into columns */
    const char *zCommit;              /* How to commit changes */
    Jsi_Channel in;                   /* The input file */
    int lineno = 0;             /* Line number of input file */
    int created = 0;
    const char *zSep;
    const char *zNull;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 2);
    ImportData opts = {};

    if (arg) {
        if (Jsi_OptionsProcess(interp, ImportOptions, &opts, arg, 0) < 0)
            return JSI_ERROR;
    }
    zConflict = copyConflictStrs[opts.conflict];
    
    if(opts.separator ) {
        zSep = opts.separator;
    } else {
        zSep = (opts.csv ? "," : "\t");
    }
    if(opts.nullvalue ) {
        zNull = opts.nullvalue;
    } else {
        zNull = "";
    }
    zTable = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 1);
    zFile = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    nSep = Jsi_Strlen(zSep);
    nNull = Jsi_Strlen(zNull);
    if( nSep==0 ) 
        return Jsi_LogError("Error: non-null separator required for copy");


    zSql = sqlite3_mprintf("SELECT * FROM '%q'", zTable);
    if (zSql==0) 
        return Jsi_LogError("Error: bad table: %s", zTable);
    
    if (opts.headers) {
        in = Jsi_Open(interp, fname, "rb");
        if( in==0 ) 
            return Jsi_LogError("Error: cannot open file: %s", zFile);
        if ((zLine = dbLocalGetline(0, in))==0 ) {
            Jsi_Close(in);
            return JSI_ERROR;
        }
        Jsi_Close(in);
        char *zn, *ze, *z = zLine;
        Jsi_DString cStr = {};
        int zlen = 0, icnt = 0;
        Jsi_DSAppend(&cStr, "CREATE TABLE IF NOT EXISTS '", zTable, "' (", NULL);
        while (1) {
            zn = Jsi_Strstr(z, zSep);
            if (!zn) zlen = Jsi_Strlen(z);
            else zlen = zn-z;
            if (zlen<=0) break;
            ze = z+zlen-1;
            Jsi_DSAppend(&cStr, (icnt?",":""), "'", NULL);
            icnt++;
            if (opts.csv && *z=='"' && zn>z && *ze == '"')
                Jsi_DSAppendLen(&cStr, z+1, zlen-2);
            else
                Jsi_DSAppendLen(&cStr, z, zlen);
            Jsi_DSAppend(&cStr, "'", NULL);
            if (!zn) break;
            z = zn+nSep;
        }
        Jsi_DSAppend(&cStr, ");", NULL);
        Jsi_Free(zLine);
        if (zlen<=0) {
            Jsi_DSFree(&cStr);
            Jsi_LogError("null header problem");
            return JSI_ERROR;
        }
        rc = sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);
        Jsi_DSFree(&cStr);
        if (rc) 
            return Jsi_LogError("%s", sqlite3_errmsg(jdb->db));
        created = 1;
    }
    
    nByte = Jsi_Strlen(zSql);
    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);
        sqlite3_free(zSql);
    if( rc ) {
        Jsi_LogError("%s", sqlite3_errmsg(jdb->db));
        nCol = 0;
    } else {
        nCol = sqlite3_column_count(pStmt);
    }
    sqlite3_finalize(pStmt);
    if( nCol==0 ) {
        rc = JSI_ERROR;
        goto bail;
    }
    zSql = (char*)Jsi_Malloc( nByte + 50 + nCol*2 );
    if( zSql==0 ) {
        Jsi_LogError("Error: can't malloc()");
        rc = JSI_ERROR;
        goto bail;
    }
    sqlite3_snprintf(nByte+50, zSql, "INSERT OR %q INTO '%q' VALUES(?",
                     zConflict, zTable);
    j = Jsi_Strlen(zSql);
    for(i=1; i<nCol; i++) {
        zSql[j++] = ',';
        zSql[j++] = '?';
    }
    zSql[j++] = ')';
    zSql[j] = 0;
    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);
    Jsi_Free(zSql);
    if( rc ) {
        Jsi_LogError("Error: %s", sqlite3_errmsg(jdb->db));
        sqlite3_finalize(pStmt);
        return JSI_ERROR;
    }
    in = Jsi_Open(interp, fname, "rb");
    if( in==0 ) {
        Jsi_LogError("Error: cannot open file: %s", zFile);
        sqlite3_finalize(pStmt);
        return JSI_ERROR;
    }
    azCol = (char**)Jsi_Malloc( sizeof(azCol[0])*(nCol+1) );
    if( azCol==0 ) {
        Jsi_LogError("Error: can't malloc()");
        Jsi_Close(in);
        rc = JSI_ERROR;
        goto bail;
    }
    (void)sqlite3_exec(jdb->db, "BEGIN", 0, 0, 0);
    zCommit = "COMMIT";
    while ((zLine = dbLocalGetline(0, in))!=0 ) {
        char *z;
        i = 0;
        lineno++;
        if (opts.limit>0 && lineno > opts.limit) {
            Jsi_Free(zLine);
            break;
        }
        if (lineno == 1 && opts.headers) {
            Jsi_Free(zLine);
            continue;
        }
        if (opts.csv && Jsi_Strchr(zLine,'"')) 
        {
            char *zn, *z = zLine;
            Jsi_DString sStr = {};
            int qcnt = 0;
            i = -1;
            while (*z) if (*z++ == '"') qcnt++;
            z = zLine;
            if (qcnt%2) { /* aggregate quote spanning newlines */
                Jsi_DSAppend(&sStr, zLine, NULL);
                do {
                    lineno++;
                    Jsi_DSAppend(&sStr, "\n", NULL);
                    Jsi_Free(zLine);
                    if (((zLine = dbLocalGetline(0, in)))==0)
                        break;
                    Jsi_DSAppend(&sStr, zLine, NULL);
                    z = zLine;
                    while (*z) if (*z++ == '"') qcnt++;
                } while (qcnt%2);
                z = Jsi_DSValue(&sStr);
            }
            if (qcnt%2) {
                Jsi_DSFree(&sStr);
                Jsi_Free(zLine);
                Jsi_Close(in);
                Jsi_LogError("unterminated string at line: %d", lineno);
                break;
            }
            while (z) {
                if (*z != '\"') { /* Handle un-quoted value */
                    zn = Jsi_Strstr(z, zSep);
                    azCol[++i] = z;
                    if (!zn)
                        break;
                    *zn = 0;
                    z = zn+nSep;
                    continue;
                }
                /* Handle quoted value */
                zn = ++z;
                Jsi_DString cStr = {};
                while (1) {
                    if (!zn)
                        break;
                    if (*zn != '"')
                        Jsi_DSAppendLen(&cStr, zn, 1);
                    else {
                        if (zn[1] == '"') {
                            zn++;
                            Jsi_DSAppendLen(&cStr, "\"", 1);
                        } else if (zn[1] == 0) {
                            break;
                        } else if (Jsi_Strncmp(zn+1,zSep, nSep)==0) {
                            *zn = 0;
                            zn += (nSep + 1);
                            break;
                        } else {
                            /* Invalid, comma should be right after close quote, so just eat quote. */
                            Jsi_DSAppendLen(&cStr, zn, 1);
                        }
                    }
                    zn++;
                }
                Jsi_Strcpy(z, Jsi_DSValue(&cStr));
                Jsi_DSFree(&cStr);
                azCol[++i] = z;
                z = zn;
            }
        } else {
            azCol[0] = zLine;
            for(i=0, z=zLine; *z; z++) {
                if( *z==zSep[0] && Jsi_Strncmp(z, zSep, nSep)==0 ) {
                    *z = 0;
                    i++;
                    if( i<nCol ) {
                        azCol[i] = &z[nSep];
                        z += nSep-1;
                    }
                }
            }
        }
        if( i+1!=nCol ) {
            Jsi_LogError("%s line %d: expected %d columns of data but found %d",
                 zFile, lineno, nCol, i+1);
            zCommit = "ROLLBACK";
            break;
        }
        for(i=0; i<nCol; i++) {
            /* check for null data, if so, bind as null */
            if( (nNull>0 && Jsi_Strcmp(azCol[i], zNull)==0)
                    || Jsi_Strlen(azCol[i])==0
              ) {
                sqlite3_bind_null(pStmt, i+1);
            } else {
                sqlite3_bind_text(pStmt, i+1, azCol[i], -1, SQLITE_STATIC );
            }
        }
        sqlite3_step(pStmt);
        rc = sqlite3_reset(pStmt);
        if (zLine)
            Jsi_Free(zLine);
        if( rc!=SQLITE_OK ) {
            Jsi_LogError("%s at line: %d", sqlite3_errmsg(jdb->db), lineno);
            zCommit = "ROLLBACK";
            break;
        }
    }
    Jsi_Free(azCol);
    Jsi_Close(in);
    sqlite3_finalize(pStmt);
    (void)sqlite3_exec(jdb->db, zCommit, 0, 0, 0);

    if( zCommit[0] == 'C' ) {
        /* success, set result as number of lines processed */
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)lineno);
        rv = JSI_OK;
    } else {
        rv = JSI_ERROR;
    }
    
bail:
    if (rc != JSI_OK && created && opts.conflict == CC_ROLLBACK) {
        Jsi_DString cStr = {};
        Jsi_DSAppend(&cStr, "DROP TABLE IF EXISTS '", zTable, "';", NULL);
        (void)sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);
        Jsi_DSFree(&cStr);
    }
    return rv;
}

/*
** Make sure we have a PACKAGE_VERSION macro defined.  This will be
** defined automatically by the TEA makefile.  But other makefiles
** do not define it.
*/
#ifndef PACKAGE_VERSION
# define PACKAGE_VERSION SQLITE_VERSION
#endif


static Jsi_RC SqliteCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *p;
    if (!(p = dbGetDbHandle(interp, _this, funcPtr)))
        return JSI_ERROR;
    DbClose(p->db);
    p->db = NULL;
    return JSI_OK;
}

#define FN_evaluate JSI_INFO("\
Supports multiple semicolon seperated commands. \
Variable binding is NOT performed, results are discarded, and  \
no value is returned")
static Jsi_RC SqliteEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = SQLITE_OK, rc2;
    Jsi_Db *jdb;
    sqlite3_stmt *pStmt = NULL;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    sqlite3 *db = jdb->db;
    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *zStart = zSql, *zLeftover = NULL, *zErrMsg = NULL;
    int lnum = 1;

    while( zSql && zSql[0] && (SQLITE_OK == rc) ) {
        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);

        if( SQLITE_OK != rc ) {
            break;
        } else {
            if( !pStmt ) {
                /* this happens for a comment or white-space */
                zSql = zLeftover;
                while( isspace(zSql[0]) ) zSql++;
                continue;
            }

            do {
                if (jdb->debug & TMODE_STEP)
                    JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", zSql);
                rc = sqlite3_step(pStmt);
            } while( rc == SQLITE_ROW );
            rc2 = sqlite3_finalize(pStmt);
            if( rc!=SQLITE_NOMEM ) rc = rc2;
            if( rc==SQLITE_OK ) {
                zSql = zLeftover;
                while( isspace(zSql[0]) ) zSql++;
            } else {
            }
        }
    }
 
    if (rc == SQLITE_OK)
        return JSI_OK;
    while (zSql && zStart<zSql) {
        if (zStart[0] == '\n') lnum++;
        zStart++;
    }
    zErrMsg = sqlite3_errmsg(db);
    Jsi_LogError("sqlite error: %s in statement at line %d", (zErrMsg ? zErrMsg : ""), lnum);
    return JSI_ERROR;
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, 
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
};

/*
** Output a single term of CSV.  Actually, p->separator is used for
** the separator, which may or may not be a comma.  p->nullvalue is
** the null value.  Strings are quoted if necessary.
*/
static void dbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)
{
    if( z==0 ) {
        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:"", NULL);
    } else {
        int i;
        int nSep = Jsi_Strlen(p->separator);
        for(i=0; z[i]; i++) {
            if( needCsvQuote[((unsigned char*)z)[i]] || 
                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {
                i = 0;
                break;
            }
        }
        if( i==0 ) {
            Jsi_DSAppend(dStr, "\"", NULL);
            for(i=0; z[i]; i++) {
                if( z[i]=='"' ) Jsi_DSAppend(dStr, "\"", NULL);
                Jsi_DSAppendLen(dStr, z+i, 1);
            }
            Jsi_DSAppend(dStr, "\"", NULL);
        } else {
            Jsi_DSAppend(dStr, z, NULL);
        }
    }
    if( bSep ) {
        Jsi_DSAppend(dStr, p->separator, NULL);
    }
}

static void dbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)
{
    while( *z ) {
        switch (*z) {
        case '<':
            Jsi_DSAppend(dStr, "&lt;", NULL);
            break;
        case '>':
            Jsi_DSAppend(dStr, "&gt;", NULL);
            break;
        case '&':
            Jsi_DSAppend(dStr, "&amp;", NULL);
            break;
        case '\"':
            Jsi_DSAppend(dStr, "&quot;", NULL);
            break;
        case '\'':
            Jsi_DSAppend(dStr, "&#39;", NULL);
            break;
        default:
            Jsi_DSAppendLen(dStr, z, 1);
            break;
        }
        z++;
    }
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
*/
static void dbOutputQuotedString(Jsi_DString *dStr, const char *z) {
    int i;
    int nSingle = 0;
    for(i=0; z[i]; i++) {
        if( z[i]=='\'' ) nSingle++;
    }
    if( nSingle==0 ) {
        Jsi_DSAppend(dStr,"'", z, "'", NULL);
    } else {
        Jsi_DSAppend(dStr,"'", NULL);
        while( *z ) {
            for(i=0; z[i] && z[i]!='\''; i++) {}
            if( i==0 ) {
                Jsi_DSAppend(dStr,"''", NULL);
                z++;
            } else if( z[i]=='\'' ) {
                Jsi_DSAppendLen(dStr,z, i);
                Jsi_DSAppend(dStr,"''", NULL);
                z += i+1;
            } else {
                Jsi_DSAppend(dStr, z, NULL);
                break;
            }
        }
        Jsi_DSAppend(dStr,"'", NULL);
    }
}
/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/
static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){
  int i;
  char out[100], *zBlob = (char *)pBlob;
  Jsi_DSAppend(dStr, "X'", NULL);
  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),"%02x",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }
  Jsi_DSAppend(dStr, "'", NULL);
}

#define FN_sqlexec JSI_INFO("\
Return values in formatted as JSON, HTML, etc. \
, optionally calling function with a result object")
static Jsi_RC SqliteQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc = JSI_OK;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString eStr = {};
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString ddStr, *dStr = &ddStr;
    Jsi_DSInit(dStr);
#endif
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int cnt = 0;
    char **apColName = NULL;
    int *apColType = NULL, isopts = 0;
    DbEvalContext sEval = {};
    QueryOpts opts, *oEopt = NULL;
    opts = jdb->queryOpts;
    opts.callback = NULL;
    opts.width = NULL;
    Jsi_Value *callback = NULL, *width = NULL;
            
    if (arg) {
        if (Jsi_ValueIsFunction(interp,arg)) {
            callback = opts.callback = arg;
        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {
            isopts = 1;
        } else 
            return Jsi_LogError("argument must be a function, or options");
    }

    if (isopts) {
        if (Jsi_OptionsProcess(interp, ExecFmtOptions, &opts, arg, 0) < 0)
            return JSI_ERROR;
        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);
        width = (opts.width ? opts.width : jdb->queryOpts.width);
    }
    if (opts.cdata) {
        Jsi_CDataDb* copts = Jsi_CDataLookup(interp, opts.cdata);
        if (!copts) 
            return Jsi_LogError("unknown cdata name: %s", opts.cdata);
        int n = Jsi_DbQuery(jdb, copts, zSql);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
        return JSI_OK;
    }
    if (!opts.separator) {
        switch (opts.mode) {
            case _JSI_EF_LIST: opts.separator = "|"; break;
            case _JSI_EF_COLUMN: opts.separator = " "; break;
            case _JSI_EF_TABS: opts.separator = "\t"; break;
            default: opts.separator = ",";
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = opts.nocache;
    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)
        goto bail;
    sEval.ret = *ret;
    oEopt = jdb->optPtr;
    jdb->optPtr = &opts;
    if (callback) {
        sEval.tocall = callback;
        if (opts.mode != _JSI_EF_ROWS) {
            Jsi_LogError("'mode' must be 'rows' with 'callback'");
            rc = JSI_ERROR;
            goto bail;
        }
        rc = dbEvalCallCmd(&sEval, interp, JSI_OK);
        goto bail;
    } else
    switch (opts.mode) {
    case _JSI_EF_NONE:
        while(JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        goto bail;
        break;
    case _JSI_EF_JSON:
        if (opts.headers) {
            Jsi_DSAppend(dStr, "[ ", NULL);
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0) {
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    }
                    Jsi_DSAppend(dStr, "]", NULL);
                    cnt++;
                }
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "[", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, "]", NULL);
                cnt++;
                if (opts.limit && cnt>opts.limit) break;
            }
            Jsi_DSAppend(dStr, " ]", NULL);
            
        } else {
            Jsi_DSAppend(dStr, "[ ", NULL);
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "{", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    Jsi_DSAppend(dStr, ":", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, "}", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSAppend(dStr, " ]", NULL);
        }
        break;
        
    case _JSI_EF_JSON2: {
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && 1) {
                    Jsi_DSAppend(dStr, "{ \"names\": [ ", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    }
                    Jsi_DSAppend(dStr, " ], \"values\": [ ", NULL);
                }
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "[", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, " ]", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            if (cnt)
                Jsi_DSAppend(dStr, " ] } ", NULL);
        }
        break;
        
    case _JSI_EF_LIST:
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSAppend(dStr, apColName[i], NULL);
                }
            }

            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                dbEvalSetColumn(&sEval, i, dStr);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        break;
        
    case _JSI_EF_COLUMN: {
        int *wids = NULL;
        Jsi_DString vStr = {};
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i, w;
            int nCol;
            
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && nCol>0) {
                Jsi_DString sStr;
                wids = (int*)Jsi_Calloc(nCol, sizeof(int));
                Jsi_DSInit(&sStr);
                for(i=0; i<nCol; i++) {
                    int j = Jsi_Strlen(apColName[i]);
                    wids[i] = (j<10?10:j);
                    if (width) {
                        Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);
                        if (wv) {
                            Jsi_Number dv;
                            Jsi_ValueGetNumber(interp, wv, &dv);
                            if (dv>0)
                                wids[i] = (int)dv;
                        }
                    }
                    w = (j<wids[i] ? j : wids[i]);
                    Jsi_DSAppendLen(dStr, apColName[i], w);
                    w = (j<wids[i] ? wids[i]-j+1 : 0);
                    while (w-- > 0)
                        Jsi_DSAppend(dStr, " ", NULL);
                }
                for(i=0; i<nCol && opts.headers; i++) {
                    w = wids[i];
                    w -= Jsi_Strlen(apColName[i]);
                    if (i) {
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(&sStr, opts.separator, NULL);
                    }
                    w = wids[i];
                    while (w-- > 0)
                        Jsi_DSAppend(&sStr, "-", NULL);
                }
                if (opts.headers)
                    Jsi_DSAppend(dStr, "\n", Jsi_DSValue(&sStr), "\n", NULL);
                Jsi_DSFree(&sStr);
            }

            if (cnt)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                int nl = Jsi_DSLength(&vStr);
                if (nl > wids[i]) {
                    Jsi_DSSetLength(&vStr, wids[i]);
                    w = 0;
                } else {
                    w = wids[i]-nl;
                }
                Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                while (w-- > 0)
                    Jsi_DSAppend(dStr, " ", NULL);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        if (wids)
            Jsi_Free(wids);
        break;
    }
    
    case _JSI_EF_INSERT: {
        Jsi_DString vStr = {};    
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            const char *tbl = (opts.table ? opts.table : "table");
            if (cnt)
                Jsi_DSAppend(dStr, "\n", NULL);
            Jsi_DSAppend(dStr, "INSERT INTO ", tbl, " VALUES(", NULL);
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            for(i=0; i<nCol; i++) {
                Jsi_Number dv;
                const char *azArg;
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;
                int ptype = sqlite3_column_type(pStmt, i);
                
                azArg = Jsi_DSValue(&vStr);
                const char *zSep = i>0 ? ",": "";
                if( (azArg[i]==0) || (apColType && apColType[i]==SQLITE_NULL) ) {
                  Jsi_DSAppend(dStr, zSep, "NULL", NULL);
                }else if( ptype ==SQLITE_TEXT ) {
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputQuotedString(dStr, azArg);
                }else if (ptype==SQLITE_INTEGER || ptype ==SQLITE_FLOAT) {
                  Jsi_DSAppend(dStr, zSep, azArg, NULL);
                }else if (ptype ==SQLITE_BLOB) {
                  const void *pBlob = sqlite3_column_blob(pStmt, i );
                  int nBlob = sqlite3_column_bytes(pStmt, i);
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputHexBlob(dStr, pBlob, nBlob);
                }else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ){
                  Jsi_DSAppend(dStr, zSep, azArg, NULL);
                }else{
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputQuotedString(dStr, azArg);
                }
            }
            Jsi_DSAppend(dStr, ");", NULL);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
    }

    case _JSI_EF_TABS:
    case _JSI_EF_CSV: {
        Jsi_DString vStr = {};  
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSAppend(dStr, apColName[i], NULL);
                }
            }

            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                if (opts.mode == _JSI_EF_CSV)
                    dbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);
                else
                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_LINE: {
        int i, w = 5, ww;
        int nCol;
        Jsi_DString vStr = {};   
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0) {
                for(i=0; i<nCol; i++) {
                    ww = Jsi_Strlen(apColName[i]);
                    if (ww>w)
                        w = ww;
                }
            }

            for(i=0; i<nCol; i++) {
                Jsi_DString eStr;
                Jsi_DSInit(&eStr);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                Jsi_DSPrintf(&eStr, "%*s = %s", w, apColName[i], Jsi_DSValue(&vStr));
                Jsi_DSAppend(dStr, (cnt?"\n":""), Jsi_DSValue(&eStr), NULL);
                Jsi_DSFree(&eStr);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_HTML: {
        Jsi_DString vStr = {};   
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                Jsi_DSAppend(dStr, "<TR>", NULL);
                for(i=0; i<nCol; i++) {
                    Jsi_DSAppend(dStr, "<TH>", NULL);
                    dbOutputHtmlString(&opts, apColName[i], dStr);
                    Jsi_DSAppend(dStr, "</TH>", NULL);
                }
                Jsi_DSAppend(dStr, "</TR>", NULL);
            }
            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            Jsi_DSAppend(dStr, "<TR>", NULL);
            for(i=0; i<nCol; i++) {
                Jsi_DSAppend(dStr, "<TD>", NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                dbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);
                Jsi_DSAppend(dStr, "</TD>", NULL);
            }
            Jsi_DSAppend(dStr, "</TR>", NULL);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_ROWS:
    {
        Jsi_Value *vcur, *vrow;
        int cnt = 0;
        Jsi_Obj *oall, *ocur;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
            vrow = Jsi_ValueMakeObject(interp, NULL, ocur);
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);
            }
            Jsi_ObjArrayAdd(interp, oall, vrow);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    case _JSI_EF_ARRAYS:
    {
        Jsi_Value *vcur, *vrow;
        int cnt = 0;
        Jsi_Obj *oall, *ocur;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                for(i=0; i<nCol; i++) {
                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                    Jsi_ObjArrayAdd(interp, ocur, vcur);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
            }
            vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjArrayAdd(interp, ocur, vcur);
            }
            Jsi_ObjArrayAdd(interp, oall, vrow);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    case _JSI_EF_ARRAY1D:
    {
        Jsi_Value *vcur;
        int cnt = 0;
        Jsi_Obj *oall;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                    Jsi_ObjArrayAdd(interp, oall, vcur);
                }
            }
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjArrayAdd(interp, oall, vcur);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    }
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));
bail:
    dbEvalFinalize(&sEval);
    if (isopts) {
        Jsi_OptionsFree(interp, ExecFmtOptions, &opts, 0);
    }
    Jsi_DSFree(dStr);
    Jsi_DSFree(&eStr);
    jdb->optPtr = oEopt;
    return rc;
}

static Jsi_RC SqliteOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    DbEvalContext sEval = {};
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    sEval.nocache = jdb->queryOpts.nocache;
    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)
        return rc;
    sEval.ret = *ret;
    sEval.tocall = NULL;
    int cnt = 0;


    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;
        int nCol = sqlite3_column_count(pStmt);
        if (nCol>0)
            dbEvalSetColumnValue(&sEval, 0, ret);
        cnt++;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    return rc;
}

static Jsi_RC SqliteExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    const char *zSql;
    Jsi_DString dStr = {};
    DbEvalContext sEval = {};
    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = jdb->queryOpts.nocache;
    if (dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    int cnt = 0;


    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;
        int nCol = sqlite3_column_count(pStmt);
        if (nCol>0)
            cnt++;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeBool(interp, ret, cnt);
    return rc;
}

static Jsi_RC SqliteFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef SQLITE_OMIT_LOAD_EXTENSION
#if (SQLITE_VERSION_NUMBER>3007009)
    const char *zName = "main";
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Db *jdb;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    if (argc)
        zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    zName = sqlite3_db_filename(jdb->db, zName);
    if (zName)
        Jsi_ValueMakeStringDup(interp, ret, zName);
#endif
#endif
    return JSI_OK;
}

/*
** Find an SqlFunc structure with the given name.  Or create a new
** one if an existing one cannot be found.  Return a pointer to the
** structure.
*/
static SqlFunc *dbFindSqlFunc(Jsi_Db *jdb, const char *zName) {
    SqlFunc *p, *pNew;
    int i;
    pNew = (SqlFunc*)Jsi_Calloc(1, sizeof(*pNew) + Jsi_Strlen(zName) + 1 );
    pNew->sig = SQLITE_SIG_FUNC;
    pNew->zName = (char*)&pNew[1];
    for(i=0; zName[i]; i++) {
        pNew->zName[i] = tolower(zName[i]);
    }
    pNew->zName[i] = 0;
    for(p=jdb->pFunc; p; p=p->pNext) {
        if( Jsi_Strcmp(p->zName, pNew->zName)==0 ) {
            Jsi_Free((char*)pNew);
            return p;
        }
    }
    pNew->interp = jdb->interp;
    pNew->pScript = 0;
    Jsi_DSInit(&pNew->dScript);
    pNew->pNext = jdb->pFunc;
    jdb->pFunc = pNew;
    return pNew;
}

static Jsi_RC SqliteFunctionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SqlFunc *pFunc;
    Jsi_Value *tocall, *nVal;
    char *zName;
    int rc, nArg = -1, argc;
    argc = Jsi_ValueGetLength(interp, args);
    Jsi_Db *jdb;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    tocall = Jsi_ValueArrayIndex(interp, args, 1);
    if (zName == NULL) 
        return Jsi_LogError("expected name");
    if (!Jsi_ValueIsFunction(interp, tocall)) 
        return Jsi_LogError("expected function");
    if (argc == 3) {
        nVal = Jsi_ValueArrayIndex(interp, args, 2);
        if (Jsi_GetIntFromValue(interp, nVal, &nArg) != JSI_OK)
            return JSI_ERROR;
    } else {
        Jsi_FunctionArguments(interp, tocall, &nArg);
    }
    if (nArg > SQLITE_LIMIT_FUNCTION_ARG) 
        return Jsi_LogError("to many args");
    /*  if( argc==6 ){
        const char *z = Jsi_GetString(objv[3]);
        int n = Jsi_Strlen(z);
        if( n>2 && strncmp(z, "-argcount",n)==0 ){
          if( Jsi_GetIntFromObj(interp, objv[4], &nArg) ) return JSI_ERROR;
          if( nArg<0 )
              return Jsi_LogError( "number of arguments must be non-negative");
        }
        pScript = objv[5];
      }else if( argc!=4 ){
        Jsi_WrongNumArgs(interp, 2, objv, "NAME [-argcount N] SCRIPT");
        return JSI_ERROR;
      }else{
        pScript = objv[3];
      }*/
    pFunc = dbFindSqlFunc(jdb, zName);
    if( pFunc==0 ) return JSI_ERROR;
    SQLSIGASSERT(pFunc,FUNC);

    pFunc->tocall = tocall;
    Jsi_IncrRefCount(interp, pFunc->tocall);
    rc = sqlite3_create_function(jdb->db, zName, nArg, SQLITE_UTF8,
                                 pFunc, jsiSqlFunc, 0, 0);

    if( rc!=SQLITE_OK ) {
        rc = JSI_ERROR;
        Jsi_LogError("function create error: %s", (char *)sqlite3_errmsg(jdb->db));
    }
    return JSI_OK;
}

static Jsi_RC SqliteLastInsertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide rowid;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    rowid = dbLastInsertRowid(jdb);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);
    return JSI_OK;
}

static Jsi_RC SqliteInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    sqlite3_interrupt(jdb->db);
    return JSI_OK;
}


static Jsi_RC SqliteCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str =  Jsi_ValueString(interp, s, NULL);
    int isComplete = 0;
    if (str)
        isComplete = sqlite3_complete( str );
    Jsi_ValueMakeBool(interp, ret, isComplete);
    return JSI_OK;
}

static Jsi_RC SqliteEnableLoadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef SQLITE_OMIT_LOAD_EXTENSION
    Jsi_Db *jdb;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    bool onoff;
    if( Jsi_GetBoolFromValue(interp, arg, &onoff) != JSI_OK) {
        return JSI_ERROR;
    }
    sqlite3_enable_load_extension(jdb->db, onoff);
    return JSI_OK;
#else
    Jsi_LogError("extension loading is turned off at compile-time");
    return JSI_ERROR;
#endif
}

static Jsi_RC SqliteErrorCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = sqlite3_errcode(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}


static Jsi_RC SqliteChangesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = sqlite3_changes(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}


static Jsi_RC SqliteTotalChangesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = sqlite3_total_changes(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_restore JSI_INFO("\
   db.restore(FILENAME, ?,DATABASE? ) \
\n\
Open a database file named FILENAME.  Transfer the content \
of FILENAME into the local database DATABASE (default: 'main').")

static Jsi_RC SqliteRestoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    const char *zSrcFile;
    const char *zDestDb;
    sqlite3 *pSrc;
    sqlite3_backup *pBackup;
    int nTimeout = 0;
    int rc;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    int argc = Jsi_ValueGetLength(interp, args);
    if( argc==1 ) {
        zDestDb = "main";
    } else {
        zDestDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    }
    Jsi_DString dStr = {};
    if (!vFile)
        zSrcFile = ":memory:";
    else {
        zSrcFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zSrcFile == NULL) 
            return Jsi_LogError("bad or missing file name");
    }
    rc = sqlite3_open_v2(zSrcFile, &pSrc, SQLITE_OPEN_READONLY, 0);

    if( rc!=SQLITE_OK ) {
        Jsi_LogError("cannot open source database: %s", sqlite3_errmsg(pSrc));
        DbClose(pSrc);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    pBackup = sqlite3_backup_init(jdb->db, zDestDb, pSrc, "main");
    if( pBackup==0 ) {
        Jsi_LogError("restore failed: %s", sqlite3_errmsg(jdb->db));
        DbClose(pSrc);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
            || rc==SQLITE_BUSY ) {
        if( rc==SQLITE_BUSY ) {
            if( nTimeout++ >= 3 ) break;
            sqlite3_sleep(100);
        }
    }
    sqlite3_backup_finish(pBackup);
    Jsi_RC rv;
    if( rc==SQLITE_DONE ) {
        rv = JSI_OK;
    } else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ) {
        Jsi_LogError("restore failed: source database busy");
        rv = JSI_ERROR;
    } else {
        Jsi_LogError("restore failed: %s", sqlite3_errmsg(jdb->db));
        rv = JSI_ERROR;
    }
    Jsi_DSFree(&dStr);
    DbClose(pSrc);
    return rv;
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static Jsi_RC SqliteTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Number n;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_GetNumberFromValue(interp, s, &n);
    sqlite3_busy_timeout( jdb->db, (int)n );
    return JSI_OK;
}
#endif

#define FN_transaction JSI_INFO("\
   db.transaction(FUNC ?,'deferred'|'immediate'|'exclusive'?)\
\n\
Start a new transaction (if we are not already in the midst of a \
transaction) and execute the JS function FUNC.  After FUNC \
completes, either commit the transaction or roll it back if FUNC \
throws an exception.  Or if no new transation was started, do nothing. \
pass the exception on up the stack.")
static Jsi_RC SqliteTransactionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_Db *jdb;

    int argc = Jsi_ValueGetLength(interp, args);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    Jsi_Value *pScript;
    const char *zBegin = "SAVEPOINT _jsi_transaction";

    if( jdb->nTransaction==0 && argc==2 ) {
        Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
        static const char *TTYPE_strs[] = {
            "deferred",   "exclusive",  "immediate", 0
        };
        enum TTYPE_enum {
            TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE
        };
        int ttype;
        if( Jsi_ValueGetIndex(interp, arg, TTYPE_strs, "transaction type",
                              0, &ttype) ) {
            return JSI_ERROR;
        }
        switch( (enum TTYPE_enum)ttype ) {
        case TTYPE_DEFERRED:    /* no-op */
            ;
            break;
        case TTYPE_EXCLUSIVE:
            zBegin = "BEGIN EXCLUSIVE";
            break;
        case TTYPE_IMMEDIATE:
            zBegin = "BEGIN IMMEDIATE";
            break;
        }
    }
    pScript = Jsi_ValueArrayIndex(interp, args, argc-1);
    if(!Jsi_ValueIsFunction(interp, pScript)) 
        return Jsi_LogError("expected function");

    /* Run the SQLite BEGIN command to open a transaction or savepoint. */
    jdb->disableAuth++;
    rc = sqlite3_exec(jdb->db, zBegin, 0, 0 ,0);
    jdb->disableAuth--;
    if( rc!=SQLITE_OK ) 
        return Jsi_LogError("%s", sqlite3_errmsg(jdb->db));
    jdb->nTransaction++;

    /* Evaluate the function , then
    ** call function dbTransPostCmd() to commit (or rollback) the transaction
    ** or savepoint.  */
    Jsi_RC rv = Jsi_FunctionInvoke(interp, pScript, NULL, NULL, NULL);
    rv = dbTransPostCmd(jdb, interp, rv);
    return rv;
}

static Jsi_RC SqliteVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    char *str;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    str=Jsi_Strdup((char *)sqlite3_libversion());
    Jsi_ValueMakeString(interp, ret, str);
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_backup JSI_INFO("\
    db.backup(FILENAME, ?DATABASE?) \
\n\
Open or create a database file named FILENAME.  Transfer the \
content of local database DATABASE (default: 'main') into the \
FILENAME database.")

static Jsi_RC SqliteBackupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_RC rv = JSI_OK;
    int rc;
    const char *zDestFile;
    const char *zSrcDb;
    sqlite3 *pDest;
    sqlite3_backup *pBackup;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    int argc = Jsi_ValueGetLength(interp, args);
    if( argc==1 ) {
        zSrcDb = "main";
    } else {
        zSrcDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    }
    Jsi_DString dStr = {};
    if (!vFile)
        zDestFile = ":memory:";
    else {
        zDestFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zDestFile == NULL) 
            return Jsi_LogError("bad or missing file name");
    }
    rc = sqlite3_open(zDestFile, &pDest);
    if( rc!=SQLITE_OK ) {
        Jsi_LogError("cannot open target database %s: %s", zDestFile, sqlite3_errmsg(pDest));
        DbClose(pDest);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    pBackup = sqlite3_backup_init(pDest, "main", jdb->db, zSrcDb);
    if( pBackup==0 ) {
        Jsi_LogError("backup failed: %s", sqlite3_errmsg(pDest));
        DbClose(pDest);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ) {}
    sqlite3_backup_finish(pBackup);
    if( rc==SQLITE_DONE ) {
        rv = JSI_OK;
    } else {
        Jsi_LogError("backup failed: %s", sqlite3_errmsg(pDest));
        rv = JSI_ERROR;
    }
    Jsi_DSFree(&dStr);
    DbClose(pDest);
    return rv;
}
#endif

static Jsi_RC SqliteConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    //jdb->hasOpts = 1; //TODO: memory leak?
    int oms = jdb->maxStmts;
    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);
    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {
        JSI_DBQUERY_PRINTF( "option maxStmts value %d is not in range 0..%d", jdb->maxStmts, MAX_PREPARED_STMTS);
        jdb->maxStmts = oms;
        rc = JSI_ERROR;
    }
    dbPrepStmtLimit(jdb);
    return rc;
}

static Jsi_CmdSpec sqliteCmds[] = {
    { "Sqlite",         SqliteConstructor,      0,  2,  "file:string=void, options:object=void",
        .help="Create a new db connection to the named file or :memory:",
        .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },
#ifndef SQLITE_OMIT_AUTHORIZATION
    { "authorizor",     SqliteAuthorizorCmd,    0,  1, "callback:function=void", .help="Setup authorizor", .retType=(uint)JSI_TT_FUNCTION, .flags=0, .info=FN_authorizer },
#endif
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "backup",         SqliteBackupCmd,        1,  2, "file:string, dbname:string='main'", .help="Backup db to file", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_backup },
    { "busy",           SqliteBusyCmd,          0,  1, "callback:function=void", .help="Function callback upon open busy", .retType=(uint)JSI_TT_FUNCTION, .flags=0, .info=FN_busy },
#endif
    { "changes",        SqliteChangesCmd,       0,  0, "", .help="Return the number of rows that were modified, inserted, or deleted by last command", .retType=(uint)JSI_TT_NULL },
    { "close",          SqliteCloseCmd,         0,  0, "", .help="Close db", .retType=(uint)JSI_TT_VOID },
#ifndef OMIT_SQLITE_COLLATION
    { "collate",        SqliteCollateCmd,       2,  2, "name:string, callback:function", .help="Create new SQL collation command", .retType=(uint)JSI_TT_VOID },
    { "collation_needed",SqliteCollationNeededCmd,0,  1, "callback:null|function=void", .help="Set/get func to call on unknown collation", .retType=(uint)JSI_TT_FUNCTION },
#endif
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "commit_hook",    SqliteCommitHookCmd,    0,  1, "callback:null|function=void", .help="Set/get func to call on commit", .retType=(uint)JSI_TT_FUNCTION, .flags=0, .info=FN_commithook },
#endif
    { "complete",       SqliteCompleteCmd,      1,  1, "sql:string", .help="Return true if sql is complete", .retType=(uint)JSI_TT_BOOLEAN },
    { "conf",           SqliteConfCmd,          0,  1, "options:string|object=void", .help="Configure options", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },
    { "enable_load_extension", SqliteEnableLoadCmd, 1,  1, "enable:boolean", .help="En/disable loading of extensions (default false)"},
    { "errorcode",      SqliteErrorCodeCmd,     0,  0, "", .help = "Return the numeric error code that was returned by the most recent call to sqlite3_exec()", .retType=(uint)JSI_TT_NULL },
    { "eval",           SqliteEvalCmd,          1,  1, "sql:string", .help="Run sql commands without input/output", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_evaluate },
    { "query",          SqliteQueryCmd,         1,  2, "sql:string, options:function|object=void", .help="Evaluate an sql query with bindings", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_sqlexec, .opts=ExecFmtOptions },
    { "exists",         SqliteExistsCmd,        1,  1, "sql:string", .help="Execute sql, and return true if there is at least one result value", .retType=(uint)JSI_TT_BOOLEAN },
    { "filename",       SqliteFilenameCmd,      0,  1, "name:string='main'", .help="Return filename for named or all attached databases", .retType=(uint)JSI_TT_STRING },
    { "func",           SqliteFunctionCmd,      2,  3, "name:string, callback:function, numArgs:number=void", .help="Register a new function with database", .retType=(uint)JSI_TT_VOID },
    { "import",         SqliteImportCmd,        2,  3, "table:string, file:string, options:object=void", .help="Import data from file into table ", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_import, .opts=ImportOptions },
    { "interrupt",      SqliteInterruptCmd,     0,  0, "", .help="Interrupt in progress statement", .retType=(uint)JSI_TT_VOID },
    { "lastInsert",     SqliteLastInsertCmd,    0,  0, "", .help="Return rowid of last insert", .retType=(uint)JSI_TT_NUMBER },
    { "onecolumn",      SqliteOnecolumnCmd,     1,  1, "sql:string", .help="Execute sql, and return a single value", .retType=(uint)JSI_TT_ANY },
    { "profile",        SqliteProfileCmd,       0,  1, "callback:null|function=void", .help="Set/get func to call on every SQL executed. Call args are: SQL,time", .retType=(uint)JSI_TT_FUNCTION, .flags=0, .info=FN_profile },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "progress",       SqliteProgressCmd,      0,  2, "nth:number=void, callback:null|function=void", .help="Set/get func to call on every N VM opcodes executed", .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "rekey",          SqliteRekeyCmd,         1,  1, "key:string", .help="Change the encryption key on the currently open database", .retType=(uint)JSI_TT_BOOLEAN },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "restore",        SqliteRestoreCmd,       1,  2, "file:string, dbname:string", .help="Restore db from file (default db is 'main')", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_restore },
    { "rollback_hook",  SqliteRollbackHookCmd,  0,  1, "callback:null|function=void", .help="Set/get func to call on rollback", .retType=(uint)JSI_TT_FUNCTION },
    { "timeout",        SqliteTimeoutCmd,       1,  1, "millisecs:number", .help="Delay for the number of milliseconds specified when a file is locked"},
#endif
    { "total_changes",  SqliteTotalChangesCmd,  0,  0, "", .help="Return the number of rows that were modified, inserted, or deleted since db opened", .retType=(uint)JSI_TT_NUMBER },
    { "trace",          SqliteTraceCmd,         0,  1, "callback:null|function=void", .help="Set/get func to trace SQL: Call args are: SQL", .retType=(uint)JSI_TT_FUNCTION, .flags=0, .info=FN_trace },
    { "transaction",    SqliteTransactionCmd,   1,  2, "callback:function, type:string=void", .help="Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_transaction },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "update_hook",    SqliteUpdateHookCmd,    0,  1, "callback:null|function=void", .help="Set/get func to call on update: Call args are: OP,db,table,rowid", .retType=(uint)JSI_TT_FUNCTION },
    { "unlock_notify",  SqliteUnlockNotifyCmd,  0,  1, "callback:null|function=void", .help="Set/get func to call on unlock", .retType=(uint)JSI_TT_FUNCTION },
    { "wal_hook",       SqliteWalHookCmd,       0,  1, "callback:null|function=void", .help="Set/get func to call on wal commit: Call args are: db,numEntries", .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "version",        SqliteVersionCmd,       0,  0, "", .help="Return database verion string", .retType=(uint)JSI_TT_STRING },
    { NULL, 0,0,0,0, .help="Commands for accessing sqlite databases" }
};

//static Jsi_CmdSpec sqliteCmds[];


static Jsi_UserObjReg sqliteobject = {
    .name   = "Sqlite",
    .spec   = sqliteCmds,
    .freefun= sqliteObjFree,
    .istrue = sqliteObjIsTrue,
    .isequ  = sqliteObjEqual
};

/**   new Sqlite(FILENAME,?-vfs VFSNAME?,?-key KEY?,?-readonly BOOLEAN?,
**                           ?-create BOOLEAN?,?-nomutex BOOLEAN?)
**
** This is the sqlite constructior called  using "new Sqlite".
**
** The first argument is the name of the database file.
**
*/

static Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc = JSI_ERROR;
    /* void *cd = clientData; */
    int  flags;
    char *zErrMsg;
    const char *zFile = NULL, *vfs = 0;
    /* In normal use, each JSI interpreter runs in a single thread.  So
    ** by default, we can turn of mutexing on SQLite database connections.
    ** However, for testing purposes it is useful to have mutexes turned
    ** on.  So, by default, mutexes default off.  But if compiled with
    ** SQLITE_JSI_DEFAULT_FULLMUTEX then mutexes default on.
    */
    flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX
    flags |= SQLITE_OPEN_FULLMUTEX;
#else
    flags |= SQLITE_OPEN_NOMUTEX;
#endif

    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_DString dStr = {};
    int ismem = 0;
    Jsi_Obj *userObjPtr;
    Jsi_Value *toacc;
    const char *vf;
    
    if (vFile==NULL || Jsi_ValueIsNull(interp, vFile) ||
        ((vf = Jsi_ValueString(interp, vFile, NULL)) && !Jsi_Strcmp(vf,":memory:"))) {
        zFile = ":memory:";
        ismem = 1;
    } else {
        zFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zFile == NULL) 
            return Jsi_LogError("bad or missing file name");
    }
    zErrMsg = 0;
    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );
    if( db==0 ) {
        Jsi_DSFree(&dStr);
        Jsi_LogError("malloc failed");
        return JSI_ERROR;
    }
    db->sig = SQLITE_SIG_DB;
    db->maxStmts = NUM_PREPARED_STMTS;
    db->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (db->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, db, arg, 0) < 0) {
        Jsi_DSFree(&dStr);
        return JSI_ERROR;

    }
    db->version = SQLITE_VERSION_NUMBER;
    if (ismem == 0 && Jsi_InterpAccess(interp, vFile, db->readonly==0) != JSI_OK) {
        Jsi_LogError("Safe accces denied");
        goto bail;
    }

    if (db->maxStmts<0 || db->maxStmts>MAX_PREPARED_STMTS) {
        Jsi_LogError("option maxStmts value %d is not in range 0..%d", db->maxStmts, MAX_PREPARED_STMTS);
        goto bail;
    }
    if (db->readonly) {
        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);
        flags |= SQLITE_OPEN_READONLY;
    } else {
        flags &= ~SQLITE_OPEN_READONLY;
        flags |= SQLITE_OPEN_READWRITE;
        if (db->nocreate) {
            flags &= ~SQLITE_OPEN_CREATE;
        }
    }
    if (db->vfs)
        vfs = Jsi_ValueToString(interp, db->vfs, NULL);
    if(db->mutex == MUTEX_NONE) {
        flags |= SQLITE_OPEN_NOMUTEX;
        flags &= ~SQLITE_OPEN_FULLMUTEX;
    } else {
        flags &= ~SQLITE_OPEN_NOMUTEX;
    }
    if(db->mutex ==MUTEX_FULL) {
        flags |= SQLITE_OPEN_FULLMUTEX;
        flags &= ~SQLITE_OPEN_NOMUTEX;
    } else {
        flags &= ~SQLITE_OPEN_FULLMUTEX;
    }
  
    if (SQLITE_OK != sqlite3_open_v2(zFile, &db->db, flags, vfs)) {
        Jsi_LogError("db open failed");
        goto bail;
    }
    //Jsi_DSFree(&translatedFilename);

    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {
        zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(db->db));
        DbClose(db->db);
        db->db = 0;
    }
#ifdef SQLITE_HAS_CODEC
    if( db->db && db->key) {
        const char *key = 0;
        if (db->key)
            key = Jsi_ValueString(interp, db->key, NULL);
        if (key)
            sqlite3_key(db->db, key, Jsi_Strlen(key));
    }
#endif
    if( db->db==0 ) {
        sqlite3_free(zErrMsg);
        goto bail;
    }
;
    toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Sqlite", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }
    userObjPtr = Jsi_ValueGetObj(interp, toacc /* constructor obj*/);
    if ((db->objId = Jsi_UserObjNew(interp, &sqliteobject, userObjPtr, db))<0)
        goto bail;
    db->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    db->userObjPtr = userObjPtr;
    //dbSys->cnt = Jsi_UserObjCreate(interp, sqliteobject.name /*dbSys*/, userObjPtr, db);
    db->interp = interp;
    db->optPtr = &db->queryOpts;
    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);
    rc = JSI_OK;
    
bail:
    if (rc != JSI_OK) {
        if (db->hasOpts)
            Jsi_OptionsFree(interp, SqlOptions, db, 0);
        Jsi_Free(db);
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeUndef(interp, ret);
    return rc;
}

#endif

typedef struct {
    Jsi_CDataDb *binds;
    Jsi_StructSpec *rowidPtr, *dirtyPtr;
    int optLen;             /* Length of binds[0].binds */
} OptionBind;

const char *jsi_DbOptionTypeStr(Jsi_OptionId typ, bool cname)
{
    const Jsi_OptionType* ti = Jsi_OptionTypeInfo(typ);
    if (ti)
        return (cname?ti->cName:ti->idName);
    return NULL;
}

static Jsi_RC dbBindOptionStmt(Jsi_Db *jdb, sqlite3_stmt *pStmt, OptionBind *obPtr,
                            int dataIdx, int bindMax, Jsi_CDataDb *dbopts)
{
    Jsi_Interp *interp = jdb->interp;
    int j, k, cnt = 0, idx, sidx = -1, rc = 0;
    Jsi_StructSpec *specPtr, *specs;
    void *rec;
    Jsi_DString *eStr;
    const char *bName;
    int lastBind = sqlite3_bind_parameter_count(pStmt);
    if (lastBind<=0)
        return JSI_OK;
    int structSize = 0;
    Jsi_Wide flags = 0;
    sqlite3_destructor_type statFlags = ((dbopts->noStatic)?SQLITE_TRANSIENT:SQLITE_STATIC);
    specPtr = dbopts[0].sf;
    structSize = specPtr[obPtr->optLen].size;
    
    for (j=1; j<=lastBind; j++) {
        bName = sqlite3_bind_parameter_name(pStmt, j);
        if (bName==NULL || bName[0]==0 || bName[1]==0)
            continue;
        idx = j;
        if (dbopts[0].prefix==0)
            k = 0;
        else {
            for (k=0; dbopts[k].sf; k++) {
                if (bName[0] == dbopts[k].prefix)
                    break;
            }
            if (bindMax>0 && k>=bindMax)
                continue;
            if (!dbopts[k].sf) {
                Jsi_LogError("bad bind: %s", bName);
                continue;
            }
        }
        specs = dbopts[k].sf;
        rec = dbopts[k].data;
        if (k==0) {
            if (dbopts->isMap) {
                Jsi_Map *map = *(typeof(map)*)rec;
                rec = Jsi_MapEntryFind(map, (void*)(intptr_t)dataIdx);
                if (!rec) return JSI_ERROR;
            } else if (dbopts->isPtrs)
                rec = ((void**)rec)[dataIdx];
            else
                rec = ((uchar*)rec)+ (dataIdx * structSize);
        }
        if (bName[0] == '?')
            sidx = atoi(bName+1);
        for (specPtr = specs, cnt=1; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++, cnt++) {
            if (specPtr->flags&JSI_OPT_DB_IGNORE)
                continue;
            if (bName[0] == '?') {
                if (cnt == sidx)
                    break;
            } else {
                const char *sName = specPtr->name;
                if (bName[1] == sName[0] && !Jsi_Strcmp(bName+1, sName))
                    break;
            }
        }
        if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) 
            return Jsi_LogError("unknown bind: %s", bName);

        char *ptr = (char *)rec + specPtr->offset;
        switch (specPtr->id) {
        case JSI_OPTION_BOOL:
            rc = sqlite3_bind_int(pStmt, idx, *(int*)ptr);
            break;
        case JSI_OPTION_INT: rc = sqlite3_bind_int64(pStmt, idx, *(int*)ptr); break;
        case JSI_OPTION_UINT:rc = sqlite3_bind_int64(pStmt, idx, *(uint*)ptr); break;
        case JSI_OPTION_INT8: rc = sqlite3_bind_int64(pStmt, idx, *(int8_t*)ptr); break;
        case JSI_OPTION_UINT8:rc = sqlite3_bind_int64(pStmt, idx, *(uint8_t*)ptr); break;
        case JSI_OPTION_INT16: rc = sqlite3_bind_int64(pStmt, idx, *(int16_t*)ptr); break;
        case JSI_OPTION_UINT16:rc = sqlite3_bind_int64(pStmt, idx, *(uint16_t*)ptr); break;
        case JSI_OPTION_INT32: rc = sqlite3_bind_int64(pStmt, idx, *(int32_t*)ptr); break;
        case JSI_OPTION_UINT32:rc = sqlite3_bind_int64(pStmt, idx, *(uint32_t*)ptr); break;
        case JSI_OPTION_TIME_W:
        case JSI_OPTION_INT64: rc = sqlite3_bind_int64(pStmt, idx, *(int64_t*)ptr); break;
        case JSI_OPTION_UINT64:rc = sqlite3_bind_int64(pStmt, idx, *(uint64_t*)ptr); break;
        case JSI_OPTION_USHORT:rc = sqlite3_bind_int64(pStmt, idx, *(ushort*)ptr); break;
        case JSI_OPTION_SHORT:rc = sqlite3_bind_int64(pStmt, idx, *(short*)ptr); break;
        case JSI_OPTION_LONG:rc = sqlite3_bind_int64(pStmt, idx, *(long*)ptr); break;
        case JSI_OPTION_ULONG:rc = sqlite3_bind_int64(pStmt, idx, *(ulong*)ptr); break;
        case JSI_OPTION_INTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(intptr_t*)ptr); break;
        case JSI_OPTION_UINTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(uintptr_t*)ptr); break;
        case JSI_OPTION_SIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(size_t*)ptr); break;
        case JSI_OPTION_SSIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(ssize_t*)ptr); break;
        case JSI_OPTION_LDOUBLE:rc = sqlite3_bind_int64(pStmt, idx, *(ldouble*)ptr); break;
        case JSI_OPTION_FLOAT:rc = sqlite3_bind_int64(pStmt, idx, *(float*)ptr); break;
        case JSI_OPTION_TIME_T:
            rc = sqlite3_bind_int64(pStmt, idx, (Jsi_Wide)*(time_t*)ptr);
            break;
        case JSI_OPTION_NUMBER:
            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);
            break;
        case JSI_OPTION_TIME_D:
        case JSI_OPTION_DOUBLE:
            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);
            break;
        case JSI_OPTION_CUSTOM: {
            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
            if (cust && cust->formatProc) {
                Jsi_DString dStr;
                Jsi_DSInit(&dStr);
                if ((*cust->formatProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, &dStr, rec, flags) != JSI_OK) {
                    Jsi_DSFree(&dStr);
                    return JSI_ERROR;
                }
                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(&dStr), -1, SQLITE_TRANSIENT );
                Jsi_DSFree(&dStr);
            } else 
                return Jsi_LogError("missing or invalid custom for \"%s\"", specPtr->name);
            break;
        }
        case JSI_OPTION_DSTRING:
            eStr = (Jsi_DString*)ptr;
            if (jdb->optPtr->nullvalue && !Jsi_Strcmp(jdb->optPtr->nullvalue, Jsi_DSValue(eStr)))
                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );
            else
                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(eStr), -1, statFlags );
            break;
        case JSI_OPTION_STRBUF:
            if (jdb->optPtr->nullvalue && ptr && !Jsi_Strcmp(jdb->optPtr->nullvalue, (char*)ptr))
                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );
            else
                rc = sqlite3_bind_text(pStmt, idx, (char*)ptr, -1, statFlags );
            break;
        case JSI_OPTION_STRKEY:
            rc = sqlite3_bind_text(pStmt, idx, *(char**)ptr, -1, SQLITE_STATIC );
            break;
#ifndef JSI_LITE_ONLY
        case JSI_OPTION_STRING:
            rc = sqlite3_bind_text(pStmt, idx, Jsi_ValueString(interp, *((Jsi_Value **)ptr), NULL), -1, statFlags );
            break;
#else
        case JSI_OPTION_STRING:
#endif
        case JSI_OPTION_VALUE: /* Unsupported. */
        case JSI_OPTION_VAR:
        case JSI_OPTION_OBJ:
        case JSI_OPTION_ARRAY:
        case JSI_OPTION_REGEXP:
        case JSI_OPTION_FUNC:
#ifdef __cplusplus
        case JSI_OPTION_END:
        case JSI_OPTION_USEROBJ:
#else
        default:
#endif
            Jsi_LogError("unsupported jdb option type \"%s\" for \"%s\"", jsi_DbOptionTypeStr(specPtr->id, 0), specPtr->name);
            return JSI_ERROR;

        }
        if (rc != SQLITE_OK)
            Jsi_LogError("bind failure: %s", sqlite3_errmsg(jdb->db));
    }
    cnt++;
    return JSI_OK;
}

/* Prepare, bind, then step.
 * If there are results return JSI_OK. On error return JSI_ERROR;
 */
static Jsi_RC dbEvalStepOption(DbEvalContext *p, OptionBind *obPtr, int *cntPtr, int dataIdx, int bindMax, Jsi_CDataDb *dbopts, int *erc) {
    Jsi_Db *jdb = p->jdb;
    int cnt = 0;
    while( p->zSql[0] || p->pPreStmt ) {
        Jsi_RC rc;
        cnt++;
        if( p->pPreStmt==0 ) {
            rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
            if( rc!=JSI_OK ) return rc;
        }
        if (bindMax!=0) {
            rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, obPtr, dataIdx, bindMax, dbopts);
            if( rc!=JSI_OK ) return rc;
        }
        rc = dbEvalStepSub(p, 1, erc);
        if (rc != JSI_BREAK)
            return rc;
        *cntPtr = cnt;
    }
    
    /* Finished */
    return JSI_BREAK;
}

static Jsi_StructSpec* dbLookupSpecFromName(Jsi_StructSpec *specs, const char *name) {
    Jsi_StructSpec *specPtr = NULL;
    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {
        if  (specPtr->flags&JSI_OPT_DB_IGNORE)
            continue;
        const char *cname = specPtr->name;
        if (cname[0] == name[0] && !Jsi_Strncasecmp(cname, name, -1))
            return specPtr;
    }
    return NULL;
}

const char* Jsi_DbKeyAdd(Jsi_Db *jdb, const char *str)
{
#ifndef JSI_LITE_ONLY
    if (jdb->interp)
        return Jsi_KeyAdd(jdb->interp, str);
#endif
    Jsi_HashEntry *hPtr;
    bool isNew;
    hPtr = Jsi_HashEntryNew(jdb->strKeyTbl, str, &isNew);
    assert(hPtr) ;
    return (const char*)Jsi_HashKeyGet(hPtr);
}

static int dbOptSelect(Jsi_Db *jdb, const char *cmd, OptionBind *obPtr, Jsi_CDataDb *dbopts)
{
    void *rec = dbopts[0].data, **recPtrPtr = NULL;
    Jsi_Interp *interp = jdb->interp;
    Jsi_StructSpec *specPtr, *specs = dbopts[0].sf;
    DbEvalContext sEval = {};
    int ccnt = 0;
    Jsi_Wide flags = 0;
    const char *cPtr = Jsi_Strstr(cmd, " %s");
    if (!cPtr) cPtr = Jsi_Strstr(cmd, "\t%s");
    Jsi_DString *eStr;
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString sStr, *dStr = &sStr;
    Jsi_DSInit(dStr);
#endif
    dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0);
    if (dbopts->noCache)
        sEval.nocache = 1;
    Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);
    if (cPtr) {
        Jsi_DSAppend(dStr, " ", NULL);
        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {
            if (specPtr == obPtr->dirtyPtr || (specPtr->flags&JSI_OPT_DB_IGNORE))
                continue;
            if (ccnt)
                Jsi_DSAppendLen(dStr, ",", 1);
            Jsi_DSAppend(dStr, "[", specPtr->name, "]", NULL);
            ccnt++; 
        }
        Jsi_DSAppend(dStr, cPtr+3, NULL);
    }
    sEval.zSql = Jsi_DSValue(dStr);
    sEval.nocache = jdb->optPtr->nocache;
    int rc = JSI_ERROR, erc = -1, structSize = 0;
    int cnt = 0, dataMax = (dbopts->isPtr2?0:1);
    int multi = (dbopts->isPtr2!=0);
    int dnum = dbopts[0].arrSize;
    if (dnum<=0 && !dbopts->isPtr2) {
        dataMax = dnum = 1;
    }
    if (dnum>1) {
        multi = 1;
        dataMax = dbopts[0].arrSize;
    }
    if (dbopts->isPtr2) {
        recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */
        rec = *recPtrPtr;
    }
    structSize = specs[obPtr->optLen].size;

    cnt = 0;
    int ncnt = 0, bindMax = -1, dataIdx = -1;
    while(1) {
        dataIdx++;
        if (dataIdx>=dataMax) {
            if (!dbopts->isPtr2)
                break;
            else {
            /* Handle fully dynamic allocation of memory. */
#ifndef JSI_DB_MAXDYN_SIZE
#define JSI_DB_MAXDYN_SIZE 100000000
#endif
#ifndef JSI_DB_DYN_INCR
#define JSI_DB_DYN_INCR 16
#endif
                int ddMax = (dbopts->maxSize>0?dbopts->maxSize:JSI_DB_MAXDYN_SIZE);
                if (dataMax>=ddMax)
                    break;
                int olddm = dataMax;
                dataMax += JSI_DB_DYN_INCR;
                if (dataMax>ddMax)
                    dataMax = ddMax;
                if (!olddm)
                    rec = Jsi_Calloc(dataMax+1, sizeof(void*));
                else {
                    rec = Jsi_Realloc(rec, (dataMax+1)*sizeof(void*));
                    memset((char*)rec+olddm*sizeof(void*), 0, (dataMax-olddm+1)*sizeof(void*));
                }
                *recPtrPtr = rec;
            }
        }

        rc = dbEvalStepOption(&sEval, obPtr, &ncnt, dataIdx, bindMax, dbopts, &erc);
        if (rc == JSI_ERROR)
            break;
        if (rc != JSI_OK)
            break;
        cnt += ncnt;
        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;
        int idx;
        int nCol;
        char **apColName;
        const char *str;
        int *apColType;
        void *prec = rec;
        bindMax = 0;

        if (dbopts->isPtr2 || dbopts->isPtrs) {
            prec = ((void**)rec)[dataIdx];
            if (!prec)
                ((void**)rec)[dataIdx] = prec = Jsi_Calloc(1, structSize);
        } else
                prec = (char*)rec + (dataIdx * structSize);
        dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
        for (idx=0; idx<nCol; idx++) {
            specPtr = dbLookupSpecFromName(specs, apColName[idx]);
            if (!specPtr) {
                Jsi_LogError("unknown column name: %s", apColName[idx]);
                goto bail;
            }          
            if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) {
                Jsi_LogError("unknown option type \"%d\" for \"%s\"", specPtr->id, specPtr->name);
                goto bail;
            }
            char *ptr = (char*)prec + specPtr->offset;

            switch (specPtr->id) {
                case JSI_OPTION_BOOL:
                    *(int*)ptr = sqlite3_column_int(pStmt, idx);
                    break;
                case JSI_OPTION_INT: *(int*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_UINT: *(uint*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_INTPTR_T: *(intptr_t*)ptr = (intptr_t)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_UINTPTR_T: *(uintptr_t*)ptr = (uintptr_t)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_SIZE_T: *(size_t*)ptr = (size_t)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_SSIZE_T: *(ssize_t*)ptr = (ssize_t)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_SHORT: *(short*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_USHORT: *(ushort*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_LONG: *(long*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_ULONG: *(ulong*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_INT8: *(int8_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_UINT8: *(uint8_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_INT16: *(int16_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_UINT16: *(uint16_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_INT32: *(int32_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_UINT32: *(uint32_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_INT64: *(int64_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_TIME_W:
                case JSI_OPTION_UINT64: *(uint64_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;
                case JSI_OPTION_TIME_T:
                    *(time_t*)ptr = (time_t)sqlite3_column_int64(pStmt, idx);
                    break;
                case JSI_OPTION_NUMBER:
                    *(Jsi_Number*)ptr = (Jsi_Number)sqlite3_column_double(pStmt, idx);
                    break;
                case JSI_OPTION_TIME_D:
                case JSI_OPTION_FLOAT:
                    *(float*)ptr = (float)sqlite3_column_double(pStmt, idx);
                    break;
                case JSI_OPTION_DOUBLE:
                    *(double*)ptr = (double)sqlite3_column_double(pStmt, idx);
                    break;
                case JSI_OPTION_LDOUBLE:
                    *(ldouble*)ptr = (ldouble)sqlite3_column_double(pStmt, idx);
                    break;
                case JSI_OPTION_DSTRING:
                    eStr = (Jsi_DString*)ptr;
                    str = (char*)sqlite3_column_text(pStmt, idx );
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    Jsi_DSSet(eStr, str?str:"");
                    break;
                case JSI_OPTION_STRBUF:
                    str = (char*)sqlite3_column_text(pStmt, idx );
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    strncpy((char*)ptr, str?str:"", specPtr->size);
                    ((char*)ptr)[specPtr->size-1] = 0;
                    break;
                case JSI_OPTION_CUSTOM: {
                    Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
                    if (cust && cust->parseProc) {
                        str = (char*)sqlite3_column_text(pStmt, idx );
                        if ((*cust->parseProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, str, prec, flags) != JSI_OK) {
                            goto bail;
                        }
                    } else {
                        Jsi_LogError("missing or invalid custom for \"%s\"", specPtr->name);
                        goto bail;
                    }
                    break;
                }
                case JSI_OPTION_STRKEY:
                    str = (char*)sqlite3_column_text(pStmt, idx );
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    *(char**)ptr = (str?(char*)Jsi_DbKeyAdd(jdb, str):NULL);
                    break;
#ifndef JSI_LITE_ONLY
                case JSI_OPTION_STRING: {
                    Jsi_Value *vPtr = *((Jsi_Value **)ptr);
                    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {
                        if (vPtr) Jsi_DecrRefCount(interp, vPtr);
                        *((Jsi_Value **)ptr) = NULL;
                    }
                    str = (char*)sqlite3_column_text(pStmt, idx );
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    if (str) {
                        vPtr = Jsi_ValueNewStringDup(interp, str);
                        *((Jsi_Value **)ptr) = vPtr;
                    }
                    break;
                }
#else
                case JSI_OPTION_STRING:        
#endif
                case JSI_OPTION_VALUE: /* The rest are unsupported. */
                case JSI_OPTION_VAR:
                case JSI_OPTION_OBJ:
                case JSI_OPTION_ARRAY:
                case JSI_OPTION_REGEXP:
                case JSI_OPTION_FUNC:
                
#ifdef __cplusplus
                case JSI_OPTION_USEROBJ:
                case JSI_OPTION_END:
#else
                default:
#endif
                    JSI_DBQUERY_PRINTF( "unsupported type: %d:%s\n", specPtr->id,
                        jsi_DbOptionTypeStr(specPtr->id, 0));
                    break;
            }
        }
        if (dbopts[0].callback)
            dbopts[0].callback(interp, dbopts, prec);
        cnt++;
        if (!multi)
            break;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    return (rc==JSI_OK?cnt:erc);

bail:
    dbEvalFinalize(&sEval);
    return erc;
}

static int jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)
{
    int k, cnt, erc = -1;
    Jsi_CDataDb statbinds[] = {{}, {}};
    if (!dbopts) dbopts = statbinds;
    OptionBind ob = {.binds = dbopts};
    Jsi_StructSpec *specPtr, *specs;
    Jsi_Interp *interp = jdb->interp;
    if (!query) query="";
    if (query[0]==';') {
        if (!dbExecCmd(jdb, query+1, &erc)) {
            Jsi_LogError("EXEC ERROR=\"%s\", SQL=\"%s\"", sqlite3_errmsg(jdb->db), query);
            return erc;
        }
        return 0;
    }
    const char *cPtr = Jsi_Strstr(query, " %s");
    if (!cPtr) cPtr = Jsi_Strstr(query, "\t%s");
    if (!dbopts) {
        Jsi_LogError("dbopts may not be null");
        return -1;
    }
    if (!dbopts[0].data) {
        Jsi_LogError("data may not be null");
        return -1;
    }
    if (!dbopts[0].sf) {
        Jsi_LogError("specs may not be null");
        return -1;
    }
    for (k=0; dbopts[k].sf; k++) {
        if (dbopts[k].arrSize>1 || k==0) {
            int scnt = 0;
            for (specPtr = dbopts[k].sf, scnt=0; specPtr->id>=JSI_OPTION_BOOL
                && specPtr->id < JSI_OPTION_END; specPtr++, scnt++) {
                if (specPtr->flags&JSI_OPT_DB_IGNORE)
                    continue;
                if (k==0) {
                    if (specPtr->flags&JSI_OPT_DB_ROWID) {
                        if (specPtr->id != JSI_OPTION_INT64) {
                            Jsi_LogError("rowid flag must be a wide field: %s", specPtr->name);
                            return -1;
                        }
                        ob.rowidPtr = specPtr;
                    }
                    if (specPtr->flags&JSI_OPT_DB_DIRTY) {
                        if (specPtr->id == JSI_OPTION_BOOL || specPtr->id == JSI_OPTION_INT) {
                            ob.dirtyPtr = specPtr;
                        } else {
                            Jsi_LogError("dirty flag must be a int/bool field: %s", specPtr->name);
                            return -1;
                        }
                    }
                            
                }
            }
            if (k==0)
                ob.optLen = scnt;
            assert(specPtr->id == JSI_OPTION_END);
        }
        if (!dbopts[k].prefix) break;
    }
    specs = dbopts[0].sf;
    int structSize = specs[ob.optLen].size;
    if (dbopts->memClear || dbopts->memFree) {
        cnt = dbopts[0].arrSize;
        void *rec = dbopts[0].data, *prec = rec;
        void **recPtrPtr = NULL;
        if (dbopts->isPtr2) {
            recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */
            rec = *recPtrPtr;
        }
        if (cnt<=0 && rec && dbopts->isPtr2) {
            for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);
        }
        for (k=0; k<cnt; k++) {
            if (dbopts->isPtr2 || dbopts->isPtrs)
                prec = ((void**)rec)[k];
            else
                prec = (char*)rec + (k * structSize);
            if (!prec)
                continue;
            Jsi_OptionsFree(interp, (Jsi_OptionSpec*)specs, prec, 0);
            if (dbopts->isPtr2 || dbopts->isPtrs) {
                Jsi_Free(prec);
            }
        }
        if (recPtrPtr) {
            Jsi_Free(*recPtrPtr);
            *recPtrPtr = NULL;
        }
        if (query == NULL || query[0] == 0)
            return 0;
    }
    
    if (!Jsi_Strncasecmp(query, "SELECT", 6))
        return dbOptSelect(jdb, query, &ob, dbopts);
        
    DbEvalContext sEval = {};
    int insert = 0, replace = 0, update = 0;
    char nbuf[100], *bPtr;
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString sStr, *dStr = &sStr;
    Jsi_DSInit(dStr);
#endif
    if (dbopts->noCache)
        sEval.nocache = 1;
    if (dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0) != JSI_OK)
        return -1;
    int dataMax = dbopts[0].arrSize;
    cnt = 0;
    if (dataMax==0)
        dataMax = 1;
    char ch[2];

    ch[0] = dbopts[0].prefix;
    ch[1] = 0;
    if (!ch[0])
        ch[0] = ':';
    if ((update=(Jsi_Strncasecmp(query, "UPDATE", 6)==0))) {
        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);
        if (cPtr) {
            Jsi_DSAppend(dStr, " ", NULL);
            int cidx = 0;
            int killf = (JSI_OPT_DB_IGNORE|JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);
            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || (specPtr->flags&killf))
                    continue;
                const char *fname = specPtr->name;
                if (ch[0] == '?')
                    snprintf(bPtr=nbuf, sizeof(nbuf), "%d", cidx+1);
                else
                    bPtr = (char*)specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), "[", fname, "]=",
                    ch, bPtr, NULL);
                cnt++;
            }
            Jsi_DSAppend(dStr, cPtr+3, NULL);
        }
    } else if ((insert=(Jsi_Strncasecmp(query, "INSERT", 6)==0))
        || (replace=(Jsi_Strncasecmp(query, "REPLACE", 7)==0))) {
        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);
        if (cPtr) {
            Jsi_DSAppend(dStr, " (", NULL);
            int killf = JSI_OPT_DB_IGNORE;
            if (replace)
                killf |= (JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);
            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || specPtr->flags&killf)
                    continue;
                const char *fname = specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), "[", fname, "]", NULL);
                cnt++;
            }
            Jsi_DSAppendLen(dStr,") VALUES(", -1);
            cnt = 0;
            int cidx = 0;
            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr
                    || specPtr->flags&killf)
                    continue;
                if (ch[0] == '?')
                    snprintf(bPtr=nbuf, sizeof(nbuf), "%d", cidx+1);
                else
                    bPtr = (char*)specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), ch, bPtr, NULL);
                cnt++;
            }
            Jsi_DSAppend(dStr,")", cPtr+3, NULL);
        }
    } else if (!Jsi_Strncasecmp(query, "DELETE", 6)) {
        Jsi_DSAppend(dStr, query, NULL);
    } else {
        Jsi_LogError("unrecognized query \"%s\": expected one of: SELECT, UPDATE, INSERT, REPLACE or DELETE", query);
        return -1;
    }
    sEval.zSql = Jsi_DSValue(dStr);

    int rc, bindMax = -1, dataIdx = 0;
    cnt = 0;
    int ismodify = (replace||insert||update);
    int isnew = (replace||insert);
    int didBegin = 0;
    DbEvalContext *p = &sEval;
    rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
    if( rc!=JSI_OK ) return -1;
    if (dataMax>1 && !dbopts->noBegin) {
        didBegin = 1;
        if (!dbExecCmd(jdb, JSI_DBQUERY_BEGIN_STR, &erc))
            goto bail;
    }
    while (dataIdx<dataMax) {
        if (ismodify && ob.dirtyPtr && (dbopts->dirtyOnly)) { /* Check to limit updates to dirty values only. */
            void *rec = dbopts[0].data;
            if (dbopts->isPtrs || dbopts->isPtr2)
                rec = ((void**)rec)[dataIdx];
            else
                rec = (char*)rec + (dataIdx * structSize);
            char *ptr = (char*)rec + ob.dirtyPtr->offset;
            int isDirty = *(int*)ptr;
            int bit = 0;
            if (ob.dirtyPtr->id == JSI_OPTION_BOOL)
                bit = (uintptr_t)ob.dirtyPtr->data;
            if (!(isDirty&(1<<(bit)))) {
                dataIdx++;
                continue;
            }
            isDirty &= ~(1<<(bit));
            *(int*)ptr = isDirty; /* Note that the dirty bit is cleared, even upon error.*/
        }
        rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, &ob, dataIdx, bindMax, dbopts);
        if( rc!=JSI_OK )
            goto bail;
        bindMax = 1;
        rc = dbEvalStepSub(p, (dataIdx>=dataMax), &erc);
        if (rc == JSI_ERROR)
            goto bail;
        cnt += sqlite3_changes(jdb->db);
        if (rc != JSI_OK && rc != JSI_BREAK)
            break;
        if (ob.rowidPtr && isnew) {
            void *rec = dbopts[0].data;
            if (dbopts->isPtrs || dbopts->isPtr2)
                rec = ((void**)rec)[dataIdx];
            else
                rec = (char*)rec + (dataIdx * structSize);
            char *ptr = (char*)rec + ob.rowidPtr->offset;
            *(Jsi_Wide*)ptr = dbLastInsertRowid(jdb);
        }
        dataIdx++;
    }
    if (didBegin && !dbExecCmd(jdb, JSI_DBQUERY_COMMIT_STR, &erc))
        rc = JSI_ERROR;
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    return (rc==JSI_OK?cnt:erc);

bail:
    dbEvalFinalize(&sEval);
    if (didBegin)
        dbExecCmd(jdb, JSI_DBQUERY_ROLLBACK_STR, NULL);
    return erc;
}

int
Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)
{
    int rc = jsi_DbQuery(jdb, dbopts, query);
#ifdef JSI_DBQUERY_ERRORCMD
    if (rc<0)
        rc = JSI_DBQUERY_ERRORCMD(jdb, specs, data, arrSize, query, dopts, rc);
#endif
    return rc;
}

void *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)
{
    SQLSIGASSERT(jdb,DB);
    return jdb->db;
}

/* This is the non-script, JSI_LITE_ONLY creator for Jsi_Db */
Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)
{
    char *zErrMsg;
#ifdef JSI_LITE_ONLY
    if (0) { /* Hack to get rid of compiler warnings. */
        const char **ee = execFmtStrs;
        ee = mtxStrs;
        ee = trcModeStrs;
        ee = ee;
    }
#endif
    int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX
    flags |= SQLITE_OPEN_FULLMUTEX;
#else
    flags |= SQLITE_OPEN_NOMUTEX;
#endif
    if (!zFile)
        zFile = ":memory:";
    zErrMsg = 0;
    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );
    if( db==0 ) {
        JSI_DBQUERY_PRINTF( "malloc failed\n");
        return NULL;
    }
    db->sig = SQLITE_SIG_DB;
    db->maxStmts = NUM_PREPARED_STMTS;
    db->optPtr = &db->queryOpts;

    if (inFlags&JSI_DBI_READONLY) {
        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);
        flags |= SQLITE_OPEN_READONLY;
    } else {
        flags &= ~SQLITE_OPEN_READONLY;
        flags |= SQLITE_OPEN_READWRITE;
        if (inFlags&JSI_DBI_NOCREATE) {
            flags &= ~SQLITE_OPEN_CREATE;
        }
    }
    if(inFlags&JSI_DBI_NO_MUTEX) {
        flags |= SQLITE_OPEN_NOMUTEX;
        flags &= ~SQLITE_OPEN_FULLMUTEX;
    } else {
        flags &= ~SQLITE_OPEN_NOMUTEX;
    }
    if(inFlags&JSI_DBI_FULL_MUTEX) {
        flags |= SQLITE_OPEN_FULLMUTEX;
        flags &= ~SQLITE_OPEN_NOMUTEX;
    } else {
        flags &= ~SQLITE_OPEN_FULLMUTEX;
    }
    char cpath[PATH_MAX];
    char *npath = Jsi_FileRealpathStr(NULL, zFile, cpath);
    
    if (SQLITE_OK != sqlite3_open_v2(npath, &db->db, flags, NULL)) {
        JSI_DBQUERY_PRINTF( "db open failed\n");
        goto bail;
    }
    //Jsi_DSFree(&translatedFilename);

    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {
        zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(db->db));
        DbClose(db->db);
        db->db = 0;
    }
    if( db->db==0 ) {
        JSI_DBQUERY_PRINTF( "Db open failed %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
        goto bail;
    }
    db->stmtHash = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);
    db->strKeyTbl = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);
    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);
    return db;
    
bail:
    return NULL;
}

#ifndef JSI_LITE_ONLY

static Jsi_RC Jsi_DoneSqlite(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &sqliteobject);
    const char *provide = "Sqlite";
    Jsi_PkgProvide(interp, provide, -1, NULL);
    return JSI_OK;
}
#ifdef JSI_DB_TEST
#include "c-demos/dbdemo.c"
#endif

Jsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release)
{
    if (release) return Jsi_DoneSqlite(interp);
    Jsi_Hash* dbSys;
#if JSI_USE_STUBS
    if (Jsi_StubsInit(interp, 0) != JSI_OK)
        return JSI_ERROR;
#endif

    const char *provide = "Sqlite";
    if (Jsi_PkgProvide(interp, provide, 1, Jsi_InitSqlite) != JSI_OK)
        return JSI_ERROR;
    if (!(dbSys = Jsi_UserObjRegister(interp, &sqliteobject))) 
        return Jsi_LogError("Failed to init sqlite extension");
    if (!Jsi_CommandCreateSpecs(interp, sqliteobject.name, sqliteCmds, dbSys, JSI_CMDSPEC_ISOBJ))
        return JSI_ERROR;
#ifdef JSI_DB_TEST
    if (getenv("RUN_DB_TEST"))
        TestSqlite(interp);
#endif
    jsi_DbVfs **dbVfsPtrPtr = (jsi_DbVfs **)Jsi_InterpGetData(interp, JSI_SQLITE_DB_VFS, NULL);
    if (dbVfsPtrPtr)
        *dbVfsPtrPtr = &SqliteDbVfs;
    return JSI_OK;
}
#endif //JSI_LITE_ONLY

#else // !JSI__SQLITE
/* Linking for when Sqlite is not compiled-in. */

static jsi_DbVfs *jsi_dbVfsPtr = NULL;
#ifndef JSI_LITE_ONLY


Jsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release)
{
    if (!release) Jsi_InterpSetData(interp, JSI_SQLITE_DB_VFS, &jsi_dbVfsPtr, NULL);
    return JSI_OK;
}

Jsi_RC Jsi_doneSqlite(Jsi_Interp *interp)
{
    Jsi_InterpFreeData(interp, JSI_SQLITE_DB_VFS);
    return JSI_OK;
}
#endif

int
Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dPtr, const char *query)
{
    if (!jsi_dbVfsPtr) {
        printf( "Sqlite unsupported\n");
        return -1;
    }
    return jsi_dbVfsPtr->dbcQuery(jdb, dPtr, query);
}

void *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)
{
    if (!jsi_dbVfsPtr) {
        printf( "Sqlite unsupported\n");
        return NULL;
    }
    return jsi_dbVfsPtr->dbHandle(interp, jdb);
}

Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)
{
    if (!jsi_dbVfsPtr) {
        printf( "Sqlite unsupported\n");
        return NULL;
    }
    return jsi_dbVfsPtr->dbNew(zFile, inFlags);
}


#endif
#ifndef JSI_LITE_ONLY
#if JSI__WEBSOCKET==1
#if JSI__MEMDEBUG
#include "jsiInt.h"
#else

#ifndef JSI_AMALGAMATION
#include "jsi.h"
#endif
JSI_EXTENSION_INI

#define jsi_Sig int

#endif /* JSI_MEM_DEBUG */

#include <time.h>
#include <sys/time.h>

#include <ctype.h>

#ifdef CMAKE_BUILD
#include "lws_config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <assert.h>
#include <limits.h>
#include <fcntl.h>
#ifdef WIN32
#define _GET_TIME_OF_DAY_H
#ifdef EXTERNAL_POLL
    #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #endif
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #include <stddef.h>

    #include "websock-w32.h"
#endif

#else /* WIN32 */
#include <syslog.h>
#include <unistd.h>
#endif /* WIN32 */

#include <signal.h>

#include <libwebsockets.h>
#if (LWS_LIBRARY_VERSION_MAJOR != 1 || LWS_LIBRARY_VERSION_MINOR != 7)
// Newer versions of lws have changed incompatibly.
#error "Version 1.7 of websockets is required, but have: " ## LWS_LIBRARY_VERSION
#endif

//#define LWS_NO_EXTENSIONS

#ifdef EXTERNAL_POLL
static int max_poll_elements;
static struct pollfd *jws_pollfds;
static int *fd_lookup;
static int jws_num_pollfds;
static int force_exit = 0;
#endif /* EXTERNAL_POLL */

typedef enum {  PWS_DEAD, PWS_HTTP, PWS_CONNECTED, PWS_RECV, PWS_SENT, PWS_SENDERR } pws_state;
enum { JWS_SIG_SYS=0xdeadbeea, JWS_SIG_OBJ, JWS_SIG_PWS };

#ifndef NDEBUG
#ifndef _JSI_MEMCLEAR
#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));
#endif
#else
#define _JSI_MEMCLEAR(s)
#endif
#define WSSIGASSERT(s,n) assert(s->sig == JWS_SIG_##n)

enum {
    /* always first */
    JWS_PROTOCOL_HTTP = 0,
    JWS_PROTOCOL_WEBSOCK,
    /* always last */
    JWS_PROTOCOL__MAX
};

#ifdef interface
#undef interface
#endif

typedef struct { /* Interp wide data. */
    uint sig;
    Jsi_Interp *interp;
    Jsi_Hash *wsTable;
    int wIdx;
} jws_ObjInterpData;

typedef struct {
    int sentCnt, recvCnt, recvErrCnt, sentErrCnt, httpCnt, uploadCnt;
    time_t sentLast, recvLast, recvErrLast, sentErrLast, httpLast;
    time_t uploadStart, uploadLast, uploadEnd;
    int redirCnt;
    time_t redirLast;
    int connectCnt;
} jws_StatData;

typedef struct { /* Per server (or client) data. */
    uint sig;
    jws_ObjInterpData *interpData;
    Jsi_Interp *interp;
    Jsi_Hash *pssTable;
    Jsi_Value *onAuth, *onCloseLast, *onClose, *onConnect, *onOpen, *onRecv,
        *onUpload, *redirectUrl, *defaultUrl, *onGet, *onUnknown,
        *rootdir, *interface, *address, *mimeTypes;
    bool client, noUpdate, noWebsock, noWarn, use_ssl, local, defHandlers, handlersPkg;
    int version;
    int idx;
    int port;
    int maxUpload;
    int maxDownload;
    jws_StatData stats;
    char *iface;
    const char *clientName;
    const char *clientIP;
    const char *useridPass;
    struct lws_context *instCtx;
    Jsi_Value *getRegexp;
    unsigned int oldus;
    int opts;
    int hasOpts;
    int debug;
    int maxConnects;
    int daemonize;
    int deleted;
    int close_test;
    int createCnt;
    int redirAllCnt;
    bool redirDisable;
    int recvBufSize, recvBufCnt;
    int recvBufTimeout;
    int lastRevCnt; // For update
    time_t createLast;
    time_t startTime;
    char *cmdName;
    struct lws *wsi_choked[20];
    int num_wsi_choked;
    struct lws *wsi;

    struct lws_context *context;
    struct lws_context_creation_info info;
    Jsi_Event *event;
    Jsi_Obj *fobj;
    Jsi_Hash *handlers;
    int objId;
    struct lws_protocols protocols[JWS_PROTOCOL__MAX+1];
    int ietf_version;
    int rx_buffer_size;
    char *ssl_cert_filepath;
    char *ssl_private_key_filepath;
    int ws_uid;
    int ws_gid;
    char *cl_host;
    char *cl_origin;
    // Preserve headers from http for use in websockets.
    int sfd;        // File descriptor for http.
    int hdrSz[200]; // Space for up to 100 headers
    int hdrNum;     // Num of above.
    Jsi_DString dHdrs; // Store header string here.
} jws_CmdObj;

typedef struct { /* Per session connection (to each server) */
    uint sig;
    jws_CmdObj *cmdPtr;
    pws_state state;
    jws_StatData stats;
    struct lws *wsi;
    Jsi_HashEntry *hPtr;
    void *user;
    int cnt;
    lws_filefd_type fd;
    int wid;
    int sfd;
    bool isWebsock;
    const char *clientName;
    const char *clientIP;
    int hdrSz[200]; // Space for up to 100 headers
    int hdrNum;     // Num of above.
    
    // Pointers to reset.
    Jsi_DString dHdrs; // Store header string here.
    Jsi_Stack *stack;
    Jsi_DString uploadData; // Space for file upload data.
    Jsi_DString recvBuf; // To buffer recv when recvJSON is true.
} jws_Pss;

typedef struct {
    Jsi_Value *val, *objVar;
    const char *arg;
    int triedLoad;
    int flags;
} jws_Hander;

#ifndef jsi_IIOF
#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY
#define jsi_IIRO .flags=JSI_OPT_READ_ONLY
#endif

static Jsi_OptionSpec WPSStats[] =
{
    JSI_OPT(INT,        jws_StatData, connectCnt,   .help="Number of active connections", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, httpCnt,      .help="Number of http reqs", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, httpLast,     .help="Time of last http reqs", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, recvCnt,      .help="Number of recieves", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, recvLast,     .help="Time of last recv", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, redirLast,    .help="Time of last redirect", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, redirCnt,     .help="Count of redirects", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, sentCnt,      .help="Number of sends", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, sentLast,     .help="Time of last send", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, sentErrCnt,   .help="Number of sends", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, sentErrLast,  .help="Time of last sendErr", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, sentErrLast,  .help="Time of last sendErr", jsi_IIRO),
    JSI_OPT(INT,        jws_StatData, uploadCnt,    .help="Number of uploads", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, uploadEnd,    .help="Time of upload end", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, uploadLast,   .help="Time of last upload input", jsi_IIRO),
    JSI_OPT(TIME_T,     jws_StatData, uploadStart,  .help="Time of upload start", jsi_IIRO),
    JSI_OPT_END(jws_StatData, .help="Per-connection statistics")
};

static Jsi_OptionSpec WPSOptions[] =
{
    JSI_OPT(STRKEY,     jws_Pss, clientIP,     .help="Client IP Address", jsi_IIRO),
    JSI_OPT(STRKEY,     jws_Pss, clientName,   .help="Client hostname", jsi_IIRO),
    JSI_OPT(CUSTOM,     jws_Pss, stats,        .help="Statistics for connection", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),
    JSI_OPT(BOOL,       jws_Pss, isWebsock,    .help="Socket has been upgraded to a websocket connection" ),
    JSI_OPT(DSTRING,    jws_Pss, uploadData,   .help="Uploaded data (raw)" ),
    JSI_OPT_END(jws_Pss, .help="Per-connection options")
};

static Jsi_OptionSpec WSOptions[] =
{
    JSI_OPT(STRING, jws_CmdObj, address,    .help="In client-mode the address to connect to (127.0.0.1)" ),
    JSI_OPT(BOOL,   jws_CmdObj, client,     .help="Run in client mode", jsi_IIOF),
    JSI_OPT(INT,    jws_CmdObj, debug,      .help="Set debug level. Setting this to 512 will turn on max libwebsocket log levels"),
    JSI_OPT(STRING, jws_CmdObj, defaultUrl, .help="Default when no url or / is given"),
    JSI_OPT(BOOL,   jws_CmdObj, defHandlers,.help="Enable the standard builtin handlers, ie: .htmli, .cssi and .jsi", jsi_IIOF),
    JSI_OPT(REGEXP, jws_CmdObj, getRegexp,  .help="Call onGet() only if Url matches pattern"),
//    JSI_OPT(CUSTOM, jws_CmdObj, handlersPkg,.help="Handlers use package() to upgrade string to function object"),
    JSI_OPT(STRING, jws_CmdObj, interface,  .help="Interface for server to listen on, eg. 'eth0' or 'lo'", jsi_IIOF),
    JSI_OPT(BOOL,   jws_CmdObj, local,      .help="Limit connections to localhost addresses on the 127 network"),
    JSI_OPT(INT,    jws_CmdObj, maxConnects,.help="In server mode, max number of client connections accepted"),
    JSI_OPT(OBJ,    jws_CmdObj, mimeTypes,  .help="Object providing map of file extensions to mime types (eg. {txt:'text/plain', bb:'text/bb'})", jsi_IIOF),
    JSI_OPT(BOOL,   jws_CmdObj, noUpdate,   .help="Disable update event-processing (eg. to exit)"),
    JSI_OPT(BOOL,   jws_CmdObj, noWebsock,  .help="Serve html, but disallow websocket upgrade", jsi_IIOF),
    JSI_OPT(BOOL,   jws_CmdObj, noWarn,     .help="Quietly ignore file related errors"),
    JSI_OPT(FUNC,   jws_CmdObj, onAuth,     .help="Function to call for http basic authentication", .flags=0, .custom=0, .data=(void*)"id:number, url:string, userpass:string"),
    JSI_OPT(FUNC,   jws_CmdObj, onClose,    .help="Function to call when the websocket connection closes", .flags=0, .custom=0, .data=(void*)"id:number"),
    JSI_OPT(FUNC,   jws_CmdObj, onCloseLast,.help="Function to call when last websock connection closes", .flags=0, .custom=0, .data=(void*)""),
    JSI_OPT(FUNC,   jws_CmdObj, onConnect,  .help="Function to call on a new http connection, returns false to kill", .flags=0, .custom=0, .data=(void*)"id:number"),
    JSI_OPT(FUNC,   jws_CmdObj, onGet,      .help="Function to call to server out content", .flags=0, .custom=0, .data=(void*)"id:number, url:string, args:object"),
    JSI_OPT(FUNC,   jws_CmdObj, onOpen,     .help="Function to call when the websocket connection occurs", .flags=0, .custom=0, .data=(void*)"id:number"),
    JSI_OPT(FUNC,   jws_CmdObj, onUnknown,  .help="Function to call to server out content when no file exists", .flags=0, .custom=0, .data=(void*)"id:number, url:string, args:object"),
    JSI_OPT(FUNC,   jws_CmdObj, onUpload,   .help="Function to call when upload starts or completes", .flags=0, .custom=0, .data=(void*)"id:number, complete:boolean"),
    JSI_OPT(FUNC,   jws_CmdObj, onRecv,     .help="Function to call when websock data recieved", .flags=0, .custom=0, .data=(void*)"id:number, data:string"),
    JSI_OPT(INT,    jws_CmdObj, maxDownload,.help="Max size of file download"),
    JSI_OPT(INT,    jws_CmdObj, maxUpload,  .help="Max size of file upload to accept"),
    JSI_OPT(INT,    jws_CmdObj, port,       .help="Port for server to listen on (8080)", jsi_IIOF),
    JSI_OPT(INT,    jws_CmdObj, recvBufSize,.help="Large recv buffer size, eg. to ensure full JSON was been received. -1=disable, 0=default of 1024", jsi_IIOF),
    JSI_OPT(INT,    jws_CmdObj, recvBufTimeout,.help="Timeout wait for recv to finish.  0=default of 60 seconds", jsi_IIOF),
    JSI_OPT(STRING, jws_CmdObj, redirectUrl,.help="Redirect to, when no url or / is given"),
    JSI_OPT(BOOL,   jws_CmdObj, redirDisable,.help="Disable redirects"),
    JSI_OPT(VALUE,  jws_CmdObj, rootdir,    .help="Directory to serve html from (\".\")"),
    JSI_OPT(CUSTOM, jws_CmdObj, stats,      .help="Statistical data", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),
    JSI_OPT(TIME_T, jws_CmdObj, startTime,  .help="Time of websocket start", jsi_IIRO),
    JSI_OPT(BOOL,   jws_CmdObj, use_ssl,    .help="Use https (for client)", jsi_IIOF),
    JSI_OPT(STRKEY, jws_CmdObj, useridPass, .help="The USER:PASSWD to use for basic authentication"),
    JSI_OPT(INT,    jws_CmdObj, version,    .help="Version number compiled against", jsi_IIRO),
    JSI_OPT_END(jws_CmdObj, .help="Websocket options")
};

static Jsi_RC jws_websocketObjFree(Jsi_Interp *interp, void *data);
static bool jws_websocketObjIsTrue(void *data);
static bool jws_websocketObjEqual(void *data1, void *data2);


/* this protocol server (always the first one) just knows how to do HTTP */

static int
jws_callback_http(struct lws *wsi,
      enum lws_callback_reasons reason,
      void *user, void *in, size_t len);
static int
jws_callback_websock(struct lws *wsi,
      enum lws_callback_reasons reason,
      void *user, void *in, size_t len);

#if 0
/* list of supported protocols and callbacks */
static struct lws_protocols protocols[] = {
    /* first protocol must always be HTTP handler */

    {
        .name="http-only",
        .callback=jws_callback_http,
        .per_session_data_size=0,
        .rx_buffer_size=0,
    },
    {
        .name="jsi-protocol",
        .callback=jws_callback_websock,
        .per_session_data_size=sizeof(jws_Pss),
        .rx_buffer_size=0,
    },

    { NULL, NULL, 0, 0 } /* terminator */
};
#endif

static jws_Pss*
jws_getPss(jws_CmdObj *cmdPtr, struct lws *wsi, void *user, int create, int ishttp)
{
    Jsi_HashEntry *hPtr;
    bool isNew = 0;
    jws_Pss *pss = (jws_Pss*)user;
    if (user==NULL)
        return NULL;
    int sfd = lws_get_socket_fd(wsi);
    if (sfd<0) {
        //puts("SFD negative");
        return NULL;
    }
    int sid = ((sfd<<1)|ishttp);
    if (create)
        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, (void*)(intptr_t)sid, &isNew);
    else
        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)(intptr_t)sid);
    if (!hPtr)
        return NULL;
    //printf("PSS FD(http=%d, create=%d) = %d\n", ishttp, create, sfd);
    if (create == 0 || isNew == 0) {
        WSSIGASSERT(pss, PWS);
        return pss;
    }
    memset(pss, 0, sizeof(*pss));
    if (!ishttp) {
        cmdPtr->stats.connectCnt++;
        cmdPtr->createCnt++;
        cmdPtr->createLast = time(NULL);
        if (Jsi_DSLength(&cmdPtr->dHdrs)) {
            Jsi_DSAppend(&pss->dHdrs, Jsi_DSValue(&cmdPtr->dHdrs), NULL);
            Jsi_DSFree(&pss->uploadData);
            memcpy(pss->hdrSz, cmdPtr->hdrSz, sizeof(cmdPtr->hdrSz));
        }
        pss->hdrNum = cmdPtr->hdrNum;

        jws_Pss *hpss;
        Jsi_HashEntry *hPtr2 = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)(intptr_t)(sid|1));
        if (0 && hPtr2 && (hpss = (jws_Pss *)Jsi_HashValueGet(hPtr2))) {
            //printf("FOUND HTTP: %d\n", sfd);
            // Transcribe http to websocket.
            memcpy(pss, hpss, sizeof(*pss));
            // Reset pointers.
            pss->stack = 0;
            Jsi_DSInit(&pss->dHdrs);
            Jsi_DSInit(&pss->uploadData);
            if (Jsi_DSLength(&hpss->dHdrs))
                Jsi_DSAppend(&pss->dHdrs, Jsi_DSValue(&hpss->dHdrs), NULL);
        }
    }
    pss->isWebsock = !ishttp;
    pss->sig = JWS_SIG_PWS;
    pss->hPtr = hPtr;
    Jsi_HashValueSet(hPtr, pss);
    pss->cmdPtr = cmdPtr;
    pss->wsi = wsi;
    pss->user = user; /* Same as pss. */
    pss->state = PWS_CONNECTED;
    pss->cnt = cmdPtr->idx++;
    pss->wid = sid;
    pss->sfd = sfd;
    return pss;
}

static Jsi_RC jws_DelPss(Jsi_Interp *interp, void *data) { Jsi_Free(data); return JSI_OK; }
static Jsi_RC jws_recv_flush(jws_CmdObj *cmdPtr, jws_Pss *pss);

static void
jws_deletePss(jws_Pss *pss)
{
    WSSIGASSERT(pss, PWS);
    if (pss->state == PWS_DEAD)
        return;
    jws_recv_flush(pss->cmdPtr, pss);
    if (pss->hPtr) {
        Jsi_HashValueSet(pss->hPtr, NULL);
        Jsi_HashEntryDelete(pss->hPtr);
        pss->hPtr = NULL;
    }
    if (pss->stack) {
        Jsi_StackFreeElements(pss->cmdPtr->interp, pss->stack, jws_DelPss);
        Jsi_StackFree(pss->stack);
    }
    jws_CmdObj*cmdPtr = pss->cmdPtr;
    cmdPtr->sfd = pss->sfd;
    Jsi_DSFree(&cmdPtr->dHdrs);
    if (Jsi_DSLength(&pss->dHdrs)) {
        Jsi_DSAppend(&cmdPtr->dHdrs, Jsi_DSValue(&pss->dHdrs), NULL);
        memcpy(cmdPtr->hdrSz, pss->hdrSz, sizeof(cmdPtr->hdrSz));
        cmdPtr->hdrNum = pss->hdrNum;
    }
    pss->clientName = cmdPtr->clientName;
    pss->clientIP = cmdPtr->clientIP;
    Jsi_DSFree(&pss->dHdrs);
    Jsi_DSFree(&pss->uploadData);
    if (pss->isWebsock)
        pss->cmdPtr->stats.connectCnt--;
    /*Jsi_ObjDecrRefCount(pss->msgs);*/
    pss->state = PWS_DEAD;
}

static int jws_write(jws_Pss* pss, struct lws *wsi, unsigned char *buf, int len, enum lws_write_protocol proto)
{
    jws_CmdObj *cmdPtr = pss->cmdPtr;
    int m = lws_write(wsi, buf, len, proto);
    if (m >= 0) {
        cmdPtr->stats.sentCnt++;
        cmdPtr->stats.sentLast = time(NULL);
        pss->stats.sentCnt++;
        pss->stats.sentLast = time(NULL);
    } else {
        pss->state = PWS_SENDERR;
        pss->stats.sentErrCnt++;
        pss->stats.sentErrLast = time(NULL);
        cmdPtr->stats.sentErrCnt++;
        cmdPtr->stats.sentErrLast = time(NULL);
    }    
    return m;
}

static int jws_ServeString(jws_Pss *pss, struct lws *wsi,
    const char *buf, int code, const char *reason, const char *mime)
{
    int rc, strLen = Jsi_Strlen(buf);
    Jsi_DString jStr = {};
    Jsi_DSPrintf(&jStr,
        "HTTP/1.0 %d %s\x0d\x0a"
        "Server: libwebsockets\x0d\x0a"
        "Content-Type: %s\x0d\x0a"
        "Content-Length: %u\x0d\x0a\x0d\x0a",
        (code<=0?200:code), (reason?reason:"OK"),
        (mime?mime:"text/html"),
        strLen);
    Jsi_DSAppend(&jStr, buf, NULL);
    char *vStr = Jsi_DSValue(&jStr);
    rc = jws_write(pss, wsi, (unsigned char*)vStr, Jsi_Strlen(vStr), LWS_WRITE_HTTP);
    Jsi_DSFree(&jStr);
    return rc;
}

static const char*
jws_Header(jws_Pss *pss, const char *name, int *lenPtr)
{
    int i, nlen = Jsi_Strlen(name);
    const char *ret = NULL, *cp = Jsi_DSValue(&pss->dHdrs);
    for (i=0; i<pss->hdrNum; i+=2) {
        int sz = pss->hdrSz[i];
        int mat = (!Jsi_Strncasecmp(cp, name, nlen) && cp[nlen]=='=');
        cp += 1 + sz;
        if (mat) {
            ret = cp;
            if (lenPtr)
                *lenPtr = pss->hdrSz[i+1];
            break;
        }
        cp += (1 + pss->hdrSz[i+1]);
    }
    return ret;
}


static int
jws_GetHeaders(jws_Pss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)
{
    int n = 0, i = 0;
    char buf[1000];
    const char *cp;
    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {
        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);
        n++;
        if (i>=(n*2+2)) break;
        if (len<=0) continue;
        buf[sizeof(buf)-1] = 0;
        if (!buf[0]) continue;
        Jsi_DSAppend(dStr, cp, "=", buf, "\n", NULL);
        if (lens) {
            lens[i++] = Jsi_Strlen(cp);
            lens[i++] = Jsi_Strlen(buf);
        }
    }
    return i;
}

static Jsi_Value*
jws_DumpHeaders(jws_CmdObj *cmdPtr, struct lws *wsi)
{
    int n = 0;
    char buf[BUFSIZ];
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    Jsi_Value *nv, *ret = Jsi_ValueMakeObject(interp, NULL, nobj);
    Jsi_ValueMakeObject(interp, &ret, nobj);
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebugLabel(ret, "websock", "dump_handshake");
#endif
    const unsigned char *cp;
    while ((cp = lws_token_to_string((enum lws_token_indexes)n))) {
       lws_hdr_copy(wsi, buf, sizeof(buf), (enum lws_token_indexes)n);
        buf[sizeof(buf)-1] = 0;
        if (!buf[0]) continue;
        nv = Jsi_ValueNewStringDup(interp, buf);
        Jsi_ObjInsert(interp, nobj, (char*)cp, nv, 0);
        n++;
    }
    return ret;
}


static void jws_getUriArgsJSON(struct lws *wsi, Jsi_DString *dStr)
{
    int n = 0;
    char buf[BUFSIZ];
    int cnt = 0;
    while (lws_hdr_copy_fragment(wsi, buf, sizeof(buf), WSI_TOKEN_HTTP_URI_ARGS, n++) > 0) 
    {
         char *cp, *value = buf;
        if ((cp = Jsi_Strchr(buf, '=')))
        {
            *cp = 0;
            value = cp+1;
        }
        Jsi_DSAppend(dStr,  (cnt++?", ":""), "\"", buf, "\":\"", value, "\"", NULL);
    }
}


static Jsi_RC jws_GetCmd(Jsi_Interp *interp, jws_CmdObj *cmdPtr, jws_Pss* pss, struct lws *wsi, const char *inPtr, Jsi_Value *cmd)
{ 
    Jsi_RC jrc;
    Jsi_Value *retStr = Jsi_ValueNew1(interp);
    Jsi_DString dStr = {};
    Jsi_DSPrintf(&dStr, "[%g, \"%s\", {", (Jsi_Number)pss->wid, inPtr );
    jws_getUriArgsJSON(wsi, &dStr);
    Jsi_DSAppend(&dStr, "}]", NULL);
    jrc = Jsi_FunctionInvokeJSON(interp, cmd, Jsi_DSValue(&dStr), &retStr);
    Jsi_DSSetLength(&dStr, 0);
    const char *rstr;
    if (jrc != JSI_OK)
        rstr = "Error";
    else
        rstr = Jsi_ValueGetDString(interp, retStr, &dStr, 0);
    int srv = (rstr[0] != 0);
    if (srv)
        jws_ServeString(pss, wsi, rstr, jrc==JSI_OK?0:404, NULL, NULL);
    else
        jrc = JSI_BREAK;
    Jsi_DecrRefCount(interp, retStr);
    Jsi_DSFree(&dStr);
    return jrc;
}

static int jws_callback_http(struct lws *wsi,
                         enum lws_callback_reasons reason, void *user,
                         void *in, size_t len)
{
    struct lws_context *context = lws_get_context(wsi);
    char buf[BUFSIZ];
    //int sfd;
    const char *ext = NULL;
    const char *inPtr = (char*)in;
    unsigned char buffer[BUFSIZ+LWS_PRE];
    time_t ostart = 0;
    char client_name[128], client_ip[128];
    // int n;
#ifdef EXTERNAL_POLL
    int m;
    int fd = (int)(long)user;
#endif
    jws_Pss *npss = NULL, *pss = (jws_Pss *)user;
    jws_CmdObj *cmdPtr = (jws_CmdObj *)lws_context_user(context);
    Jsi_Interp *interp = cmdPtr->interp;
    int rc = 0;

    buf[0] = 0;
    WSSIGASSERT(cmdPtr, OBJ);
    switch (reason) {
#ifndef EXTERNAL_POLL
    case LWS_CALLBACK_GET_THREAD_ID:
    case LWS_CALLBACK_UNLOCK_POLL:
    case LWS_CALLBACK_PROTOCOL_INIT:
    case LWS_CALLBACK_ADD_POLL_FD:
    case LWS_CALLBACK_DEL_POLL_FD:
    case LWS_CALLBACK_LOCK_POLL:
        return rc;
#else
        /*
         * callbacks for managing the external poll() array appear in
         * protocol 0 callback
         */

    case LWS_CALLBACK_ADD_POLL_FD:

        if (jws_num_pollfds >= max_poll_elements) {
            lwsl_err("LWS_CALLBACK_ADD_POLL_FD: too many sockets to track\n");
            return 1;
        }

        fd_lookup[fd] = jws_num_pollfds;
        jws_pollfds[jws_num_pollfds].fd = fd;
        jws_pollfds[jws_num_pollfds].events = (int)(long)len;
        jws_pollfds[jws_num_pollfds++].revents = 0;
        break;

    case LWS_CALLBACK_DEL_POLL_FD:
        if (!--jws_num_pollfds)
            break;
        m = fd_lookup[fd];
        /* have the last guy take up the vacant slot */
        jws_pollfds[m] = jws_pollfds[jws_num_pollfds];
        fd_lookup[jws_pollfds[jws_num_pollfds].fd] = m;
        break;

#endif
    
    default:
        break;

    }
    
    switch (reason) {
    case LWS_CALLBACK_FILTER_HTTP_CONNECTION:
        //if (cmdPtr->debug)
          //  jws_DumpHeaders(cmdPtr, wsi);
        break;
    case LWS_CALLBACK_PROTOCOL_INIT:
        break;
    case LWS_CALLBACK_CLOSED_HTTP:
        lws_get_socket_fd(wsi);
        //printf("CLOSED: %d\n", sfd);
        jws_deletePss(pss);
        break;
    case LWS_CALLBACK_WSI_CREATE:
    case LWS_CALLBACK_FILTER_NETWORK_CONNECTION:
        break;

    case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:
        client_name[0] = 0;
        client_ip[0] = 0;
        lws_get_peer_addresses(wsi, lws_get_socket_fd(wsi), client_name,
                                         sizeof(client_name), client_ip, sizeof(client_ip));
        if (client_name[0])
            cmdPtr->clientName = Jsi_KeyAdd(interp, client_name);
        if (client_ip[0])
            cmdPtr->clientIP = Jsi_KeyAdd(interp, client_ip);
        
        if (cmdPtr->clientName || cmdPtr->clientIP) {
            cmdPtr->instCtx = context;
            if (cmdPtr->debug)
                fprintf(stderr,  "Received network connect from %s (%s)\n",
                     cmdPtr->clientName, cmdPtr->clientIP);
            if (cmdPtr->local && (cmdPtr->clientName && Jsi_Strcmp(cmdPtr->clientName, "localhost"))) {
                if (cmdPtr->debug)
                    fprintf(stderr,  "Dropping non-localhost connection\n");
                return 1;
            }
        }

        //if (cmdPtr->debug)
        //    jws_DumpHeaders(cmdPtr, wsi);
        if (cmdPtr->maxConnects && cmdPtr->stats.connectCnt>=cmdPtr->maxConnects) {
            if (cmdPtr->debug)
                fprintf(stderr, "maxConnects exceeded: rejecting connection <%p>\n", user);
            rc = -1;
        }
        /* if we returned non-zero from here, we kill the connection */
        break;

    case LWS_CALLBACK_HTTP:
    {
        const char *mime = "text/html";
        time_t now = time(NULL);

        /* if a legal POST URL, let it continue and accept data */
        if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))
            return 0;

        if (cmdPtr->redirDisable && difftime(now, cmdPtr->stats.redirLast)>=600)
            cmdPtr->redirDisable = 0;
        if (cmdPtr->defaultUrl && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, "/")) && 
            (inPtr = Jsi_ValueString(cmdPtr->interp, cmdPtr->defaultUrl, NULL)) && inPtr[0]) {
            // replaced.
        }
        else if (cmdPtr->redirectUrl && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, "/")) && !cmdPtr->redirDisable) {
            inPtr = Jsi_ValueString(cmdPtr->interp, cmdPtr->redirectUrl, NULL);
            if (inPtr) {
                cmdPtr->stats.redirCnt++;
                if (cmdPtr->stats.redirLast && difftime(now, cmdPtr->stats.redirLast)<300 && ++cmdPtr->redirAllCnt>1000)
                    cmdPtr->redirDisable = 1;
                cmdPtr->stats.redirLast = now;
                snprintf(buf, sizeof(buf), "<head><meta http-equiv=\"refresh\" content=\"1; url=%s\" /></head><body>Redirecting...</body>", inPtr);
                rc = jws_ServeString(pss, wsi, buf, 0, NULL, NULL);
                break;
            }
        }
        npss = jws_getPss(cmdPtr, wsi, user, 1, 1);
        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {
            pss->clientName = cmdPtr->clientName;
            pss->clientIP = cmdPtr->clientIP;
        }
            
        Jsi_DSSetLength(&pss->dHdrs, 0);
        pss->hdrNum = jws_GetHeaders(pss, wsi, &pss->dHdrs, pss->hdrSz, sizeof(pss->hdrSz)/sizeof(int));

        if (!inPtr)
            inPtr = "/";

        if (cmdPtr->useridPass || cmdPtr->onAuth) {
            int ok = 0;
            int alen;
            const char *auth = jws_Header(pss, "authorization", &alen);
            if (auth && Jsi_Strncasecmp(auth, "basic ", 6)) {
                auth += 6;
                Jsi_DString eStr = {}, bStr = {};
                Jsi_DSAppendLen(&eStr, auth, alen);
                Jsi_Base64(Jsi_DSValue(&eStr), -1, &bStr, 1);
                const char *bp = Jsi_DSValue(&bStr);
                if (bp && bp[0]) {
                    if (!cmdPtr->onAuth)
                        ok = (!Jsi_Strcmp(cmdPtr->useridPass, bp));
                    else {
                        /* Pass 3 args: id, url and userid:pass . */
                        Jsi_Obj *oarg1;
                        Jsi_Value *vpargs, *vargs[3];
                        npss = jws_getPss(cmdPtr, wsi, user, 1, 1);
                        vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
                        vargs[1] = Jsi_ValueNewStringDup(interp, inPtr);
                        vargs[2] = Jsi_ValueNewStringDup(interp, bp);
                        vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 3, 0));
                        Jsi_IncrRefCount(interp, vpargs);
                        bool rb = Jsi_FunctionInvokeBool(interp, cmdPtr->onAuth, vpargs);
                        if (Jsi_InterpGone(interp))
                            return JSI_ERROR;
            
                        Jsi_DecrRefCount(interp, vpargs);
                        if (rb != 0 && rb != 1)
                            rc = JSI_ERROR;
                        if (rc != JSI_OK) 
                            return Jsi_LogError("websock bad rcv eval");
                        ok = rb;
                    }        
                }
                Jsi_DSFree(&eStr);
                Jsi_DSFree(&bStr);
            }
            if (!ok) {
                snprintf(buf, sizeof(buf), "HTTP/1.0 401 unauthorized\x0d\x0a"
                 "WWW-Authenticate: Basic realm=\"jsirealm\"\x0d\x0a"
                 "Content-Length: 0\x0d\x0a"
                 "\x0d\x0a" );
                jws_write(pss, wsi, (unsigned char *)buf, Jsi_Strlen(buf), LWS_WRITE_HTTP);

                return -1;
            }
        }

        if (cmdPtr->onConnect) {
            // 1 arg id
            int killcon = 0;
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2], *ret = Jsi_ValueNew1(interp);
            npss = jws_getPss(cmdPtr, wsi, user, 1, 1);
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
            Jsi_IncrRefCount(interp, vargs[0]);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 1));
            Jsi_DecrRefCount(interp, vargs[0]);
            Jsi_IncrRefCount(interp, vpargs);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onConnect, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return 1;
            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {
                if (cmdPtr->debug)
                    fprintf(stderr, "WS:KILLING CONNECTION: %p\n", pss);
                killcon = 1;
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return 1;
            }
            if (killcon)
                return 1;
        }
        
        if (cmdPtr->onGet) {
            Jsi_RC jrc;
            int rrv = 1;
            if (cmdPtr->getRegexp) {
                rrv = 0;
                jrc = Jsi_RegExpMatch(interp, cmdPtr->getRegexp, inPtr, &rrv, NULL);
                if (jrc != JSI_OK)
                    return 1;
            }
            if (rrv) {
                jrc = jws_GetCmd(interp, cmdPtr, pss, wsi, inPtr, cmdPtr->onGet);
                if (jrc == JSI_ERROR)
                    return 1;
                if (jrc == JSI_OK)
                    break;
            }
        }
        ext = Jsi_Strrchr(inPtr, '.');
        
        const char *rootdir = (cmdPtr->rootdir?Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL):"./");
        char statPath[PATH_MAX];
        if (!Jsi_Strncmp(inPtr, "/jsi/", 5)) {
            // Get the path for system files, eg /zvfs or /usr/local/lib/jsi
            const char *loadFile = NULL;
            Jsi_PkgRequire(interp, "Sys", 0);
            if (Jsi_PkgVersion(interp, "Sys", &loadFile)>=0) {
                if (loadFile) {
                    snprintf(statPath, sizeof(statPath), "%s", loadFile);
                    char *lcp = Jsi_Strrchr(statPath, '/');
                    if (lcp) {
                        *lcp = 0;
                        inPtr += 5;
                        rootdir = statPath;
                    }
                }
            }
        }

        snprintf(buf, sizeof(buf), "%s/%s", rootdir, inPtr);
        if (ext) {
            Jsi_HashEntry *hPtr;

            if (Jsi_Strncasecmp(ext,".png", -1) == 0) mime = "image/png";
            else if (Jsi_Strncasecmp(ext,".ico", -1) == 0) mime = "image/icon";
            else if (Jsi_Strncasecmp(ext,".gif", -1) == 0) mime = "image/gif";
            else if (Jsi_Strncasecmp(ext,".jpeg", -1) == 0) mime = "image/jpeg";
            else if (Jsi_Strncasecmp(ext,".jpg", -1) == 0) mime = "image/jpeg";
            else if (Jsi_Strncasecmp(ext,".js", -1) == 0) mime = "application/x-javascript";
            else if (Jsi_Strncasecmp(ext,".jsi", -1) == 0) mime = "application/x-javascript";
            else if (Jsi_Strncasecmp(ext,".svg", -1) == 0) mime = "image/svg+xml";
            else if (Jsi_Strncasecmp(ext,".css", -1) == 0) mime = "text/css";
            else if (Jsi_Strncasecmp(ext,".cssi", -1) == 0) mime = "text/css";
            else if (Jsi_Strncasecmp(ext,".json", -1) == 0) mime = "application/json";
            else if (Jsi_Strncasecmp(ext,".txt", -1) == 0) mime = "text/plain";
            else if (Jsi_Strncasecmp(ext,".html", -1) == 0) mime = "text/html";
            else if (Jsi_Strncasecmp(ext,".htmli", -1) == 0) mime = "text/html";
            else if (cmdPtr->mimeTypes) {
                /* Lookup mime type in mimeTypes object. */
                const char *nmime;
                Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);
                if (mVal && ((nmime = Jsi_ValueString(interp, mVal, NULL))))
                    mime = nmime;
            }
            
            if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext))) {
                /* Use interprete html eg. using jsi_wpp preprocessor */
                Jsi_DString jStr = {};
                Jsi_Value *vrc = NULL;
                int hrc = 0, strLen, evrc, isalloc=0;
                char *vStr, *hstr = NULL;
                jws_Hander *hdlPtr = (jws_Hander*)Jsi_HashValueGet(hPtr);
                Jsi_Value *hv = hdlPtr->val;
                
                if (Jsi_Strchr(buf, '\'') || Jsi_Strchr(buf, '\"')) {
                    jws_ServeString(pss, wsi, "Can not handle quotes in url", 404, NULL, NULL);    
                    return 1;                
                }
                cmdPtr->handlersPkg=1;
                
                // Attempt to load package and get function.
                if ((hdlPtr->flags&1) && cmdPtr->handlersPkg && Jsi_ValueIsString(interp, hv)
                    && ((hstr = Jsi_ValueString(interp, hv, NULL)))) {
                    vrc = Jsi_NameLookup(interp, hstr);
                    if (!vrc) {
                        int pver = Jsi_PkgRequire(interp, hstr, 0);
                        if (pver >= 0)
                            vrc = Jsi_NameLookup(interp, hstr);
                    }
                    if (!vrc || !Jsi_ValueIsFunction(interp, vrc)) {
                        if (vrc)
                            Jsi_DecrRefCount(interp, vrc);
                        Jsi_LogError("Failed to autoload handle: %s", hstr);
                        jws_ServeString(pss, wsi, "Failed to autoload handler", 404, NULL, NULL);    
                        return 1;                
                    }
                    if (hdlPtr->val)
                        Jsi_DecrRefCount(interp, hdlPtr->val);
                    hdlPtr->val = vrc;
                    Jsi_IncrRefCount(interp, vrc);
                    hv = vrc;
                }
                
                if ((hdlPtr->flags&2) && !hdlPtr->triedLoad && !hdlPtr->objVar && Jsi_ValueIsFunction(interp, hv)) {
                    // Run command and from returned object get the parse function.
                    hdlPtr->triedLoad = 1;
                    Jsi_DSAppend(&jStr, "[null", NULL); 
                    if (hdlPtr->arg)
                        Jsi_DSAppend(&jStr, ", ", hdlPtr->arg, NULL); // TODO: JSON encode.
                    Jsi_DSAppend(&jStr, "]", NULL);
                    vrc = Jsi_ValueNew1(interp);
                    evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);
                    if (evrc != JSI_OK || !vrc || !Jsi_ValueIsObjType(interp, vrc, JSI_OT_OBJECT)) {
                        Jsi_LogError("Failed to load obj: %s", hstr);
                        jws_ServeString(pss, wsi, "Failed to load obj", 404, NULL, NULL);    
                        return 1;                
                    }
                    Jsi_Value *fvrc = Jsi_ValueObjLookup(interp, vrc, "parse", 0);
                    if (!fvrc || !Jsi_ValueIsFunction(interp, fvrc)) {
                        Jsi_LogError("Failed to find parse: %s", hstr);
                        jws_ServeString(pss, wsi, "Failed to find parse", 404, NULL, NULL);    
                        return 1;                
                    }
                    hdlPtr->objVar = fvrc;
                    Jsi_IncrRefCount(interp, fvrc);
                    hv = vrc;
                    
                }

                if (hdlPtr->objVar) {  // Call the obj.parse function.
                    Jsi_DSAppend(&jStr, "[\"", buf, "\"]", NULL); // TODO: JSON encode.
                    vrc = Jsi_ValueNew1(interp);
                    evrc = Jsi_FunctionInvokeJSON(interp, hdlPtr->objVar, Jsi_DSValue(&jStr), &vrc);
                    isalloc = 1;
                }
                else if (Jsi_ValueIsFunction(interp, hv)) {
                    Jsi_DSAppend(&jStr, "[\"", buf, "\"", NULL); // TODO: JSON encode.
                    if (hdlPtr->arg)
                        Jsi_DSAppend(&jStr, ", ", hdlPtr->arg, NULL);
                    Jsi_DSAppend(&jStr, "]", NULL);
                    vrc = Jsi_ValueNew1(interp);
                    evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);
                    isalloc = 1;
                } else {
                    // One shot invoke of string command.
                    hstr = Jsi_ValueString(interp, hv, NULL);
                    Jsi_DSAppend(&jStr, hstr, "('", buf, "'", NULL);
                    if (hdlPtr->arg)
                        Jsi_DSAppend(&jStr, ", ", hdlPtr->arg, NULL);
                    Jsi_DSAppend(&jStr, ");", NULL);
                    evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);
                    if (evrc == JSI_OK)
                        vrc = Jsi_InterpResult(interp);
                }
                // Take result from vrc and return it.
                if (evrc != JSI_OK) {
                    Jsi_LogError("failure in websocket handler");
                } else if ((!vrc) ||
                    (!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {
                    Jsi_LogError("failed to get result");
                } else {
                    Jsi_DSSetLength(&jStr, 0);
                    Jsi_DSPrintf(&jStr,
                        "HTTP/1.0 200 OK\x0d\x0a"
                        "Server: libwebsockets\x0d\x0a"
                        "Content-Type: %s\x0d\x0a"
                        "Content-Length: %u\x0d\x0a\x0d\x0a",
                        mime,
                        strLen);
                    vStr = Jsi_DSAppend(&jStr, vStr, NULL);
                    hrc = jws_write(pss, wsi, (unsigned char*)vStr, Jsi_Strlen(vStr), LWS_WRITE_HTTP);
                }
                Jsi_DSFree(&jStr);
                if (isalloc)
                    Jsi_DecrRefCount(interp, vrc);
                if (hrc<=0)
                    return 1;
                goto try_to_reuse;
            }
        }
        if (!buf[0]) {
            if (cmdPtr->debug)
                fprintf(stderr, "Unknown file: %s\n", inPtr);
            break;
        }
        Jsi_Value* fname = Jsi_ValueNewStringDup(interp, buf);
        Jsi_IncrRefCount(interp, fname);

        Jsi_StatBuf jsb;
        if (Jsi_Stat(interp, fname, &jsb) || jsb.st_size<=0) {
nofile:
            if (cmdPtr->onUnknown) {
                Jsi_RC jrc = jws_GetCmd(interp, cmdPtr, pss, wsi, inPtr, cmdPtr->onUnknown);
                if (jrc == JSI_ERROR)
                    return 1;
                if (jrc == JSI_OK)
                    break;
            }

            if (cmdPtr->noWarn==0 && Jsi_Strstr(buf, "favicon.ico")==0)
                fprintf(stderr, "failed open file for read: %s\n", buf);
            rc = jws_ServeString(pss, wsi, "<b style='color:red'>ERROR: can not serve file!</b>", 404, NULL, NULL);
            Jsi_DecrRefCount(interp, fname);
            break;
        }
        if (S_ISDIR(jsb.st_mode)) {
            if (cmdPtr->noWarn==0)
                fprintf(stderr, "can not serve directory: %s\n", buf);
            rc = jws_ServeString(pss, wsi, "<b style='color:red'>ERROR: can not serve directory!</b>", 404, NULL, NULL);
            Jsi_DecrRefCount(interp, fname);
            break;
        }

        if (Jsi_FSNative(interp, fname)) {     
            Jsi_DecrRefCount(interp, fname);
            // Large native files we send asyncronously.
            if (jsb.st_size>(BUFSIZ*4) && !Jsi_InterpSafe(interp)) {
    
                unsigned long file_len;
                unsigned char *p = buffer + LWS_PRE;
                unsigned char *end = p + sizeof(buffer) - LWS_PRE;
    
                pss->fd = lws_plat_file_open(wsi, buf, &file_len,
                                 LWS_O_RDONLY);
    
                if (pss->fd == LWS_INVALID_FILE) {
                    lwsl_err("faild to open file %s\n", buf);
                    return -1;
                }
    
                if (lws_add_http_header_status(wsi, 200, &p, end))
                    return 1;
                if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SERVER,
                            (unsigned char *)"libwebsockets",
                        13, &p, end))
                    return 1;
                if (lws_add_http_header_by_token(wsi,
                        WSI_TOKEN_HTTP_CONTENT_TYPE,
                            (unsigned char *)mime,
                        Jsi_Strlen(mime), &p, end))
                    return 1;
                if (lws_add_http_header_content_length(wsi,
                                       file_len, &p,
                                       end))
                    return 1;
                if (lws_finalize_http_header(wsi, &p, end))
                    return 1;
                *p = '\0';
                lwsl_info("%s\n", buffer + LWS_PRE);
    
                int n = jws_write(pss, wsi, buffer + LWS_PRE, p - (buffer + LWS_PRE),
                          LWS_WRITE_HTTP_HEADERS);
                if (n < 0) {
                    lws_plat_file_close(wsi, pss->fd);
                    return -1;
                }

                lws_callback_on_writable(wsi);
                break;
            }
            
            // Smaller files can go in one shot.
            int hrc = lws_serve_http_file(wsi, buf, mime, NULL, 0);
            if (hrc<0) {
                if (cmdPtr->noWarn==0)
                    fprintf(stderr, "can not serve file (%d): %s\n", hrc, buf);
                return 1;
            } else if (hrc > 0 && lws_http_transaction_completed(wsi))
                return -1;
        } else {
            // Need to read data for non-native files.
            Jsi_Channel chan = Jsi_Open(interp, fname, "rb");
            int n, sum = 0;

            if (!chan) {
                goto nofile;
            }
            Jsi_DString dStr = {};
            char sbuf[BUFSIZ];
            Jsi_DSPrintf(&dStr,
                "HTTP/1.0 200 OK\x0d\x0a"
                "Server: libwebsockets\x0d\x0a"
                "Content-Type: %s\x0d\x0a"
                "Content-Length: %u\x0d\x0a\x0d\x0a",
                mime,
                (unsigned int)jsb.st_size);
            while (sum < 10000000 && (n = Jsi_Read(chan, sbuf, sizeof(sbuf))) > 0) {
                Jsi_DSAppendLen(&dStr, sbuf, n);
                sum += n;
            }
            Jsi_Close(chan);
            char *str = Jsi_DSValue(&dStr);
            int hrc, strLen = Jsi_DSLength(&dStr);
            Jsi_DecrRefCount(interp, fname);
            hrc = jws_write(pss, wsi, (unsigned char*)str, strLen, LWS_WRITE_HTTP);
            Jsi_DSFree(&dStr);
            if (hrc<0) {
                if (cmdPtr->noWarn==0)
                    fprintf(stderr, "can not serve data (%d): %s\n", hrc, buf);
                return 1;
            } else if (hrc > 0 && lws_http_transaction_completed(wsi))
                return -1;

        }
        /*
         * notice that the sending of the file completes asynchronously,
         * we'll get a LWS_CALLBACK_HTTP_FILE_COMPLETION callback when
         * it's done
         */

        break;
    }

    case LWS_CALLBACK_HTTP_BODY:
        if (cmdPtr->maxUpload<=0 || !cmdPtr->onUpload) {
            if (cmdPtr->noWarn==0)
                fprintf(stderr, "Upload disabled: maxUpload=%d, onUpload=%p\n", cmdPtr->maxUpload, cmdPtr->onUpload);
            return -1;
        }
        cmdPtr->stats.uploadLast = pss->stats.uploadLast = time(NULL);
        Jsi_DSAppendLen(&pss->uploadData, inPtr, len);

        ostart = pss->stats.uploadStart;
        if (!pss->stats.uploadStart) {
            cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = 0;
            cmdPtr->stats.uploadStart = pss->stats.uploadStart = time(NULL);
            cmdPtr->stats.uploadCnt++;
            pss->stats.uploadCnt++;
            Jsi_DSSetLength(&pss->uploadData, 0);
        }
        if (!ostart)
            break;

    case LWS_CALLBACK_HTTP_BODY_COMPLETION:
        if (!ostart)
            cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = time(NULL);
        if (cmdPtr->onUpload) {
            /* Pass 2 args: id and bool=true for complete. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            npss = jws_getPss(cmdPtr, wsi, user, 1, 1);
            if (npss != pss)
                fprintf(stderr, "bad pss\n");
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
            vargs[1] = Jsi_ValueNewNumber(interp, (ostart==0));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 2, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onUpload, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                goto errout;
            }
        }        
        lws_return_http_status(wsi, HTTP_STATUS_OK, NULL);
        goto try_to_reuse;

    case LWS_CALLBACK_HTTP_FILE_COMPLETION:
        goto try_to_reuse;

    case LWS_CALLBACK_HTTP_WRITEABLE: {
        lwsl_info("LWS_CALLBACK_HTTP_WRITEABLE\n");

        if (pss->fd == LWS_INVALID_FILE)
            goto try_to_reuse;

        /*
         * we can send more of whatever it is we were sending
         */
        unsigned long amount;
        int sent = 0;
        unsigned char buffer[BUFSIZ*10];
        do {
            int n = sizeof(buffer) - LWS_PRE;
            int m = lws_get_peer_write_allowance(wsi);
            if (m == 0)
                goto later;

            if (m != -1 && m < n)
                n = m;

            n = lws_plat_file_read(wsi, pss->fd,
                           &amount, buffer + LWS_PRE, n);
            if (n < 0) {
                lwsl_err("problem reading file\n");
                goto bail;
            }
            n = (int)amount;
            if (n == 0)
                goto penultimate;
            /*
             * To support HTTP2, must take care about preamble space
             *
             * identification of when we send the last payload frame
             * is handled by the library itself if you sent a
             * content-length header
             */
            m = jws_write(pss, wsi, buffer + LWS_PRE, n, LWS_WRITE_HTTP);
            if (m < 0) {
                lwsl_err("write failed\n");
                /* write failed, close conn */
                goto bail;
            }
            if (m) /* while still active, extend timeout */
                lws_set_timeout(wsi, PENDING_TIMEOUT_HTTP_CONTENT, 5);
            sent += m;

        } while (!lws_send_pipe_choked(wsi) && (sent < 500 * 1024 * 1024));
later:
        lws_callback_on_writable(wsi);
        break;
penultimate:
        lws_plat_file_close(wsi, pss->fd);
        pss->fd = LWS_INVALID_FILE;
        goto try_to_reuse;

bail:
        lws_plat_file_close(wsi, pss->fd);

        return -1;
    }

    default:
        break;
    }

    //if (npss) jws_deletePss(npss);
    return rc;
    
try_to_reuse:
    //if (npss) jws_deletePss(npss);
    if (lws_http_transaction_completed(wsi))
        return -1;

    return 0;
    
errout:
    //if (npss) jws_deletePss(npss);
    return -1;
}

static Jsi_RC jws_recv_callback(Jsi_Interp *interp, jws_CmdObj *cmdPtr, jws_Pss *pss,  const char *inPtr, int nlen)
{
    Jsi_Obj *oarg1;
    Jsi_Value *vpargs, *vargs[2];
    if (nlen<=0)
        return JSI_OK;
    vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
    vargs[1]  = Jsi_ValueNewString(interp, inPtr, nlen);
    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 2, 0));
    Jsi_IncrRefCount(interp, vpargs);
    
    Jsi_Value *ret = Jsi_ValueNew1(interp);
    Jsi_ValueMakeUndef(interp, &ret);
    Jsi_RC rc = Jsi_FunctionInvoke(interp, cmdPtr->onRecv, vpargs, &ret, NULL);
    if (Jsi_InterpGone(interp))
        return JSI_ERROR;
    if (rc == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0) {
        /* TODO: handle callback return data??? */
    }
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}


static int
jws_callback_websock(struct lws *wsi,
      enum lws_callback_reasons reason,
      void *user, void *in, size_t len)
{
    struct lws_context *context = lws_get_context(wsi);

    jws_Pss *pss = (jws_Pss *)user;
    jws_CmdObj *cmdPtr = (jws_CmdObj *)lws_context_user(context);
    Jsi_Interp *interp = cmdPtr->interp;
    char *inPtr = (char*)in;
    int sLen, bSiz, n, rc =0, cnt = 0; /*, result = JSI_OK;*/;
#define LWSPAD (LWS_SEND_BUFFER_PRE_PADDING + LWS_SEND_BUFFER_POST_PADDING)
#define LBUFMAX (BUFSIZ+LWSPAD)
    char buf[LBUFMAX], *bufPtr = buf;
    char *statBuf = NULL;
    int statSize = 0;

    WSSIGASSERT(cmdPtr, OBJ);
    switch (reason) {
    case LWS_CALLBACK_PROTOCOL_INIT:
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_INIT: %p\n", user);
        if (cmdPtr->noWebsock)
            return 1;
        //pss = jws_getPss(cmdPtr, wsi, user, 1, 0);
        break;
        
    case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:
        //pss = jws_getPss(cmdPtr, wsi, user, 1, 0);
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_FILTER: %p\n", pss);
        if (cmdPtr->onConnect) {
            int killcon = 0;
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2], *ret = Jsi_ValueNew1(interp);
            
            vargs[0] = jws_DumpHeaders(cmdPtr, wsi);
            Jsi_IncrRefCount(interp, vargs[0]);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 1));
            Jsi_DecrRefCount(interp, vargs[0]);
            Jsi_IncrRefCount(interp, vpargs);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onConnect, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return 1;
            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {
                if (cmdPtr->debug)
                    fprintf(stderr, "WS:KILLING CONNECTION: %p\n", pss);
                killcon = 1;
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return 1;
            }
            if (killcon)
                return 1;
        }
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
    case LWS_CALLBACK_ESTABLISHED:
        pss = jws_getPss(cmdPtr, wsi, user, 1, 0);
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_ESTABLISHED: %d,%p\n", pss->wid, pss);
        if (cmdPtr->onOpen) {
            /* Pass 1 args: id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) 
                return Jsi_LogError("websock bad rcv eval");
        }        
        break;

    case LWS_CALLBACK_CLOSED:
    case LWS_CALLBACK_PROTOCOL_DESTROY:
        pss = (jws_Pss *)user;
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CLOSE: %p\n", pss);
        if (!pss) break;
        if (cmdPtr->onClose) {
            /* Pass 2 args: id and data. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onClose, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) 
                return Jsi_LogError("websock bad rcv eval");
        }        
        jws_deletePss(pss);
        if (cmdPtr->stats.connectCnt<=0 && cmdPtr->onCloseLast) {
            Jsi_FunctionInvokeBool(interp, cmdPtr->onCloseLast, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
        }
        break;
    case LWS_CALLBACK_CLIENT_WRITEABLE:
    case LWS_CALLBACK_SERVER_WRITEABLE:
        pss = jws_getPss(cmdPtr, wsi, user, 0, 0);
        if (!pss) break;
        n=0;
        while (cnt++<100 && pss->stack) {
            char *data = (char*)Jsi_StackUnshift(pss->stack);
            unsigned char *p;
            if (data == NULL)
                break;
            pss->state = PWS_SENT;
            sLen = Jsi_Strlen(data);
            bSiz = sLen + LWSPAD;
            if (bSiz >= (int)LBUFMAX) {
                if (statBuf == NULL) {
                    statSize = bSiz+1+LBUFMAX;
                    statBuf = (char*)Jsi_Malloc(statSize);
                } else if (statSize <= bSiz) {
                    statSize = bSiz+1+LBUFMAX;
                    statBuf = (char*)Jsi_Realloc(statBuf, statSize);
                }
                bufPtr = statBuf;
            }
            // TODO: check output size
            p = (unsigned char *)bufPtr+LWS_SEND_BUFFER_PRE_PADDING;
            memcpy(p, data, sLen);
            Jsi_Free(data);
            n = jws_write(pss, wsi, p, sLen, LWS_WRITE_TEXT);
            if (cmdPtr->debug>=10)
                fprintf(stderr, "WS:CLIENT WRITE(%p): %d=>%d\n", pss, sLen, n);
                                   
            if (n >= 0) {
                cmdPtr->stats.sentCnt++;
                cmdPtr->stats.sentLast = time(NULL);
                pss->stats.sentCnt++;
                pss->stats.sentLast = time(NULL);
            } else {
                lwsl_err("ERROR %d writing to socket\n", n);
                pss->state = PWS_SENDERR;
                pss->stats.sentErrCnt++;
                pss->stats.sentErrLast = time(NULL);
                cmdPtr->stats.sentErrCnt++;
                cmdPtr->stats.sentErrLast = time(NULL);
                rc = 1;
                break;
            }

            // lwsl_debug("tx fifo %d\n", (ringbuffer_head - pss->ringbuffer_tail) & (MAX_MESSAGE_QUEUE - 1));

            /*if (lws_send_pipe_choked(wsi)) {
                    libwebsocket_callback_on_writable(context, wsi);
                    return 0;
            }*/
        }
        if (bufPtr && bufPtr != buf)
            Jsi_Free(bufPtr);
        break;
        
    case LWS_CALLBACK_CLIENT_RECEIVE:
    case LWS_CALLBACK_RECEIVE:
    {
        pss = jws_getPss(cmdPtr, wsi, user, 0, 0);
        if (!pss) break;
        if (cmdPtr->debug>=10)
            fprintf(stderr, "WS:RECV: %p\n", pss);

        //fprintf(stderr, "rx %d\n", (int)len);
        pss->stats.recvCnt++;
        pss->stats.recvLast = time(NULL);
        cmdPtr->stats.recvCnt++;
        cmdPtr->stats.recvLast = time(NULL);

        if (cmdPtr->onRecv ) {
            /* Pass 2 args: id and data. */
            int nlen = len, bsiz = cmdPtr->recvBufSize, rblen = Jsi_DSLength(&pss->recvBuf);
            if (nlen<=0)
                return 0;
            if (bsiz>=0 && nlen >= ((bsiz?bsiz:1024)-1)) { // Websockets buffers a max of 1K.
                if (rblen<=0) {
                    if (bsiz!=0 || rblen || Jsi_JSONParse(NULL, inPtr, NULL, 0) != JSI_OK) {
                        // Buffer if first chunk, user did not override buf size, and not a complete JSON msg.
                        cmdPtr->recvBufCnt++;
                        Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);
                        break;
                    }
                } else {
                    Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);
                    break;
                }
            } else if (rblen) {
                cmdPtr->recvBufCnt--;
                Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);
                nlen = Jsi_DSLength(&pss->recvBuf);
                inPtr = Jsi_DSFreeDup(&pss->recvBuf);
            } else {
                Jsi_DString inStr;
                Jsi_DSInit(&inStr);
                Jsi_DSAppendLen(&inStr, inPtr, len);
                inPtr = Jsi_DSFreeDup(&inStr);
            }
            rc = jws_recv_callback(interp, cmdPtr, pss, inPtr, nlen);
        
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return 1;
            }
        }
        //if (!Jsi_Strlen(Jsi_GetStringResult(interp))) { }
        lws_callback_on_writable_all_protocol(cmdPtr->context, lws_get_protocol(wsi));

        //if (len < 6)
            //break;
        //if (Jsi_Strcmp((const char *)in, "reset\n") == 0)
        //pss->number = 0;
        break;
 
    }
    default:
        break;
    }
    return rc;
}


static Jsi_RC WebSocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
  
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-websock object");
    return Jsi_OptionsConf(interp, WSOptions, cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);

}

static Jsi_RC WebSocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-websock object");
    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Number vid;
    if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0) 
        return Jsi_LogError("Expected number id");
    int id = (int)vid;
    jws_Pss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        jws_Pss* tpss = (jws_Pss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(tpss, PWS);
        if (tpss->wid == id && tpss->state != PWS_DEAD) {
            pss = tpss;
            break;
        }
    }

    if (!pss) 
        return Jsi_LogError("No such id: %d", id);
    return Jsi_OptionsConf(interp, WPSOptions, pss, Jsi_ValueArrayIndex(interp, args, 1), ret, 0);
}

static Jsi_RC WebSocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-websock object");
    Jsi_DString dStr = {"["};
    jws_Pss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int cnt = 0;
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        pss = (jws_Pss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(pss, PWS);
        if (pss->state != PWS_DEAD) {
            Jsi_DSPrintf(&dStr, "%s%d", (cnt++?",":""), pss->wid);
        }
    }
    Jsi_DSAppend(&dStr, "]", NULL);
    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}


static Jsi_RC jws_HandlerAdd(Jsi_Interp *interp, jws_CmdObj *cmdPtr, const char *ext, const char *cmd, const char *argStr, int flags)
{
    Jsi_HashEntry *hPtr;
    jws_Hander *hdlPtr;
    Jsi_Value *valPtr = Jsi_ValueNewStringDup(interp, cmd);
    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, ext, NULL);
    if (!hPtr)
        return JSI_ERROR;
    hdlPtr = (jws_Hander *)Jsi_Calloc(1, sizeof(*hdlPtr));
    hdlPtr->val = valPtr;
    hdlPtr->flags = flags;
    if (argStr)
        hdlPtr->arg = Jsi_KeyLookup(interp, argStr);
    Jsi_HashValueSet(hPtr, hdlPtr);
    Jsi_IncrRefCount(interp, valPtr);
    return JSI_OK;
}

#define FN_wshandler JSI_INFO("\
With no args, returns list of handlers.  With one arg, returns value for that handler."\
"Otherwise, sets the handler. When cmd is a string, the call is via Jsi_Main([cmd], arg).\
If a cmd is a function, it is called with a single arg: the file name.")
static Jsi_RC WebSocketHandlerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_HashEntry *hPtr;
    jws_Hander *hdlPtr;
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-websock object");
    WSSIGASSERT(cmdPtr, OBJ);
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0) {
        Jsi_HashSearch search;
        Jsi_Obj* obj = Jsi_ObjNew(interp);
        for (hPtr = Jsi_HashSearchFirst(cmdPtr->handlers, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {
            const char *key = (char*)Jsi_HashKeyGet(hPtr);
            Jsi_Value *val = (Jsi_Value*)Jsi_HashValueGet(hPtr);
            Jsi_ObjInsert(interp, obj, key, val, 0);
        }
        Jsi_ValueMakeObject(interp, ret, obj);
        return JSI_OK;
    }
    if (argc == 1) {
        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, Jsi_ValueArrayIndexToStr(interp, args, 0, NULL));
        if (!hPtr)
            return JSI_OK;
        hdlPtr = (jws_Hander*)Jsi_HashValueGet(hPtr);
        Jsi_ValueReplace(interp, ret, hdlPtr->val);
        return JSI_OK;
    }
    const char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 1);
    if (Jsi_ValueIsNull(interp, valPtr)) {
        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, key);
        if (!hPtr)
            return JSI_OK;
        hdlPtr = (jws_Hander*)Jsi_HashValueGet(hPtr);
        if (hdlPtr->val)
            Jsi_DecrRefCount(interp, hdlPtr->val);
        Jsi_HashValueSet(hPtr, NULL);
        Jsi_HashEntryDelete(hPtr);
        Jsi_Free(hdlPtr);
        Jsi_ValueMakeStringDup(interp, ret, key);
        return JSI_OK;
    }
    if (Jsi_ValueIsFunction(interp, valPtr)==0 && Jsi_ValueIsString(interp, valPtr)==0) 
        return Jsi_LogError("expected string, function or null");
    Jsi_Value *argPtr = Jsi_ValueArrayIndex(interp, args, 2);
    if (argPtr) {
        if (Jsi_ValueIsNull(interp, argPtr))
            argPtr = NULL;
        else if (!Jsi_ValueIsString(interp, argPtr)) 
            return Jsi_LogError("expected a string");
    }
    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, key, NULL);
    if (!hPtr)
        return JSI_ERROR;
    hdlPtr = (jws_Hander *)Jsi_Calloc(1, sizeof(*hdlPtr));
    Jsi_Value *flagPtr = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number fl = 0;
    if (flagPtr && Jsi_ValueIsNumber(interp, flagPtr))
        Jsi_ValueGetNumber(interp, flagPtr, &fl);
    hdlPtr->val = valPtr;
    if (argPtr) {
        hdlPtr->arg = Jsi_ValueString(interp, argPtr, NULL);
        if (hdlPtr->arg)
            hdlPtr->arg = Jsi_KeyLookup(interp, hdlPtr->arg);
    }
    hdlPtr->flags = fl;
    Jsi_HashValueSet(hPtr, hdlPtr);
    Jsi_IncrRefCount(interp, valPtr);
    return JSI_OK;
}

#define FN_wssend JSI_INFO("\
Send a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.")

static Jsi_RC WebSocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply in a non-websock object");
    WSSIGASSERT(cmdPtr, OBJ);
    //int len;
    //char *in;
    //Jsi_HashEntry *hPtr;
    //Jsi_HashSearch cursor;
    //Jsi_Obj *objPtr;
    jws_Pss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char *str = Jsi_ValueString(interp, arg, NULL);
    int id = -1, argc = Jsi_ValueGetLength(interp, args);
    Jsi_DString eStr = {};
    if (argc>1) {
        Jsi_Number dnum;
        Jsi_Value *darg = Jsi_ValueArrayIndex(interp, args, 1);
        if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK) 
            return Jsi_LogError("invalid id");
        id = (int)dnum;
    }
    if (!str) {
        str = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);
    }
    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
        pss = (jws_Pss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(pss, PWS);
        if ((id<0 || pss->wid == id) && pss->state != PWS_DEAD) {
            if (!pss->stack)
                pss->stack = Jsi_StackNew();
            Jsi_StackPush(pss->stack, Jsi_Strdup(str));
        }
    }
   
    Jsi_DSFree(&eStr);
    return JSI_OK;
}

static Jsi_RC jws_recv_flush(jws_CmdObj *cmdPtr, jws_Pss *pss)
{
    int nlen = Jsi_DSLength(&pss->recvBuf);
    if (nlen<=0)
        return JSI_OK;
    cmdPtr->recvBufCnt--;
    const char *inPtr = Jsi_DSFreeDup(&pss->recvBuf);
    Jsi_RC rc = jws_recv_callback(cmdPtr->interp, cmdPtr, pss, inPtr, nlen);
    if (rc != JSI_OK) {
        pss->stats.recvErrCnt++;
        pss->stats.recvErrLast = time(NULL);
    }
    return rc;
}

static int jws_Service(jws_CmdObj *cmdPtr)
{
    int n = 0;
    struct timeval tv;

    gettimeofday(&tv, NULL);
    if (cmdPtr->recvBufCnt) { // Flush buffered data.
        jws_Pss *pss = NULL;
        Jsi_HashEntry *hPtr;
        Jsi_HashSearch cursor;
        for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);
            hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {
            pss = (jws_Pss*)Jsi_HashValueGet(hPtr);
            WSSIGASSERT(pss, PWS);
            if (pss->state == PWS_DEAD) continue;
            if (Jsi_DSLength(&pss->recvBuf)<=0) continue;
            int to = cmdPtr->recvBufTimeout;
            if (to>=0 && pss->stats.recvLast && difftime(time(NULL), pss->stats.recvLast)<(double)(to?to:60)) continue;
            jws_recv_flush(cmdPtr, pss);
        }
    }

    /*
     * This provokes the LWS_CALLBACK_SERVER_WRITEABLE for every
     * live websocket connection using the DUMB_INCREMENT protocol,
     * as soon as it can take more packets (usually immediately)
     */

    if (((unsigned int)tv.tv_usec - cmdPtr->oldus) > 50000) {
        lws_callback_on_writable_all_protocol(cmdPtr->context, &cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK]);
        cmdPtr->oldus = tv.tv_usec;
    }

#ifdef EXTERNAL_POLL

    /*
     * this represents an existing server's single poll action
     * which also includes libwebsocket sockets
     */

    n = poll(jws_pollfds, jws_num_pollfds, 50);
    if (n < 0)
        return 0;


    if (n)
        for (n = 0; n < jws_num_pollfds; n++)
            if (jws_pollfds[n].revents)
                /*
                * returns immediately if the fd does not
                * match anything under libwebsockets
                * control
                */
                if (lws_service_fd(context,
                                            &jws_pollfds[n]) < 0)
                    return -1;
#else
    /*
     * If libwebsockets sockets are all we care about,
     * you can use this api which takes care of the poll()
     * and looping through finding who needed service.
     *
     * If no socket needs service, it'll return anyway after
     * the number of ms in the second argument.
     */

    n = lws_service(cmdPtr->context, 50);
#endif
    return n;
}

static Jsi_RC WebSocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) 
        return Jsi_LogError("Apply to non-websock object");
    if (!cmdPtr->noUpdate)
        jws_Service(cmdPtr);
    return JSI_OK;
}

static Jsi_RC jws_websockUpdate(Jsi_Interp *interp, void *data)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)data;
    WSSIGASSERT(cmdPtr,OBJ);
    jws_Service(cmdPtr);
    return JSI_OK;
}

static void jws_websocketObjErase(jws_CmdObj *cmdPtr)
{
    if (cmdPtr->interp) {
        if (cmdPtr->event)
            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);
        cmdPtr->event = NULL;
        if (cmdPtr->hasOpts)
            Jsi_OptionsFree(cmdPtr->interp, WSOptions, cmdPtr, 0);
        cmdPtr->hasOpts = 0;
        if (cmdPtr->handlers)
            Jsi_HashDelete(cmdPtr->handlers);
        cmdPtr->handlers = NULL;
        if (cmdPtr->pssTable)
            Jsi_HashDelete(cmdPtr->pssTable);
        cmdPtr->pssTable = NULL;
        Jsi_DSFree(&cmdPtr->dHdrs);
    }
    cmdPtr->interp = NULL;
}

static Jsi_RC jws_websocketObjFree(Jsi_Interp *interp, void *data)
{
    jws_CmdObj *cmdPtr = (jws_CmdObj*)data;
    WSSIGASSERT(cmdPtr,OBJ);
    struct lws_context *ctx = cmdPtr->context;
    jws_websocketObjErase(cmdPtr);
    if (ctx) 
        lws_context_destroy(ctx);
    _JSI_MEMCLEAR(cmdPtr);
    Jsi_Free(cmdPtr);
    return JSI_OK;
}

static bool jws_websocketObjIsTrue(void *data)
{
    //jws_CmdObj *cmdPtr = data;
    return 1;
   /* if (!fo->websockname) return 0;
    else return 1;*/
}

static bool jws_websocketObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static Jsi_RC jws_freeHandlers(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    jws_Hander *h = (jws_Hander*)ptr;
    if (!h)
        return JSI_OK;
    if (h->val)
        Jsi_DecrRefCount(interp, h->val);
    if (h->objVar)
        Jsi_DecrRefCount(interp, h->objVar);
    Jsi_Free(h);
    return JSI_OK;
}

static Jsi_RC jws_freePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    jws_Pss *pss = (jws_Pss*)ptr;
    WSSIGASSERT(pss, PWS);
    if (pss) {
        pss->hPtr = NULL;
        jws_deletePss(pss);
    }
    return JSI_OK;
}

static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *verStr = NULL;
    verStr = lws_get_library_version();
    if (verStr) {
        char buf[100], *cp;
        snprintf(buf, sizeof(buf), "%s", verStr);
        cp = Jsi_Strchr(buf, ' ');
        if (cp) *cp = 0;
        Jsi_ValueMakeStringDup(interp, ret, buf);
    }
    return JSI_OK;
}


#define FN_WebSocket JSI_INFO("\
Create a websocket server/client object.  The server serves out pages to a \
web browser, which can use javascript to upgrade connection to a bidirectional websocket.")
static Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    

static Jsi_CmdSpec websockCmds[] = {
    { "WebSocket",  WebSocketConstructor, 0,  1, "options:object=void", .help="Create websocket server/client object", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_WebSocket, .opts=WSOptions },
    { "conf",       WebSocketConfCmd,     0,  1, "options:string|object=void",.help="Configure options", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WSOptions },
    { "handler",    WebSocketHandlerCmd,  0,  4, "extension:string=void, cmd:string|function=void, arg:string|null=void, flags:number=0", 
        .help="Get/Set handler command for an extension", .retType=(uint)JSI_TT_FUNCTION|JSI_TT_ARRAY|JSI_TT_STRING|JSI_TT_UNDEFINED, .flags=0, .info=FN_wshandler },
    { "ids",        WebSocketIdsCmd,      0,  0, "", .help="Return list of ids", .retType=(uint)JSI_TT_ARRAY},
    { "idconf",     WebSocketIdConfCmd,   1,  2, "id:number, options:string|object=void",.help="Configure options for id", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WPSOptions },
    { "send",       WebSocketSendCmd,     1,  2, "data:any, id:number=-1", .help="Send a websocket message to id", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_wssend },
    { "update",     WebSocketUpdateCmd,   0,  0, "", .help="Service events for just this websocket", .retType=(uint)JSI_TT_VOID },
    { "version",    WebSocketVersionCmd,  0,  0, "", .help="Runtime library version string", .retType=(uint)JSI_TT_STRING },
    { NULL, 0,0,0,0, .help="Commands for managing WebSocket server/client connections"  }
};


static Jsi_UserObjReg websockobject = {
    "WebSocket",
    websockCmds,
    jws_websocketObjFree,
    jws_websocketObjIsTrue,
    jws_websocketObjEqual
};

static const struct lws_extension jsi_lws_exts[] = {
    {
        "permessage-deflate",
        lws_extension_callback_pm_deflate,
        "permessage-deflate"
    },
    {
        "deflate-frame",
        lws_extension_callback_pm_deflate,
        "deflate_frame"
    },
    { NULL, NULL, NULL /* terminator */ }
};

static Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jws_CmdObj *cmdPtr;
    Jsi_Value *toacc = NULL;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    cmdPtr = (jws_CmdObj*)Jsi_Calloc(1, sizeof(*cmdPtr));
    cmdPtr->sig = JWS_SIG_OBJ;
    cmdPtr->port = 8080;
    //cmdPtr->rootdir = "./";

    cmdPtr->interp = interp;
    cmdPtr->protocols[JWS_PROTOCOL_HTTP].name="http-only";
    cmdPtr->protocols[JWS_PROTOCOL_HTTP].callback=jws_callback_http;
    cmdPtr->protocols[JWS_PROTOCOL_HTTP].per_session_data_size=sizeof(jws_Pss);
    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name="jsi-protocol";
    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].callback=jws_callback_websock;
    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].per_session_data_size=sizeof(jws_Pss);
    cmdPtr->ietf_version = -1;
    cmdPtr->rx_buffer_size = 0;
    cmdPtr->ws_gid = -1;
    cmdPtr->ws_uid = -1;
    cmdPtr->startTime = time(NULL);
    cmdPtr->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (cmdPtr->hasOpts && Jsi_OptionsProcess(interp, WSOptions, cmdPtr, arg, 0) < 0) {
        cmdPtr->deleted = 1;
        jws_websocketObjFree(interp, cmdPtr);
        //Jsi_EventuallyFree(cmdPtr, destroyjws_CmdObj);
        return JSI_ERROR;
    }
#ifdef LWS_LIBRARY_VERSION_NUMBER
    cmdPtr->version = LWS_LIBRARY_VERSION_NUMBER;
#endif
    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].rx_buffer_size=cmdPtr->rx_buffer_size;
    cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jws_freePss);
    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);


#if !defined(LWS_NO_DAEMONIZE) && !defined(WIN32)
    /* 
     * normally lock path would be /var/lock/lwsts or similar, to
     * simplify getting started without having to take care about
     * permissions or running as root, set to /tmp/.lwsts-lock
     */
    if (cmdPtr->daemonize && lws_daemonize("/tmp/.lwsts-lock")) {
        if (cmdPtr->debug)
            fprintf(stderr, "WS:Failed to daemonize\n");
        jws_websocketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
#endif
    cmdPtr->info.user = cmdPtr;
    cmdPtr->info.iface = cmdPtr->interface ? Jsi_ValueString(interp, cmdPtr->interface, NULL) : NULL;
    cmdPtr->info.protocols = cmdPtr->protocols;

    cmdPtr->info.extensions = jsi_lws_exts;

    cmdPtr->info.ssl_cert_filepath = cmdPtr->ssl_cert_filepath;
    cmdPtr->info.ssl_private_key_filepath = cmdPtr->ssl_private_key_filepath;
    cmdPtr->info.gid = cmdPtr->ws_gid;
    cmdPtr->info.uid = cmdPtr->ws_uid;
    cmdPtr->opts = LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME|LWS_SERVER_OPTION_VALIDATE_UTF8;
    cmdPtr->info.options = cmdPtr->opts;
    cmdPtr->info.max_http_header_pool = 16;
    cmdPtr->info.timeout_secs = 5;
    cmdPtr->info.ssl_cipher_list = "ECDHE-ECDSA-AES256-GCM-SHA384:"
                   "ECDHE-RSA-AES256-GCM-SHA384:"
                   "DHE-RSA-AES256-GCM-SHA384:"
                   "ECDHE-RSA-AES256-SHA384:"
                   "HIGH:!aNULL:!eNULL:!EXPORT:"
                   "!DES:!MD5:!PSK:!RC4:!HMAC_SHA1:"
                   "!SHA1:!DHE-RSA-AES128-GCM-SHA256:"
                   "!DHE-RSA-AES128-SHA256:"
                   "!AES128-GCM-SHA256:"
                   "!AES128-SHA256:"
                   "!DHE-RSA-AES256-SHA256:"
                   "!AES256-GCM-SHA384:"
                   "!AES256-SHA256";

    lws_set_log_level(cmdPtr->debug>1?cmdPtr->debug-1:0, NULL);
    cmdPtr->context = lws_create_context(&cmdPtr->info);
    if (cmdPtr->context == NULL) {
        Jsi_LogError("libwebsocket init failed on port %d (try another port?)", cmdPtr->port);
        jws_websocketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }

    if (cmdPtr->client) {
        struct lws_client_connect_info lci;
        lci.context = cmdPtr->context;
        lci.address = cmdPtr->address ? Jsi_ValueString(cmdPtr->interp, cmdPtr->address, NULL) : "127.0.0.1";
        lci.port = cmdPtr->port;
        lci.ssl_connection = cmdPtr->use_ssl;
        lci.path = cmdPtr->rootdir?Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL):"./";
        lci.host = cmdPtr->cl_host?cmdPtr->cl_host:"localhost";
        lci.origin = cmdPtr->cl_origin?cmdPtr->cl_origin:"localhost";
        lci.protocol = cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name;
        lci.ietf_version_or_minus_one = cmdPtr->ietf_version;
        
        if (NULL == lws_client_connect_via_info(&lci))
        {
            Jsi_LogError("websock connect failed");
            jws_websocketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
    }

    cmdPtr->event = Jsi_EventNew(interp, jws_websockUpdate, cmdPtr);
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "WebSocket", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &websockobject, fobj, cmdPtr))<0) {
        jws_websocketObjFree(interp, cmdPtr);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    cmdPtr->handlers = Jsi_HashNew(interp, JSI_KEYS_STRING, jws_freeHandlers);
    if (cmdPtr->defHandlers) {
        const char *argStr = NULL;
        if (cmdPtr->debug)
            argStr = "{debug:1}";
        jws_HandlerAdd(interp, cmdPtr, ".jsi",   "Jsi_Jspp",   argStr, 1);
        jws_HandlerAdd(interp, cmdPtr, ".htmli", "Jsi_Htmlpp", argStr, 1);
        jws_HandlerAdd(interp, cmdPtr, ".cssi",  "Jsi_Csspp",  argStr, 1);
    }
    cmdPtr->fobj = fobj;
    return JSI_OK;
}

static Jsi_RC Jsi_DoneWebSocket(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &websockobject);
    Jsi_PkgProvide(interp, "WebSocket", -1, NULL);
    return JSI_OK;
}


Jsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release)
{
    if (release)
        return Jsi_DoneWebSocket(interp);
    Jsi_Hash *wsys;
    const char *libver = lws_get_library_version();
    int lvlen = sizeof(LWS_LIBRARY_VERSION)-1;
    if (Jsi_Strncmp(libver, LWS_LIBRARY_VERSION, lvlen) || !isspace(libver[lvlen])) 
        return Jsi_LogError("Library version mismatch: %s != %s", LWS_LIBRARY_VERSION, lws_get_library_version());
#if JSI_USE_STUBS
  if (Jsi_StubsInit(interp, 0) != JSI_OK)
    return JSI_ERROR;
#endif
    if (Jsi_PkgProvide(interp, "WebSocket", 1, Jsi_InitWebSocket) != JSI_OK)
        return JSI_ERROR;
    if (!(wsys = Jsi_UserObjRegister(interp, &websockobject))) {
        Jsi_LogBug("Can not init webSocket");
        return JSI_ERROR;
    }

    if (!Jsi_CommandCreateSpecs(interp, websockobject.name, websockCmds, wsys, JSI_CMDSPEC_ISOBJ))
        return JSI_ERROR;
    return JSI_OK;
}

#endif
#endif
#if JSI__MYSQL==1
/* JSI Javascript Interface to MySql. */

typedef enum { MYSQL_SIG_DB = 0xbeefdeaa, MYSQL_SIG_FUNC, MYSQL_SIG_EXEC, MYSQL_SIG_STMT } MySql_Sig;

#define SQLSIGASSERT(s,n) assert(s->sig == MYSQL_SIG_##n)
#define SQLSIGINIT(s,n) s->sig = MYSQL_SIG_##n

#ifndef NDEBUG
#ifndef _JSI_MEMCLEAR
#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));
#endif
#else
#define _JSI_MEMCLEAR(s)
#endif
#ifndef JSI_DB_DSTRING_SIZE
#define JSI_DB_DSTRING_SIZE 2000
#endif

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <ctype.h>
#include <stdio.h>
#include <mysql/mysql.h>
#include <mysql/my_config.h>

#if JSI__MEMDEBUG
#include "jsiInt.h"
#else
#include "jsi.h"
JSI_EXTENSION_INI
#endif

#ifndef NUM_PREPARED_STMTS
#define NUM_PREPARED_STMTS 100
#endif
#ifndef MAX_PREPARED_STMTS
#define MAX_PREPARED_STMTS 10000
#endif

#ifndef JSI_DBQUERY_PRINTF
#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#endif

/*
** New SQL functions can be created as JSI scripts.  Each such function
** is described by an instance of the following structure.
*/
typedef struct SqlFunc SqlFunc;
struct SqlFunc {
    MySql_Sig sig;
    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */
    Jsi_Value   *tocall;    /* Callee */
    char        *pScript;   /* The char* representation of the script */
    Jsi_DString dScript;
    char        *zName;     /* Name of this function */
    SqlFunc     *pNext;     /* Next function on the list of them all */
};

/*
** New collation sequences function can be created as JSI scripts.  Each such
** function is described by an instance of the following structure.
*/
typedef struct SqlCollate SqlCollate;
struct SqlCollate {
    MySql_Sig sig;
    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */
    Jsi_Value   *zScript;  /* The function to be run */
    SqlCollate  *pNext;    /* Next function on the list of them all */
};

typedef struct SqlFieldResults {
    MYSQL_FIELD *field;
    my_bool isnull;
    unsigned long len;
    int vsize;
    enum enum_field_types mapType; // Maps to one of DOUBLE, BOOL, VARCHAR or TIMESTAMP
    Jsi_OptionId jsiTypeMap;  // Type of data for Jsi.
    union { // Space for data.
        char vchar;
        double vdouble;  // Must convert if Jsi_Number is a long double.
        long long vlonglong;
        my_bool vbool;
        char *vstring;
        MYSQL_TIME timestamp;
    } buffer;
} SqlFieldResults;

/*
    result_bind[0].buffer_type = MYSQL_TYPE_LONG;
    result_bind[0].buffer = &result_int;
    result_bind[0].buffer_length = sizeof(result_int);
    result_bind[0].length = &result_len;
    result_bind[0].is_null = &result_is_null[0];
*/

/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/
typedef struct MysqlPrep MysqlPrep;
struct MysqlPrep {
    MySql_Sig sig;
    int deleting;
    MysqlPrep *pNext;  /* Next in linked list */
    MysqlPrep *pPrev;  /* Previous on the list */
    MYSQL_STMT    *myStmt;  /* The prepared statement */
    MYSQL_RES     *resultMetaData;
    MYSQL_RES     *paramMetaData;
    MYSQL_BIND    *bindParam;
    MYSQL_BIND    *bindResult;
    SqlFieldResults *fieldResult;
    SqlFieldResults *fieldParam;
    //int resultColumns, paramCount;
    uint nSql;                /* chars in zSql[] */
    char *zSql;        /* Text of the SQL statement */
    const char *zRawSql;     /* SQL before named params extracted. */
    
    int numParam; // Count of input params.
    int numCol; // Count of columns in results
    Jsi_HashEntry *entry;
    Jsi_ListEntry *elPtr;
    char **colNames;       /* List of column names. */
    Jsi_OptionId *colTypes;
    // Following used by named params.
    char *origSql;
    char **paramNames;       /* List of param names. */
    int *paramMyTypes;
    int paramCnt;
    Jsi_DString *naStr;
};

static const char *execFmtStrs[] = {
    "rows", "arrays", "array1d", "list", "column", "json",
    "json2", "html", "csv", "insert", "line", "tabs", "none", NULL
};

typedef enum {
    _mdb_EF_ROWS, _mdb_EF_ARRAYS, _mdb_EF_ARRAY1D, _mdb_EF_LIST, _mdb_EF_COLUMN, _mdb_EF_JSON,
    _mdb_EF_JSON2, _mdb_EF_HTML, _mdb_EF_CSV, _mdb_EF_INSERT, _mdb_EF_LINE, _mdb_EF_TABS, _mdb_EF_NONE
} mdbOutput_Mode;


const char *mdbTypeChkStrs[] = { "convert", "error", "warn", "disable", NULL };

typedef enum { mdbTypeCheck_Cast, mdbTypeCheck_Error, mdbTypeCheck_Warn,  mdbTypeCheck_None } mdbTypeCheck_Mode;

typedef struct QueryOpts {
    MySql_Sig sig;
    Jsi_Value *callback, *values;
    Jsi_Value *paramVar;
    int limit;
    mdbOutput_Mode mode;
    mdbTypeCheck_Mode typeCheck;
    bool mapundef, nocache, headers, noNamedParams, prefetch;
    const char *separator;
    const char *nullvalue;
    const char *table;
    //const char *CData; // Name of cdata to use for query.
    const char* varName;
    Jsi_Value *width;
    int maxString;
} QueryOpts;

static const char *trcModeStrs[] = {"eval", "delete", "prepare", "step", NULL}; // Bit-set packed into an int.
enum {mdbTMODE_EVAL=0x1, mdbTMODE_DELETE=0x2, mdbTMODE_PREPARE=0x4, mdbTMODE_STEP=0x4};

typedef struct MySqlObj {
    MySql_Sig sig;
    MYSQL  *db;               /* The "real" database structure. MUST BE FIRST */
    Jsi_Interp *interp;        /* The interpreter used for this database */
    Jsi_Value *host;
    const char *user;
    const char *password;
    const char *database;
    int port;
    char *zNull;               /* Text to substitute for an SQL NULL value */
    SqlFunc *pFunc;            /* List of SQL functions */
    int rc;                    /* Return code of most recent mysql_exec() */
    Jsi_List *stmtCache;
//    MysqlPrep *stmtList; /* List of prepared statements*/
//    MysqlPrep *stmtLast; /* Last statement in the list */
    Jsi_Hash *stmtHash;        /* Hash table for statements. */
    int maxStmts;               /* The next maximum number of stmtList */
    int numStmts;                 /* Number of statements in stmtList */
    bool bindWarn, forceInt, reconnect, enableMulti;
    int nStep, nSort;          /* Statistics for most recent operation */
    int nTransaction;          /* Number of nested [transaction] methods */
    int errorCnt;               /* Count of errors. */
    Jsi_Value *key;             /* Key, for codec. */
    int hasOpts;
    Jsi_Obj *userObjPtr;
    QueryOpts queryOpts, *optPtr;
    int objId;
    int debug;
    int deleted;
    Jsi_Event *event;
    //int trace;
    Jsi_DString name;
    int last_errno;
    Jsi_Number version;
    int dbflags;
    Jsi_Value *sslKey, *sslCert, *sslCA, *sslCAPath, *sslCipher;
    Jsi_Hash *typeNameHash;
} MySqlObj;

typedef struct MyDbEvalContext {
    MySqlObj *jdb;                /* Database handle */
    Jsi_DString *dzSql;               /* Object holding string zSql */
    const char *zSql;               /* Remaining SQL to execute */
    MysqlPrep *prep;      /* Current statement */
    int nCol;                       /* Number of columns returned by pStmt */
    Jsi_Value *tocall;
    Jsi_Value *ret;
    /*OBS */
    Jsi_Value *pArray;              /* Name of array variable */
    Jsi_Value *pValVar;             /* Name of list for values. */
    int nocache;
    int namedParams;
} MyDbEvalContext;

static Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value);
static Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p );
static void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard );

void mdbTypeNameHashInit(MySqlObj *jdb) {
    Jsi_Interp *interp = jdb->interp;
    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    Jsi_HashSet(hPtr, (void*)"string", (void*)MYSQL_TYPE_STRING);
    Jsi_HashSet(hPtr, (void*)"double", (void*)MYSQL_TYPE_DOUBLE);
    Jsi_HashSet(hPtr, (void*)"integer", (void*)MYSQL_TYPE_LONGLONG);
    Jsi_HashSet(hPtr, (void*)"bool", (void*)MYSQL_TYPE_TINY);
    Jsi_HashSet(hPtr, (void*)"blob", (void*)MYSQL_TYPE_BLOB);
    Jsi_HashSet(hPtr, (void*)"date", (void*)MYSQL_TYPE_DATE);
    Jsi_HashSet(hPtr, (void*)"time", (void*)MYSQL_TYPE_TIME);
    Jsi_HashSet(hPtr, (void*)"timestamp", (void*)MYSQL_TYPE_TIMESTAMP);
    Jsi_HashSet(hPtr, (void*)"datetime", (void*)MYSQL_TYPE_DATETIME);
}

static Jsi_OptionSpec QueryFmtOptions[] =
{
    JSI_OPT(FUNC,   QueryOpts, callback, .help="Function to call with each row result", .flags=0, .custom=0, .data=(void*)"values:object" ),
    JSI_OPT(BOOL,   QueryOpts, headers, .help="First row returned contains column labels"),
    JSI_OPT(INT,    QueryOpts, limit, .help="Maximum number of returned values"),
    JSI_OPT(BOOL,   QueryOpts, mapundef, .help="In variable binds, map an 'undefined' var to null"),
    JSI_OPT(INT,    QueryOpts, maxString, .help="If not using prefetch, the maximum string value size (0=8K)"),
    JSI_OPT(CUSTOM, QueryOpts, mode, .help="Set output mode of returned data", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=execFmtStrs),
    JSI_OPT(BOOL,   QueryOpts, nocache, .help="Query is not to be cached"),
    JSI_OPT(BOOL,   QueryOpts, noNamedParams, .help="Disable translating sql to support named params"),
    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help="Null string output (for non-json mode)"),
    JSI_OPT(ARRAY,  QueryOpts, paramVar, .help="Array var to use for parameters" ),
    JSI_OPT(BOOL,   QueryOpts, prefetch, .help="Let client library cache entire results"),
    JSI_OPT(STRKEY, QueryOpts, separator, .help="Separator string (for csv and text mode)"),
    //JSI_OPT(STRKEY, QueryOpts, CData, .help="Name of CData object to use"),
    JSI_OPT(STRKEY, QueryOpts, table, .help="Table name for mode=insert"),
    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help="Type check mode (error)", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=mdbTypeChkStrs),
    JSI_OPT(ARRAY,  QueryOpts, values, .help="Values for ? bind parameters" ),
    JSI_OPT(STRKEY, QueryOpts, varName,  .help="String name of array var for ? bind parameters" ),
    JSI_OPT(CUSTOM, QueryOpts, width, .help="In column mode, set column widths", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)mdbIsNumArray),
    JSI_OPT_END(QueryOpts)
};


#define IIOF .flags=JSI_OPT_INIT_ONLY
static Jsi_OptionSpec SqlOptions[] =
{
    JSI_OPT(BOOL,   MySqlObj, bindWarn, .help="Treat failed variable binds as a warning", IIOF),
    JSI_OPT(STRKEY, MySqlObj, database, .help="Database to use", IIOF ),
    JSI_OPT(CUSTOM, MySqlObj, debug,    .help="Enable debug trace for various operations", .flags=0, .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),
    JSI_OPT(BOOL,   MySqlObj, enableMulti,.help="Accept muiltiple semi-colon separated statements in eval()", IIOF),
    JSI_OPT(INT,    MySqlObj, errorCnt, .help="Count of errors", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(CUSTOM, MySqlObj, queryOpts, .help="Default options for exec", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=QueryFmtOptions),
    JSI_OPT(BOOL,   MySqlObj, forceInt, .help="Bind float as int if possible"),
    JSI_OPT(STRING, MySqlObj, host,     .help="IP address or host name for mysqld (default is 127.0.0.1)"),
    JSI_OPT(INT,    MySqlObj, maxStmts, .help="Max cache size for compiled statements"),
    JSI_OPT(DSTRING,MySqlObj, name,     .help="Name for this db handle"),
    JSI_OPT(INT,    MySqlObj, numStmts, .help="Current size of compiled statement cache", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(STRKEY, MySqlObj, password, .help="Database password.", IIOF ),
    JSI_OPT(INT,    MySqlObj, port,     .help="IP port for mysqld", IIOF),
    JSI_OPT(BOOL,   MySqlObj, reconnect, .help="Reconnect"),
    JSI_OPT(STRING, MySqlObj, sslKey, .help="SSL key"),
    JSI_OPT(STRING, MySqlObj, sslCert, .help="SSL Cert"),
    JSI_OPT(STRING, MySqlObj, sslCA, .help="SSL CA"),
    JSI_OPT(STRING, MySqlObj, sslCAPath, .help="SSL CA path"),
    JSI_OPT(STRING, MySqlObj, sslCipher, .help="SSL Cipher"),
    JSI_OPT(STRKEY, MySqlObj, user,     .help="Database user name. Default is current user-name.", IIOF ),
    JSI_OPT(DOUBLE, MySqlObj, version,  .help="Mysql version number", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT_END(MySqlObj)
};

/* Start of code. */

// Convert MySql time to JS unix time in ms. TODO: handle "neg" and years outside of unix time.
static Jsi_Number mdbMyTimeToJS(MYSQL_TIME* mtm)
{
    struct tm tm;
    tm.tm_sec = mtm->second;
    tm.tm_min = mtm->minute;
    tm.tm_hour = mtm->hour;
    tm.tm_mday = mtm->day;
    tm.tm_mon = mtm->month-1;
    tm.tm_year = mtm->year - 1900;
    time_t tim = mktime(&tm);
    if (tim == (time_t)-1)
        return -1;
    return (Jsi_Number)tim*1000 + (Jsi_Number)mtm->second_part/1000000.0;
}

static void mdbJsToMyTime(Jsi_Number time, MYSQL_TIME* mtm, int utc)
{
    struct tm tm;
    time_t tim = (time_t)(time/1000);
    if (utc)
        gmtime_r(&tim, &tm);
    else
        localtime_r(&tim, &tm);
    mtm->second = tm.tm_sec;
    mtm->minute = tm.tm_min;
    mtm->hour = tm.tm_hour;
    mtm->day = tm.tm_mday;
    mtm->month = tm.tm_mon+1;
    mtm->year = tm.tm_year + 1900;
    Jsi_Number secs = (tim/1000.0);
    mtm->second_part = (int)((secs-(int)secs)*1000000);
}

static Jsi_RC mdbEvalInit(
    Jsi_Interp *interp,
    MyDbEvalContext *p,               /* Pointer to structure to initialize */
    MySqlObj *jdb,                  /* Database handle */
    const char* zSql,                /* Value containing SQL script */
    Jsi_DString *dStr,
    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */
    Jsi_Obj *pValVar                  /* Name element in array for list. */
) {
    p->dzSql = dStr;
    p->zSql = Jsi_DSAppend(p->dzSql, zSql?zSql:"", NULL);
    p->jdb = jdb;
    return JSI_OK;
}

static void mdbEvalFinalize(MyDbEvalContext *p) {
    if( p->prep) {
        mdbReleaseStmt(p->jdb, p->prep, p->nocache);
        p->prep = 0;
    }
    Jsi_DSFree(p->dzSql);
}

static void mdbEvalRowInfo( MyDbEvalContext *eval, int *pnCol, char ***papColName, Jsi_OptionId **papColType) {
    if (!papColName) {
        //TODO: Array ???
    }
    *papColName = eval->prep->colNames;
    *papColType = eval->prep->colTypes;
    *pnCol = eval->prep->numCol;
}

/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */
static Jsi_RC mdbEvalStepSub(MyDbEvalContext *eval, int release, int *erc) {
    MySqlObj *jdb = eval->jdb;
    Jsi_Interp *interp = jdb->interp;
    MysqlPrep *prep = eval->prep;
    SQLSIGASSERT(prep, STMT);
    MYSQL_STMT *myStmt = prep->myStmt;

    if (jdb->debug & mdbTMODE_STEP)
        JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", prep->zSql);
    int m = mysql_stmt_fetch(myStmt);
    if (m == MYSQL_NO_DATA)
        return JSI_BREAK;
    if (m) 
        return Jsi_LogError("fetch failed: %s", mysql_error(jdb->db));
    return JSI_OK;
#if 0
    if( eval->pArray ) {
        mdbEvalRowInfo(eval, 0, 0, 0);
    }
    if (release==0)
        return JSI_BREAK;
    eval->prep = 0;
    return JSI_OK;
#endif
}

static void mdbRelease1Stmt( MySqlObj *jdb, MysqlPrep *prep ) {
    // TODO: split out parts reusable by cached query.
    int i;
    if (prep->deleting)
        return;
    prep->deleting = 1;
    if (prep->myStmt)
        mysql_stmt_close(prep->myStmt);
    if (prep->resultMetaData)
        mysql_free_result(prep->resultMetaData);
    if (prep->paramMetaData)
        mysql_free_result(prep->paramMetaData);
    if (prep->bindParam)
        Jsi_Free(prep->bindParam);
    if (prep->fieldParam)
        Jsi_Free(prep->fieldParam);
    if (prep->bindResult) {
        for (i=0; i<prep->numCol; i++) {
            MYSQL_BIND *bind = prep->bindResult+i;
            if (bind->buffer_type == MYSQL_TYPE_STRING && bind->buffer)
                Jsi_Free(bind->buffer);
        }
        Jsi_Free(prep->bindResult);
    }
    if (prep->fieldResult)
        Jsi_Free(prep->fieldResult);
    if (prep->colTypes)
        Jsi_Free(prep->colTypes);
    if (prep->colNames)
        Jsi_Free(prep->colNames);
    if (prep->zSql)
        Jsi_Free(prep->zSql);
    if (prep->naStr) {
        Jsi_Free(prep->origSql);
        Jsi_DSFree(prep->naStr);
        Jsi_Free(prep->naStr);
    }
    if (prep->entry)
        Jsi_HashEntryDelete(prep->entry);
    if (prep->elPtr) {
        Jsi_ListEntry *pPtr = prep->elPtr;
        prep->elPtr = NULL;
        Jsi_ListEntryDelete(pPtr);
    }
    Jsi_Free(prep);
    jdb->numStmts--;
}


static Jsi_RC mdbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {
    MySqlObj *jdb = (MySqlObj*)interp;
    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;
    mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));
    return JSI_OK;
}

static void mdbStmtLimit( MySqlObj *jdb)
{
    while(jdb->numStmts>jdb->maxStmts ) {
        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);
        mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}

/*
** Finalize and free a list of prepared statements
*/
static void mdbFlushStmtCache( MySqlObj *jdb ) {
    Jsi_ListClear(jdb->stmtCache);
    jdb->numStmts = 0;
}

/*
** Release a statement reference obtained by calling mdbPrepareAndBind().
** There should be exactly one call to this function for each call to
** mdbPrepareAndBind().
**
** If the discard parameter is non-zero, then the statement is deleted
** immediately. Otherwise it is added to the LRU list and may be returned
** by a subsequent call to mdbPrepareAndBind().
*/
static void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard ) {
    if( jdb->maxStmts<=0 || discard ) {
        /* If the cache is turned off, deallocated the statement */
        mdbRelease1Stmt(jdb, prep);
    } else {
        /* Add the prepared statement to the beginning of the cache list. */
        if (!prep->elPtr)
            prep->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, prep);
        else
            Jsi_ListPushFront(jdb->stmtCache, prep->elPtr);
        mdbStmtLimit(jdb);
    }
}

long long mdbLastInsertRowid(MySqlObj* jdb)
{
    return mysql_insert_id(jdb->db);
}


static const char *mdbFindEndStr(const char *cp) {
    const char endc = *cp;
    cp++;
    while (*cp && *cp != endc) {
        if (*cp == '\\' && cp[1]) cp++;
        cp++;
    }
    if (*cp != endc)
        return NULL;
    return ++cp;
}
// Collect named parameters and translate Sql to use ?
static Jsi_RC MySqlExtractParmNames(MySqlObj* jdb, const char *sql, Jsi_DString *sStr, Jsi_DString *nStr) {
    const char *ocp, *cp = sql;
    int cnt = 0;
    while (*cp) {
        if (*cp == '\"'||*cp == '\'') {
            ocp = cp;
            cp = mdbFindEndStr(cp);
            if (!cp)
                return JSI_ERROR;
            Jsi_DSAppendLen(sStr, ocp, cp-ocp+1);
        } else if ((*cp == '@' || *cp == ':' || *cp == '$' ) && (isalpha(cp[1]) || cp[1] == '_')) {
            ocp = cp;
            cp+=2;
            while (*cp && (isalnum(*cp) || *cp == '_'))
                cp++;
            if (*ocp == '$' && *cp == '(') {
                const char *ttp = NULL, *ttb = NULL, *eq = NULL;
                cp++;
                if (*cp == '[')
                    eq = cp++;
                while (*cp && (isalnum(*cp) || *cp == '_' || *cp == ':' || *cp == '.' || *cp == ']')) {
                    if (*cp == ':') {
                        if (ttp)
                            return JSI_ERROR;
                        ttp = cp;
                    }
                    if (*cp == ']') {
                        if (ttb)
                            return JSI_ERROR;
                        ttb = cp;
                        if (cp[1] != ')' && cp[1] != ':' && cp[1] != '.')
                            return JSI_ERROR;
                    }
                    cp++;
                }
                if (*cp != ')')
                    return JSI_ERROR;
                if (eq && !ttb)
                    return JSI_ERROR;
                if (ttp) {
                    Jsi_DString tStr = {};
                    Jsi_DSAppendLen(&tStr, ttp+1, (cp - ttp - 1));
                    if (!jdb->typeNameHash) mdbTypeNameHashInit(jdb);
                    int rc = (Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr)) != NULL);
                    if (!rc) {
                        Jsi_DString eStr = {};
                        Jsi_HashEntry *hPtr;
                        Jsi_HashSearch search;
                        Jsi_Interp *interp = jdb->interp;
                        int n = 0;
                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);
                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
                            const char *key = (char*)Jsi_HashKeyGet(hPtr);
                            Jsi_DSAppend(&eStr, (n++?", ":""), key, NULL);
                        }
                        Jsi_LogWarn("bind type \"%s\" is not one of: %s", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));
                        Jsi_DSFree(&eStr);
                    }
                    Jsi_DSFree(&tStr);
                    if (!rc)
                        return JSI_ERROR;
                }
            } else
                cp--;
            if (cnt++)
                Jsi_DSAppendLen(nStr, " ", 1);
            Jsi_DSAppendLen(nStr, ocp, cp-ocp+1);
            Jsi_DSAppendLen(sStr, "?", 1);
        } else if (*cp == '\\' && cp[1]) {
            Jsi_DSAppendLen(sStr, cp, 2);
            cp++;
        } else {
            Jsi_DSAppendLen(sStr, cp, 1);
        }
        cp++;
    }
    return JSI_OK;
}

/*
** Search the cache for a prepared-statement object that implements the
** first SQL statement in the buffer pointed to by parameter zIn. If
** no such prepared-statement can be found, allocate and prepare a new
** one. In either case, bind the current values of the relevant Jsi
** variables to any $var, :var or @var variables in the statement. Before
** returning, set *ppPreStmt to point to the prepared-statement object.
**
** Output parameter *pzOut is set to point to the next SQL statement in
** buffer zIn, or to the '\0' byte at the end of zIn if there is no
** next statement.
**
** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned
** and an error message loaded into interpreter jdb->interp.
*/
static Jsi_RC mdbPrepareStmt(MyDbEvalContext *p)
{
    MySqlObj *jdb = p->jdb;
    //int namedParams = !jdb->optPtr->noNamedParams;
    const char *zSql = p->zSql;         /* Pointer to first SQL statement in zIn */
    MYSQL_STMT *myStmt;            /* Prepared statement object */
    MysqlPrep *prep = 0;  /* Pointer to cached statement */
    Jsi_RC rc = JSI_OK;
    Jsi_Interp *interp = jdb->interp;


    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);
    if (entry && ((prep = (MysqlPrep*)Jsi_HashValueGet(entry)))) {
        
        if (jdb->debug & mdbTMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare cache-hit: %s\n", zSql);
        myStmt = prep->myStmt;

        /* When a prepared statement is found, unlink it from the
        ** cache list.  It will later be added back to the beginning
        ** of the cache list in order to implement LRU replacement.
        */
        Jsi_ListPop(jdb->stmtCache, prep->elPtr);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
        
        // Sanity check for schema check: right now we just use number of columns
        if (prep->numCol != (int)mysql_stmt_field_count(prep->myStmt)) {
            mdbRelease1Stmt(jdb, prep);
            prep = NULL;
        }
    }
    
    /* If no prepared statement was found. Compile the SQL text. Also allocate
    ** a new MysqlPrep structure.  */
    if (!prep) {
        myStmt = mysql_stmt_init(jdb->db);
        if (!myStmt) 
            return Jsi_LogError("can't get statement: %s", mysql_error(jdb->db));
        char **paramNames;
        int paramCnt;
        int namedParams = 0;
        Jsi_DString *naStr = NULL;
        if (p->namedParams)
        {
            Jsi_RC rc = JSI_OK;
            Jsi_DString nsStr, nnStr;
            Jsi_DSInit(&nsStr);
            Jsi_DSInit(&nnStr);
            if (MySqlExtractParmNames(jdb, zSql, &nsStr, &nnStr) != JSI_OK)
                rc = Jsi_LogError("parsing names from query: %s", zSql);
            else if (Jsi_DSLength(&nnStr)) {
                namedParams = 1;
                zSql = Jsi_DSFreeDup(&nsStr);
                naStr = (Jsi_DString*)Jsi_Calloc(1, sizeof(*naStr));
                Jsi_SplitStr(Jsi_DSValue(&nnStr), &paramCnt, &paramNames, " ", naStr);
            }
            Jsi_DSFree(&nsStr);
            Jsi_DSFree(&nnStr);
            if (rc != JSI_OK)
                return rc;
        }

        if (mysql_stmt_prepare(myStmt, zSql, Jsi_Strlen(zSql)) )
        {
            Jsi_LogError("error in sql: %s", mysql_error(jdb->db));
            mysql_stmt_close(myStmt);
            if (namedParams) {
                Jsi_DSFree(naStr);
                Jsi_Free(naStr);
                Jsi_Free((char*)zSql);
            }
            return JSI_ERROR;
        }

        if (jdb->debug & mdbTMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare new: %s\n", zSql);
        assert( prep==0 );
        prep = (MysqlPrep*)Jsi_Calloc(1, sizeof(MysqlPrep));
        jdb->numStmts++;
        prep->sig = MYSQL_SIG_STMT;
        prep->myStmt = myStmt;
        if (!namedParams)
            prep->zSql = Jsi_Strdup(zSql);
        else {
            prep->zSql = (char*)zSql;
            prep->origSql = Jsi_Strdup(p->zSql);
            prep->naStr = naStr;
            prep->paramCnt = paramCnt;
            prep->paramNames = paramNames;
        }
        prep->paramMetaData = mysql_stmt_param_metadata(myStmt);
        prep->resultMetaData = mysql_stmt_result_metadata(myStmt);
        prep->numCol = mysql_stmt_field_count(myStmt);
        if (prep->numCol>0)
            prep->bindResult = (MYSQL_BIND *)Jsi_Calloc(prep->numCol, sizeof(MYSQL_BIND));
        prep->numParam = mysql_stmt_param_count(myStmt);
        if (prep->numParam>0 && !prep->bindParam) {
            prep->bindParam = (MYSQL_BIND *)Jsi_Calloc(prep->numParam, sizeof(MYSQL_BIND));
            prep->fieldParam = (SqlFieldResults*)Jsi_Calloc(prep->numParam, sizeof(*prep->fieldParam));
        }
        bool isNew = 0;
        prep->entry = Jsi_HashEntryNew(jdb->stmtHash, p->zSql, &isNew);
        if (!isNew)
            JSI_DBQUERY_PRINTF( "mysql dup stmt entry");
        Jsi_HashValueSet(prep->entry, prep);
    }
    p->prep = prep;
    return rc;
}

/*
** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is
** returned, then an error message is stored in the interpreter before
** returning.
**
** A return value of JSI_OK means there is a row of data available. The
** data may be accessed using mdbEvalRowInfo() and dbEvalColumnValue(). This
** is analogous to a return of _MYSQLN_(ROW) from mysql_step(). If JSI_BREAK
** is returned, then the SQL script has finished executing and there are
** no further rows available. This is similar to _MYSQLN_(DONE).
*/
static Jsi_RC mdbEvalPrep(MyDbEvalContext *p) {
    MysqlPrep *prep = p->prep;
    Jsi_Interp *interp = p->jdb->interp;
    Jsi_RC rc = JSI_OK;
    if( p->prep==0 ) {
        rc = mdbPrepareAndBind(p); //p->jdb, p->zSql, &p->zSql, &p->prep);
        if( rc!=JSI_OK )
            return rc;
        prep = p->prep;
        if (p->jdb->optPtr->prefetch) {
            my_bool aBool = 1;
            mysql_stmt_attr_set(prep->myStmt, STMT_ATTR_UPDATE_MAX_LENGTH, &aBool);
        }
        if (mysql_stmt_execute(prep->myStmt)) {
            Jsi_Interp *interp = p->jdb->interp;
            rc = Jsi_LogError("execute failed: %s", mysql_error(p->jdb->db));
        }
        if (p->jdb->optPtr->prefetch && mysql_stmt_store_result(prep->myStmt)) {
            Jsi_LogWarn("prefetch failed, disabling: %s", mysql_error(p->jdb->db));
            p->jdb->optPtr->prefetch = 0;
        }
        MYSQL_RES *res = mysql_stmt_result_metadata(prep->myStmt);
        MYSQL_FIELD *field;
        if (res) {
            // Setup field mappings to/from Jsi.
            prep->fieldResult = (SqlFieldResults*)Jsi_Calloc(res->field_count, sizeof(*prep->fieldResult));
            prep->colNames = (char**)Jsi_Calloc(res->field_count, sizeof(char*));
            prep->colTypes = (Jsi_OptionId*)Jsi_Calloc(res->field_count, sizeof(int));
            int iCnt = 0;
            while((field = mysql_fetch_field(res)))
            {
                assert(iCnt<prep->numCol);
                SqlFieldResults *fres = prep->fieldResult+iCnt;
                MYSQL_BIND *bindResult = prep->bindResult+iCnt;
                
                bindResult->buffer = &fres->buffer.vchar;
                fres->field = field;
                prep->colNames[iCnt] = field->name;
                switch (field->type) {
                    case MYSQL_TYPE_TINY:
                    case MYSQL_TYPE_BIT:
                        if (field->length == 1) {
                            fres->jsiTypeMap = JSI_OPTION_BOOL;
                            fres->mapType = MYSQL_TYPE_DOUBLE;
                            fres->vsize = 1;
                            break;
                            
                        }
                    case MYSQL_TYPE_SHORT:
                    case MYSQL_TYPE_LONG:
                    case MYSQL_TYPE_DECIMAL:
                        fres->jsiTypeMap = JSI_OPTION_INT64;
                        fres->mapType = MYSQL_TYPE_LONG;
                        fres->vsize = sizeof(long long);
                        break;
                    case MYSQL_TYPE_LONGLONG:
                        fres->jsiTypeMap = JSI_OPTION_INT64;
                        fres->mapType = MYSQL_TYPE_LONGLONG;
                        fres->vsize = sizeof(long long);
                        break;
                    
                    case MYSQL_TYPE_FLOAT:
                    case MYSQL_TYPE_DOUBLE:
                        fres->jsiTypeMap = JSI_OPTION_DOUBLE;
                        fres->mapType = MYSQL_TYPE_DOUBLE;
                        fres->vsize = sizeof(double);
                        break;
                    case MYSQL_TYPE_TIME:
                    case MYSQL_TYPE_DATE:
                    case MYSQL_TYPE_DATETIME:
                    case MYSQL_TYPE_TIMESTAMP:
                        fres->jsiTypeMap = JSI_OPTION_TIME_D; //TODO: time
                        fres->mapType = MYSQL_TYPE_DATETIME;
                        fres->vsize = sizeof(MYSQL_TIME);
                        break;
                    case MYSQL_TYPE_STRING:
                    default:
                        if (IS_NUM(field->type)) {
                            fres->mapType = MYSQL_TYPE_LONGLONG;
                            fres->jsiTypeMap = JSI_OPTION_DOUBLE;
                            fres->vsize = sizeof(double);
                        } else {
                            fres->jsiTypeMap = JSI_OPTION_STRING;
                            fres->mapType = MYSQL_TYPE_STRING;
                            if (p->jdb->optPtr->prefetch)
                                fres->vsize = field->max_length;
                            else
                                fres->vsize = p->jdb->optPtr->maxString;
                            if (fres->vsize <= 0)
                                fres->vsize = BUFSIZ;
                            bindResult->buffer = fres->buffer.vstring = (char*)Jsi_Malloc(fres->vsize);
                            fres->buffer.vstring[0] = 0;
                        }
                        break;
                }
                prep->colTypes[iCnt] = fres->jsiTypeMap;
                bindResult->buffer_type = fres->mapType;
                bindResult->buffer_length = fres->vsize;
                bindResult->length = &fres->len;
                bindResult->is_null = &fres->isnull;
                iCnt++;
            }
        }
        else return JSI_BREAK;
        if (mysql_stmt_bind_result(prep->myStmt, prep->bindResult)) {
            fprintf(stderr, "mysql_stmt_bind_Result(), failed. Error:%s\n", mysql_stmt_error(prep->myStmt));
            return JSI_ERROR;
        }
    }
    return rc;
}

static Jsi_RC mdbEvalStep(MyDbEvalContext *p) {
    Jsi_RC rc = JSI_OK;
    if( p->prep==0)
        rc = mdbEvalPrep(p);
    if (rc == JSI_BREAK)
        return JSI_BREAK;
    if (rc == JSI_OK)
        rc = mdbEvalStepSub(p, 1, NULL);
    return rc;
}

const char *mysqlGetbindParamName(MysqlPrep* pStmt, int n) {
    if (n>=1 && n<=pStmt->paramCnt)
        return pStmt->paramNames[n-1];
    return NULL;
}
  
/*
enum enum_field_types { MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY,
                        MYSQL_TYPE_SHORT,  MYSQL_TYPE_LONG,
                        MYSQL_TYPE_FLOAT,  MYSQL_TYPE_DOUBLE,
                        MYSQL_TYPE_NULL,   MYSQL_TYPE_TIMESTAMP,
                        MYSQL_TYPE_LONGLONG,MYSQL_TYPE_INT24,
                        MYSQL_TYPE_DATE,   MYSQL_TYPE_TIME,
                        MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR,
                        MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR,
                        MYSQL_TYPE_BIT,
                        MYSQL_TYPE_NEWDECIMAL=246,
                        MYSQL_TYPE_ENUM=247,
                        MYSQL_TYPE_SET=248,
                        MYSQL_TYPE_TINY_BLOB=249,
                        MYSQL_TYPE_MEDIUM_BLOB=250,
                        MYSQL_TYPE_LONG_BLOB=251,
                        MYSQL_TYPE_BLOB=252,
                        MYSQL_TYPE_VAR_STRING=253,
                        MYSQL_TYPE_STRING=254,
                        MYSQL_TYPE_GEOMETRY=255

};
*/
/*
 * MYSQL_TYPE_TINY  1
MYSQL_TYPE_SHORT    2
MYSQL_TYPE_LONG 4
MYSQL_TYPE_LONGLONG 8
MYSQL_TYPE_FLOAT    4
MYSQL_TYPE_DOUBLE   8
MYSQL_TYPE_TIME sizeof(MYSQL_TIME)
MYSQL_TYPE_DATE sizeof(MYSQL_TIME)
MYSQL_TYPE_DATETIME sizeof(MYSQL_TIME)
MYSQL_TYPE_STRING   data length
MYSQL_TYPE_BLOB data_length
*/


static Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p)
{
    if (mdbPrepareStmt(p) != JSI_OK)
        return JSI_ERROR;
    MysqlPrep *prep = p->prep;
    MySqlObj *jdb = p->jdb;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *pv = NULL, *lv = NULL, *apv = NULL;
    char tname[50];

    Jsi_RC rc = JSI_OK;
    int i, n, decr, nVar = prep->numParam;

    if (nVar<=0)
        return rc;
    if (!prep->bindParam)
        prep->bindParam = (MYSQL_BIND*)Jsi_Calloc(nVar, sizeof(MYSQL_BIND));
    else
        memset(prep->bindParam, 0, (nVar * sizeof(MYSQL_BIND)));
    for(i=1; i<=nVar; i++) {
        int btype = 0;
        int isInt = 0;
        int isBlob = 0;
        const char *zVar = mysqlGetbindParamName(prep, i);
        tname[0] = 0;
        decr = 0;
        if (zVar == NULL) {
            if (!jdb->optPtr || (!jdb->optPtr->varName && !jdb->optPtr->values)) 
                return Jsi_LogError("? bind without varName/values for param %d", i);
            if (!apv) {
                if (!(apv = jdb->optPtr->values))
                    apv = Jsi_NameLookup(interp, jdb->optPtr->varName);
            }
            if (apv == NULL || !Jsi_ValueIsArray(interp, apv)) 
                return Jsi_LogError("can not find array var: %s", jdb->optPtr->varName);
            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) 
                return Jsi_LogError("array element %d missing", nVar);
        }
        else if ((zVar[0]!='$' && zVar[0]!=':' && zVar[0]!='@') ) 
            return Jsi_LogError("can not find bind var %s", zVar); else {
           
            int zvLen = Jsi_Strlen(zVar);
            char *zcp;
            if (zVar[0] =='$' && ((zcp = Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')
            {
                Jsi_DString vStr;
                Jsi_DSInit(&vStr);
                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));
                int slen = Jsi_Strlen(zcp);
                const char *ttp;
                if (jdb->optPtr->typeCheck!=mdbTypeCheck_None && (ttp = Jsi_Strchr(zVar,':'))) {
                    // Extract bind-type.
                    Jsi_DString tStr = {};
                    int tlen = Jsi_Strlen(ttp+1);
                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);
                    snprintf(tname, sizeof(tname), "%s", Jsi_DSValue(&tStr));
                    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(jdb->typeNameHash, tname);
                    assert(hPtr);
                    btype = (long)Jsi_HashValueGet(hPtr);
                    Jsi_DSFree(&tStr);
                    slen -= tlen;
                }

                if (isdigit(zcp[1])) {
                    Jsi_DSAppendLen(&vStr, "[", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                    Jsi_DSAppendLen(&vStr, "]", 1);
                } else {
                    if (zcp[1] != '[')
                        Jsi_DSAppendLen(&vStr, ".", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                }
                lv = pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));
                Jsi_DSFree(&vStr);
                //decr = 1;
            } else
                pv = Jsi_VarLookup(interp, &zVar[1]);
        }
        Jsi_Number r;
        SqlFieldResults *fres = prep->fieldParam+i-1;
        MYSQL_BIND *bind = prep->bindParam+i-1;
        memset(bind, 0, sizeof(*bind));
        // Now create binding.
        if(!pv ) {
            if (!jdb->bindWarn) {
                rc = Jsi_LogError("unknown bind param: %s", zVar);
                break;
            } else
                Jsi_LogWarn("unknown bind param: %s", zVar);
        } else {
            if (btype && !Jsi_ValueIsUndef(interp, pv)) {
                int done = 0, match = 1, cast = (jdb->optPtr->typeCheck==mdbTypeCheck_Cast);
                switch (btype) {
                    case MYSQL_TYPE_BLOB:
                        isBlob = 1;
                    case MYSQL_TYPE_STRING:
                        if (cast)
                            Jsi_ValueToString(interp, pv, &n);
                        else
                            match = Jsi_ValueIsString(interp, pv); 
                        break;
                    case MYSQL_TYPE_DOUBLE:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv); 
                        break;
                    case MYSQL_TYPE_LONGLONG:
                        isInt = 1;
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv); 
                        break;
                    case MYSQL_TYPE_TINY:
                        if (cast)
                            Jsi_ValueToBool(interp, pv);
                        else
                            match = Jsi_ValueIsBoolean(interp, pv); 
                        break;
                    case MYSQL_TYPE_TIME:
                    case MYSQL_TYPE_DATE:
                    case MYSQL_TYPE_DATETIME:
                    case MYSQL_TYPE_TIMESTAMP:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else if (!Jsi_ValueIsNumber(interp, pv))
                            goto errout;
                        Jsi_GetNumberFromValue(interp, pv, &r);
                        bind->buffer_type = (enum enum_field_types)btype;
                        bind->buffer=&fres->buffer.timestamp;
                        bind->buffer_length = sizeof(fres->buffer.timestamp);
                        bind->length = NULL;
                        mdbJsToMyTime(r, &fres->buffer.timestamp, 1);
                        done = 1;
                        break;
                    default:
                        Jsi_LogBug("Unhandled bind type: %s = %d", tname, btype);
                }
                if (done)
                    continue;
                 if (cast == 0 && match == 0) 
errout:
                 {
                    int ltyp = (jdb->optPtr->typeCheck==mdbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);
                    Jsi_LogMsg(interp, ltyp, "bind param \"%s\" type is not \"%s\"", zVar, tname);
                    if (ltyp == JSI_LOG_ERROR)
                        return JSI_ERROR;
                }
            }
            
            if (Jsi_ValueIsBoolean(interp, pv)) {
                bool nb;
                Jsi_GetBoolFromValue(interp, pv, &nb);
                n = nb;
                bind->buffer_type = MYSQL_TYPE_TINY;
                bind->buffer = &fres->buffer.vchar;
                bind->buffer_length = sizeof(fres->buffer.vchar);
                bind->length = &fres->len;
                //bind->is_null = &fres->isnull;
                fres->buffer.vchar = n;
                
            } else if (Jsi_ValueIsNumber(interp, pv)) {
                Jsi_Number r;
                Jsi_Wide wv;
                Jsi_GetNumberFromValue(interp, pv, &r);
                wv = (Jsi_Wide)r;
                bind->buffer_type = MYSQL_TYPE_DOUBLE;
                bind->buffer = &fres->buffer.vdouble;
                bind->buffer_length = sizeof(fres->buffer.vdouble);
                bind->length = &fres->len;
                fres->buffer.vdouble = (double)r;
                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0)) {
                    bind->buffer = &fres->buffer.vlonglong;
                    bind->buffer_type = MYSQL_TYPE_LONGLONG;
                    bind->buffer_length = sizeof(fres->buffer.vlonglong);
                    fres->buffer.vlonglong = wv;
                }
            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->optPtr->mapundef)) {
bindnull:
                bind->buffer_type = MYSQL_TYPE_NULL;
                bind->buffer = &fres->buffer.vchar;
                bind->buffer_length = sizeof(fres->buffer.vchar);
                bind->length = &fres->len;
                fres->buffer.vchar = 0;

            } else if (Jsi_ValueIsString(interp, pv)) {
                char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);
                bind->buffer_type = MYSQL_TYPE_STRING;
                bind->buffer=sstr;
                bind->buffer_length = n;
                bind->length = NULL;
                if (isBlob)
                    bind->buffer_type = MYSQL_TYPE_BLOB;
            } else {
                if (!jdb->bindWarn) {
                    rc = Jsi_LogError("bind param must be string/number/bool/null: %s", zVar);
                    break;
                } else {
                    Jsi_LogWarn("bind param must be string/number/bool/null: %s", zVar);
                    goto bindnull;
                }
            }
            if (decr)
                Jsi_DecrRefCount(interp, pv);
        }
    }
    if (mysql_stmt_bind_param(prep->myStmt, prep->bindParam))
        rc = Jsi_LogError("bind failed: %s", mysql_error(jdb->db));
    if (lv)
        Jsi_DecrRefCount(interp, lv);
    return rc;
}


static void mdbClose(MYSQL  *db) {
        mysql_close(db);
}

static Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value)
{
    if (!Jsi_ValueIsArray(interp, value)) 
        return Jsi_LogError("expected array of numbers");
    int i, argc = Jsi_ValueGetLength(interp, value);
    for (i=0; i<argc; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);
        if (!Jsi_ValueIsNumber(interp, v)) 
            return Jsi_LogError("expected array of numbers");
    }
    return JSI_OK;
}

/*
** JSI calls this procedure when an MYSQL  database command is
** deleted.
*/
static void mdbDeleteCmd(MySqlObj *jdb)
{
    Jsi_Interp *interp = jdb->interp;
    if (jdb->debug & mdbTMODE_DELETE)
        JSI_DBQUERY_PRINTF( "DEBUG: delete\n");
    if (jdb->stmtCache)
        mdbFlushStmtCache(jdb);
    if (jdb->stmtHash)
        Jsi_HashDelete(jdb->stmtHash);
    //closeIncrblobChannels(jdb);
    if (jdb->db) {
        mdbClose(jdb->db);
    }
    while( jdb->pFunc ) {
        SqlFunc *pFunc = jdb->pFunc;
        jdb->pFunc = pFunc->pNext;
        Jsi_DSFree(&pFunc->dScript);
        Jsi_DecrRefCount(interp, pFunc->tocall);
        Jsi_Free((char*)pFunc);
    }
    if( jdb->zNull ) {
        Jsi_Free(jdb->zNull);
    }
    if (jdb->typeNameHash)
        Jsi_HashDelete(jdb->typeNameHash);
    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);
    if (jdb->stmtCache)
        Jsi_ListDelete(jdb->stmtCache);
}

/*
** Return a JSON formatted value for the iCol'th column of the row currently pointed to by
** the MyDbEvalContext structure passed as the first argument.
*/
static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {
    Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    if (field->isnull) {
        Jsi_DSAppend(dStr, "null", NULL);
        return;
    }
    const char *zBlob = "";
    int bytes = 0;

    switch(field->jsiTypeMap) {
        case JSI_OPTION_BOOL: {
            snprintf(nbuf, sizeof(nbuf), "%s", field->buffer.vchar?"true":"false");
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_INT64: {
            snprintf(nbuf, sizeof(nbuf), "%lld", field->buffer.vlonglong);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DOUBLE: {
            Jsi_NumberToString(field->buffer.vdouble, nbuf, sizeof(nbuf));
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        //case JSI_OPTION_TIME_T:
        case JSI_OPTION_TIME_D:
        case JSI_OPTION_TIME_W: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            Jsi_NumberToString(jtime, nbuf, sizeof(nbuf));
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_STRING:
            zBlob = field->buffer.vstring;
        default:
        {
            if( !zBlob ) {
                Jsi_DSAppend(dStr, "null", NULL);
                return;
            }
            Jsi_JSONQuote(interp, zBlob, bytes, dStr);
            return;
        }
    }
}

static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {
    //Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    Jsi_Interp *interp = p->jdb->interp;
    if (field->isnull)
        return;
        
    switch(field->jsiTypeMap) {
        case JSI_OPTION_STRING: {
            int bytes = field->len;
            const char *zBlob = field->buffer.vstring;
    
            if( !zBlob ) {
                const char *nv = p->jdb->optPtr->nullvalue;
                Jsi_DSAppend(dStr, nv?nv:"null", NULL);
                return;
            }
            Jsi_DSAppendLen(dStr, zBlob, bytes);
            return;
        }
        case JSI_OPTION_BOOL: {
            snprintf(nbuf, sizeof(nbuf), "%s", field->buffer.vchar?"true":"false");
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_INT64: {
            snprintf(nbuf, sizeof(nbuf), "%lld", field->buffer.vlonglong);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        //case JSI_OPTION_TIME_T:
        case JSI_OPTION_TIME_D:
        case JSI_OPTION_TIME_W: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            Jsi_NumberToString(jtime, nbuf, sizeof(nbuf));
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DOUBLE: {
            Jsi_NumberToString(field->buffer.vdouble, nbuf, sizeof(nbuf));
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        default:
            Jsi_LogWarn("unknown type: %d", field->jsiTypeMap);
    
    }
}


static Jsi_Value* mdbEvalSetColumnValue(MyDbEvalContext *p, int iCol, Jsi_Value **val) {
    Jsi_Interp *interp = p->jdb->interp;
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    if (field->isnull)
        return Jsi_ValueMakeNull(interp, val);
        
    switch(field->jsiTypeMap) {
        case JSI_OPTION_STRING: {
            int bytes = field->len;
            char *zBlob = field->buffer.vstring;
            if( !zBlob ) {
                return Jsi_ValueMakeNull(interp, val);
            }
            zBlob = (char*)Jsi_Malloc(bytes+1);
            memcpy(zBlob, field->buffer.vstring, bytes);
            zBlob[bytes] = 0;
            return Jsi_ValueMakeBlob(interp, val, (unsigned char*)zBlob, bytes+1);
        }
        case JSI_OPTION_BOOL:
            return Jsi_ValueMakeBool(interp, val, field->buffer.vchar);
        case JSI_OPTION_INT64:
             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vlonglong);
        //case JSI_OPTION_TIME_T:
        case JSI_OPTION_TIME_D:
        case JSI_OPTION_TIME_W: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            return Jsi_ValueMakeNumber(interp, val, jtime);
        }
        case JSI_OPTION_DOUBLE:
             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vdouble);
        default:
            Jsi_LogWarn("unknown type: %d", field->jsiTypeMap);
    }
    return Jsi_ValueNew1(interp);
}

static Jsi_RC mdbEvalCallCmd( MyDbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)
{
    int cnt = 0;
    Jsi_RC rc = result;
    Jsi_Value *varg1;
    Jsi_Obj *argso;
    char **apColName = NULL;
    Jsi_OptionId *apColType = NULL;
    if (p->jdb->debug & mdbTMODE_EVAL)
        JSI_DBQUERY_PRINTF( "DEBUG: eval\n");

    while( (rc==JSI_OK) && JSI_OK==(rc = mdbEvalStep(p)) ) {
        int i;
        int nCol;

        cnt++;
        mdbEvalRowInfo(p, &nCol, &apColName, &apColType);
        if (nCol<=0)
            continue;
        if (Jsi_ValueIsNull(interp,p->tocall))
            continue;
        /* Single object containing sql result members. */
        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));
        for(i=0; i<nCol; i++) {
            Jsi_Value *nnv = mdbEvalSetColumnValue(p, i, NULL);
            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);
        }
        Jsi_IncrRefCount(interp, varg1);
        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);
        Jsi_DecrRefCount(interp, varg1);
        if (rb)
            break;
    }
    //mdbEvalFinalize(p);

    if( rc==JSI_OK || rc==JSI_BREAK ) {
        //Jsi_ResetResult(interp);
        rc = JSI_OK;
    }
    return rc;
}

static MySqlObj *_mysql_getDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)
{
    MySqlObj *jdb = (MySqlObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!jdb) {
        Jsi_LogError("MySql call to a non-mysql object");
        return NULL;
    }
    if (!jdb->db)
    {
        Jsi_LogError("MySql db is closed");
        return NULL;
    }
    return jdb;
}

static void mysqlObjErase(MySqlObj *jdb)
{
    mdbDeleteCmd(jdb);
    jdb->db = NULL;
}

static Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data)
{
    MySqlObj *fo = (MySqlObj*)data;
    SQLSIGASSERT(fo,DB);
    mysqlObjErase(fo);
    _JSI_MEMCLEAR(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static bool mysqlObjIsTrue(void *data)
{
    MySqlObj *fo = (MySqlObj*)data;
    SQLSIGASSERT(fo,DB);
    if (!fo->db) return 0;
    else return 1;
}

static bool mysqlObjEqual(void *data1, void *data2)
{
    //SQLSIGASSERT(data1,DB);
    //SQLSIGASSERT(data2,DB);
    return (data1 == data2);
}
static MYSQL* mdbConnect(Jsi_Interp *interp, MySqlObj* jdb)
{
    return mysql_real_connect(jdb->db,
        jdb->host?Jsi_ValueString(interp, jdb->host, NULL):NULL,
        jdb->user, jdb->password, jdb->database,
        jdb->port, 0, jdb->dbflags);
}

#define FN_MySql JSI_INFO("\
Create a mysql client.")
static Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);

static Jsi_RC MySqlReconnectCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);
    if (!jdb) return JSI_ERROR;
    int oldMax = jdb->maxStmts;
    jdb->maxStmts = 0;
    mdbStmtLimit(jdb);
    jdb->maxStmts = oldMax;
    mysql_close(jdb->db);
    jdb->db = mysql_init(NULL);
    if (!mdbConnect(interp, jdb)) 
        return Jsi_LogError("reconnect failed: %s", mysql_error(jdb->db));
    return JSI_OK;
}

#define FN_evaluate JSI_INFO("\
Variable binding is NOT performed.  \
Returns number of modified fields")
static Jsi_RC MySqlEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);
    if (!jdb) return JSI_ERROR;
    int zLen, cnt = 0;
    Jsi_RC rc = JSI_OK;
    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, &zLen);

    if (mysql_real_query(jdb->db, zSql, zLen))
        rc = Jsi_LogError("mysql error: %s", mysql_error(jdb->db));
    else if (jdb->enableMulti) {
        MYSQL_RES *results;
        int sr = mysql_next_result(jdb->db);
        while (sr == 0 && (results = mysql_store_result(jdb->db)))
            mysql_free_result(results);
        cnt = mysql_field_count(jdb->db);
    }
        
    if (rc == JSI_OK)
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);
    return rc;
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, 
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
};

/*
** Output a single term of CSV.  Actually, p->separator is used for
** the separator, which may or may not be a comma.  p->nullvalue is
** the null value.  Strings are quoted if necessary.
*/
static void mdbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)
{
    if( z==0 ) {
        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:"", NULL);
    } else {
        int i;
        int nSep = Jsi_Strlen(p->separator);
        for(i=0; z[i]; i++) {
            if( needCsvQuote[((unsigned char*)z)[i]] || 
                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {
                i = 0;
                break;
            }
        }
        if( i==0 ) {
            Jsi_DSAppend(dStr, "\"", NULL);
            for(i=0; z[i]; i++) {
                if( z[i]=='"' ) Jsi_DSAppend(dStr, "\"", NULL);
                Jsi_DSAppendLen(dStr, z+i, 1);
            }
            Jsi_DSAppend(dStr, "\"", NULL);
        } else {
            Jsi_DSAppend(dStr, z, NULL);
        }
    }
    if( bSep ) {
        Jsi_DSAppend(dStr, p->separator, NULL);
    }
}

static void mdbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)
{
    while( *z ) {
        switch (*z) {
        case '<':
            Jsi_DSAppend(dStr, "&lt;", NULL);
            break;
        case '>':
            Jsi_DSAppend(dStr, "&gt;", NULL);
            break;
        case '&':
            Jsi_DSAppend(dStr, "&amp;", NULL);
            break;
        case '\"':
            Jsi_DSAppend(dStr, "&quot;", NULL);
            break;
        case '\'':
            Jsi_DSAppend(dStr, "&#39;", NULL);
            break;
        default:
            Jsi_DSAppendLen(dStr, z, 1);
            break;
        }
        z++;
    }
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
*/
static void mdbOutputQuotedString(Jsi_DString *dStr, const char *z) {
    int i;
    int nSingle = 0;
    for(i=0; z[i]; i++) {
        if( z[i]=='\'' ) nSingle++;
    }
    if( nSingle==0 ) {
        Jsi_DSAppend(dStr,"'", z, "'", NULL);
    } else {
        Jsi_DSAppend(dStr,"'", NULL);
        while( *z ) {
            for(i=0; z[i] && z[i]!='\''; i++) {}
            if( i==0 ) {
                Jsi_DSAppend(dStr,"''", NULL);
                z++;
            } else if( z[i]=='\'' ) {
                Jsi_DSAppendLen(dStr,z, i);
                Jsi_DSAppend(dStr,"''", NULL);
                z += i+1;
            } else {
                Jsi_DSAppend(dStr, z, NULL);
                break;
            }
        }
        Jsi_DSAppend(dStr,"'", NULL);
    }
}

static Jsi_RC MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc = JSI_OK;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString eStr = {};
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int cnt = 0;
    char **apColName = NULL;
    Jsi_OptionId *apColType = NULL;
    int isopts = 0;
    MyDbEvalContext sEval = {};
    QueryOpts opts, *oEopt = NULL;
    opts = jdb->queryOpts;
    opts.callback = NULL;
    opts.width = NULL;
    Jsi_Value *callback = NULL, *width = NULL;
            
    if (arg) {
        if (Jsi_ValueIsNull(interp,arg)) {
        } else if (Jsi_ValueIsFunction(interp,arg)) {
            callback = opts.callback = arg;
        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {
            isopts = 1;
        } else 
            return Jsi_LogError("argument must be null, a function, or options");
    }

    if (isopts) {
        if (Jsi_OptionsProcess(interp, QueryFmtOptions, &opts, arg, 0) < 0)
            return JSI_ERROR;
        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);
        width = (opts.width ? opts.width : jdb->queryOpts.width);
    }
/*    if (jdb->queryOpts.CData) {
        char *cdata = (char*)jdb->queryOpts.CData;
        MySqlObjMultipleBind* copts = Jsi_CarrayLookup(interp, cdata);
        if (!copts) 
            return Jsi_LogError("unknown CData option: %s", jdb->queryOpts.CData);
        int n = MySqlObjQuery(jdb, copts->opts, copts->data, copts->numData, zSql, copts->flags);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
        return JSI_OK;
    } */
    if (!opts.separator) {
        switch (opts.mode) {
            case _mdb_EF_LIST: opts.separator = "|"; break;
            case _mdb_EF_COLUMN: opts.separator = " "; break;
            case _mdb_EF_TABS: opts.separator = "\t"; break;
            default: opts.separator = ",";
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = opts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) {
        rc = JSI_ERROR;
        goto bail;
    }
    sEval.namedParams = (opts.noNamedParams==0 && !opts.values);
    sEval.ret = *ret;
    oEopt = jdb->optPtr;
    jdb->optPtr = &opts;
    
    if (sEval.namedParams) {
        rc = mdbEvalPrep(&sEval);
        if (rc == JSI_ERROR)
            goto bail;
        if (rc == JSI_BREAK) {
            rc = JSI_OK;
            goto bail;
        }
    }
    if (callback) {
        sEval.tocall = callback;
        if (opts.mode != _mdb_EF_ROWS)
            rc = Jsi_LogError("'mode' must be 'rows' with 'callback'");
        else 
            rc = mdbEvalCallCmd(&sEval, interp, JSI_OK);
        goto bail;
    }
    switch (opts.mode) {
        case _mdb_EF_NONE:
            while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            goto bail;
            break;
        case _mdb_EF_JSON:
            if (opts.headers) {
                Jsi_DSAppend(dStr, "[ ", NULL);
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt == 0) {
                        Jsi_DSAppend(dStr, "[", NULL);
                        for(i=0; i<nCol; i++) {
                            if (i)
                                Jsi_DSAppend(dStr, ", ", NULL);
                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        }
                        Jsi_DSAppend(dStr, "]", NULL);
                        cnt++;
                    }
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, "]", NULL);
                    cnt++;
                    if (opts.limit && cnt>opts.limit) break;
                }
                Jsi_DSAppend(dStr, " ]", NULL);
                
            } else {
                Jsi_DSAppend(dStr, "[ ", NULL);
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "{", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        Jsi_DSAppend(dStr, ":", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, "}", NULL);
                    cnt++;
                    if (opts.limit && cnt>=opts.limit) break;
                }
                Jsi_DSAppend(dStr, " ]", NULL);
            }
            break;
            
        case _mdb_EF_JSON2: {
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt == 0 && 1) {
                        Jsi_DSAppend(dStr, "{ \"names\": [ ", NULL);
                        for(i=0; i<nCol; i++) {
                            if (i)
                                Jsi_DSAppend(dStr, ", ", NULL);
                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        }
                        Jsi_DSAppend(dStr, " ], \"values\": [ ", NULL);
                    }
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, " ]", NULL);
                    cnt++;
                    if (opts.limit && cnt>=opts.limit) break;
                }
                if (cnt)
                    Jsi_DSAppend(dStr, " ] } ", NULL);
            }
            break;
            
        case _mdb_EF_LIST:
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(dStr, apColName[i], NULL);
                    }
                }
    
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    mdbEvalSetColumn(&sEval, i, dStr);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            break;
            
        case _mdb_EF_COLUMN: {
            int *wids = NULL;
            Jsi_DString vStr = {};
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i, w;
                int nCol;
                
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && nCol>0) {
                    Jsi_DString sStr;
                    wids = (int*)Jsi_Calloc(nCol, sizeof(int));
                    Jsi_DSInit(&sStr);
                    for(i=0; i<nCol; i++) {
                        int j = Jsi_Strlen(apColName[i]);
                        wids[i] = (j<10?10:j);
                        if (width) {
                            Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);
                            if (wv) {
                                Jsi_Number dv;
                                Jsi_ValueGetNumber(interp, wv, &dv);
                                if (dv>0)
                                    wids[i] = (int)dv;
                            }
                        }
                        w = (j<wids[i] ? j : wids[i]);
                        Jsi_DSAppendLen(dStr, apColName[i], w);
                        w = (j<wids[i] ? wids[i]-j+1 : 0);
                        while (w-- > 0)
                            Jsi_DSAppend(dStr, " ", NULL);
                    }
                    for(i=0; i<nCol && opts.headers; i++) {
                        w = wids[i];
                        w -= Jsi_Strlen(apColName[i]);
                        if (i) {
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                            Jsi_DSAppend(&sStr, opts.separator, NULL);
                        }
                        w = wids[i];
                        while (w-- > 0)
                            Jsi_DSAppend(&sStr, "-", NULL);
                    }
                    if (opts.headers)
                        Jsi_DSAppend(dStr, "\n", Jsi_DSValue(&sStr), "\n", NULL);
                    Jsi_DSFree(&sStr);
                }
    
                if (cnt)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    int nl = Jsi_DSLength(&vStr);
                    if (nl > wids[i]) {
                        Jsi_DSSetLength(&vStr, wids[i]);
                        w = 0;
                    } else {
                        w = wids[i]-nl;
                    }
                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                    while (w-- > 0)
                        Jsi_DSAppend(dStr, " ", NULL);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            if (wids)
                Jsi_Free(wids);
            break;
        }
        
        case _mdb_EF_INSERT: {
            Jsi_DString vStr = {};    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                const char *tbl = (opts.table ? opts.table : "table");
                if (cnt)
                    Jsi_DSAppend(dStr, "\n", NULL);
                Jsi_DSAppend(dStr, "INSERT INTO ", tbl, " VALUES(", NULL);
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                for(i=0; i<nCol; i++) {
                    Jsi_Number dv;
                    const char *azArg;
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    
                    MysqlPrep *prep = sEval.prep;
                    Jsi_OptionId ptype = prep->fieldResult[i].jsiTypeMap;
                    
                    azArg = Jsi_DSValue(&vStr);
                    const char *zSep = i>0 ? ",": "";
                    if (azArg[i]==0) {
                      Jsi_DSAppend(dStr, zSep, "NULL", NULL);
                    } else if( ptype ==JSI_OPTION_STRING) {
                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                      mdbOutputQuotedString(dStr, azArg);
                    } else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) {
                      Jsi_DSAppend(dStr, zSep, azArg, NULL);
                    } else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ) {
                      Jsi_DSAppend(dStr, zSep, azArg, NULL);
                    } else {
                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                      mdbOutputQuotedString(dStr, azArg);
                    }
                }
                Jsi_DSAppend(dStr, ");", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
        }
    
        case _mdb_EF_TABS:
        case _mdb_EF_CSV: {
            Jsi_DString vStr = {};  
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(dStr, apColName[i], NULL);
                    }
                }
    
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    if (opts.mode == _mdb_EF_CSV)
                        mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);
                    else
                        Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_LINE: {
            int i, w = 5, ww;
            int nCol;
            Jsi_DString vStr = {};   
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0) {
                    for(i=0; i<nCol; i++) {
                        ww = Jsi_Strlen(apColName[i]);
                        if (ww>w)
                            w = ww;
                    }
                }
    
                for(i=0; i<nCol; i++) {
                    Jsi_DString eStr;
                    Jsi_DSInit(&eStr);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    Jsi_DSPrintf(&eStr, "%*s = %s", w, apColName[i], Jsi_DSValue(&vStr));
                    Jsi_DSAppend(dStr, (cnt?"\n":""), Jsi_DSValue(&eStr), NULL);
                    Jsi_DSFree(&eStr);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_HTML: {
            Jsi_DString vStr = {};   
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    Jsi_DSAppend(dStr, "<TR>", NULL);
                    for(i=0; i<nCol; i++) {
                        Jsi_DSAppend(dStr, "<TH>", NULL);
                        mdbOutputHtmlString(&opts, apColName[i], dStr);
                        Jsi_DSAppend(dStr, "</TH>", NULL);
                    }
                    Jsi_DSAppend(dStr, "</TR>", NULL);
                }
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                Jsi_DSAppend(dStr, "<TR>", NULL);
                for(i=0; i<nCol; i++) {
                    Jsi_DSAppend(dStr, "<TD>", NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);
                    Jsi_DSAppend(dStr, "</TD>", NULL);
                }
                Jsi_DSAppend(dStr, "</TR>", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_ROWS:
        {
            Jsi_Value *vcur, *vrow;
            int cnt = 0;
            Jsi_Obj *oall, *ocur;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
                vrow = Jsi_ValueMakeObject(interp, NULL, ocur);
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
        case _mdb_EF_ARRAYS:
        {
            Jsi_Value *vcur, *vrow;
            int cnt = 0;
            Jsi_Obj *oall, *ocur;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                    for(i=0; i<nCol; i++) {
                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                        Jsi_ObjArrayAdd(interp, ocur, vcur);
                    }
                    Jsi_ObjArrayAdd(interp, oall, vrow);
                }
                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjArrayAdd(interp, ocur, vcur);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
        case _mdb_EF_ARRAY1D:
        {
            Jsi_Value *vcur;
            int cnt = 0;
            Jsi_Obj *oall;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                        Jsi_ObjArrayAdd(interp, oall, vcur);
                    }
                }
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjArrayAdd(interp, oall, vcur);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
    }
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));
bail:
    mdbEvalFinalize(&sEval);
    if (isopts) {
        Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0);
    }
    Jsi_DSFree(dStr);
    Jsi_DSFree(&eStr);
    jdb->optPtr = oEopt;

    return rc;
}

static Jsi_RC MySqlOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    MyDbEvalContext sEval = {};
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    sEval.nocache = jdb->queryOpts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    sEval.tocall = NULL;
    int cnt = 0;


    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
        int nCol = sEval.prep->numCol;
        if (nCol>0)
            mdbEvalSetColumnValue(&sEval, 0, ret);
        cnt++;
    }
    mdbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    return rc;
}

static Jsi_RC MySqlExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_RC rc;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    const char *zSql;
    Jsi_DString dStr = {};
    MyDbEvalContext sEval = {};
    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = jdb->queryOpts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    int cnt = 0;


    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
        int nCol = sEval.prep->numCol;
        if (nCol>0)
            cnt++;
    }
    mdbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeBool(interp, ret, cnt);
    return rc;
}

static Jsi_RC MySqlLastRowidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide rowid;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    rowid = mdbLastInsertRowid(jdb);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);
    return JSI_OK;
}

/*
static Jsi_RC MySqlInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    _SQL_LITE_N_(_interrupt)(jdb->db);
    return JSI_OK;
} */


static Jsi_RC MySqlCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str =  Jsi_ValueString(interp, s, NULL);
    int isComplete = 0;
    if (str)
        isComplete = 0; // sqlite3_complete( str );
    Jsi_ValueMakeBool(interp, ret, isComplete);
    return JSI_OK;
}

static Jsi_RC MySqlErrorNoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int n = mysql_errno(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}

static Jsi_RC MySqlErrorStateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    const char *str = mysql_sqlstate(jdb->db);
    if (str)
        Jsi_ValueMakeStringDup(interp, ret, str);
    return JSI_OK;
}

static Jsi_RC MySqlLastQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    const char *str = mysql_info(jdb->db);
    if (str)
        Jsi_ValueMakeStringDup(interp, ret, str);
    return JSI_OK;
}

static Jsi_RC MySqlResetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
#if (MYSQL_VERSION_ID >= 50703)
    int oldMax = jdb->maxStmts;
    jdb->maxStmts = 0;
    mdbStmtLimit(jdb);
    jdb->maxStmts = oldMax;
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_reset_connection(jdb->db));
#else
    Jsi_LogWarn("mysql reset requires version 5.7.3+");
#endif
    return JSI_OK;    
}


static Jsi_RC MySqlPingCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int n = mysql_ping(jdb->db);
    bool noErr = 0;
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    if (val)
        Jsi_ValueGetBoolean(interp, val, &noErr);
    if (n && noErr==0) 
        return Jsi_LogError("ping failed: (%d) %s", n, mysql_error(jdb->db));
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);

    return JSI_OK;    
}

static Jsi_RC MySqlAffectedRowsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_affected_rows(jdb->db));
    return JSI_OK;
}
static Jsi_RC MySqlInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    const char *str, *svals[20];
    int i = 0;
    svals[i++] = "clientInfo";
    svals[i++] = mysql_get_client_info();
    svals[i++] = "hostInfo";
    svals[i++] = mysql_get_host_info(jdb->db);
    svals[i++] = "serverInfo";
    svals[i++] = mysql_get_server_info(jdb->db);
    svals[i++] = "stat";
    svals[i++] = mysql_stat(jdb->db);
    svals[i++] = 0;
    i = 0;
    while (svals[i]) {
        str = svals[i+1];
        Jsi_ObjInsert(interp, nobj, svals[i], str?Jsi_ValueNewStringDup(interp, str):Jsi_ValueNewNull(interp), 0);
    }
    Jsi_ObjInsert(interp, nobj, "threadId", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_thread_id(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "protocolVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_proto_info(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "clientVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_client_version()), 0);
    Jsi_ObjInsert(interp, nobj, "serverVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_server_version(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "warningCount", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_warning_count(jdb->db)), 0);
    return JSI_OK;
}

static Jsi_RC MySqlConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    //jdb->hasOpts = 1;
    int oms = jdb->maxStmts;
    const char *oldu = jdb->user, *oldpw = jdb->password, *olddb = jdb->database;
    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);
    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {
        JSI_DBQUERY_PRINTF( "option maxStmts value %d is not in range 0..%d", jdb->maxStmts, MAX_PREPARED_STMTS);
        jdb->maxStmts = oms;
        rc = JSI_ERROR;
    }
    if (oldu != jdb->user || oldpw != jdb->password || olddb != jdb->database)
        if (!mysql_change_user(jdb->db, jdb->user, jdb->password, jdb->database)) {
            rc = JSI_ERROR;
            jdb->user = oldu;
            jdb->password = oldpw;
            jdb->database = olddb;
        }
    mdbStmtLimit(jdb);
    return rc;
}

static Jsi_CmdSpec mysqlCmds[] = {
    { "MySql",          MySqlConstructor,    0,  1,  "options:object=void",  
        .help="Create a new db connection to a MySql database:", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },
    { "affectedRows",   MySqlAffectedRowsCmd,0, 0, "", .help="Return affected rows", .retType=(uint)JSI_TT_NUMBER },
    { "complete",       MySqlCompleteCmd,   1,  1, "sql:string", .help="Return true if sql is complete", .retType=(uint)JSI_TT_BOOLEAN },
    { "conf",           MySqlConfCmd,       0,  1, "options:string|object=void", .help="Configure options", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },
    { "errorNo",        MySqlErrorNoCmd,    0,  0, "", .help = "Return error code returned by most recent call to mysql3_exec()", .retType=(uint)JSI_TT_NUMBER },
    { "errorState",     MySqlErrorStateCmd, 0,  0, "", .help = "Return the mysql error state str" , .retType=(uint)JSI_TT_STRING},
    { "eval",           MySqlEvalCmd,       1,  1, "sql:string", .help="Run sql commands without input/output", .retType=(uint)JSI_TT_NUMBER },
    { "exists",         MySqlExistsCmd,     1,  1, "sql:string", .help="Execute sql, and return true if there is at least one result value", .retType=(uint)JSI_TT_BOOLEAN },
    { "info",           MySqlInfoCmd,       0,  0, "", .help="Return info about last query", .retType=(uint)JSI_TT_OBJECT },
    { "lastQuery",      MySqlLastQueryCmd,  0,  0, "", .help="Return info string about most recently executed statement", .retType=(uint)JSI_TT_STRING },
    { "lastRowid",      MySqlLastRowidCmd,  0,  0, "", .help="Return rowid of last insert", .retType=(uint)JSI_TT_NUMBER },
    { "onecolumn",      MySqlOnecolumnCmd,  1,  1, "sql:string", .help="Execute sql, and return a single value", .retType=(uint)JSI_TT_ANY },
    { "ping",           MySqlPingCmd,       0,  1, "noError:boolean=false", .help="Ping connection", .retType=(uint)JSI_TT_NUMBER },
    { "query",          MySqlQueryCmd,      1,  2, "sql:string, options:function|object=void", .help="Run sql query with input and/or outputs.", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=QueryFmtOptions },
    { "reconnect",      MySqlReconnectCmd,  0,  0, "", .help="Reconnect with current settings", .retType=(uint)JSI_TT_VOID },
    { "reset",          MySqlResetCmd,      0,  0, "", .help="Reset connection", .retType=(uint)JSI_TT_NUMBER },
    { NULL, 0,0,0,0, .help="Commands for accessing mysql databases" }
};

    
static Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data);
static bool  mysqlObjEqual(void *data1, void *data2);
static bool  mysqlObjIsTrue(void *data);

static Jsi_UserObjReg mysqlobject = {
    .name   = "MySql",
    .spec   = mysqlCmds,
    .freefun= mysqlObjFree,
    .istrue = mysqlObjIsTrue,
    .isequ  = mysqlObjEqual
};

static Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    jdb = (MySqlObj*)Jsi_Calloc(1, sizeof(*jdb));
    SQLSIGINIT(jdb, DB);
    const char *groupname = "mysqljsi";
    
    jdb->maxStmts = NUM_PREPARED_STMTS;
    jdb->forceInt = 1;
    jdb->interp = interp;
    jdb->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (jdb->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, jdb, arg, 0) < 0) {
        jdb->deleted = 1;
        mysqlObjFree(interp, jdb);
        return JSI_ERROR;
    }
    jdb->db = mysql_init(NULL);
    jdb->version = (MYSQL_VERSION_MAJOR + ((Jsi_Number)MYSQL_VERSION_MINOR/100.0) + ((Jsi_Number)MYSQL_VERSION_PATCH/10000.0));

#if (MYSQL_VERSION_ID>=32350)
    if (jdb->reconnect)
    {
      my_bool reconnect = 1;
      mysql_options(jdb->db, MYSQL_OPT_RECONNECT, &reconnect);
    }
    mysql_options(jdb->db, MYSQL_READ_DEFAULT_GROUP, groupname);
#endif

#if (MYSQL_VERSION_ID >= 40107)
    if (jdb->sslKey) {
        const char *sslcert = Jsi_ValueString(interp, jdb->sslCert, NULL),
            *sslca = Jsi_ValueString(interp, jdb->sslCA, NULL),
            *sslcapath = Jsi_ValueString(interp, jdb->sslCAPath, NULL),
            *sslcipher = Jsi_ValueString(interp, jdb->sslCipher, NULL),
            *sslkey = Jsi_ValueString(interp, jdb->sslKey, NULL);
        mysql_ssl_set(jdb->db, sslkey, sslcert, sslca, sslcapath, sslcipher);
        jdb->dbflags |= CLIENT_SSL;
    }
#endif

    if (!mdbConnect(interp, jdb)) {
        Jsi_LogError("connect failed %s", mysql_error(jdb->db));
        mysqlObjFree(interp, jdb);
        return JSI_ERROR;
    }

    if (jdb->enableMulti) {
        if (mysql_set_server_option(jdb->db, MYSQL_OPTION_MULTI_STATEMENTS_ON))
            Jsi_LogWarn("multi on failed %s", mysql_error(jdb->db));
    }
    //jdb->event = Jsi_EventNew(interp, mysqlUpdate, jdb); //TODO: events
    Jsi_Value *toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "MySql", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((jdb->objId = Jsi_UserObjNew(interp, &mysqlobject, fobj, jdb))<0) {
        mysqlObjFree(interp, jdb);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    jdb->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    jdb->userObjPtr = fobj;
    jdb->optPtr = &jdb->queryOpts;
    jdb->stmtCache = Jsi_ListNew((Jsi_Interp*)jdb, 0, mdbStmtFreeProc);
    return JSI_OK;
}


static Jsi_RC Jsi_DoneMySql(Jsi_Interp *interp)
{
    if (Jsi_UserObjUnregister(interp, &mysqlobject) != JSI_OK)
        return JSI_ERROR;
    Jsi_PkgProvide(interp, "MySql", -1, NULL);
    return JSI_OK;
}


static int _jsimysqlinit = 0; // TODO: use interp data to support unloading.

Jsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release)
{
    if (release) {
        if (release>1)
            mysql_library_end();
        return Jsi_DoneMySql(interp);
    }
    Jsi_Hash* dbSys;
#ifndef JSI_OMIT_THREADS
    if (_jsimysqlinit == 0 && mysql_library_init(0, NULL, NULL)) {
        fprintf(stderr, "failed to initialize MySQL library\n");
        exit(1);
    }
#else
    return Jsi_LogError("Threads required for mysql");
#endif
    _jsimysqlinit = 1;
#if JSI_USE_STUBS
  if (Jsi_StubsInit(interp, 0) != JSI_OK)
    return JSI_ERROR;
#endif
    if (Jsi_PkgProvide(interp, "MySql", 1, Jsi_InitMySql) != JSI_OK)
        return JSI_ERROR;
    if (!(dbSys = Jsi_UserObjRegister(interp, &mysqlobject))) 
        return Jsi_LogError("Failed to init mysql extension");
    if (!Jsi_CommandCreateSpecs(interp, mysqlobject.name, mysqlCmds, dbSys, JSI_CMDSPEC_ISOBJ))
        return JSI_ERROR;
#ifdef JSI_DB_TEST
    if (getenv("RUN_DB_TEST"))
        TestMySql(interp);
#endif
    return JSI_OK;
}

#endif
/* Jsi commands to access C-data.   http://jsish.org */
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#ifndef JSI_OMIT_CDATA
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdint.h>
#include <sys/time.h>

#define UdcGet(udf, _this, funcPtr) \
   CDataObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr); \
    if (!udf) \
        return Jsi_LogError("CData.%s called with non-CData object", funcPtr->cmdSpec->name);

enum { jsi_CTYP_DYN_MEMORY=(1LL<<32), jsi_CTYP_STRUCT=(1LL<<33), jsi_CTYP_ENUM=(1LL<<34) };

typedef struct {
    JSI_DBDATA_FIELDS  
    Jsi_StructSpec *sl, *keysf;
    Jsi_Map** mapPtr;
    const char *help, *structName, *keyName, *varParam;
    uint flags;
    bool isAlloc;
    Jsi_Map_Type mapType;
    Jsi_Key_Type keyType;
    Jsi_Wide user;
    Jsi_Interp *interp;
    int objId;
    Jsi_Obj *fobj;
} CDataObj;

static Jsi_StructSpec*  jsi_csStructGet(Jsi_Interp *interp, const char *name);
static Jsi_StructSpec*   jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec* sl);

static Jsi_EnumSpec*    jsi_csEnumGet(Jsi_Interp *interp, const char *name);
static Jsi_EnumSpec*    jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec* sf);
static Jsi_RC     jsi_csStructInit(Jsi_StructSpec* s, uchar* data);
static Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,
    void *rec, Jsi_Value **ret, int flags, int skipArgs);
static Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec, Jsi_Wide* valPtr, Jsi_OptionSpec *spec, int idx, bool isSet);

static Jsi_StructSpec*  jsi_csStructFields(Jsi_Interp *interp, const char *name) {
    Jsi_StructSpec* sp = jsi_csStructGet(interp, name);
    if (sp)
        return (Jsi_StructSpec*)sp->data;
    return NULL;
}

enum {
    JSI_CS_SIG_NamedData=0xdeaf0100,
    JSI_CS_SIG_Ctx,
};

#define JSI_CS_DSIG(obj) (*(Jsi_Sig*)obj)


/* Traverse hash table and match unique substring. */
Jsi_HashEntry *jsi_csfindInHash(Jsi_Interp *interp, Jsi_Hash * tbl, const char *name)
{
    int len;
    Jsi_HashSearch se;
    Jsi_HashEntry *sentry = 0, *entry = Jsi_HashEntryFind(tbl, name);
    if (entry)
        return entry;
    len = Jsi_Strlen(name);
    entry = Jsi_HashSearchFirst(tbl, &se);
    while (entry) {
        char *ename = (char *) Jsi_HashKeyGet(entry);
        if (!Jsi_Strncmp(name, ename, len)) {
            if (sentry)
                return 0;
            sentry = entry;
        }
        entry = Jsi_HashSearchNext(&se);
    }
    return sentry;
}

/* Traverse enum and match unique substring. */
Jsi_OptionSpec *jsi_csgetEnum(Jsi_Interp *interp, const char *name)
{
    Jsi_HashEntry *entry = jsi_csfindInHash(interp, interp->EnumHash, name);
    return entry ? (Jsi_OptionSpec *) Jsi_HashValueGet(entry) : 0;
}


/************* INITIALIZERS  *********************************************/

/* Init Type hash */
void jsi_csInitType(Jsi_Interp *interp)
{
    if (interp->CTypeHash->numEntries) return;
    bool isNew;
    Jsi_HashEntry *entry;
    const Jsi_OptionType *tl;
    if (!interp->typeInit) {
        int i;
        for (i = JSI_OPTION_BOOL; i!=JSI_OPTION_END; i++) {
            tl = Jsi_OptionTypeInfo((Jsi_OptionId)i);
            entry = Jsi_HashEntryNew(interp->TYPEHash, tl->idName, &isNew);
            if (!isNew)
                Jsi_LogBug("duplicate type: %s", tl->idName);
            Jsi_HashValueSet(entry, (void*)tl);
            if (tl->cName && tl->cName[0])
                Jsi_HashSet(interp->CTypeHash, tl->cName, (void*)tl);
        }
    }
    interp->typeInit = 1;
}

static Jsi_RC jsi_csSetupStruct(Jsi_Interp *interp, Jsi_StructSpec *sl, Jsi_StructSpec *sf, Jsi_OptionType* st) {
    bool isNew;
    int cnt = 0, boffset = 0;
    if (Jsi_HashEntryFind(interp->CTypeHash, sl->name))
        return Jsi_LogError("struct is c-type: %s", sl->name);
    Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->StructHash, sl->name, &isNew);
    if (!isNew)
        return Jsi_LogError("duplicate struct: %s", sl->name);
    Jsi_HashValueSet(entry, sl);
    while (sf && sf->id != JSI_OPTION_END) {
        if (!sf->type)
            sf->type = Jsi_OptionTypeInfo(sf->id);
        if (!sf->type && sf->tname)
            sf->type = Jsi_TypeLookup(interp, sf->tname);
        if (sf->type && sf->type->extData && (sf->type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT))) {
            Jsi_OptionSpec *es = (typeof(es))sf->type->extData;
            es->value++;
            if ((sf->type->flags&jsi_CTYP_ENUM)) {
                sf->custom = Jsi_Opt_SwitchEnum;
                sf->data = es->extData;
            }
        }
        if (!sf->size) {
            if (!sf->type)
                return Jsi_LogError("unknown id");
            sf->tname = sf->type->cName;
            sf->size = sf->type->size;
            sf->idx = cnt;
            sf->boffset = boffset;
            if (sf->bits) {
                if (sf->bits>64)
                    return Jsi_LogError("bits too large");
                boffset += sf->bits;
                sf->id = JSI_OPTION_CUSTOM;
                sf->custom=Jsi_Opt_SwitchBitfield;
                sf->iniVal.ini_OPT_BITS=&jsi_csBitGetSet;
            } else {
                sf->offset = (boffset+7)/8;
                boffset += sf->type->size*8;
            }
        }
        sf++, cnt++;
    }
    sl->idx = cnt;
    if (!sl->size) 
        sl->size = (boffset+7)/8;
    if (sl->ssig)
        Jsi_HashSet(interp->SigHash, (void*)(uintptr_t)sl->ssig, sl);
    if (!st)
        st = (typeof(st))Jsi_Calloc(1, sizeof(*st));
    st->cName = sl->name;
    st->idName = "CUSTOM";
    st->id = JSI_OPTION_CUSTOM;
    st->size = sl->size;
    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_STRUCT;
    st->extData = sl;
    Jsi_HashSet(interp->CTypeHash, st->cName, st);
    return JSI_OK;
}

/* Init Struct hash */
static void jsi_csInitStructTables(Jsi_Interp *interp)
{
    Jsi_StructSpec *sf, *sl = interp->statics->structs;
    while (sl  && sl->name) {
        sf = (typeof(sf))sl->data;
        jsi_csSetupStruct(interp, sl, sf, NULL);
        sl++;
    }
}

static Jsi_RC jsi_csSetupEnum(Jsi_Interp *interp, Jsi_EnumSpec *sl, Jsi_EnumSpec *sf, Jsi_OptionType* st) {
    bool isNew;
    int cnt = 0;
    if (Jsi_HashEntryFind(interp->CTypeHash, sl->name))
        return Jsi_LogError("enum is c-type: %s", sl->name);
    Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);
    if (!isNew)
        return Jsi_LogError("duplicate enum: %s", sl->name);
    Jsi_HashValueSet(entry, sl);
    Jsi_Number val = 0;
    while (sf && sf->id != JSI_OPTION_END) {
        if (!sf->idx) {
            sf->value = val++;
            sf->idx = cnt;
        }
        Jsi_HashSet(interp->EnumItemHash, sf->name, sf);
        sf++, cnt++;
    }
    Jsi_HashSet(interp->EnumHash, sl->name, sl);
    sl->idx = cnt;
    if (!sl->size) 
        sl->size = cnt;
    if (!st)
        st = (typeof(st))Jsi_Calloc(1, sizeof(*st));
    st->cName = sl->name;
    st->idName = "CUSTOM";
    st->id = JSI_OPTION_CUSTOM;
    st->size = sl->size;
    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_ENUM;
    st->extData = sl;
    Jsi_HashSet(interp->CTypeHash, st->cName, st);
    return JSI_OK;
}

/* Init Enum hash */
void jsi_csInitEnum(Jsi_Interp *interp)
{
    bool isNew;
    Jsi_EnumSpec *sl = interp->statics->enums;
    while (sl && sl->name && sl->id != JSI_OPTION_END) {
        Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);
        if (!isNew)
            Jsi_LogBug("duplicate enum: %s", sl->name);
        assert(isNew);
        Jsi_HashValueSet(entry, sl);
        sl++;
    }
}

/* Find the enum name in all enums */
Jsi_OptionSpec *jsi_csInitEnumItem(Jsi_Interp *interp)
{
    Jsi_HashEntry *entry;
    bool isNew;
    Jsi_EnumSpec *sl = interp->statics->enums;
    while (sl &&  sl->name && sl->id != JSI_OPTION_END) {
        Jsi_OptionSpec *ei = (typeof(ei))sl->data;
        while (ei->name  && ei->id != JSI_OPTION_END) {
            entry = Jsi_HashEntryNew(interp->EnumItemHash, ei->name, &isNew);
            if (!isNew)
                Jsi_LogBug("duplicate enum item: %s", ei->name);
            Jsi_HashValueSet(entry, ei);
            ei++;
        }
        sl++;
    }
    return 0;
}

Jsi_StructSpec *jsi_csGetStruct(Jsi_Interp *interp, const char *name) {
    return (Jsi_StructSpec *)Jsi_HashGet(interp->StructHash, name, 0);
}

// Format struct key.
static Jsi_Value *jsi_csFmtKeyCmd(Jsi_MapEntry* hPtr, Jsi_MapOpts *opts, int flags)
{
    void *rec = (opts->mapType==JSI_MAP_HASH ? Jsi_HashKeyGet((Jsi_HashEntry*)hPtr): Jsi_TreeKeyGet((Jsi_TreeEntry*)hPtr));
    if (!rec) return NULL;
    CDataObj *cd = (typeof(cd))opts->user;
    assert(cd);
    Jsi_Interp *interp = cd->interp;
    if (!cd->slKey || !cd->slKey)
        return NULL;
    Jsi_Value *v = Jsi_ValueNew1(interp);
    if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, rec, NULL, &v, flags) == JSI_OK)
        return v;
    Jsi_DecrRefCount(interp, v);
    return NULL;
}

static Jsi_RC jsi_csCDataNew(Jsi_Interp *interp, const char *name, const char *structName,
    const char *help, const char *varParm) {
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSPrintf(&dStr, "var %s = new CData({structName:\"%s\"", name, structName);
    if (help)
        Jsi_DSPrintf(&dStr, ", help:\"%s\"", help);
    /*if (vd[i].value)
        Jsi_DSPrintf(&dStr, ", arrSize:%u", (uint)vd[i].value);*/
    if (varParm)
        Jsi_DSPrintf(&dStr, ", varParam:\"%s\"", varParm);
    Jsi_DSPrintf(&dStr, "});");
    Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);
    Jsi_DSFree(&dStr);
    return rc;
}

Jsi_RC jsi_csInitVarDefs(Jsi_Interp *interp)
{
    Jsi_VarSpec *vd = interp->statics->vars;
    int i;
    for (i=0; vd[i].name; i++) {
        const char *name = vd[i].name;
        const char *structName = vd[i].info;
        const char *help = vd[i].help;
        const char *varParm = (const char*)vd[i].userData;

        if (JSI_OK != jsi_csCDataNew(interp, name, structName, help, varParm))
            return JSI_ERROR;
#if 0        
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        Jsi_DSPrintf(&dStr, "var %s = new CData({structName:\"%s\"});", name, structName);
        if (help)
            Jsi_DSPrintf(&dStr, ", help:\"%s\"", help);
        /*if (vd[i].value)
            Jsi_DSPrintf(&dStr, ", arrSize:%u", (uint)vd[i].value);*/
        if (varParm)
            Jsi_DSPrintf(&dStr, ", varParam:\"%s\"", varParm);
        Jsi_DSPrintf(&dStr, "});");
        Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);
        Jsi_DSFree(&dStr);
        if (rc != JSI_OK)
            return JSI_ERROR;
#endif
    }
    return JSI_OK;
}

Jsi_StructSpec *jsi_csStructGet(Jsi_Interp *interp, const char *name)
{
    if (!name) return NULL;
    Jsi_StructSpec *sl,*spec = jsi_csGetStruct(interp, name);
    if (spec) return spec;

    Jsi_CData_Static *CData_Strs = interp->statics;
    while (CData_Strs) {
        sl = CData_Strs->structs;
        while (sl->name) {
            if (!Jsi_Strcmp(name, sl->name))
                return sl;
            sl++;
        }
        CData_Strs = CData_Strs->nextPtr;
    }
    return NULL;
}


Jsi_EnumSpec *jsi_csGetEnum(Jsi_Interp *interp, const char *name) {
    return (Jsi_EnumSpec *)Jsi_HashGet(interp->EnumHash, name, 0);
}

/* Traverse enum and match unique substring. */
Jsi_EnumSpec *jsi_csEnumGet(Jsi_Interp *interp, const char *name)
{
    Jsi_EnumSpec *sl, *spec = jsi_csGetEnum(interp, name);
    if (spec) return spec;

    Jsi_CData_Static *CData_Strs = interp->statics;
    while (CData_Strs) {
        sl = CData_Strs->enums;
        while (sl->name) {
            if (!Jsi_Strcmp(name, sl->name))
                return sl;
            sl++;
        }
        CData_Strs = CData_Strs->nextPtr;
    }
    return NULL;
}

/****************************************************************/

/* Traverse from top looking for field in struct, match unique substrings. */
Jsi_StructSpec *jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec * sl)
{
    Jsi_StructSpec *sf, *ff = 0, *f = (typeof(f))sl->data;
    int cnt = 0;
    uint len = Jsi_Strlen(name);
    sf = f;
    while (sf->id != JSI_OPTION_END) {
        if (!Jsi_Strncmp(name, sf->name, len)) {
            if (!sf->name[len])
                return sf;
            ff = sf;
            cnt++;
        }
        sf++;
    }
    if (cnt == 1)
        return ff;
    return 0;
}

/* Traverse from top looking for item in enum, match unique substrings. */
Jsi_EnumSpec *jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec * el)
{
    Jsi_EnumSpec *ff = 0, *sf;
    int cnt = 0;
    uint len = Jsi_Strlen(name);
    sf = (typeof(sf))el->data;
    if (!sf)
        return 0;
    while (sf->id != JSI_OPTION_END) {
        if (!Jsi_Strncmp(name, sf->name, len)) {
            if (!sf->name[len])
                return sf;
            ff = sf;
            cnt++;
        }
        sf++;
    }
    if (cnt == 1)
        return ff;
    return 0;
}

/******* INIT ***************************************************/


/* Initialize a struct to default values */
static Jsi_RC jsi_csStructInit(Jsi_StructSpec * sl, uchar * data)
{
    /* Jsi_OptionSpec *sf; */
    assert(sl);
    if (!data) {
        fprintf(stderr, "missing data at %s:%d", __FILE__, __LINE__);
        return JSI_ERROR;
    }
    if (sl->custom) {
        memcpy(data, sl->custom, sl->size);
    } else {
        memset(data, 0, sl->size);
    }
    if (sl->ssig)
        *(Jsi_Sig *) data = sl->ssig;
    return JSI_OK;
}

static Jsi_RC CDataEnumNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    int argc = Jsi_ValueGetLength(interp, args);
    
    if (argc == 0)
        return Jsi_HashKeysDump(interp, interp->EnumHash, ret, 0);
    char *arg1 = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);
    Jsi_EnumSpec *s, *sf;
    if (arg1 == NULL || !(s = (Jsi_EnumSpec*)Jsi_HashGet(interp->EnumHash, arg1, 0)))
        return Jsi_LogError("Unknown enum: %s", arg1);
    Jsi_ValueMakeArrayObject(interp, ret, NULL);
    sf = (typeof(sf))s->data;
    int m = 0;
    while (sf && sf->id != JSI_OPTION_END)
    {
        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, sf->name), m++);
        sf++;
    }
    return JSI_OK;
}

////// ENUM

static Jsi_OptionSpec EnumOptions[] =
{
    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help="Flags for enum", jsi_IIOF),
    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help="Description of enum", jsi_IIOF ),
    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help="Name of enum", jsi_IIOF ),
    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help="Number of items in enum", jsi_IIRO ),
    JSI_OPT(INT64,      Jsi_EnumSpec, value,  .help="Reference count", jsi_IIRO ),
    JSI_OPT_END(Jsi_EnumSpec, .help="Options for CData enum")
};

static Jsi_OptionSpec EnumFieldOptions[] =
{
    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help="Flags for item", jsi_IIOF),
    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help="Desciption of item", jsi_IIOF ),
    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help="Name of item", jsi_IIOF ),
    JSI_OPT(INT64,      Jsi_EnumSpec, value,  .help="Value for item", jsi_IIOF),
    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help="Index of item in enum", jsi_IIRO ),
    JSI_OPT_END(Jsi_EnumSpec, .help="Options for CData item")
};

static Jsi_RC CDataEnumFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    Jsi_EnumSpec *ei, *sf;
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!(sf = jsi_csEnumGet(interp, arg1)))
        return Jsi_LogError("unknown enum item: %s", arg1);
    ei = 0;
    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    if (!(ei = jsi_csEnumGetItem(interp, arg2, sf)))
        return JSI_OK;

    return CDataOptionsConf(interp, EnumFieldOptions, args, ei, ret, 0, 2);
}

static Jsi_RC CDataEnumConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    Jsi_EnumSpec *sf;
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!(sf = jsi_csEnumGet(interp, arg1)))
        return Jsi_LogError("unknown enum: %s", arg1);
    return CDataOptionsConf(interp, EnumOptions, args, sf, ret, 0, 1);
}


static Jsi_RC CDataEnumUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_HashEntry *entry = NULL;
    Jsi_OptionType *st = NULL;
    if (name) {
        entry = Jsi_HashEntryFind(interp->EnumHash, name);
        st = Jsi_TypeLookup(interp, name);
    }
    if (!entry || !st)
        return Jsi_LogError("Unknown enum: %s", name);
    Jsi_EnumSpec *sf, *sl = (typeof(sl))Jsi_HashValueGet(entry);
    if (sl->value)
        return Jsi_LogError("Enum in use");
    Jsi_HashEntryDelete(entry);
    sf = (typeof(sf))sl->data;
    while (sf && sf->id != JSI_OPTION_END) {
        entry = Jsi_HashEntryFind(interp->EnumItemHash, name);
        if (entry)
            Jsi_HashEntryDelete(entry);
        sf++;
    }
    entry = Jsi_HashEntryFind(interp->CTypeHash, name);
    if (entry)
        Jsi_HashEntryDelete(entry);
    Jsi_Free(st);
    return JSI_OK;
}

/* Defines: Handles the "CData.enum.define" subcommand */
static Jsi_RC CDataEnumDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    uint flen, i;
    jsi_csInitType(interp);
    Jsi_Value *flds = Jsi_ValueArrayIndex(interp, args, 1);
    if (!flds || !Jsi_ValueIsArray(interp,flds) || (flen=Jsi_ValueGetLength(interp, flds))<1)
        return Jsi_LogError("arg 2 must be a non-empty array");
    Jsi_EnumSpec *sl, *sf, recs[flen+1];
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    memset(recs, 0, sizeof(recs));
    sl = recs+flen;
    if (!val || Jsi_OptionsProcess(interp, EnumOptions, sl, val, 0) < 0)
        return JSI_ERROR;
    if (jsi_csEnumGet(interp, sl->name))
        return Jsi_LogError("enum already exists: %s", sl->name);
    for (i = 0; i<flen; i++) {
        val = Jsi_ValueArrayIndex(interp, flds, i);
        sf = recs+i;
        if (!val || Jsi_OptionsProcess(interp, EnumFieldOptions, sf, val, 0) < 0)
            return JSI_ERROR;
        if (Jsi_HashGet(interp->EnumItemHash, sf->name, 0))
            return Jsi_LogError("duplicate enum item: %s", sf->name);
    }
    Jsi_OptionType *st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + sizeof(char*)*(flen+1)+sizeof(recs));
    sf = (typeof(sf))((uchar*)st + sizeof(*st));
    sl = sf+flen;
    const char **el = (typeof(el))(sl + 1);
    memcpy(sf, recs, sizeof(recs));
    for (i = 0; i<flen; i++)
        el[i] = sf[i].name;
    sl->id = JSI_OPTION_END;
    sl->data = sf;
    sl->extData = el;
    Jsi_RC rc = jsi_csSetupEnum(interp, sl, sf, st);
    if (rc != JSI_OK)
        Jsi_Free(st);
    return rc;
}

static Jsi_RC CDataEnumValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    const char *arg1, *arg2;
    Jsi_EnumSpec *ei, *el = 0;
    arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    if (!(el = jsi_csEnumGet(interp, arg1))) {
        return JSI_OK;
    }
    if (!(ei = jsi_csEnumGetItem(interp, arg2, el)))
        return JSI_OK;
    Jsi_ValueMakeNumber(interp, ret, ei->value);
    return JSI_OK;
}


/* Return the enum symbol that matches the given integer value. */
static Jsi_RC CDataEnumFindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_EnumSpec *ei, *el;
    if (!(el = jsi_csEnumGet(interp, arg1)))
        return Jsi_LogError("Unknown enum: %s", arg1);
    Jsi_Wide wval;
    if (Jsi_GetWideFromValue(interp, arg2, &wval) != JSI_OK)
        return JSI_ERROR;

    ei = (typeof(ei))el->data;
    while (ei->name) {
        if (wval == (Jsi_Wide)ei->value) {
            Jsi_ValueMakeStringKey(interp, ret, ei->name);
            return JSI_OK;
        }
        ei++;
    }
    return JSI_OK;
}

static Jsi_RC CDataEnumGetDfn(Jsi_Interp *interp, Jsi_EnumSpec * sl, Jsi_DString *dsPtr)
{
    
    Jsi_EnumSpec *sf;
    Jsi_DString eStr = {};

    Jsi_DSAppend(dsPtr, "{ name: \"", sl->name, "\"", NULL);
    if (sl->flags)
        Jsi_DSPrintf(dsPtr, ", flags:%" PRIx64, sl->flags);
    if (sl->help && sl->help[0]) {
        Jsi_DSAppend(dsPtr, ", label:", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);
        Jsi_DSFree(&eStr);
    }
    sf = (typeof(sf))sl->data;
    Jsi_DSAppend(dsPtr, ", fields:[", NULL);
    while (sf->id != JSI_OPTION_END) {
        Jsi_DSPrintf(dsPtr, " { name:\"%s\", value:%" PRIx64, sf->name, (uint64_t)sf->value);
        if (sf->help && sl->help[0]) {
            Jsi_DSAppend(dsPtr, ", label:", Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);
            Jsi_DSFree(&eStr);
        }
        Jsi_DSAppend(dsPtr, "}", NULL);
        sf++;
    }
    Jsi_DSAppend(dsPtr, "]}", NULL);
    return JSI_OK;
}

static Jsi_RC CDataEnumGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_EnumSpec *sl = jsi_csEnumGet(interp, name);
    if (!sl)
        return JSI_OK;
    JSI_DSTRING_VAR(dsPtr, 400);
    Jsi_RC rc = CDataEnumGetDfn(interp, sl, dsPtr);
    if (JSI_OK == rc)
        rc = Jsi_JSONParse(interp, Jsi_DSValue(dsPtr), ret, 0);
    Jsi_DSFree(dsPtr);
    return rc;
}

static Jsi_CmdSpec enumCmds[] = {
    {"conf",    CDataEnumConfCmd,    1, 2, "enum:string, options:object|string=void",.help="Configure options for enum", .retType=0, .flags=0, .info=0, .opts=EnumOptions},
    {"define",  CDataEnumDefineCmd,  2, 2, "options:object, fields:array", .help="Create an enum: value of items same as in fieldconf", .retType=0, .flags=0, .info=0, .opts=EnumOptions},
    {"fieldconf",CDataEnumFieldConfCmd,2, 3, "enum:string, field:string, options:object|string=void",.help="Configure options for fields", .retType=0, .flags=0, .info=0, .opts=EnumFieldOptions},
    {"find",    CDataEnumFindCmd,    2, 2, "enum:string, intValue:number", .help="Find item with given value in enum", .retType=(uint)JSI_TT_STRING},
    {"get",     CDataEnumGetCmd,     1, 1, "enum:string", .help="Return enum definition", .retType=(uint)JSI_TT_OBJECT},
    {"names",   CDataEnumNamesCmd,   0, 1, "enum:string=void", .help="Return name list of all enums, or items within one enum", .retType=(uint)JSI_TT_ARRAY},
    {"undefine",CDataEnumUndefineCmd,1, 1, "enum:string",.help="Remove an enum", .retType=0, .flags=0, .info=0, .opts=0},
    {"value",   CDataEnumValueCmd,   2, 2, "enum:string, item:string", .help="Return value for given enum item", .retType=(uint)JSI_TT_NUMBER},
    { NULL,   0,0,0,0, .help="Enum commands" }
};

/************************** STRUCT ******************************/

static Jsi_RC CDataStructGetDfn(Jsi_Interp *interp, Jsi_StructSpec * sl, Jsi_DString *dsPtr)
{
    
    Jsi_StructSpec *sf;
    Jsi_DString eStr = {};
    sf = (typeof(sf))sl->data;
    Jsi_DSPrintf(dsPtr, "{ \"name\": \"%s\", \"size\":%d", sl->name, sl->size);
    if (sl->flags)
        Jsi_DSPrintf(dsPtr, ", \"flags\":0x%" PRIx64, sl->flags);
    if (sl->help && sl->help[0]) {
        Jsi_DSAppend(dsPtr, ", \"label\":", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);
        Jsi_DSFree(&eStr);
    }
    if (sl->ssig)
        Jsi_DSPrintf(dsPtr, ", \"sig\":0x%x", sl->ssig);
    Jsi_DSAppend(dsPtr, ", \"fields\":[", NULL);
    while (sf->id != JSI_OPTION_END) {
        Jsi_DSPrintf(dsPtr, " { \"name\":\"%s\",  \"id:\"\"%s\", \"size\":%d, \"bitsize\":%d,"
            "\"offset\":%d, , \"bitoffs\":%d, \"isbit\":%d, \"label\":",
             sf->name, sf->tname, sf->size, sf->bits,
             sf->offset, sf->boffset, sf->flags&JSI_OPT_IS_BITS?1:0 );
        if (sf->help && sl->help[0]) {
            Jsi_DSAppend(dsPtr, Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);
            Jsi_DSFree(&eStr);
        } else
            Jsi_DSAppend(dsPtr,"\"\"", NULL);
        Jsi_DSAppend(dsPtr, "}", NULL);
        sf++;
    }
    Jsi_DSAppend(dsPtr, "]}", NULL);
    return JSI_OK;
}

/* Return the structure definition. */
static Jsi_RC CDataStructGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);

    if (!sl)
        return Jsi_LogError("unkown struct: %s", arg1);
    Jsi_DString dStr = {};
    Jsi_RC rc = CDataStructGetDfn(interp, sl, &dStr);
    if (JSI_OK == rc)
        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}

static Jsi_RC CDataStructNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    int argc = Jsi_ValueGetLength(interp, args);

    if (argc == 0)
        return Jsi_HashKeysDump(interp, interp->StructHash, ret, 0);
    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_StructSpec *sf, *sl;
    if (name == NULL || !(sl = jsi_csGetStruct(interp, name)))
        return Jsi_LogError("Unknown struct: %s", name);
    Jsi_ValueMakeArrayObject(interp, ret, NULL);
    sf = (typeof(sf))sl->data;
    int m = 0;
    while (sf && sf->id != JSI_OPTION_END)
    {
        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, sf->name), m++);
        sf++;
    }
    return JSI_OK;
}

static Jsi_RC CDataStructSchemaCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_StructSpec *sf = jsi_csStructFields(interp, arg1);

    if (!sf)
        return Jsi_LogError("unkown struct: %s", arg1);;

    Jsi_DString dStr = {};
    Jsi_OptionsData(interp, (Jsi_OptionSpec*)sf, &dStr, 1);
    Jsi_ValueMakeString(interp, ret, Jsi_DSFreeDup(&dStr));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

/* Scanning function */
static Jsi_RC jsi_csValueToFieldType(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)
{
    if (inStr)
        return JSI_ERROR;
    Jsi_OptionSpec *sp = (typeof(sp))record;

    if (!inStr) {
        if (!inValue || Jsi_ValueIsString(interp, inValue)==0)
            return Jsi_LogError("expected string");
        inStr = Jsi_ValueString(interp, inValue, NULL);
    }
    const Jsi_OptionType* typ = Jsi_TypeLookup(interp, inStr);
    if (!typ)
        return Jsi_LogError("unknown type: %s", inStr);
    sp->id = typ->id;
    sp->type = typ;
    return JSI_OK;
}

/* Printing function. */
static Jsi_RC jsi_csFieldTypeToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)
{
    if (outStr)
        return JSI_ERROR;
    Jsi_OptionSpec *sp = (typeof(sp))record;
    //const char **s = (const char**)((char*)record + spec->offset);
    const char *s = sp->tname;
    if (outStr)
        Jsi_DSAppend(outStr, s, NULL);
    else if (s)
        Jsi_ValueMakeStringKey(interp, outValue, s);
    else
        Jsi_ValueMakeNull(interp, outValue);
    return JSI_OK;
}

static Jsi_OptionCustom jsi_OptSwitchFieldType = {
    .name="fieldtype", .parseProc=jsi_csValueToFieldType, .formatProc=jsi_csFieldTypeToValue, .freeProc=NULL,
};

static Jsi_OptionSpec StructOptions[] =
{
    JSI_OPT(UINT32, Jsi_StructSpec, crc,     .help="Crc for struct", jsi_IIOF ),
    JSI_OPT(INT64,  Jsi_StructSpec, flags,   .help="Flags for struct", jsi_IIOF ),
    JSI_OPT(STRKEY, Jsi_StructSpec, help,    .help="Struct description", jsi_IIOF ),
    JSI_OPT(UINT32, Jsi_StructSpec, idx,     .help="Number of fields in struct", jsi_IIRO ),
    JSI_OPT(STRKEY, Jsi_StructSpec, name,    .help="Name of struct", jsi_IIOF|JSI_OPT_REQUIRED ),
    JSI_OPT(UINT,   Jsi_StructSpec, size,    .help="Size of struct in bytes", jsi_IIRO ),
    JSI_OPT(UINT32, Jsi_StructSpec, ssig,    .help="Signature for struct", jsi_IIOF),
    JSI_OPT(INT64,  Jsi_StructSpec, value,   .help="Reference count", jsi_IIRO ),
    JSI_OPT_END(Jsi_StructSpec, .help="Options for CData struct create")
};

static Jsi_OptionSpec StructFieldOptions[] =
{
    JSI_OPT(UINT32, Jsi_StructSpec,   bits,   .help="Size of bitfield", jsi_IIOF ),
    JSI_OPT(UINT32, Jsi_StructSpec,   boffset,.help="Bit offset of field within struct", jsi_IIRO ),
    JSI_OPT(INT64,  Jsi_StructSpec,   flags,  .help="Flags for field", jsi_IIOF ),
    JSI_OPT(UINT32, Jsi_StructSpec,   idx,    .help="Index of field in struct", jsi_IIRO ),
    JSI_OPT(STRKEY, Jsi_StructSpec,   help,   .help="Field description", jsi_IIOF ),
    JSI_OPT(STRKEY, Jsi_StructSpec,   info,   .help="Initial value for field", jsi_IIOF ),
    JSI_OPT(STRKEY, Jsi_StructSpec,   name,   .help="Name of field", jsi_IIOF|JSI_OPT_REQUIRED ),
    JSI_OPT(UINT,   Jsi_StructSpec,   offset, .help="Offset of field within struct", jsi_IIRO ),
    JSI_OPT(UINT,   Jsi_StructSpec,   size,   .help="Size of field", jsi_IIOF ),
    JSI_OPT(CUSTOM, Jsi_StructSpec,   type,   .help="Type of field", jsi_IIOF|JSI_OPT_REQUIRED, .custom=&jsi_OptSwitchFieldType,  .data=NULL ),
    JSI_OPT_END(Jsi_StructSpec, .help="Options for CData struct field")
};

static Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,
    void *rec, Jsi_Value **ret, int flags, int skipArgs)
{
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *val;
    flags |= JSI_OPTS_IS_UPDATE;

    if (argc == skipArgs)
        return Jsi_OptionsDump(interp, specs, rec, ret, flags);
    val = Jsi_ValueArrayIndex(interp, args, skipArgs);
    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);
    if (vtyp == JSI_VT_STRING) {
        char *str = Jsi_ValueString(interp, val, NULL);
        return Jsi_OptionsGet(interp, specs, rec, str, ret, flags);
    }
    if (vtyp != JSI_VT_OBJECT && vtyp != JSI_VT_NULL)
        return Jsi_LogError("expected string, object, or null");
    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE) < 0)
        return JSI_ERROR;
    return JSI_OK;
}


/* Defines: Handles the "CData.struct.conf" subcommand */
static Jsi_RC CDataStructConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);
    if (!sl)
        return Jsi_LogError("unknown struct: %s", arg1);
    return CDataOptionsConf(interp, StructOptions, args, sl, ret, 0, 1);
}

static Jsi_RC CDataStructUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_HashEntry *entry = NULL;
    if (name)
        entry = Jsi_HashEntryFind(interp->StructHash, name);
    if (!entry)
        return Jsi_LogError("Unknown struct: %s", name);
    Jsi_StructSpec *sl = (typeof(sl))Jsi_HashValueGet(entry);
    if (sl->value)
        return Jsi_LogError("Struct in use");
    Jsi_HashEntryDelete(entry);
    entry = Jsi_HashEntryFind(interp->CTypeHash, name);
    if (entry)
        Jsi_HashEntryDelete(entry);
    return JSI_OK;
}

/* Defines: Handles the "CData.define.create" subcommand */
static Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    uint flen, i;
    jsi_csInitType(interp);
    Jsi_Value *flds = Jsi_ValueArrayIndex(interp, args, 1);
    if (!flds || !Jsi_ValueIsArray(interp,flds) || (flen=Jsi_ValueGetLength(interp, flds))<1)
        return Jsi_LogError("arg 2 must be a non-empty array");
    Jsi_StructSpec *sl, *sf, recs[flen+1];
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    memset(recs, 0, sizeof(recs));
    sl = recs+flen;
    if (!val || Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0)
        return JSI_ERROR;
    if (jsi_csStructGet(interp, sl->name))
        return Jsi_LogError("struct already exists: %s", sl->name);
    for (i = 0; i<flen; i++) {
        val = Jsi_ValueArrayIndex(interp, flds, i);
        sf = recs+i;
        if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0)
            return JSI_ERROR;
    }
    Jsi_OptionType *st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + sizeof(recs));
    sf = (typeof(sf))((uchar*)st + sizeof(*st));
    sl = sf+flen;
    memcpy(sf, recs, sizeof(recs));
    sl->id = JSI_OPTION_END;
    sl->data = sf;
    Jsi_RC rc = jsi_csSetupStruct(interp, sl, sf, st);
    if (rc != JSI_OK)
        Jsi_Free(st);
    return rc;
}

/* Defines: Handles the "CData.struct.fieldconf" subcommand */
static Jsi_RC CDataStructFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_StructSpec *sf, *sl = jsi_csStructGet(interp, arg1);
    if (!sl)
        return Jsi_LogError("unknown struct: %s", arg1);
    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    if (!arg2 || !(sf = jsi_csFieldGet(interp, arg2, sl)))
        return Jsi_LogError("unknown field: %s", arg2);
    return CDataOptionsConf(interp, StructFieldOptions, args, sf, ret, 0, 2);
}

static Jsi_CmdSpec structCmds[] =
{
    {"conf",      CDataStructConfCmd,   1, 2, "struct:string, options:object|string=void", .help="Configure options for struct", .retType=0, .flags=0, .info=0, .opts=StructOptions},
    {"define",    CDataStructDefineCmd, 2, 2, "options:object, fields:array", .help="Create a struct: field values same as in fieldconf", .retType=0, .flags=0, .info=0, .opts=StructOptions},
    {"fieldconf", CDataStructFieldConfCmd,2,3,"struct:string, field:string, options:object|string=void", .help="Configure options for fields", .retType=0, .flags=0, .info=0, .opts=StructFieldOptions},
    {"get",       CDataStructGetCmd,    1, 2, "struct, options:object=void", .help="Return the struct definition", .retType=(uint)JSI_TT_OBJECT},
    {"names",     CDataStructNamesCmd,  0, 1, "struct:string=void", .help="Return name list of all structs, or fields for one struct", .retType=(uint)JSI_TT_ARRAY},
    {"schema",    CDataStructSchemaCmd, 1, 1, "", .help="Return database schema for struct", .retType=(uint)JSI_TT_STRING },
    {"undefine",  CDataStructUndefineCmd,1, 1, "name:string",.help="Remove a struct", .retType=0, .flags=0, .info=0, .opts=0},
    {NULL}
};



static Jsi_RC jsi_csGetKey(Jsi_Interp *interp, CDataObj *cd, Jsi_Value *arg, void **kPtr, size_t ksize, int anum)
{
    void *kBuf = *kPtr;
    *kPtr = NULL;
    if (!arg)
        return JSI_OK;
    Jsi_Number nval = 0;
    switch (cd->keyType) {
        case JSI_KEYS_STRING:
        case JSI_KEYS_STRINGKEY:
            *kPtr = (void*)Jsi_ValueString(interp, arg, NULL);
            if (!*kPtr)
                return Jsi_LogError("arg %d: expected string key", anum);
            break;
        case JSI_KEYS_ONEWORD:
            if (Jsi_ValueGetNumber(interp, arg, &nval) != JSI_OK)
                return Jsi_LogError("arg %d: expected number key", anum);
            *kPtr = (void*)(uintptr_t)nval;
            break;
        default: {
            if (!cd->slKey) {
badkey:
                return Jsi_LogError("arg %d: expected struct key", anum);
            }
            if (arg->vt == JSI_VT_OBJECT && arg->d.obj->ot == JSI_OT_OBJECT) {
                if (cd->slKey->size>ksize || !kBuf)
                    goto badkey;
                memset(kBuf, 0, cd->slKey->size);
                if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, kBuf, arg, NULL, 0) != JSI_OK)
                    return JSI_ERROR;
                *kPtr = kBuf;
            } else
                return Jsi_LogError("arg %d: expected object key", anum);
        }
    }
    return JSI_OK;
}

#define FN_dataGetN JSI_INFO("If given a name argument, gets data for the named field. \
Otherwise gets data for all fields in struct.")
static Jsi_RC CDataGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdcGet(cd, _this, funcPtr);
    uchar *dptr = NULL;
    Jsi_Value *karg = Jsi_ValueArrayIndex(interp, args, 0);
    char kbuf[BUFSIZ];
    void *key = kbuf;
    bool isNull = Jsi_ValueIsNull(interp, karg);
    if (isNull) {
        if (cd->mapPtr || cd->arrSize>1)
            return Jsi_LogError("null key used with c-array/map");
    } else {
        if (!cd->mapPtr && cd->arrSize<=0)
            return Jsi_LogError("must be array/map");
        if (JSI_OK != jsi_csGetKey(interp, cd, karg, &key, sizeof(kbuf), 1))
        return JSI_ERROR;
    }

    dptr = (uchar*)cd->data;
    if (isNull) {
    } else if (cd->mapPtr) {
        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);
        if (mPtr)
            dptr = (uchar*)Jsi_MapValueGet(mPtr);
        else
            return Jsi_LogError("arg 1: key not found [%s]", Jsi_ValueToString(interp, karg, NULL));
    } /*else if (!cd->arrSize)
        return Jsi_LogError("arg 2: expected a c-array or map");*/
    else {
        uint kind = (intptr_t)key;
        if (kind>=cd->arrSize)
            return Jsi_LogError("array index out of bounds: %d not in 0,%d", kind, cd->arrSize-1);

        dptr = ((uchar*)cd->data) + cd->sl->size*kind;
        if (cd->isPtrs)
            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;
        else if (cd->isPtr2) {
            dptr = (uchar*)(*(void**)dptr);
            dptr += sizeof(void*)*kind;
        }
    }
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc != 2 && argc != 1)
        return Jsi_LogError("expected 1 or 2 args");
    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);
    return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);
}

#define FN_dataSet JSI_INFO("Sets data value for given a name argument.")
static Jsi_RC CDataSetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdcGet(cd, _this, funcPtr);
    uchar *dptr = NULL;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char kbuf[BUFSIZ];
    void *key = kbuf;
    bool isNull = Jsi_ValueIsNull(interp, arg);
    if (isNull) {
        if (cd->mapPtr || cd->arrSize)
            return Jsi_LogError("null key used with c-array/map");
    } else {
        if (!cd->mapPtr && cd->arrSize<=0)
            return Jsi_LogError("must be array/map");
        if (JSI_OK != jsi_csGetKey(interp, cd, arg, &key, sizeof(kbuf), 1))
            return JSI_ERROR;
    }

    dptr = (uchar*)cd->data;
    if (isNull) {
    } else if (cd->mapPtr) {
        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);
        if (mPtr)
            dptr = (uchar*)Jsi_MapValueGet(mPtr);
        else {
            bool isNew;
            if (cd->maxSize && Jsi_MapSize(*cd->mapPtr)>=cd->maxSize)
                return Jsi_LogError("map would exceeded maxSize: %d", cd->maxSize);
            if (!cd->noAuto)
                mPtr = Jsi_MapEntryNew(*cd->mapPtr, key, &isNew);
            if (!mPtr)
                return Jsi_LogError("arg 1: key not found [%s]", Jsi_ValueToString(interp, arg, NULL));
            Jsi_StructSpec *sl = cd->sl;
            dptr = (uchar*)Jsi_Calloc(1, sl->size);
            Jsi_MapValueSet(mPtr, dptr);
            jsi_csStructInit(sl, dptr);
        }
    } else if (!cd->arrSize)
        return Jsi_LogError("expected a c-array or map");
    else {
        uint kind = (uintptr_t)key;
        if (kind>=cd->arrSize)
            return Jsi_LogError("array index out of bounds: %d not in 0,%d", kind, cd->arrSize-1);
        dptr = ((uchar*)cd->data) + cd->sl->size*kind;
        if (cd->isPtrs)
            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;
        else if (cd->isPtr2)
            dptr = (uchar*)(*(void**)dptr) + sizeof(void*)*kind;
    }
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);
    if (argc == 2) {
        if (!Jsi_ValueIsObjType(interp, arg2, JSI_OT_OBJECT))
            return Jsi_LogError("arg 3: last must be an object with 3 args");
        return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);
    } else if (argc != 3)
        return Jsi_LogError("expected 2 or 3 args");
    const char *cp;
    if (!(cp = Jsi_ValueString(interp, arg2, NULL)))
        return Jsi_LogError("with 3 args, string expected for arg 3");
    Jsi_Value *arg3 = Jsi_ValueArrayIndex(interp, args, 2);
    return Jsi_OptionsSet(interp, (Jsi_OptionSpec*)cd->sf, dptr, cp, arg3, 0);
}

static Jsi_RC CDataInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdcGet(cd, _this, funcPtr);
    Jsi_StructSpec *sl = cd->sl;
    Jsi_DString dStr= {};
    const char *sptr = Jsi_DSPrintf(&dStr, "{struct:\"%s\", label:\"%s\"}", sl->name, cd->help?cd->help:"");
    Jsi_RC rc = JSI_ERROR;
    if (!sptr)
        return Jsi_LogError("format failed");
    else
        rc = Jsi_JSONParse(interp, sptr, ret, 0);
    Jsi_DSFree(&dStr);
    if (rc != JSI_OK)
        return rc;
    Jsi_Obj *sobj;
    Jsi_Value *svalue;
    if (cd->sf) {
        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj,(Jsi_OptionSpec*) cd->sf);
        sobj = (*ret)->d.obj;
        Jsi_ObjInsert(interp, sobj, "spec", svalue, 0);
    }
    if (cd->slKey) {
        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, (Jsi_OptionSpec*)cd->slKey);
        sobj = (*ret)->d.obj;
        Jsi_ObjInsert(interp, sobj, "keySpec", svalue, 0);
    }    return JSI_OK;
}


const char *csMapTypeStrs[] = { "none", "hash", "tree",  "list", NULL };
const char *csKeyTypeStrs[] = { "string", "strkey", "number",  NULL };

static Jsi_OptionSpec CDataOptions[] = {
    JSI_OPT(UINT,     CDataObj, arrSize, .help="If an array, its size in elements", jsi_IIOF ),
    JSI_OPT(UINT,     CDataObj, flags,   .help="Flags", jsi_IIOF|JSI_OPT_FMT_HEX ),
    JSI_OPT(STRKEY,   CDataObj, help,    .help="Description of data", jsi_IIOF ),
    JSI_OPT(STRKEY,   CDataObj, keyName, .help="Key struct, for key struct maps", jsi_IIOF ),
    JSI_OPT(CUSTOM,   CDataObj, keyType, .help="Key id", jsi_IIOF|JSI_OPT_COERCE, .custom=Jsi_Opt_SwitchEnum, .data=csKeyTypeStrs),
    JSI_OPT(CUSTOM,   CDataObj, mapType, .help="If a map, its type", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=csMapTypeStrs),
    JSI_OPT(UINT,     CDataObj, maxSize, .help="Limit the array size or number of keys in a map" ),
//    JSI_OPT(STRKEY,   CDataObj, name,    .help="Name of data", jsi_IIOF|JSI_OPT_REQUIRED ),
    JSI_OPT(BOOL,     CDataObj, noAuto,  .help="Disable automatic key-add to map in 'setN'"),
    JSI_OPT(STRKEY,   CDataObj, structName,  .help="Struct used for storing data", jsi_IIOF|JSI_OPT_REQUIRED ),
    JSI_OPT(INT64,    CDataObj, user,    .help="User data" ),
    JSI_OPT(STRKEY,   CDataObj, varParam,.help="Param for maps/array vars", jsi_IIOF ),
    JSI_OPT_END(CDataObj, .help="Options for CData named")
};


static bool jsi_csBitSetGet(int isSet, uchar *tbuf, int bits, Jsi_UWide *valPtr) {
    union bitfield *bms = (union bitfield *)tbuf;
    Jsi_UWide val = *valPtr;
    union bitfield {
        Jsi_UWide b1:1; Jsi_UWide b2:2; Jsi_UWide b3:3; Jsi_UWide b4:4; Jsi_UWide b5:5; Jsi_UWide b6:6;
        Jsi_UWide b7:7; Jsi_UWide b8:8; Jsi_UWide b9:9; Jsi_UWide b10:10; Jsi_UWide b11:11; Jsi_UWide b12:12;
        Jsi_UWide b13:13; Jsi_UWide b14:14; Jsi_UWide b15:15; Jsi_UWide b16:16; Jsi_UWide b17:17; 
        Jsi_UWide b18:18; Jsi_UWide b19:19; Jsi_UWide b20:20; Jsi_UWide b21:21; Jsi_UWide b22:22;
        Jsi_UWide b23:23; Jsi_UWide b24:24; Jsi_UWide b25:25; Jsi_UWide b26:26; Jsi_UWide b27:27;
        Jsi_UWide b28:28; Jsi_UWide b29:29; Jsi_UWide b30:30; Jsi_UWide b31:31; Jsi_UWide b32:32;
        Jsi_UWide b33:33; Jsi_UWide b34:34; Jsi_UWide b35:35; Jsi_UWide b36:36; Jsi_UWide b37:37;
        Jsi_UWide b38:38; Jsi_UWide b39:39; Jsi_UWide b40:40; Jsi_UWide b41:41; Jsi_UWide b42:42;
        Jsi_UWide b43:43; Jsi_UWide b44:44; Jsi_UWide b45:45; Jsi_UWide b46:46; Jsi_UWide b47:47;
        Jsi_UWide b48:48; Jsi_UWide b49:49; Jsi_UWide b50:50; Jsi_UWide b51:51; Jsi_UWide b52:52;
        Jsi_UWide b53:53; Jsi_UWide b54:54; Jsi_UWide b55:55; Jsi_UWide b56:56; Jsi_UWide b57:57;
        Jsi_UWide b58:58; Jsi_UWide b59:59; Jsi_UWide b60:60; Jsi_UWide b61:61; Jsi_UWide b62:62;
        Jsi_UWide b63:63; Jsi_UWide b64:64;
    };
    if (isSet) {
        switch (bits) {
    #define CBSN(n) \
            case n: bms->b##n = val; return (bms->b##n == val)
           CBSN(1); CBSN(2); CBSN(3); CBSN(4); CBSN(5); CBSN(6); CBSN(7); CBSN(8);
           CBSN(9); CBSN(10); CBSN(11); CBSN(12); CBSN(13); CBSN(14); CBSN(15); CBSN(16);
           CBSN(17); CBSN(18); CBSN(19); CBSN(20); CBSN(21); CBSN(22); CBSN(23); CBSN(24);
           CBSN(25); CBSN(26); CBSN(27); CBSN(28); CBSN(29); CBSN(30); CBSN(31); CBSN(32);
           CBSN(33); CBSN(34); CBSN(35); CBSN(36); CBSN(37); CBSN(38); CBSN(39); CBSN(40);
           CBSN(41); CBSN(42); CBSN(43); CBSN(44); CBSN(45); CBSN(46); CBSN(47); CBSN(48);
           CBSN(49); CBSN(50); CBSN(51); CBSN(52); CBSN(53); CBSN(54); CBSN(55); CBSN(56);
           CBSN(57); CBSN(58); CBSN(59); CBSN(60); CBSN(61); CBSN(62); CBSN(63); CBSN(64);
        }
        assert(0);
    }
    switch (bits) {
#define CBGN(n) \
        case n: val = bms->b##n; break
       CBGN(1); CBGN(2); CBGN(3); CBGN(4); CBGN(5); CBGN(6); CBGN(7); CBGN(8);
       CBGN(9); CBGN(10); CBGN(11); CBGN(12); CBGN(13); CBGN(14); CBGN(15); CBGN(16);
       CBGN(17); CBGN(18); CBGN(19); CBGN(20); CBGN(21); CBGN(22); CBGN(23); CBGN(24);
       CBGN(25); CBGN(26); CBGN(27); CBGN(28); CBGN(29); CBGN(30); CBGN(31); CBGN(32);
       CBGN(33); CBGN(34); CBGN(35); CBGN(36); CBGN(37); CBGN(38); CBGN(39); CBGN(40);
       CBGN(41); CBGN(42); CBGN(43); CBGN(44); CBGN(45); CBGN(46); CBGN(47); CBGN(48);
       CBGN(49); CBGN(50); CBGN(51); CBGN(52); CBGN(53); CBGN(54); CBGN(55); CBGN(56);
       CBGN(57); CBGN(58); CBGN(59); CBGN(60); CBGN(61); CBGN(62); CBGN(63); CBGN(64);
       default: assert(0);
    }
    *valPtr = val;
    return 1;
}

static Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec,  Jsi_Wide* vPtr, Jsi_OptionSpec *spec, int idx, bool isSet) {
    Jsi_UWide *valPtr = (typeof(valPtr))vPtr;
    int bits = spec->bits;
    int boffs = spec->boffset;
    if (bits<1 || bits>64) return JSI_ERROR;
    int ofs = (boffs/8);
    int bo = (boffs%8); // 0 if byte-aligned
    int Bsz = ((bits+bo+7)/8);
    uchar *rec = (uchar*)vrec;
#ifdef __SIZEOF_INT128__
    typedef unsigned __int128 utvalType;
#else
    typedef Jsi_UWide utvalType;
#endif
    utvalType tbuf[2] = {};
    uchar sbuf[20], *bptr = (uchar*)tbuf;
    memcpy(tbuf, rec+ofs, Bsz);
    Jsi_UWide mval;
    Jsi_UWide amask = ((1LL<<(bits-1))-1LL);
    utvalType tval = 0, kval = 0, lmask;
    if (bo) { // If not byte aligned, get tval and shift
        bptr = sbuf;
        kval = tval = *(typeof(tval)*)tbuf;
        tval >>= bo;
        mval = (Jsi_UWide)tval;
        *(Jsi_UWide*)bptr = mval;
    } else
         mval = *valPtr;
        
    if (!isSet) { // Get value.
        if (!jsi_csBitSetGet(0, bptr, bits, &mval))
            return JSI_ERROR;
        *valPtr = mval;
        return JSI_OK;
    }
    
    if (!jsi_csBitSetGet(1, bptr, bits, &mval))
        return JSI_ERROR;
    if (bo) {
        tval = (typeof(tval))mval;
        lmask=(amask<<bo);
        kval &= ~lmask;
        tval <<= bo;
        tval = (kval | tval);
        *(typeof(tval)*)tbuf = tval;
    }
    memcpy(rec+ofs, tbuf, Bsz);

    return JSI_OK;    
}

static Jsi_RC CDataConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdcGet(cd, _this, funcPtr);
    return CDataOptionsConf(interp, CDataOptions, args, cd, ret, 0, 0);
}
 
static Jsi_RC CDataNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    UdcGet(cd, _this, funcPtr);
    if (cd->mapType != JSI_MAP_NONE)
        return Jsi_MapKeysDump(interp, *cd->mapPtr, ret, 0);
    return Jsi_LogError("not a map");;
}

static Jsi_RC CDataUnsetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdcGet(cd, _this, funcPtr);
    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);   
    char kbuf[BUFSIZ];
    void *key = kbuf;
    if (JSI_OK != jsi_csGetKey(interp, cd, arg2, &key, sizeof(kbuf), 2)) {
        return JSI_ERROR;
    }
    uchar *dptr = NULL;
    Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);
    if (mPtr)
        dptr = (uchar*)Jsi_MapValueGet(mPtr);
    if (!dptr) {
        if (cd->keyType != JSI_KEYS_ONEWORD)
            return Jsi_LogError("no data in map: %s", (char*)key);
        else
            return Jsi_LogError("no data in map: %p", key);
        return JSI_ERROR;
    }
    Jsi_Free(dptr);
    Jsi_MapEntryDelete(mPtr);
    return JSI_OK;

}

static Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    
/* Defines: Handles the "Data" subcommand */
static Jsi_CmdSpec cdataCmds[] =
{
    {"CData",     CDataConstructor,1, 1, "options:object=void",.help="Create new map/array of structs", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=CDataOptions},
    {"conf",      CDataConfCmd,    0, 1, "options:object|string=void",.help="Configure options for c-data", .retType=0, .flags=0, .info=0, .opts=CDataOptions},
    {"info",      CDataInfoCmd,    0, 0, "", .help="Return info for data", .retType=(uint)JSI_TT_OBJECT},
    {"names",     CDataNamesCmd,   0, 0, "", .help="Return keys for map", .retType=(uint)JSI_TT_ARRAY },
    {"get"   ,    CDataGetCmd,     1, 2, "key:string|number|object|null, field:string=void", .help="Get nth value of map/array", .retType=(uint)JSI_TT_ANY},
    {"set",       CDataSetCmd,     2, 3, "key:string|number|object|null, field:object|string, value:any=void", .help="Set nth value of map/array", .retType=(uint)JSI_TT_ANY},
    {"unset",     CDataUnsetCmd,   0, 1, "key:string|number|object=void", .help="Remove entry from map/array", .retType=(uint)JSI_TT_ANY},
    {NULL}
};


static Jsi_OptionSpec TypeOptions[] = {
    JSI_OPT(STRKEY,   Jsi_OptionType, idName,  .help="The id name: usually upcased cName", jsi_IIOF ),
    JSI_OPT(STRKEY,   Jsi_OptionType, cName,   .help="C type name", jsi_IIOF ),
    JSI_OPT(STRKEY,   Jsi_OptionType, help,    .help="Description of id", jsi_IIOF ),
    JSI_OPT(STRKEY,   Jsi_OptionType, fmt,     .help="Printf format for id", jsi_IIOF ),
    JSI_OPT(STRKEY,   Jsi_OptionType, xfmt,    .help="Hex printf format for id", jsi_IIOF ),
    JSI_OPT(INT64,    Jsi_OptionType, flags,   .help="Flags for id", jsi_IIOF ),
    JSI_OPT(INT,      Jsi_OptionType, size,    .help="Size for id", jsi_IIOF ),
    JSI_OPT(INT64,    Jsi_OptionType, user,    .help="User data" ),
    JSI_OPT_END(Jsi_OptionType, .help="Options for CData id")
};

static Jsi_RC CDataTypeConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_OptionType *nd = NULL;
    jsi_csInitType(interp);
    if (arg1)
        nd = (typeof(nd))Jsi_TypeLookup(interp, arg1);
    if (!nd)
        return Jsi_LogError("Unknown type: %s", arg1);
    return CDataOptionsConf(interp, TypeOptions, args, nd, ret, 0, 1);
}

static Jsi_RC CDataTypeNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    jsi_csInitType(interp);
    int argc = Jsi_ValueGetLength(interp, args);
    return Jsi_HashKeysDump(interp, (argc?interp->CTypeHash:interp->TYPEHash), ret, 0);
}

/* Defines: Handles the "Type" subcommand */
static Jsi_CmdSpec typeCmds[] =
{
    //{"aliases",   CDataTypeAliasCmd,   0, 0, "", .help="Return type aliases", .retType=(uint)JSI_TT_ARRAY},
    {"conf",      CDataTypeConfCmd,    1, 2, "typ:string, options:object|string=void",.help="Configure options for type", .retType=0, .flags=0, .info=0, .opts=TypeOptions},
    {"names",     CDataTypeNamesCmd,   0, 1, "ctype=false", .help="Return type names", .retType=(uint)JSI_TT_ARRAY},
    {NULL}
};

static Jsi_RC jsi_csTypeFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_OptionType *type = (typeof(type))ptr;
    if (type && type->extData && (type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT)))
        ((Jsi_OptionSpec*)type->extData)->value++;
    if (type->flags&jsi_CTYP_DYN_MEMORY)
        Jsi_Free(ptr);
    return JSI_OK;
}

static Jsi_RC jsi_csMapFree(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_Free(ptr);
    return JSI_OK;
}

static Jsi_RC jsi_csNewCData(Jsi_Interp *interp, CDataObj *cd, int flags) {

    Jsi_StructSpec *slKey = NULL, *keySpec = NULL, *sf = cd->sf, *sl = cd->sl;
    
    if (!sf)
        cd->sf = sf = jsi_csStructFields(interp, cd->structName);
    if (!sl)
        sl = cd->sl = jsi_csGetStruct(interp, cd->structName);
    if (!sf)
        return Jsi_LogError("missing struct/fields: %s", cd->structName);
    
    if (cd->keyName) {
        slKey = keySpec = jsi_csGetStruct(interp, cd->keyName);
        if (slKey == NULL)
            return Jsi_LogError("unknown key struct: %s", cd->keyName);
    }

    const char *vparm = cd->varParam;
    if (vparm && vparm[0]) {
        char parm[200] = {}, *parms=parm, *ep;
        int plen = Jsi_Strlen(vparm);
        if (plen>=2 && vparm[0] == '[' && vparm[plen-1]==']') {
            snprintf(parm, sizeof(parm), "%.*s", plen-2, vparm+1);
            int sz = 0;
            if (parm[0] && isdigit(parm[0])) {
                sz=strtoul(parm, &ep, 0);
                if (*ep || sz<=0)
                    return Jsi_LogError("bad array size: %s", vparm);
                cd->arrSize = sz;
            } else {
                Jsi_EnumSpec *ei = (typeof(ei))Jsi_HashGet(interp->EnumItemHash, parm, 0);
                if (!ei || (sz=ei->value)<=0)
                    return Jsi_LogError("bad array enum: %s", vparm);
            }
            
        } else if (plen>=2 && vparm[0] == '{' && vparm[plen-1]=='}') {
            snprintf(parm, sizeof(parm), "%.*s", plen-2, vparm+1);
            if (parms[0]) {
                const char *ktn = NULL;
                if (*parms == '#') {
                     cd->mapType = JSI_MAP_HASH;
                     parms++;
                }
                if (*parms == '0') {
                    cd->keyType = JSI_KEYS_ONEWORD;
                    if (parms[1])
                        return Jsi_LogError("Trailing junk: %s", vparm);
                } else if (parms[0] == '@') {
                    slKey = jsi_csGetStruct(interp, ktn=(parms+1));
                    if (!slKey)
                        return Jsi_LogError("unknown key struct: %s", ktn);
                    cd->keyName = slKey->name;
                } else if (parms[0])
                        return Jsi_LogError("Trailing junk: %s", vparm);
            }

        } else
            return Jsi_LogError("expected either {} or []: %s", vparm);
    
    }
    cd->sl->value++;
 
    if (cd->keyName) {
        cd->slKey = jsi_csGetStruct(interp, cd->keyName);
        if (!cd->slKey)
            return Jsi_LogError("unknown key struct: %s", cd->keyName);
        cd->keysf = jsi_csStructFields(interp, cd->keyName);
        cd->keyType = (Jsi_Key_Type)slKey->size;
        cd->slKey->value++;
    }
    
    if (cd->mapType != JSI_MAP_NONE) {
        cd->data = (typeof(cd->data))Jsi_MapNew(interp, cd->mapType, cd->keyType, jsi_csMapFree);
        cd->mapPtr = (Jsi_Map**)&cd->data;
        cd->isAlloc = 1;
        if (cd->slKey) {
            Jsi_MapOpts mo;
            Jsi_MapConf(*cd->mapPtr, &mo, 0);
            mo.fmtKeyProc = jsi_csFmtKeyCmd;
            mo.user = (void*)cd;
            Jsi_MapConf(*cd->mapPtr, &mo, 1);
        }
    } else {
        uint sz = (!cd->arrSize ? 1 : cd->arrSize);
        cd->keyType = JSI_KEYS_ONEWORD;
        cd->isAlloc = 1;
        cd->data = (typeof(cd->data))Jsi_Calloc(sz, cd->sl->size);
    }

    return JSI_OK;
}

static Jsi_RC jsi_csObjFree(Jsi_Interp *interp, void *data)
{
    CDataObj *cd = (CDataObj *)data;
    cd->sl->value--;
    if (cd->slKey)
        cd->slKey->value--;
    if (cd->isAlloc) {
        if (cd->mapPtr && *cd->mapPtr) Jsi_MapDelete(*cd->mapPtr);
        else if (cd->data) Jsi_Free(cd->data);
    }
    Jsi_Free(cd);
    return JSI_OK;
}

static bool jsi_csObjIsTrue(void *data)
{
    CDataObj *fo = (CDataObj *)data;
    if (!fo->fobj) return JSI_OK;
    else return 1;
}

static bool jsi_csObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static Jsi_UserObjReg cdataobject = {
    "CData",
    cdataCmds,
    jsi_csObjFree,
    jsi_csObjIsTrue,
    jsi_csObjEqual
};

static Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *that = _this;
    Jsi_Obj *nobj;
    
    if (!Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "CData", o);
        Jsi_ValueMakeObject(interp, ret, o);
        that = *ret;
    }

    CDataObj *cd = (typeof(cd))Jsi_Calloc(1,sizeof(*cd));
    cd->interp = interp;
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);
    if (vtyp != JSI_VT_OBJECT && vtyp != JSI_VT_NULL) {
        Jsi_LogError("expected object, or null");
        goto errout;
    }
    if (Jsi_OptionsProcess(interp, CDataOptions, cd, val, 0) < 0)
        goto errout;

    if (JSI_OK != jsi_csNewCData(interp, cd, JSI_OPT_NO_SIG))
        goto errout;

    nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);
    cd->objId = Jsi_UserObjNew(interp, &cdataobject, nobj, cd);
    if (cd->objId<0) {
        goto errout;
    }
    cd->fobj = nobj;
    return JSI_OK;
    
errout:
    Jsi_OptionsFree(interp, CDataOptions, cd, 0);
    Jsi_Free(cd);
    return JSI_ERROR;

}

// Globals

static Jsi_RC jsi_DoneCData(Jsi_Interp *interp)
{
    if (!interp->SigHash) return JSI_OK;
    Jsi_HashDelete(interp->SigHash);
    Jsi_HashDelete(interp->StructHash);
    Jsi_HashDelete(interp->EnumHash);
    Jsi_HashDelete(interp->EnumItemHash);
    Jsi_HashDelete(interp->TYPEHash);
    Jsi_HashDelete(interp->CTypeHash);
    return JSI_OK;
}

Jsi_RC jsi_InitCData(Jsi_Interp *interp, int release)
{
    if (release) return jsi_DoneCData(interp);
#if JSI_USE_STUBS
    if (Jsi_StubsInit(interp, 0) != JSI_OK)
        return JSI_ERROR;
#endif

    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &cdataobject);
    if (!fsys)
        return Jsi_LogBug("Can not init cdata");

    interp->SigHash      = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
    interp->StructHash   = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->EnumHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->EnumItemHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->CTypeHash    = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_csTypeFree);
    interp->TYPEHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);

    Jsi_CommandCreateSpecs(interp, cdataobject.name,  cdataCmds,  fsys, JSI_CMDSPEC_ISOBJ);
    Jsi_CommandCreateSpecs(interp, "CEnum",  enumCmds,   NULL, 0);
    Jsi_CommandCreateSpecs(interp, "CStruct",structCmds, NULL, 0);
    Jsi_CommandCreateSpecs(interp, "CType",  typeCmds,   NULL, 0);

    if (Jsi_PkgProvide(interp, cdataobject.name, 1, jsi_InitCData) != JSI_OK)
        return JSI_ERROR;
    return JSI_OK;
}

/* Initialize a struct to default values */
Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname)
{
    Jsi_StructSpec * sl = jsi_csStructGet(interp, sname);
    if (!sl)
        return Jsi_LogError("unknown struct: %s", sname);
    return jsi_csStructInit(sl, data);
}

Jsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) {
    CDataObj *cd = (typeof(cd))Jsi_UserObjDataFromVar(interp, name);
    if (!cd)
        return NULL;
    return (Jsi_CDataDb*)cd;
}

Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics)
{
    Jsi_RC rc = JSI_OK;
    if (statics) {
        if (interp->statics)
            statics->nextPtr = interp->statics;
        interp->statics = statics;
        jsi_csInitType(interp);
        jsi_csInitStructTables(interp);
        jsi_csInitEnum(interp);
        jsi_csInitEnumItem(interp);
        rc = jsi_csInitVarDefs(interp);
    }
    return rc;
}

/* Traverse types and match unique substring. */
Jsi_OptionType *Jsi_TypeLookup(Jsi_Interp *interp, const char *name)
{
    int isup = 1;
    const char *cp = name;
    while (*cp && isup) {
        if (!isupper(*cp)) isup=0;
        cp++;
    }
    return (Jsi_OptionType*)Jsi_HashGet((isup?interp->TYPEHash:interp->CTypeHash), name, 0);
}

#else // JSI_OMIT_CDATA

Jsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) { return NULL; }
Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics) { return JSI_ERROR; }
Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname) { return JSI_ERROR; }
Jsi_OptionType *Jsi_TypeLookup(Jsi_Interp *interp, const char *name) { return NULL; }

#endif // JSI_OMIT_CDATA
#endif // JSI_LITE_ONLY
/*
** Extracted from the https://www.fossil-scm.org sources:
**
** Copyright (c) 2012 D. Richard Hipp
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the Simplified BSD License (also
** known as the "2-Clause License" or "FreeBSD License".)

** This program is distributed in the hope that it will be useful,
** but without any warranty; without even the implied warranty of
** merchantability or fitness for a particular purpose.
**
** Author contact information:
**   drh@hwaci.com
**   http://www.hwaci.com/drh/
**
*******************************************************************************
**
** This file contains code to parse a blob containing markdown text,
** using an external renderer.
*/

#ifndef JSI_LITE_ONLY
#if (defined(JSI__MARKDOWN) && JSI__MARKDOWN==1)

#include <ctype.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

enum {
    MX_AUX = 5,
    MKD_CELL_ALIGN_CENTER  = 3,  /* LEFT | RIGHT */
    MKD_CELL_ALIGN_RIGHT   = 2,
    MKD_CELL_ALIGN_LEFT    = 1,
    MKD_CELL_ALIGN_MASK    = 3,
    MKD_CELL_HEAD          = 4,
    MKD_LIST_ORDERED = 1,
    MKD_CELL_ALIGN_DEFAULT = 0,
    MKD_LI_BLOCK     = 2,  /* <li> containing block data */
    MKD_LI_END = 8  /* internal list flag */
};

enum mkd_autolink {
    MKDA_NOT_AUTOLINK,    /* used internally when it is not an autolink*/
    MKDA_NORMAL,          /* normal http/http/ftp link */
    MKDA_EXPLICIT_EMAIL,  /* e-mail link with explicit mailto: */
    MKDA_IMPLICIT_EMAIL   /* e-mail link without mailto: */
};
typedef enum mkd_autolink mkd_autolink;

struct mkd_renderer {
    /* document level callbacks */
    void (*prolog)(Jsi_DString *ob, jsi_MarkdownOpts *opts);
    void (*epilog)(Jsi_DString *ob, jsi_MarkdownOpts *opts);

    /* block level callbacks - NULL skips the block */
    void (*blockcode)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);
    void (*blockquote)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);
    void (*blockhtml)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);
    void (*header)(Jsi_DString *ob, Jsi_DString *text,
                   int level, jsi_MarkdownOpts *opts);
    void (*hrule)(Jsi_DString *ob, jsi_MarkdownOpts *opts);
    void (*list)(Jsi_DString *ob, Jsi_DString *text, int flags, jsi_MarkdownOpts *opts);
    void (*listitem)(Jsi_DString *ob, Jsi_DString *text,
                     int flags, jsi_MarkdownOpts *opts);
    void (*paragraph)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);
    void (*table)(Jsi_DString *ob, Jsi_DString *head_row, Jsi_DString *rows,
                  jsi_MarkdownOpts *opts);
    void (*table_cell)(Jsi_DString *ob, Jsi_DString *text, int flags,
                       jsi_MarkdownOpts *opts);
    void (*table_row)(Jsi_DString *ob, Jsi_DString *cells, int flags,
                      jsi_MarkdownOpts *opts);

    /* span level callbacks - NULL or return 0 prints the span verbatim */
    int (*autolink)(Jsi_DString *ob, Jsi_DString *link,
                    enum mkd_autolink type, jsi_MarkdownOpts *opts);
    int (*codespan)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);
    int (*double_emphasis)(Jsi_DString *ob, Jsi_DString *text,
                           char c, jsi_MarkdownOpts *opts);
    int (*emphasis)(Jsi_DString *ob, Jsi_DString *text, char c, jsi_MarkdownOpts *opts);
    int (*image)(Jsi_DString *ob, Jsi_DString *link, Jsi_DString *title,
                 Jsi_DString *alt, jsi_MarkdownOpts *opts);
    int (*linebreak)(Jsi_DString *ob, jsi_MarkdownOpts *opts);
    int (*link)(Jsi_DString *ob, Jsi_DString *link, Jsi_DString *title,
                Jsi_DString *content, jsi_MarkdownOpts *opts);
    int (*raw_html_tag)(Jsi_DString *ob, Jsi_DString *tag, jsi_MarkdownOpts *opts);
    int (*triple_emphasis)(Jsi_DString *ob, Jsi_DString *text,
                           char c, jsi_MarkdownOpts *opts);

    /* low level callbacks - NULL copies input directly into the output */
    void (*entity)(Jsi_DString *ob, Jsi_DString *entity, jsi_MarkdownOpts *opts);
    void (*normal_text)(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts);

    /* renderer data */
    int max_work_stack; /* prevent arbitrary deep recursion, cf README */
    const char *emph_chars; /* chars that trigger emphasis rendering */
    jsi_MarkdownOpts *opts; /* opaque data send to every rendering callback */
};

typedef struct mkd_renderer mkd_renderer;
static void mk_markdown(Jsi_DString *ob,Jsi_DString *ib,const struct mkd_renderer *rndrer);

static char* jsi_DSInitAppend(Jsi_DString *dStr, const char *str, int len);
static int jsi_DSCompare(Jsi_DString *dStr1, Jsi_DString *dStr2);


/***************
 * LOCAL TYPES *
 ***************/

/* link_ref -- reference to a link */
struct link_ref {
    Jsi_DString id;
    Jsi_DString link;
    Jsi_DString title;
};


/* mk_char_trigger -- function pointer to render active chars */
/*   returns the number of chars taken care of */
/*   data is the pointer of the beginning of the span */
/*   offset is the number of valid chars before data */
struct mkrender;

typedef size_t (*mk_char_trigger)(
    Jsi_DString *ob,
    struct mkrender *rndr,
    char *data,
    size_t offset,
    size_t size);


/* render -- structure containing one particular render */
typedef struct mkrender {
    struct mkd_renderer make;
    Jsi_DString refs;
    mk_char_trigger active_char[256];
    int work_active;
    Jsi_DString *work;
} mk_render;


/* html_tag -- structure for quick HTML tag search (inspired from discount) */
typedef struct {
    const char *text;
    int size;
} mk_html_tag;



/********************
 * GLOBAL VARIABLES *
 ********************/

/* mk_block_tags -- recognised block tags, sorted by cmp_html_tag */
static const mk_html_tag mk_block_tags[] = {
    { "p",            1 },
    { "dl",           2 },
    { "h1",           2 },
    { "h2",           2 },
    { "h3",           2 },
    { "h4",           2 },
    { "h5",           2 },
    { "h6",           2 },
    { "ol",           2 },
    { "ul",           2 },
    { "del",          3 },
    { "div",          3 },
    { "ins",          3 },
    { "pre",          3 },
    { "form",         4 },
    { "math",         4 },
    { "table",        5 },
    { "iframe",       6 },
    { "script",       6 },
    { "fieldset",     8 },
    { "noscript",     8 },
    { "blockquote",  10 }
};

#define INS_TAG (mk_block_tags + 12)
#define DEL_TAG (mk_block_tags + 10)



/***************************
 * STATIC HELPER FUNCTIONS *
 ***************************/

/* build_ref_id -- collapse whitespace from input text to make it a ref id */
static int build_ref_id(Jsi_DString *id, const char *data, size_t size) {
    size_t beg, i;
    char *id_data;

    /* skip leading whitespace */
    while( size>0 && (data[0]==' ' || data[0]=='\t' || data[0]=='\n') ) {
        data++;
        size--;
    }

    /* skip trailing whitespace */
    while( size>0 && (data[size-1]==' '
                      || data[size-1]=='\t'
                      || data[size-1]=='\n')
         ) {
        size--;
    }
    if( size==0 ) return -1;

    /* making the ref id */
    i = 0;
    Jsi_DSFree(id);
    while( i<size ) {
        /* copy non-whitespace into the output buffer */
        beg = i;
        while( i<size && !(data[i]==' ' || data[i]=='\t' || data[i]=='\n') ) {
            i++;
        }
        Jsi_DSAppendLen(id, data+beg, i-beg);

        /* add a single space and skip all consecutive whitespace */
        if( i<size ) Jsi_DSAppendLen(id, " ", 1);
        while( i<size && (data[i]==' ' || data[i]=='\t' || data[i]=='\n') ) {
            i++;
        }
    }

    /* turn upper-case ASCII into their lower-case counterparts */
    id_data = Jsi_DSValue(id);
    for(i=0; i<Jsi_DSLength(id); i++) {
        if( id_data[i]>='A' && id_data[i]<='Z' ) id_data[i] += 'a' - 'A';
    }
    return 0;
}


/* cmp_link_ref -- comparison function for link_ref sorted arrays */
static int cmp_link_ref(const void *key, const void *array_entry) {
    struct link_ref *lr = (struct link_ref *)array_entry;
    return jsi_DSCompare((Jsi_DString *)key, &lr->id);
}


/* cmp_link_ref_sort -- comparison function for link_ref qsort */
static int cmp_link_ref_sort(const void *a, const void *b) {
    struct link_ref *lra = (struct link_ref *)a;
    struct link_ref *lrb = (struct link_ref *)b;
    return jsi_DSCompare(&lra->id, &lrb->id);
}


/* cmp_html_tag -- comparison function for bsearch() (stolen from discount) */
static int cmp_html_tag(const void *a, const void *b) {
    const mk_html_tag *hta = (const mk_html_tag*)a;
    const mk_html_tag *htb = (const mk_html_tag*)b;
    if( hta->size!=htb->size ) return hta->size-htb->size;
    return Jsi_Strncasecmp(hta->text, htb->text, hta->size);
}


/* find_block_tag -- returns the current block tag */
static const mk_html_tag *find_block_tag(const char *data, size_t size) {
    size_t i = 0;
    mk_html_tag key;

    /* looking for the word end */
    while( i<size
            && ((data[i]>='0' && data[i]<='9')
                || (data[i]>='A' && data[i]<='Z')
                || (data[i]>='a' && data[i]<='z'))
         ) {
        i++;
    }
    if( i>=size ) return 0;

    /* binary search of the tag */
    key.text = data;
    key.size = i;
    return (const mk_html_tag *)bsearch(&key,
                   mk_block_tags,
                   (sizeof(mk_block_tags)/sizeof(mk_block_tags[0])),
                   sizeof mk_block_tags[0],
                   cmp_html_tag);
}


/* new_work_buffer -- get a new working buffer from the stack or create one */
static Jsi_DString *new_work_buffer(mk_render *rndr) {
    Jsi_DString *ret = 0;

    if( rndr->work_active < rndr->make.max_work_stack ) {
        ret = rndr->work + rndr->work_active;
        rndr->work_active += 1;
        Jsi_DSFree(ret);
    }
    return ret;
}


/* release_work_buffer -- release the given working buffer */
static void release_work_buffer(mk_render *rndr, Jsi_DString *buf) {
    if( !buf ) return;
    assert(rndr->work_active>0 && buf==(rndr->work+rndr->work_active-1));
    rndr->work_active -= 1;
}



/****************************
 * INLINE PARSING FUNCTIONS *
 ****************************/

/* is_mail_autolink -- looks for the address part of a mail autolink and '>' */
/* this is less strict than the original markdown e-mail address matching */
static size_t is_mail_autolink(char *data, size_t size) {
    size_t i = 0, nb = 0;
    /* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */
    while( i<size && (data[i]=='-'
                      || data[i]=='.'
                      || data[i]=='_'
                      || data[i]=='@'
                      || (data[i]>='a' && data[i]<='z')
                      || (data[i]>='A' && data[i]<='Z')
                      || (data[i]>='0' && data[i]<='9'))
         ) {
        if( data[i]=='@' ) nb++;
        i++;
    }
    if( i>=size || data[i]!='>' || nb!=1 ) return 0;
    return i+1;
}


/* tag_length -- returns the length of the given tag, or 0 if it's not valid */
static size_t tag_length(char *data, size_t size, enum mkd_autolink *autolink) {
    size_t i, j;

    /* a valid tag can't be shorter than 3 chars */
    if( size<3 ) return 0;

    /* begins with a '<' optionally followed by '/', followed by letter */
    if( data[0]!='<' ) return 0;
    i = (data[1]=='/') ? 2 : 1;
    if( (data[i]<'a' || data[i]>'z') &&  (data[i]<'A' || data[i]>'Z') ) {
        return 0;
    }

    /* scheme test */
    *autolink = MKDA_NOT_AUTOLINK;
    if( size>6
            && Jsi_Strncasecmp(data+1, "http", 4)==0
            && (data[5]==':'
                || ((data[5]=='s' || data[5]=='S') && data[6]==':'))
      ) {
        i = (data[5]==':') ? 6 : 7;
        *autolink = MKDA_NORMAL;
    } else if( size>5 && Jsi_Strncasecmp(data+1, "ftp:", 4)==0 ) {
        i = 5;
        *autolink = MKDA_NORMAL;
    } else if( size>7 && Jsi_Strncasecmp(data+1, "mailto:", 7)==0 ) {
        i = 8;
        /* not changing *autolink to go to the address test */
    }

    /* completing autolink test: no whitespace or ' or " */
    if( i>=size || i=='>' ) {
        *autolink = MKDA_NOT_AUTOLINK;
    } else if( *autolink ) {
        j = i;
        while( i<size
                && data[i]!='>'
                && data[i]!='\''
                && data[i]!='"'
                && data[i]!=' '
                && data[i]!='\t'
                && data[i]!='\n'
             ) {
            i++;
        }
        if( i>=size ) return 0;
        if( i>j && data[i]=='>' ) return i+1;
        /* one of the forbidden chars has been found */
        *autolink = MKDA_NOT_AUTOLINK;
    } else if( (j = is_mail_autolink(data+i, size-i))!=0 ) {
        *autolink = (i==8) ? MKDA_EXPLICIT_EMAIL : MKDA_IMPLICIT_EMAIL;
        return i+j;
    }

    /* looking for something looking like a tag end */
    while( i<size && data[i]!='>' ) {
        i++;
    }
    if( i>=size ) return 0;
    return i+1;
}


/* parse_inline -- parses inline markdown elements */
static void parse_inline(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t i = 0, end = 0;
    mk_char_trigger action = 0;
    Jsi_DString work = {};

    while( i<size ) {
        /* copying inactive chars into the output */
        while( end<size
                && (action = rndr->active_char[(unsigned char)data[end]])==0
             ) {
            end++;
        }
        if( end>i ) {
            if( rndr->make.normal_text ) {
                jsi_DSInitAppend(&work, data+i, end-i);
                rndr->make.normal_text(ob, &work, rndr->make.opts);
            } else {
                Jsi_DSAppendLen(ob, data+i, end-i);
            }
        }
        if( end>=size ) break;
        i = end;

        /* calling the trigger */
        end = action(ob, rndr, data+i, i, size-i);
        if( !end ) {
            /* no action from the callback */
            end = i+1;
        } else {
            i += end;
            end = i;
        }
    }
}


/* find_emph_char -- looks for the next emph char, skipping other constructs */
static size_t find_emph_char(char *data, size_t size, char c) {
    size_t i = 1;

    while( i<size ) {
        while( i<size && data[i]!=c && data[i]!='`' && data[i]!='[' ) {
            i++;
        }
        if( i>=size ) return 0;

        /* not counting escaped chars */
        if( i && data[i-1]=='\\' ) {
            i++;
            continue;
        }

        if( data[i]==c ) return i;

        /* skipping a code span */
        if( data[i]=='`' ) {
            size_t span_nb = 0, bt;
            size_t tmp_i = 0;

            /* counting the number of opening backticks */
            while( i<size && data[i]=='`' ) {
                i++;
                span_nb++;
            }
            if( i>=size ) return 0;

            /* finding the matching closing sequence */
            bt = 0;
            while( i<size && bt<span_nb ) {
                if( !tmp_i && data[i]==c ) tmp_i = i;
                if( data[i]=='`' ) bt += 1;
                else bt = 0;
                i++;
            }
            if( i>=size ) return tmp_i;
            i++;

            /* skipping a link */
        } else if( data[i]=='[' ) {
            size_t tmp_i = 0;
            char cc;
            i++;
            while( i<size && data[i]!=']' ) {
                if( !tmp_i && data[i]==c ) tmp_i = i;
                i++;
            }
            i++;
            while( i<size && (data[i]==' ' || data[i]=='\t' || data[i]=='\n') ) {
                i++;
            }
            if( i>=size ) return tmp_i;
            if( data[i]!='[' && data[i]!='(' ) { /* not a link*/
                if( tmp_i ) return tmp_i;
                else continue;
            }
            cc = data[i];
            i++;
            while( i<size && data[i]!=cc ) {
                if( !tmp_i && data[i]==c ) tmp_i = i;
                i++;
            }
            if( i>=size ) return tmp_i;
            i++;
        }
    }
    return 0;
}


/* parse_emph1 -- parsing single emphasis */
/* closed by a symbol not preceded by whitespace and not followed by symbol */
static size_t parse_emph1(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size,
    char c
) {
    size_t i = 0, len;
    Jsi_DString *work = 0;
    int r;

    if( !rndr->make.emphasis ) return 0;

    /* skipping one symbol if coming from emph3 */
    if( size>1 && data[0]==c && data[1]==c ) i = 1;

    while( i<size ) {
        len = find_emph_char(data+i, size-i, c);
        if( !len ) return 0;
        i += len;
        if( i>=size ) return 0;

        if( i+1<size && data[i+1]==c ) {
            i++;
            continue;
        }
        if( data[i]==c
                && data[i-1]!=' '
                && data[i-1]!='\t'
                && data[i-1]!='\n'
          ) {
            work = new_work_buffer(rndr);
            if( !work ) return 0;
            parse_inline(work, rndr, data, i);
            r = rndr->make.emphasis(ob, work, c, rndr->make.opts);
            release_work_buffer(rndr, work);
            return r ? i+1 : 0;
        }
    }
    return 0;
}


/* parse_emph2 -- parsing single emphasis */
static size_t parse_emph2(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size,
    char c
) {
    size_t i = 0, len;
    Jsi_DString *work = 0;
    int r;

    if( !rndr->make.double_emphasis ) return 0;

    while( i<size ) {
        len = find_emph_char(data+i, size-i, c);
        if( !len ) return 0;
        i += len;
        if( i+1<size
                && data[i]==c
                && data[i+1]==c
                && i
                && data[i-1]!=' '
                && data[i-1]!='\t'
                && data[i-1]!='\n'
          ) {
            work = new_work_buffer(rndr);
            if( !work ) return 0;
            parse_inline(work, rndr, data, i);
            r = rndr->make.double_emphasis(ob, work, c, rndr->make.opts);
            release_work_buffer(rndr, work);
            return r ? i+2 : 0;
        }
        i++;
    }
    return 0;
}


/* parse_emph3 -- parsing single emphasis */
/* finds the first closing tag, and delegates to the other emph */
static size_t parse_emph3(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size,
    char c
) {
    size_t i = 0, len;
    int r;

    while( i<size ) {
        len = find_emph_char(data+i, size-i, c);
        if( !len ) return 0;
        i += len;

        /* skip whitespace preceded symbols */
        if( data[i]!=c || data[i-1]==' ' || data[i-1]=='\t' || data[i-1]=='\n' ) {
            continue;
        }

        if( i+2<size
                && data[i+1]==c
                && data[i+2] == c
                && rndr->make.triple_emphasis
          ) {
            /* triple symbol found */
            Jsi_DString *work = new_work_buffer(rndr);
            if( !work ) return 0;
            parse_inline(work, rndr, data, i);
            r = rndr->make.triple_emphasis(ob, work, c, rndr->make.opts);
            release_work_buffer(rndr, work);
            return r ? i+3 : 0;
        } else if( i+1<size && data[i+1]==c ) {
            /* double symbol found, handing over to emph1 */
            len = parse_emph1(ob, rndr, data-2, size+2, c);
            return len ? len-2 : 0;
        } else {
            /* single symbol found, handing over to emph2 */
            len = parse_emph2(ob, rndr, data-1, size+1, c);
            return len ? len-1 : 0;
        }
    }
    return 0;
}


/* char_emphasis -- single and double emphasis parsing */
static size_t char_emphasis(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    char c = data[0];
    size_t ret;

    if( size>2 && data[1]!=c ) {
        /* whitespace cannot follow an opening emphasis */
        if( data[1]==' '
                || data[1]=='\t'
                || data[1]=='\n'
                || (ret = parse_emph1(ob, rndr, data+1, size-1, c))==0
          ) {
            return 0;
        }
        return ret+1;
    }

    if( size>3 && data[1]==c && data[2]!=c ) {
        if( data[2]==' '
                || data[2]=='\t'
                || data[2]=='\n'
                || (ret = parse_emph2(ob, rndr, data+2, size-2, c))==0
          ) {
            return 0;
        }
        return ret+2;
    }

    if( size>4 && data[1]==c && data[2]==c && data[3]!=c ) {
        if( data[3]==' '
                || data[3]=='\t'
                || data[3]=='\n'
                || (ret = parse_emph3(ob, rndr, data+3, size-3, c))==0
          ) {
            return 0;
        }
        return ret+3;
    }
    return 0;
}


/* char_linebreak -- '\n' preceded by two spaces (assuming linebreak != 0) */
static size_t char_linebreak(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    if( offset<2 || data[-1]!=' ' || data[-2]!=' ' ) return 0;
    /* removing the last space from ob and rendering */\
    int dsl = Jsi_DSLength(ob);
    if( dsl>0 && Jsi_DSValue(ob)[dsl-1]==' ' ) Jsi_DSSetLength(ob, dsl-1);
    return rndr->make.linebreak(ob, rndr->make.opts) ? 1 : 0;
}


/* char_codespan -- '`' parsing a code span (assuming codespan != 0) */
static size_t char_codespan(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    size_t end, nb = 0, i, f_begin, f_end;

    /* counting the number of backticks in the delimiter */
    while( nb<size && data[nb]=='`' ) {
        nb++;
    }

    /* finding the next delimiter */
    i = 0;
    for(end=nb; end<size && i<nb; end++) {
        if( data[end]=='`' ) i++;
        else i = 0;
    }
    if( i<nb && end>=size ) return 0; /* no matching delimiter */

    /* trimming outside whitespaces */
    f_begin = nb;
    while( f_begin<end && (data[f_begin]==' ' || data[f_begin]=='\t') ) {
        f_begin++;
    }
    f_end = end-nb;
    while( f_end>nb && (data[f_end-1]==' ' || data[f_end-1]=='\t') ) {
        f_end--;
    }

    /* real code span */
    if( f_begin<f_end ) {
        Jsi_DString work = {};
        jsi_DSInitAppend(&work, data+f_begin, f_end-f_begin);
        if( !rndr->make.codespan(ob, &work, rndr->make.opts) ) end = 0;
    } else {
        if( !rndr->make.codespan(ob, 0, rndr->make.opts) ) end = 0;
    }
    return end;
}


/* char_escape -- '\\' backslash escape */
static size_t char_escape(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    Jsi_DString work = {};
    if( size>1 ) {
        if( rndr->make.normal_text ) {
            jsi_DSInitAppend(&work, data+1,1);
            rndr->make.normal_text(ob, &work, rndr->make.opts);
        } else {
            Jsi_DSAppendLen(ob, data+1, 1);
        }
    }
    return 2;
}


/* char_entity -- '&' escaped when it doesn't belong to an entity */
/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */
static size_t char_entity(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    size_t end = 1;
    Jsi_DString work = {};
    if( end<size && data[end]=='#' ) end++;
    while( end<size
            && ((data[end]>='0' && data[end]<='9')
                || (data[end]>='a' && data[end]<='z')
                || (data[end]>='A' && data[end]<='Z'))
         ) {
        end++;
    }
    if( end<size && data[end]==';' ) {
        /* real entity */
        end++;
    } else {
        /* lone '&' */
        return 0;
    }
    if( rndr->make.entity ) {
        jsi_DSInitAppend(&work, data, end);
        rndr->make.entity(ob, &work, rndr->make.opts);
    } else {
        Jsi_DSAppendLen(ob, data, end);
    }
    return end;
}


/* char_langle_tag -- '<' when tags or autolinks are allowed */
static size_t char_langle_tag(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    enum mkd_autolink altype = MKDA_NOT_AUTOLINK;
    size_t end = tag_length(data, size, &altype);
    Jsi_DString work = {};
    int ret = 0;
    if( end ) {
        if( rndr->make.autolink && altype!=MKDA_NOT_AUTOLINK ) {
            jsi_DSInitAppend(&work, data+1, end-2);
            ret = rndr->make.autolink(ob, &work, altype, rndr->make.opts);
        } else if( rndr->make.raw_html_tag ) {
            jsi_DSInitAppend(&work, data, end);
            ret = rndr->make.raw_html_tag(ob, &work, rndr->make.opts);
        }
    }

    if( !ret ) {
        return 0;
    } else {
        return end;
    }
}


/* get_link_inline -- extract inline-style link and title from
** parenthesed data
*/
static int get_link_inline(
    Jsi_DString *link,
    Jsi_DString *title,
    char *data,
    size_t size
) {
    size_t i = 0, mark;
    size_t link_b, link_e;
    size_t title_b = 0, title_e = 0;

    /* skipping initial whitespace */
    while( i<size && (data[i]==' ' || data[i]=='\t' || data[i]=='\n') ) {
        i++;
    }
    link_b = i;

    /* looking for link end: ' " */
    while( i<size && data[i]!='\'' && data[i]!='"' ) {
        i++;
    }
    link_e = i;

    /* looking for title end if present */
    if( data[i]=='\'' || data[i]=='"' ) {
        i++;
        title_b = i;

        /* skipping whitespaces after title */
        title_e = size-1;
        while( title_e>title_b
                && (data[title_e]==' '
                    || data[title_e]=='\t'
                    || data[title_e]=='\n')
             ) {
            title_e--;
        }

        /* checking for closing quote presence */
        if (data[title_e] != '\'' &&  data[title_e] != '"') {
            title_b = title_e = 0;
            link_e = i;
        }
    }

    /* remove whitespace at the end of the link */
    while( link_e>link_b
            && (data[link_e-1]==' '
                || data[link_e-1]=='\t'
                || data[link_e-1]=='\n')
         ) {
        link_e--;
    }

    /* remove optional angle brackets around the link */
    if( data[link_b]=='<' ) link_b += 1;
    if( data[link_e-1]=='>' ) link_e -= 1;

    /* escape backslashed character from link */
    Jsi_DSFree(link);
    i = link_b;
    while( i<link_e ) {
        mark = i;
        while( i<link_e && data[i]!='\\' ) {
            i++;
        }
        Jsi_DSAppendLen(link, data+mark, i-mark);
        while( i<link_e && data[i]=='\\' ) {
            i++;
        }
    }

    /* handing back title */
    Jsi_DSFree(title);
    if( title_e>title_b ) Jsi_DSAppendLen(title, data+title_b, title_e-title_b);

    /* this function always succeed */
    return 0;
}


/* get_link_ref -- extract referenced link and title from id */
static int get_link_ref(
    mk_render *rndr,
    Jsi_DString *link,
    Jsi_DString *title,
    char *data,
    size_t size
) {
    struct link_ref *lr;

    /* find the link from its id (stored temporarily in link) */
    Jsi_DSFree(link);
    if( build_ref_id(link, data, size)<0 ) return -1;
    lr = (struct link_ref *)bsearch(link,
                 Jsi_DSValue(&rndr->refs),
                 Jsi_DSLength(&rndr->refs)/sizeof(struct link_ref),
                 sizeof (struct link_ref),
                 cmp_link_ref);
    if( !lr ) return -1;

    /* fill the output buffers */
    Jsi_DSFree(link);
    Jsi_DSFree(title);
    Jsi_DSAppendLen(link, Jsi_DSValue(&lr->link), Jsi_DSLength(&lr->link));
    Jsi_DSAppendLen(title, Jsi_DSValue(&lr->title), Jsi_DSLength(&lr->title));
    return 0;
}


/* char_link -- '[': parsing a link or an image */
static size_t char_link(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t offset,
    size_t size
) {
    int is_img = (offset && data[-1] == '!'), level;
    size_t i = 1, txt_e;
    Jsi_DString *content = 0;
    Jsi_DString *link = 0;
    Jsi_DString *title = 0;
    int ret;

    /* checking whether the correct renderer exists */
    if( (is_img && !rndr->make.image) || (!is_img && !rndr->make.link) ) {
        return 0;
    }

    /* looking for the matching closing bracket */
    for(level=1; i<size; i++) {
        if( data[i]=='\n' )        /* do nothing */;
        else if( data[i-1]=='\\' ) continue;
        else if( data[i]=='[' )    level += 1;
        else if( data[i]==']' ) {
            level--;
            if( level<=0 ) break;
        }
    }
    if( i>=size ) return 0;
    txt_e = i;
    i++;

    /* skip any amount of whitespace or newline */
    /* (this is much more laxist than original markdown syntax) */
    while( i<size && (data[i]==' ' || data[i]=='\t' || data[i]=='\n') ) {
        i++;
    }

    /* allocate temporary buffers to store content, link and title */
    content = new_work_buffer(rndr);
    link = new_work_buffer(rndr);
    title = new_work_buffer(rndr);
    if( !title ) return 0;
    ret = 0; /* error if we don't get to the callback */

    /* inline style link */
    if( i<size && data[i]=='(' ) {
        size_t span_end = i;
        while( span_end<size
                && !(data[span_end]==')' && (span_end==i || data[span_end-1]!='\\'))
             ) {
            span_end++;
        }

        if( span_end>=size
                || get_link_inline(link, title, data+i+1, span_end-(i+1))<0
          ) {
            goto char_link_cleanup;
        }

        i = span_end+1;

        /* reference style link */
    } else if( i<size && data[i]=='[' ) {
        char *id_data;
        size_t id_size, id_end = i;

        while( id_end<size && data[id_end]!=']' ) {
            id_end++;
        }

        if( id_end>=size ) goto char_link_cleanup;

        if( i+1==id_end ) {
            /* implicit id - use the contents */
            id_data = data+1;
            id_size = txt_e-1;
        } else {
            /* explicit id - between brackets */
            id_data = data+i+1;
            id_size = id_end-(i+1);
        }

        if( get_link_ref(rndr, link, title, id_data, id_size)<0 ) {
            goto char_link_cleanup;
        }

        i = id_end+1;

        /* shortcut reference style link */
    } else {
        if( get_link_ref(rndr, link, title, data+1, txt_e-1)<0 ) {
            goto char_link_cleanup;
        }

        /* rewinding the whitespace */
        i = txt_e+1;
    }

    /* building content: img alt is escaped, link content is parsed */
    if( txt_e>1 ) {
        if( is_img ) Jsi_DSAppendLen(content, data+1, txt_e-1);
        else parse_inline(content, rndr, data+1, txt_e-1);
    }

    /* calling the relevant rendering function */
    if( is_img ) {
        int dsl = Jsi_DSLength(ob);
        if( dsl>0 && Jsi_DSValue(ob)[dsl-1]=='!' ) Jsi_DSSetLength(ob, dsl-1);
        ret = rndr->make.image(ob, link, title, content, rndr->make.opts);
    } else {
        ret = rndr->make.link(ob, link, title, content, rndr->make.opts);
    }

    /* cleanup */
char_link_cleanup:
    release_work_buffer(rndr, title);
    release_work_buffer(rndr, link);
    release_work_buffer(rndr, content);
    return ret ? i : 0;
}



/*********************************
 * BLOCK-LEVEL PARSING FUNCTIONS *
 *********************************/

/* is_empty -- returns the line length when it is empty, 0 otherwise */
static size_t is_empty(const char *data, size_t size) {
    size_t i;
    for(i=0; i<size && data[i]!='\n'; i++) {
        if( data[i]!=' ' && data[i]!='\t' ) return 0;
    }
    return i+1;
}


/* is_hrule -- returns whether a line is a horizontal rule */
static int is_hrule(char *data, size_t size) {
    size_t i = 0, n = 0;
    char c;

    /* skipping initial spaces */
    if( size<3 ) return 0;
    if( data[0]==' ' ) {
        i++;
        if( data[1]==' ' ) {
            i++;
            if( data[2]==' ' ) {
                i++;
            }
        }
    }

    /* looking at the hrule char */
    if( i+2>=size || (data[i]!='*' && data[i]!='-' && data[i]!='_') ) return 0;
    c = data[i];

    /* the whole line must be the char or whitespace */
    while (i < size && data[i] != '\n') {
        if( data[i]==c ) {
            n += 1;
        } else if( data[i]!=' ' && data[i]!='\t' ) {
            return 0;
        }
        i++;
    }

    return n>=3;
}


/* is_headerline -- returns whether the line is a setext-style hdr underline */
static int is_headerline(char *data, size_t size) {
    size_t i = 0;

    /* test of level 1 header */
    if( data[i]=='=' ) {
        for(i=1; i<size && data[i]=='='; i++);
        while( i<size && (data[i]==' ' || data[i]=='\t') ) {
            i++;
        }
        return (i>=size || data[i]=='\n') ? 1 : 0;
    }

    /* test of level 2 header */
    if( data[i]=='-' ) {
        for(i=1; i<size && data[i]=='-'; i++);
        while( i<size && (data[i]==' ' || data[i]=='\t') ) {
            i++;
        }
        return (i>=size || data[i]=='\n') ? 2 : 0;
    }

    return 0;
}


/* is_table_sep -- returns whether there is a table separator at pos */
static int is_table_sep(char *data, size_t pos) {
    return data[pos]=='|' && (pos==0 || data[pos-1]!='\\');
}


/* is_tableline -- returns the number of column tables in the given line */
static int is_tableline(char *data, size_t size) {
    size_t i = 0;
    int n_sep = 0, outer_sep = 0;

    /* skip initial blanks */
    while( i<size && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }

    /* check for initial '|' */
    if( i<size && data[i]=='|') outer_sep++;

    /* count the number of pipes in the line */
    for(n_sep=0; i<size && data[i]!='\n'; i++) {
        if( is_table_sep(data, i) ) n_sep++;
    }

    /* march back to check for optional last '|' before blanks and EOL */
    while( i && (data[i-1]==' ' || data[i-1]=='\t' || data[i-1]=='\n') ) {
        i--;
    }
    if( i && is_table_sep(data, i-1) ) outer_sep += 1;

    /* return the number of column or 0 if it's not a table line */
    return (n_sep>0) ? (n_sep-outer_sep+1) : 0;
}


/* prefix_quote -- returns blockquote prefix length */
static size_t prefix_quote(char *data, size_t size) {
    size_t i = 0;
    if( i<size && data[i]==' ' ) i++;
    if( i<size && data[i]==' ' ) i++;
    if( i<size && data[i]==' ' ) i++;
    if( i<size && data[i]=='>' ) {
        if( i+1<size && (data[i+1]==' ' || data[i+1]=='\t') ) {
            return i + 2;
        } else {
            return i + 1;
        }
    } else {
        return 0;
    }
}


/* prefix_code -- returns prefix length for block code */
static size_t prefix_code(char *data, size_t size) {
    if( size>0 && data[0]=='\t' ) return 1;
    if( size>3 && data[0]==' ' && data[1]==' ' && data[2]==' ' && data[3]==' ' ) {
        return 4;
    }
    return 0;
}

/* prefix_oli -- returns ordered list item prefix */
static size_t prefix_oli(char *data, size_t size) {
    size_t i = 0;
    if( i<size && data[i]==' ') i++;
    if( i<size && data[i]==' ') i++;
    if( i<size && data[i]==' ') i++;

    if( i>=size || data[i]<'0' || data[i]>'9' ) return 0;
    while( i<size && data[i]>='0' && data[i]<='9' ) {
        i++;
    }

    if( i+1>=size
            || data[i]!='.'
            || (data[i+1]!=' ' && data[i+1]!='\t')
      ) {
        return 0;
    }
    i = i+2;
    while( i<size && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    return i;
}


/* prefix_uli -- returns ordered list item prefix */
static size_t prefix_uli(char *data, size_t size) {
    size_t i = 0;
    if( i<size && data[i]==' ') i++;
    if( i<size && data[i]==' ') i++;
    if( i<size && data[i]==' ') i++;
    if( i+1>=size
            || (data[i]!='*' && data[i]!='+' && data[i]!='-')
            || (data[i+1]!=' ' && data[i+1]!='\t')
      ) {
        return 0;
    }
    i = i+2;
    while( i<size && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    return i;
}


/* parse_block predeclaration */
static void parse_block(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size);


/* parse_blockquote -- handles parsing of a blockquote fragment */
static size_t parse_blockquote(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t beg, end = 0, pre, work_size = 0;
    char *work_data = 0;
    Jsi_DString *out = new_work_buffer(rndr);

    beg = 0;
    while( beg<size ) {
        for(end=beg+1; end<size && data[end-1]!='\n'; end++);
        pre = prefix_quote(data+beg, end-beg);
        if( pre ) {
            beg += pre; /* skipping prefix */
        } else if( is_empty(data+beg, end-beg)
                   && (end>=size
                       || (prefix_quote(data+end, size-end)==0
                           && !is_empty(data+end, size-end)))
                 ) {
            /* empty line followed by non-quote line */
            break;
        }
        if( beg<end ) { /* copy into the in-place working buffer */
            if( !work_data ) {
                work_data = data+beg;
            } else if( (data+beg)!=(work_data+work_size) ) {
                memmove(work_data+work_size, data+beg, end-beg);
            }
            work_size += end-beg;
        }
        beg = end;
    }

    if( rndr->make.blockquote ) {
        Jsi_DString fallback = {};
        if( out ) {
            parse_block(out, rndr, work_data, work_size);
        } else {
            jsi_DSInitAppend(&fallback, work_data, work_size);
        }
        rndr->make.blockquote(ob, out ? out : &fallback, rndr->make.opts);
    }
    release_work_buffer(rndr, out);
    return end;
}


/* parse_paragraph -- handles parsing of a regular paragraph */
static size_t parse_paragraph(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t i = 0, end = 0;
    int level = 0;
    char *work_data = data;
    size_t work_size = 0;
    Jsi_DString fallback = {};

    while( i<size ) {
        for(end=i+1; end<size && data[end-1]!='\n'; end++);
        if( is_empty(data+i, size-i)
                || (level = is_headerline(data+i, size-i))!= 0
          ) {
            break;
        }
        if( (i && data[i]=='#') || is_hrule(data+i, size-i) ) {
            end = i;
            break;
        }
        i = end;
    }

    work_size = i;
    while( work_size && data[work_size-1]=='\n' ) {
        work_size--;
    }

    if( !level ) {
        if( rndr->make.paragraph ) {
            Jsi_DString *tmp = new_work_buffer(rndr);
            if( tmp ) {
                parse_inline(tmp, rndr, work_data, work_size);
            } else {
                jsi_DSInitAppend(&fallback, work_data, work_size);
            }
            rndr->make.paragraph(ob, tmp ? tmp : &fallback, rndr->make.opts);
            release_work_buffer(rndr, tmp);
        }
    } else {
        if( work_size ) {
            size_t beg;
            i = work_size;
            work_size -= 1;
            while( work_size && data[work_size]!='\n' ) {
                work_size--;
            }
            beg = work_size+1;
            while( work_size && data[work_size-1]=='\n') {
                work_size--;
            }
            if( work_size ) {
                Jsi_DString *tmp = new_work_buffer(rndr);
                if( tmp ) {
                    parse_inline(tmp, rndr, work_data, work_size);
                } else {
                    jsi_DSInitAppend (&fallback, work_data, work_size);
                }
                if( rndr->make.paragraph ) {
                    rndr->make.paragraph(ob, tmp ? tmp : &fallback, rndr->make.opts);
                }
                release_work_buffer(rndr, tmp);
                work_data += beg;
                work_size = i - beg;
            } else {
                work_size = i;
            }
        }

        if( rndr->make.header ) {
            Jsi_DString *span = new_work_buffer(rndr);
            if( span ) {
                parse_inline(span, rndr, work_data, work_size);
                rndr->make.header(ob, span, level, rndr->make.opts);
            } else {
                jsi_DSInitAppend(&fallback, work_data, work_size);
                rndr->make.header(ob, &fallback, level, rndr->make.opts);
            }
            release_work_buffer(rndr, span);
        }
    }
    return end;
}


/* parse_blockcode -- handles parsing of a block-level code fragment */
static size_t parse_blockcode(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t beg, end, pre;
    Jsi_DString *work = new_work_buffer(rndr);
    if( !work ) work = ob;

    beg = 0;
    while( beg<size ) {
        for(end=beg+1; end<size && data[end-1]!='\n'; end++);
        pre = prefix_code(data+beg, end-beg);
        if( pre ) {
            beg += pre; /* skipping prefix */
        } else if( !is_empty(data+beg, end-beg) ) {
            /* non-empty non-prefixed line breaks the pre */
            break;
        }
        if( beg<end ) {
            /* verbatim copy to the working buffer, escaping entities */
            if( is_empty(data + beg, end - beg) ) {
                Jsi_DSAppendLen(work, "\n", 1);
            } else {
                Jsi_DSAppendLen(work, data+beg, end-beg);
            }
        }
        beg = end;
    }

    end = Jsi_DSLength(work);
    while( end>0 && Jsi_DSValue(work)[end-1]=='\n' ) {
        Jsi_DSSetLength(work, --end);
    }
    Jsi_DSAppendLen(work, "\n", 1);

    if( work!=ob ) {
        if( rndr->make.blockcode ) {
            rndr->make.blockcode(ob, work, rndr->make.opts);
        }
        release_work_buffer(rndr, work);
    }
    return beg;
}


/* parse_listitem -- parsing of a single list item */
/*  assuming initial prefix is already removed */
static size_t parse_listitem(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size,
    int *flags
) {
    Jsi_DString fallback = {};
    Jsi_DString *work = 0, *inter = 0;
    size_t beg = 0, end, pre, sublist = 0, orgpre = 0, i;
    int in_empty = 0, has_inside_empty = 0;

    /* keeping track of the first indentation prefix */
    if( size>1 && data[0]==' ' ) {
        orgpre = 1;
        if( size>2 && data[1]==' ' ) {
            orgpre = 2;
            if( size>3 && data[2]==' ' ) {
                orgpre = 3;
            }
        }
    }
    beg = prefix_uli(data, size);
    if( !beg ) beg = prefix_oli(data, size);
    if( !beg ) return 0;
    /* skipping to the beginning of the following line */
    end = beg;
    while( end<size && data[end-1]!='\n' ) {
        end++;
    }

    /* getting working buffers */
    work = new_work_buffer(rndr);
    inter = new_work_buffer(rndr);
    if( !work ) work = &fallback;

    /* putting the first line into the working buffer */
    Jsi_DSAppendLen(work, data+beg, end-beg);
    beg = end;

    /* process the following lines */
    while( beg<size ) {
        end++;
        while( end<size && data[end-1]!='\n' ) {
            end++;
        }

        /* process an empty line */
        if( is_empty(data+beg, end-beg) ) {
            in_empty = 1;
            beg = end;
            continue;
        }

        /* computing the indentation */
        i = 0;
        if( end-beg>1 && data[beg]==' ' ) {
            i = 1;
            if( end-beg>2 && data[beg+1]==' ' ) {
                i = 2;
                if( end-beg>3 && data[beg+2]==' ' ) {
                    i = 3;
                    if( end-beg>3 && data[beg+3]==' ' ) {
                        i = 4;
                    }
                }
            }
        }
        pre = i;
        if( data[beg]=='\t' ) {
            i = 1;
            pre = 8;
        }

        /* checking for a new item */
        if( (prefix_uli(data+beg+i, end-beg-i) && !is_hrule(data+beg+i, end-beg-i))
                || prefix_oli(data+beg+i, end-beg-i)
          ) {
            if( in_empty ) has_inside_empty = 1;
            if( pre == orgpre ) { /* the following item must have */
                break;             /* the same indentation */
            }
            if( !sublist ) sublist = Jsi_DSLength(work);

            /* joining only indented stuff after empty lines */
        } else if( in_empty && i<4 && data[beg]!='\t' ) {
            *flags |= MKD_LI_END;
            break;
        } else if( in_empty ) {
            Jsi_DSAppendLen(work, "\n", 1);
            has_inside_empty = 1;
        }
        in_empty = 0;

        /* adding the line without prefix into the working buffer */
        Jsi_DSAppendLen(work, data+beg+i, end-beg-i);
        beg = end;
    }

    /* non-recursive fallback when working buffer stack is full */
    if( !inter ) {
        if( rndr->make.listitem ) {
            rndr->make.listitem(ob, work, *flags, rndr->make.opts);
        }
        if( work!=&fallback ) release_work_buffer(rndr, work);
        Jsi_DSFree(&fallback);
        return beg;
    }

    /* render of li contents */
    if( has_inside_empty ) *flags |= MKD_LI_BLOCK;
    if( *flags & MKD_LI_BLOCK ) {
        /* intermediate render of block li */
        if( sublist && sublist<Jsi_DSLength(work) ) {
            parse_block(inter, rndr, Jsi_DSValue(work), sublist);
            parse_block(inter,
                        rndr,
                        Jsi_DSValue(work)+sublist,
                        Jsi_DSLength(work)-sublist);
        } else {
            parse_block(inter, rndr, Jsi_DSValue(work), Jsi_DSLength(work));
        }
    } else {
        /* intermediate render of inline li */
        if( sublist && sublist<Jsi_DSLength(work) ) {
            parse_inline(inter, rndr, Jsi_DSValue(work), sublist);
            parse_block(inter,
                        rndr,
                        Jsi_DSValue(work)+sublist,
                        Jsi_DSLength(work)-sublist);
        } else {
            parse_inline(inter, rndr, Jsi_DSValue(work), Jsi_DSLength(work));
        }
    }

    /* render of li itself */
    if( rndr->make.listitem ) {
        rndr->make.listitem(ob, inter, *flags, rndr->make.opts);
    }
    release_work_buffer(rndr, inter);
    if( work!=&fallback ) release_work_buffer(rndr, work);
    Jsi_DSFree(&fallback);
    return beg;
}


/* parse_list -- parsing ordered or unordered list block */
static size_t parse_list(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size,
    int flags
) {
    Jsi_DString fallback = {};
    Jsi_DString *work = new_work_buffer(rndr);
    size_t i = 0, j;
    if( !work ) work = &fallback;

    while( i<size ) {
        j = parse_listitem(work, rndr, data+i, size-i, &flags);
        i += j;
        if( !j || (flags & MKD_LI_END) ) break;
    }

    if( rndr->make.list ) rndr->make.list(ob, work, flags, rndr->make.opts);
    if( work!=&fallback ) {
        release_work_buffer(rndr, work);
        Jsi_DSFree(work);
    }
    Jsi_DSFree(&fallback);
    return i;
}


/* parse_atxheader -- parsing of atx-style headers */
static size_t parse_atxheader(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    int level = 0;
    size_t i, end, skip, span_beg, span_size;

    if( !size || data[0]!='#' ) return 0;

    while( (size_t)level<size && level<6 && data[level]=='#' ) {
        level++;
    }
    for(i=level; i<size && (data[i]==' ' || data[i]=='\t'); i++);
    span_beg = i;

    for(end=i; end<size && data[end]!='\n'; end++);
    skip = end;
    if( end<=i ) return parse_paragraph(ob, rndr, data, size);
    while( end && data[end-1]=='#' ) {
        end--;
    }
    while( end && (data[end-1]==' ' || data[end-1]=='\t') ) {
        end--;
    }
    if( end<=i ) return parse_paragraph(ob, rndr, data, size);

    span_size = end-span_beg;
    if( rndr->make.header ) {
        Jsi_DString fallback = {};
        Jsi_DString *span = new_work_buffer(rndr);

        if( span ) {
            parse_inline(span, rndr, data+span_beg, span_size);
        } else {
            jsi_DSInitAppend(&fallback, data+span_beg, span_size);
        }
        rndr->make.header(ob, span ? span : &fallback, level, rndr->make.opts);
        release_work_buffer(rndr, span);
    }
    return skip;
}


/* htmlblock_end -- checking end of HTML block : </tag>[ \t]*\n[ \t*]\n */
/*  returns the length on match, 0 otherwise */
static size_t htmlblock_end(
    const mk_html_tag *tag,
    const char *data,
    size_t size
) {
    size_t i, w;

    /* assuming data[0]=='<' && data[1]=='/' already tested */

    /* checking tag is a match */
    if( (tag->size+3)>=(int)size
            || Jsi_Strncasecmp(data+2, tag->text, tag->size)
            || data[tag->size+2]!='>'
      ) {
        return 0;
    }

    /* checking white lines */
    i = tag->size + 3;
    w = 0;
    if( i<size && (w = is_empty(data+i, size-i))==0 ) {
        return 0; /* non-blank after tag */
    }
    i += w;
    w = 0;

    if( i<size && (w = is_empty(data + i, size - i))==0 ) {
        return 0; /* non-blank line after tag line */
    }
    return i+w;
}


/* parse_htmlblock -- parsing of inline HTML block */
static size_t parse_htmlblock(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t i, j = 0;
    const mk_html_tag *curtag;
    int found;
    size_t work_size = 0;
    Jsi_DString work = {};

    /* identification of the opening tag */
    if( size<2 || data[0]!='<' ) return 0;
    curtag = find_block_tag(data+1, size-1);

    /* handling of special cases */
    if( !curtag ) {

        /* HTML comment, laxist form */
        if( size>5 && data[1]=='!' && data[2]=='-' && data[3]=='-' ) {
            i = 5;
            while( i<size && !(data[i-2]=='-' && data[i-1]=='-' && data[i]=='>') ) {
                i++;
            }
            i++;
            if( i<size ) {
                j = is_empty(data+i, size-i);
                if( j ) {
                    work_size = i+j;
                    if( !rndr->make.blockhtml ) return work_size;
                    jsi_DSInitAppend(&work, data, work_size);
                    rndr->make.blockhtml(ob, &work, rndr->make.opts);
                    return work_size;
                }
            }
        }

        /* HR, which is the only self-closing block tag considered */
        if( size>4
                && (data[1]=='h' || data[1]=='H')
                && (data[2]=='r' || data[2]=='R')
          ) {
            i = 3;
            while( i<size && data[i]!='>' ) {
                i++;
            }
            if( i+1<size ) {
                i += 1;
                j = is_empty(data+i, size-i);
                if( j ) {
                    work_size = i+j;
                    if( !rndr->make.blockhtml ) return work_size;
                    jsi_DSInitAppend(&work, data, work_size);
                    rndr->make.blockhtml(ob, &work, rndr->make.opts);
                    return work_size;
                }
            }
        }

        /* no special case recognised */
        return 0;
    }

    /* looking for an unindented matching closing tag */
    /*  followed by a blank line */
    i = 1;
    found = 0;
#if 0
    while( i<size ) {
        i++;
        while( i<size && !(data[i-2]=='\n' && data[i-1]=='<' && data[i]=='/') ) {
            i++;
        }
        if( (i+2+curtag->size)>=size ) break;
        j = htmlblock_end(curtag, data+i-1, size-i+1);
        if (j) {
            i += j-1;
            found = 1;
            break;
        }
    }
#endif

    /* if not found, trying a second pass looking for indented match */
    /* but not if tag is "ins" or "del" (following original Markdown.pl) */
    if( !found && curtag!=INS_TAG && curtag!=DEL_TAG ) {
        i = 1;
        while( i<size ) {
            i++;
            while( i<size && !(data[i-1]=='<' && data[i]=='/') ) {
                i++;
            }
            if( (i+2+curtag->size)>=size ) break;
            j = htmlblock_end(curtag, data+i-1, size-i+1);
            if (j) {
                i += j-1;
                found = 1;
                break;
            }
        }
    }

    if( !found ) return 0;

    /* the end of the block has been found */
    jsi_DSInitAppend(&work, data, i);
    if( rndr->make.blockhtml ) {
        rndr->make.blockhtml(ob, &work, rndr->make.opts);
    }
    return i;
}


/* parse_table_cell -- parse a cell inside a table */
static void parse_table_cell(
    Jsi_DString *ob,     /* output blob */
    mk_render *rndr, /* renderer description */
    char *data,          /* input text */
    size_t size,         /* input text size */
    int flags            /* table flags */
) {
    Jsi_DString fallback = {};
    Jsi_DString *span = new_work_buffer(rndr);

    if( span ) {
        parse_inline(span, rndr, data, size);
    } else {
        jsi_DSInitAppend(&fallback, data, size);
    }
    rndr->make.table_cell(ob, span ? span : &fallback, flags, rndr->make.opts);
    release_work_buffer(rndr, span);
}

static char *jsi_DSInitAppend(Jsi_DString *dStr, const char *str, int len)
{
    Jsi_DSInit(dStr);
    return Jsi_DSAppendLen(dStr, str, len);
}

static int jsi_DSCompare(Jsi_DString *dStr1, Jsi_DString *dStr2)
{
    int l1 = Jsi_DSLength(dStr1);
    int l2 = Jsi_DSLength(dStr2);
    char *c1 = Jsi_DSValue(dStr1);
    char *c2 = Jsi_DSValue(dStr2);
    if (l1==l2) return memcmp(c1, c2, l1);
    int c = memcmp(c1, c2, (l1<l2?l1:l2));
    if (c) return c;
    return (l1<l2?-1:1);
}

static void jsi_DSzero(Jsi_DString *da, int n) {
    int i;
    for(i=0; i<n; i++) {
        Jsi_DString *dStr1 = da+i;
        int l1 = Jsi_DSLength(dStr1);
        char *c1 = Jsi_DSValue(dStr1);
        memset(c1, 0, l1);
    }
}


/* parse_table_row -- parse an input line into a table row */
static size_t parse_table_row(
    Jsi_DString *ob,        /* output blob for rendering */
    mk_render *rndr,    /* renderer description */
    char *data,             /* input text */
    size_t size,            /* input text size */
    int *aligns,            /* array of default alignment for columns */
    size_t align_size,      /* number of columns with default alignment */
    int flags               /* table flags */
) {
    size_t i = 0, col = 0;
    size_t beg, end, total = 0;
    Jsi_DString *cells = new_work_buffer(rndr);
    int align;

    /* skip leading blanks and separator */
    while( i<size && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    if( i<size && data[i]=='|' ) i++;

    /* go over all the cells */
    while( i<size && total==0 ) {
        /* check optional left/center align marker */
        align = 0;
        if( data[i]==':' ) {
            align |= MKD_CELL_ALIGN_LEFT;
            i++;
        }

        /* skip blanks */
        while( i<size && (data[i]==' ' || data[i]=='\t') ) {
            i++;
        }
        beg = i;

        /* forward to the next separator or EOL */
        while( i<size && !is_table_sep(data, i) && data[i]!='\n' ) {
            i++;
        }
        end = i;
        if( i<size ) {
            i++;
            if( data[i-1]=='\n' ) total = i;
        }

        /* check optional right/center align marker */
        if( i>beg && data[end-1]==':' ) {
            align |= MKD_CELL_ALIGN_RIGHT;
            end--;
        }

        /* remove trailing blanks */
        while( end>beg && (data[end-1]==' ' || data[end-1]=='\t') ) {
            end--;
        }

        /* skip the last cell if it was only blanks */
        /* (because it is only the optional end separator) */
        if( total && end<=beg ) continue;

        /* fallback on default alignment if not explicit */
        if( align==0 && aligns && col<align_size ) align = aligns[col];

        /* render cells */
        if( cells ) parse_table_cell(cells, rndr, data+beg, end-beg, align|flags);

        col++;
    }

    /* render the whole row and clean up */
    if( cells ) {
        rndr->make.table_row(ob, cells, flags, rndr->make.opts);
    } else {
        Jsi_DString fallback = {};
        jsi_DSInitAppend(&fallback, data, total ? total : size);
        rndr->make.table_row(ob, &fallback, flags, rndr->make.opts);
    }
    release_work_buffer(rndr, cells);
    return total ? total : size;
}


/* parse_table -- parsing of a whole table */
static size_t parse_table(
    Jsi_DString *ob,
    mk_render *rndr,
    char *data,
    size_t size
) {
    size_t i = 0, head_end, col;
    size_t align_size = 0;
    int *aligns = 0;
    Jsi_DString fallback = {};
    Jsi_DString *head = 0;
    Jsi_DString *rows = new_work_buffer(rndr);
    if( !rows ) rows = &fallback;

    /* skip the first (presumably header) line */
    while( i<size && data[i]!='\n' ) {
        i++;
    }
    head_end = i;

    /* fallback on end of input */
    if( i>=size ) {
        parse_table_row(rows, rndr, data, size, 0, 0, 0);
        rndr->make.table(ob, 0, rows, rndr->make.opts);
        if( rows!=&fallback ) release_work_buffer(rndr, rows);
        return i;
    }

    /* attempt to parse a table rule, i.e. blanks, dash, colons and sep */
    i++;
    col = 0;
    while( i<size
            && (data[i]==' '
                || data[i]=='\t'
                || data[i]=='-'
                || data[i] == ':'
                || data[i] =='|')
         ) {
        if( data[i] == '|' ) align_size++;
        if( data[i] == ':' ) col = 1;
        i += 1;
    }

    if( i<size && data[i]=='\n' ) {
        align_size++;

        /* render the header row */
        head = new_work_buffer(rndr);
        if( head ) {
            parse_table_row(head, rndr, data, head_end, 0, 0, MKD_CELL_HEAD);
        }

        /* parse alignments if provided */
        if( col && (aligns=(int*)malloc(align_size * sizeof *aligns))!=0 ) {
            for(i=0; i<align_size; i++) aligns[i] = 0;
            col = 0;
            i = head_end+1;

            /* skip initial white space and optional separator */
            while( i<size && (data[i]==' ' || data[i]=='\t') ) {
                i++;
            }
            if( data[i]=='|' ) i++;

            /* compute default alignment for each column */
            while (i < size && data[i] != '\n') {
                if (data[i] == ':')
                    aligns[col] |= MKD_CELL_ALIGN_LEFT;
                while (i < size
                        && data[i] != '|' && data[i] != '\n')
                    i += 1;
                if (data[i - 1] == ':')
                    aligns[col] |= MKD_CELL_ALIGN_RIGHT;
                if (i < size && data[i] == '|')
                    i += 1;
                col += 1;
            }
        }

        /* point i to the beginning of next line/row */
        i++;

    } else {
        /* there is no valid ruler, continuing without header */
        i = 0;
    }

    /* render the table body lines */
    while( i<size && is_tableline(data + i, size - i) ) {
        i += parse_table_row(rows, rndr, data+i, size-i, aligns, align_size, 0);
    }

    /* render the full table */
    rndr->make.table(ob, head, rows, rndr->make.opts);

    /* cleanup */
    if( head ) release_work_buffer(rndr, head);
    if( rows!=&fallback ) release_work_buffer(rndr, rows);
    free(aligns);
    return i;
}


/* parse_block -- parsing of one block, returning next char to parse */
static void parse_block(
    Jsi_DString *ob,        /* output blob */
    mk_render *rndr,    /* renderer internal state */
    char *data,             /* input text */
    size_t size             /* input text size */
) {
    size_t beg, end, i;
    char *txt_data;
    int has_table = (rndr->make.table
                     && rndr->make.table_row
                     && rndr->make.table_cell);

    beg = 0;
    while( beg<size ) {
        txt_data = data+beg;
        end = size-beg;
        if( data[beg]=='#' ) {
            beg += parse_atxheader(ob, rndr, txt_data, end);
        } else if( data[beg]=='<'
                   && rndr->make.blockhtml
                   && (i = parse_htmlblock(ob, rndr, txt_data, end))!=0
                 ) {
            beg += i;
        } else if( (i=is_empty(txt_data, end))!=0 ) {
            beg += i;
        } else if( is_hrule(txt_data, end) ) {
            if( rndr->make.hrule ) rndr->make.hrule(ob, rndr->make.opts);
            while( beg<size && data[beg]!='\n' ) {
                beg++;
            }
            beg++;
        } else if( prefix_quote(txt_data, end) ) {
            beg += parse_blockquote(ob, rndr, txt_data, end);
        } else if( prefix_code(txt_data, end) ) {
            beg += parse_blockcode(ob, rndr, txt_data, end);
        } else if( prefix_uli(txt_data, end) ) {
            beg += parse_list(ob, rndr, txt_data, end, 0);
        } else if( prefix_oli(txt_data, end) ) {
            beg += parse_list(ob, rndr, txt_data, end, MKD_LIST_ORDERED);
        } else if( has_table && is_tableline(txt_data, end) ) {
            beg += parse_table(ob, rndr, txt_data, end);
        } else {
            beg += parse_paragraph(ob, rndr, txt_data, end);
        }
    }
}



/*********************
 * REFERENCE PARSING *
 *********************/

/* is_ref -- returns whether a line is a reference or not */
static int is_ref(
    char *data,         /* input text */
    size_t beg,         /* offset of the beginning of the line */
    size_t end,         /* offset of the end of the text */
    size_t *last,       /* last character of the link */
    Jsi_DString *refs   /* array of link references */
) {
    size_t i = 0;
    size_t id_offset, id_end;
    size_t link_offset, link_end;
    size_t title_offset, title_end;
    size_t line_end;
    struct link_ref lr = {
        {},
        {},
        {}
    };

    /* up to 3 optional leading spaces */
    if( beg+3>=end ) return 0;
    if( data[beg]==' ' ) {
        i = 1;
        if( data[beg+1]==' ' ) {
            i = 2;
            if( data[beg+2]==' ' ) {
                i = 3;
                if( data[beg+3]==' ' ) return 0;
            }
        }
    }
    i += beg;

    /* id part: anything but a newline between brackets */
    if( data[i]!='[' ) return 0;
    i++;
    id_offset = i;
    while( i<end && data[i]!='\n' && data[i]!='\r' && data[i]!=']' ) {
        i++;
    }
    if( i>=end || data[i]!=']' ) return 0;
    id_end = i;

    /* spacer: colon (space | tab)* newline? (space | tab)* */
    i++;
    if( i>=end || data[i]!=':' ) return 0;
    i++;
    while( i<end && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    if( i<end && (data[i]=='\n' || data[i]=='\r') ) {
        i++;
        if( i<end && data[i]=='\r' && data[i-1] == '\n' ) i++;
    }
    while( i<end && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    if( i>=end ) return 0;

    /* link: whitespace-free sequence, optionally between angle brackets */
    if( data[i]=='<' ) i++;
    link_offset = i;
    while( i<end
            && data[i]!=' '
            && data[i]!='\t'
            && data[i]!='\n'
            && data[i]!='\r'
         ) {
        i += 1;
    }
    if( data[i-1]=='>' ) link_end = i-1;
    else link_end = i;

    /* optional spacer: (space | tab)* (newline | '\'' | '"' | '(' ) */
    while( i<end && (data[i]==' ' || data[i]=='\t') ) {
        i++;
    }
    if( i<end
            && data[i]!='\n'
            && data[i]!='\r'
            && data[i]!='\''
            && data[i]!='"'
            && data[i]!='('
      ) {
        return 0;
    }
    line_end = 0;
    /* computing end-of-line */
    if( i>=end || data[i]=='\r' || data[i]=='\n' ) line_end = i;
    if( i+1<end && data[i]=='\n' && data[i+1]=='\r' ) line_end = i+1;

    /* optional (space|tab)* spacer after a newline */
    if( line_end ) {
        i = line_end+1;
        while( i<end && (data[i]==' ' || data[i]=='\t') ) {
            i++;
        }
    }

    /* optional title: any non-newline sequence enclosed in '"()
            alone on its line */
    title_offset = title_end = 0;
    if( i+1<end && (data[i]=='\'' || data[i]=='"' || data[i]=='(') ) {
        i += 1;
        title_offset = i;
        /* looking for EOL */
        while( i<end && data[i]!='\n' && data[i]!='\r' ) {
            i++;
        }
        if( i+1<end && data[i]=='\n' && data[i+1]=='\r' ) {
            title_end = i + 1;
        } else {
            title_end = i;
        }
        /* stepping back */
        i--;
        while( i>title_offset && (data[i]==' ' || data[i]=='\t') ) {
            i--;
        }
        if( i>title_offset && (data[i]=='\'' || data[i]=='"' || data[i]==')') ) {
            line_end = title_end;
            title_end = i;
        }
    }
    if( !line_end ) return 0; /* garbage after the link */

    /* a valid ref has been found, filling-in return structures */
    if( last ) *last = line_end;
    if( !refs ) return 1;
    if( build_ref_id(&lr.id, data+id_offset, id_end-id_offset)<0 ) return 0;
    Jsi_DSAppendLen(&lr.link, data+link_offset, link_end-link_offset);
    if( title_end>title_offset ) {
        Jsi_DSAppendLen(&lr.title, data+title_offset, title_end-title_offset);
    }
    Jsi_DSAppendLen(refs, (char *)&lr, sizeof lr);
    return 1;
}

/* markdown -- parses the input buffer and renders it into the output buffer */
static void mk_markdown(
    Jsi_DString *ob,                   /* output blob for rendered text */
    Jsi_DString *ib,                   /* input blob in markdown */
    const struct mkd_renderer *rndrer  /* renderer descriptor (callbacks) */
) {
    struct link_ref *lr;
    Jsi_DString text = {};
    size_t i, beg, end = 0;
    mk_render rndr;
    char *ib_data;
    jsi_MarkdownOpts *opts = rndrer->opts;
     
    /* filling the render structure */
    if( !rndrer ) return;
    rndr.make = *rndrer;
    if( rndr.make.max_work_stack<1 ) rndr.make.max_work_stack = 1;
    rndr.work_active = 0;
    rndr.work = (Jsi_DString*)Jsi_Calloc(rndr.make.max_work_stack, sizeof *rndr.work);
    rndr.refs = text;
    for(i=0; i<256; i++) rndr.active_char[i] = 0;
    if( (rndr.make.emphasis
            || rndr.make.double_emphasis
            || rndr.make.triple_emphasis)
            && rndr.make.emph_chars
      ) {
        for(i=0; rndr.make.emph_chars[i]; i++) {
            rndr.active_char[(unsigned char)rndr.make.emph_chars[i]] = char_emphasis;
        }
    }
    if( rndr.make.codespan ) rndr.active_char['`'] = char_codespan;
    if( rndr.make.linebreak ) rndr.active_char['\n'] = char_linebreak;
    if( rndr.make.image || rndr.make.link ) rndr.active_char['['] = char_link;
    rndr.active_char['<'] = char_langle_tag;
    rndr.active_char['\\'] = char_escape;
    rndr.active_char['&'] = char_entity;

    /* first pass: looking for references, copying everything else */
    beg = 0;
    ib_data = Jsi_DSValue(ib);
    while( beg<Jsi_DSLength(ib) ) { /* iterating over lines */
        if( is_ref(ib_data, beg, Jsi_DSLength(ib), &end, &rndr.refs) ) {
            beg = end;
        } else { /* skipping to the next line */
            end = beg;
            while( end<Jsi_DSLength(ib) && ib_data[end]!='\n' && ib_data[end]!='\r' ) {
                end += 1;
            }
            /* adding the line body if present */
            if( end>beg ) Jsi_DSAppendLen(&text, ib_data + beg, end - beg);
            while( end<Jsi_DSLength(ib) && (ib_data[end]=='\n' || ib_data[end]=='\r') ) {
                /* add one \n per newline */
                if( ib_data[end]=='\n'
                        || (end+1<Jsi_DSLength(ib) && ib_data[end+1]!='\n')
                  ) {
                    Jsi_DSAppendLen(&text, "\n", 1);
                }
                end += 1;
            }
            beg = end;
        }
    }

    /* sorting the reference array */
    if( Jsi_DSLength(&rndr.refs) ) {
        qsort(Jsi_DSValue(&rndr.refs),
              Jsi_DSLength(&rndr.refs)/sizeof(struct link_ref),
              sizeof(struct link_ref),
              cmp_link_ref_sort);
    }

    /* second pass: actual rendering */
    if( rndr.make.prolog ) rndr.make.prolog(ob, opts);
    parse_block(ob, &rndr, Jsi_DSValue(&text), Jsi_DSLength(&text));
    if( rndr.make.epilog ) rndr.make.epilog(ob, opts);

    /* clean-up */
    Jsi_DSFree(&text);
    lr = (struct link_ref *)Jsi_DSValue(&rndr.refs);
    end = Jsi_DSLength(&rndr.refs)/sizeof(struct link_ref);
    for(i=0; i<end; i++) {
        Jsi_DSFree(&lr[i].id);
        Jsi_DSFree(&lr[i].link);
        Jsi_DSFree(&lr[i].title);
    }
    Jsi_DSFree(&rndr.refs);
    jsi_DSzero(rndr.work, rndr.make.max_work_stack);
    free(rndr.work);
}

/* INTER_BLOCK -- skip a line between block level elements */
#define INTER_BLOCK(ob) \
  do { if( Jsi_DSLength(ob)>0 ) Jsi_DSAppendLen(ob, "\n", 1); } while (0)

/* BLOB_APPEND_LITERAL -- append a string literal to a blob */
#define BLOB_APPEND_LITERAL(blob, literal) \
  Jsi_DSAppendLen((blob), "" literal, (sizeof literal)-1)
/*
 * The empty string in the second argument leads to a syntax error
 * when the macro is not used with a string literal. Unfortunately
 * the error is not overly explicit.
 */

/* BLOB_APPEND_BLOB -- append blob contents to another */
#define BLOB_APPEND_BLOB(dest, src) \
  Jsi_DSAppendLen((dest), Jsi_DSValue(src), Jsi_DSLength(src))


/* HTML escape */

static void html_escape(Jsi_DString *ob, const char *data, size_t size) {
    size_t beg = 0, i = 0;
    while( i<size ) {
        beg = i;
        while( i<size
                && data[i]!='<'
                && data[i]!='>'
                && data[i]!='"'
                && data[i]!='&'
             ) {
            i++;
        }
        Jsi_DSAppendLen(ob, data+beg, i-beg);
        while( i<size ) {
            if( data[i]=='<' ) {
                BLOB_APPEND_LITERAL(ob, "&lt;");
            } else if( data[i]=='>' ) {
                BLOB_APPEND_LITERAL(ob, "&gt;");
            } else if( data[i]=='&' ) {
                BLOB_APPEND_LITERAL(ob, "&amp;");
            } else if( data[i]=='"' ) {
                BLOB_APPEND_LITERAL(ob, "&quot;");
            } else if( data[i]=='\'' ) {
                BLOB_APPEND_LITERAL(ob, "&#39;");
            } else {
                break;
            }
            i++;
        }
    }
}


/* HTML block tags */

/* Size of the prolog: "<div class='markdown'>\n" */
#define PROLOG_SIZE 23

static void html_prolog(Jsi_DString *ob, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<div class=\"markdown\">\n");
    assert( Jsi_DSLength(ob)==PROLOG_SIZE );
}

static void html_epilog(Jsi_DString *ob, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "</div>\n");
}

static int htmlTagLength(const char *z) {
    int n = 1;
    int inparen = 0;
    int c;
    if( z[n]=='/' ) {
        n++;
    }
    if( !isalpha(z[n]) ) return 0;
    while( isalnum(z[n]) || z[n]=='-' ) {
        n++;
    }
    c = z[n];
    if( c=='/' && z[n+1]=='>' ) {
        return n+2;
    }
    if( c!='>' && !isspace(c) ) return 0;
    while( (c = z[n])!=0 && (c!='>' || inparen) ) {
        if( c==inparen ) {
            inparen = 0;
        } else if( inparen==0 && (c=='"' || c=='\'') ) {
            inparen = c;
        }
        n++;
    }
    if( z[n]!='>' ) return 0;
    return n+1;
}


static void html_raw_block(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    char *data = Jsi_DSValue(text);
    size_t size = Jsi_DSLength(text);
//    Jsi_DString *title = (Jsi_DString*)opaque;
    while( size>0 && isspace(data[0]) ) {
        data++;
        size--;
    }
    while( size>0 && isspace(data[size-1]) ) {
        size--;
    }
    /* If the first raw block is an <h1> element, then use it as the title. */
    if( Jsi_DSLength(ob)<=PROLOG_SIZE
            && size>9
            && opts->getTitle
            && Jsi_Strncasecmp("<h1",data,3)==0
            && Jsi_Strncasecmp("</h1>", &data[size-5],5)==0
      ) {
        int nTag = htmlTagLength(data);
        opts->getTitle = 0;
        Jsi_DSAppendLen(&opts->titleStr, data+nTag, size - nTag - 5);
        return;
    }
    INTER_BLOCK(ob);
    Jsi_DSAppendLen(ob, data, size);
    BLOB_APPEND_LITERAL(ob, "\n");
}

static void html_blockcode(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<pre><code>");
    html_escape(ob, Jsi_DSValue(text), Jsi_DSLength(text));
    BLOB_APPEND_LITERAL(ob, "</code></pre>\n");
}

static void html_blockquote(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<blockquote>\n");
    BLOB_APPEND_BLOB(ob, text);
    BLOB_APPEND_LITERAL(ob, "</blockquote>\n");
}

static void html_header(
    Jsi_DString *ob,
    Jsi_DString *text,
    int level,
    jsi_MarkdownOpts *opts
) {
    /* The first header at the beginning of a text is considered as
     * a title and not output. */
    if( Jsi_DSLength(ob)<=PROLOG_SIZE && opts->getTitle) {
        BLOB_APPEND_BLOB(&opts->titleStr, text);
        opts->getTitle = 0;
        return;
    }
    INTER_BLOCK(ob);
    Jsi_DSPrintf(ob, "<h%d>", level);
    BLOB_APPEND_BLOB(ob, text);
    Jsi_DSPrintf(ob, "</h%d>", level);
}

static void html_hrule(Jsi_DString *ob, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<hr />\n");
}


static void html_list(
    Jsi_DString *ob,
    Jsi_DString *text,
    int flags,
    jsi_MarkdownOpts *opts
) {
    char ol[] = "ol";
    char ul[] = "ul";
    char *tag = (flags & MKD_LIST_ORDERED) ? ol : ul;
    INTER_BLOCK(ob);
    Jsi_DSPrintf(ob, "<%s>\n", tag);
    BLOB_APPEND_BLOB(ob, text);
    Jsi_DSPrintf(ob, "</%s>\n", tag);
}

static void html_list_item(
    Jsi_DString *ob,
    Jsi_DString *text,
    int flags,
    jsi_MarkdownOpts *opts
) {
    char *text_data = Jsi_DSValue(text);
    size_t text_size = Jsi_DSLength(text);
    while( text_size>0 && text_data[text_size-1]=='\n' ) text_size--;
    BLOB_APPEND_LITERAL(ob, "<li>");
    Jsi_DSAppendLen(ob, text_data, text_size);
    BLOB_APPEND_LITERAL(ob, "</li>\n");
}

static void html_paragraph(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<p>");
    BLOB_APPEND_BLOB(ob, text);
    BLOB_APPEND_LITERAL(ob, "</p>\n");
}


static void html_table(
    Jsi_DString *ob,
    Jsi_DString *head_row,
    Jsi_DString *rows,
    jsi_MarkdownOpts *opts
) {
    INTER_BLOCK(ob);
    BLOB_APPEND_LITERAL(ob, "<table>\n");
    if( head_row && Jsi_DSLength(head_row)>0 ) {
        BLOB_APPEND_LITERAL(ob, "<thead>\n");
        BLOB_APPEND_BLOB(ob, head_row);
        BLOB_APPEND_LITERAL(ob, "</thead>\n<tbody>\n");
    }
    if( rows ) {
        BLOB_APPEND_BLOB(ob, rows);
    }
    if( head_row && Jsi_DSLength(head_row)>0 ) {
        BLOB_APPEND_LITERAL(ob, "</tbody>\n");
    }
    BLOB_APPEND_LITERAL(ob, "</table>\n");
}

static void html_table_cell(
    Jsi_DString *ob,
    Jsi_DString *text,
    int flags,
    jsi_MarkdownOpts *opts
) {
    if( flags & MKD_CELL_HEAD ) {
        BLOB_APPEND_LITERAL(ob, "    <th");
    } else {
        BLOB_APPEND_LITERAL(ob, "    <td");
    }
    switch( flags & MKD_CELL_ALIGN_MASK ) {
    case MKD_CELL_ALIGN_LEFT: {
        BLOB_APPEND_LITERAL(ob, " align=\"left\"");
        break;
    }
    case MKD_CELL_ALIGN_RIGHT: {
        BLOB_APPEND_LITERAL(ob, " align=\"right\"");
        break;
    }
    case MKD_CELL_ALIGN_CENTER: {
        BLOB_APPEND_LITERAL(ob, " align=\"center\"");
        break;
    }
    }
    BLOB_APPEND_LITERAL(ob, ">");
    BLOB_APPEND_BLOB(ob, text);
    if( flags & MKD_CELL_HEAD ) {
        BLOB_APPEND_LITERAL(ob, "</th>\n");
    } else {
        BLOB_APPEND_LITERAL(ob, "</td>\n");
    }
}

static void html_table_row(
    Jsi_DString *ob,
    Jsi_DString *cells,
    int flags,
    jsi_MarkdownOpts *opts
) {
    BLOB_APPEND_LITERAL(ob, "  <tr>\n");
    BLOB_APPEND_BLOB(ob, cells);
    BLOB_APPEND_LITERAL(ob, "  </tr>\n");
}



/* HTML span tags */

static int html_raw_span(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    /* If the document begins with a <h1> markup, take that as the header. */
    BLOB_APPEND_BLOB(ob, text);
    return 1;
}

static int html_autolink(
    Jsi_DString *ob,
    Jsi_DString *link,
    enum mkd_autolink type,
    jsi_MarkdownOpts *opts
) {
    if( !link || Jsi_DSLength(link)<=0 ) return 0;
    BLOB_APPEND_LITERAL(ob, "<a href=\"");
    if( type==MKDA_IMPLICIT_EMAIL ) BLOB_APPEND_LITERAL(ob, "mailto:");
    html_escape(ob, Jsi_DSValue(link), Jsi_DSLength(link));
    BLOB_APPEND_LITERAL(ob, "\">");
    if( type==MKDA_EXPLICIT_EMAIL && Jsi_DSLength(link)>7 ) {
        /* remove "mailto:" from displayed text */
        html_escape(ob, Jsi_DSValue(link)+7, Jsi_DSLength(link)-7);
    } else {
        html_escape(ob, Jsi_DSValue(link), Jsi_DSLength(link));
    }
    BLOB_APPEND_LITERAL(ob, "</a>");
    return 1;
}

static int html_code_span(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    BLOB_APPEND_LITERAL(ob, "<code>");
    html_escape(ob, Jsi_DSValue(text), Jsi_DSLength(text));
    BLOB_APPEND_LITERAL(ob, "</code>");
    return 1;
}

static int html_double_emphasis(
    Jsi_DString *ob,
    Jsi_DString *text,
    char c,
    jsi_MarkdownOpts *opts
) {
    BLOB_APPEND_LITERAL(ob, "<strong>");
    BLOB_APPEND_BLOB(ob, text);
    BLOB_APPEND_LITERAL(ob, "</strong>");
    return 1;
}

static int html_emphasis(
    Jsi_DString *ob,
    Jsi_DString *text,
    char c,
    jsi_MarkdownOpts *opts
) {
    BLOB_APPEND_LITERAL(ob, "<em>");
    BLOB_APPEND_BLOB(ob, text);
    BLOB_APPEND_LITERAL(ob, "</em>");
    return 1;
}

static int html_image(
    Jsi_DString *ob,
    Jsi_DString *link,
    Jsi_DString *title,
    Jsi_DString *alt,
    jsi_MarkdownOpts *opts
) {
    BLOB_APPEND_LITERAL(ob, "<img src=\"");
    html_escape(ob, Jsi_DSValue(link), Jsi_DSLength(link));
    BLOB_APPEND_LITERAL(ob, "\" alt=\"");
    html_escape(ob, Jsi_DSValue(alt), Jsi_DSLength(alt));
    if( title && Jsi_DSLength(title)>0 ) {
        BLOB_APPEND_LITERAL(ob, "\" title=\"");
        html_escape(ob, Jsi_DSValue(title), Jsi_DSLength(title));
    }
    BLOB_APPEND_LITERAL(ob, "\" />");
    return 1;
}

static int html_line_break(Jsi_DString *ob, jsi_MarkdownOpts *opts) {
    BLOB_APPEND_LITERAL(ob, "<br />\n");
    return 1;
}

static int html_link(
    Jsi_DString *ob,
    Jsi_DString *link,
    Jsi_DString *title,
    Jsi_DString *content,
    jsi_MarkdownOpts *opts
) {
    char *zLink = Jsi_DSValue(link);
    BLOB_APPEND_LITERAL(ob, "<a href=\"");
    if( zLink && zLink[0]=='/' && opts->topLink ) {
        /* For any hyperlink that begins with "/", make it refer to the root */
        Jsi_DSAppendLen(ob, opts->topLink, -1);
    }
    html_escape(ob, Jsi_DSValue(link), Jsi_DSLength(link));
    if( title && Jsi_DSLength(title)>0 ) {
        BLOB_APPEND_LITERAL(ob, "\" title=\"");
        html_escape(ob, Jsi_DSValue(title), Jsi_DSLength(title));
    }
    BLOB_APPEND_LITERAL(ob, "\">");
    BLOB_APPEND_BLOB(ob, content);
    BLOB_APPEND_LITERAL(ob, "</a>");
    return 1;
}

static int html_triple_emphasis(
    Jsi_DString *ob,
    Jsi_DString *text,
    char c,
    jsi_MarkdownOpts *opts
) {
    BLOB_APPEND_LITERAL(ob, "<strong><em>");
    BLOB_APPEND_BLOB(ob, text);
    BLOB_APPEND_LITERAL(ob, "</em></strong>");
    return 1;
}


static void html_normal_text(Jsi_DString *ob, Jsi_DString *text, jsi_MarkdownOpts *opts) {
    html_escape(ob, Jsi_DSValue(text), Jsi_DSLength(text));
}

/*
** Convert markdown into HTML.
**
** The document title is placed in output_title if not NULL.  Or if
** output_title is NULL, the document title appears in the body.
*/
void jsi_markdown_to_html(
    Jsi_DString *input_markdown,   /* Markdown content to be rendered */
    Jsi_DString *output_body,      /* Put document body here. */
    jsi_MarkdownOpts *opts
) {
    struct mkd_renderer html_renderer = {
        /* prolog and epilog */
        html_prolog,
        html_epilog,

        /* block level elements */
        html_blockcode,
        html_blockquote,
        html_raw_block,
        html_header,
        html_hrule,
        html_list,
        html_list_item,
        html_paragraph,
        html_table,
        html_table_cell,
        html_table_row,

        /* span level elements */
        html_autolink,
        html_code_span,
        html_double_emphasis,
        html_emphasis,
        html_image,
        html_line_break,
        html_link,
        html_raw_span,
        html_triple_emphasis,

        /* low level elements */
        0,  /* entities are copied verbatim */
        html_normal_text,

        /* misc. parameters */
        64, /* maximum stack */
        "*_", /* emphasis characters */
        opts /* opaque data */
    };
    Jsi_DSFree(output_body);
    mk_markdown(output_body, input_markdown, &html_renderer);
}

#endif
#endif //JSI_LITE_ONLY
#ifndef JSI_LITE_ONLY
/* A Bison parser, made by GNU Bison 3.0.4.  */

/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output.  */
#define YYBISON 1

/* Bison version.  */
#define YYBISON_VERSION "3.0.4"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 1

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1




/* Copy the first part of user declarations.  */

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#include "jsiCode.c"
#endif


# ifndef YY_NULLPTR
#  if defined __cplusplus && 201103L <= __cplusplus
#   define YY_NULLPTR nullptr
#  else
#   define YY_NULLPTR 0
#  endif
# endif

/* Enabling verbose error messages.  */
#ifdef YYERROR_VERBOSE
# undef YYERROR_VERBOSE
# define YYERROR_VERBOSE 1
#else
# define YYERROR_VERBOSE 1
#endif

/* In a future release of Bison, this section will be replaced
   by #include "parser.h".  */
#ifndef YY_YY_PARSER_H_INCLUDED
# define YY_YY_PARSER_H_INCLUDED
/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif

/* Token type.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    STRING = 258,
    IDENTIFIER = 259,
    IF = 260,
    ELSE = 261,
    FOR = 262,
    IN = 263,
    WHILE = 264,
    DO = 265,
    CONTINUE = 266,
    SWITCH = 267,
    CASE = 268,
    DEFAULT = 269,
    BREAK = 270,
    FUNC = 271,
    RETURN = 272,
    LOCAL = 273,
    OF = 274,
    NEW = 275,
    DELETE = 276,
    TRY = 277,
    CATCH = 278,
    FINALLY = 279,
    THROW = 280,
    WITH = 281,
    UNDEF = 282,
    _TRUE = 283,
    _FALSE = 284,
    _THIS = 285,
    ARGUMENTS = 286,
    FNUMBER = 287,
    REGEXP = 288,
    TYPESTRING = 289,
    TYPENUMBER = 290,
    TYPENULL = 291,
    TYPEOBJECT = 292,
    TYPEBOOLEAN = 293,
    TYPEUSEROBJ = 294,
    TYPEITEROBJ = 295,
    TYPEREGEXP = 296,
    TYPEANY = 297,
    TYPEARRAY = 298,
    ELLIPSIS = 299,
    __DEBUG = 300,
    MIN_PRI = 301,
    ARGCOMMA = 302,
    ADDAS = 303,
    MNSAS = 304,
    MULAS = 305,
    MODAS = 306,
    LSHFAS = 307,
    RSHFAS = 308,
    URSHFAS = 309,
    BANDAS = 310,
    BORAS = 311,
    BXORAS = 312,
    DIVAS = 313,
    OR = 314,
    AND = 315,
    EQU = 316,
    NEQ = 317,
    EEQU = 318,
    NNEQ = 319,
    LEQ = 320,
    GEQ = 321,
    INSTANCEOF = 322,
    LSHF = 323,
    RSHF = 324,
    URSHF = 325,
    NEG = 326,
    INC = 327,
    DEC = 328,
    TYPEOF = 329,
    VOID = 330,
    MAX_PRI = 331
  };
#endif

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED

union YYSTYPE
{

    Jsi_OpCodes *opcodes;
    Jsi_Value *value;
    const char *str;
    Jsi_Regex* regex;
    Jsi_Number *num;
    Jsi_ScopeStrs *scopes;
    int inum;
    struct jsi_CaseExprStat* caseitem;
    struct jsi_CaseList* caselist;

};

typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif

/* Location type.  */
#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE YYLTYPE;
struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
};
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif



int yyparse (struct jsi_Pstate *pstate);

#endif /* !YY_YY_PARSER_H_INCLUDED  */

/* Copy the second part of user declarations.  */


#ifdef short
# undef short
#endif

#ifdef YYTYPE_UINT8
typedef YYTYPE_UINT8 yytype_uint8;
#else
typedef unsigned char yytype_uint8;
#endif

#ifdef YYTYPE_INT8
typedef YYTYPE_INT8 yytype_int8;
#else
typedef signed char yytype_int8;
#endif

#ifdef YYTYPE_UINT16
typedef YYTYPE_UINT16 yytype_uint16;
#else
typedef unsigned short int yytype_uint16;
#endif

#ifdef YYTYPE_INT16
typedef YYTYPE_INT16 yytype_int16;
#else
typedef short int yytype_int16;
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif ! defined YYSIZE_T
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned int
# endif
#endif

#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(Msgid) Msgid
# endif
#endif

#ifndef YY_ATTRIBUTE
# if (defined __GNUC__                                               \
      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
# else
#  define YY_ATTRIBUTE(Spec) /* empty */
# endif
#endif

#ifndef YY_ATTRIBUTE_PURE
# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
#endif

#if !defined _Noreturn \
     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
# if defined _MSC_VER && 1200 <= _MSC_VER
#  define _Noreturn __declspec (noreturn)
# else
#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YYUSE(E) ((void) (E))
#else
# define YYUSE(E) /* empty */
#endif

#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
    _Pragma ("GCC diagnostic push") \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif


#if ! defined yyoverflow || YYERROR_VERBOSE

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's 'empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
             && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* ! defined yyoverflow || YYERROR_VERBOSE */


#if (! defined yyoverflow \
     && (! defined __cplusplus \
         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yytype_int16 yyss_alloc;
  YYSTYPE yyvs_alloc;
  YYLTYPE yyls_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
      + 2 * YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
    do                                                                  \
      {                                                                 \
        YYSIZE_T yynewbytes;                                            \
        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        Stack = &yyptr->Stack_alloc;                                    \
        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / sizeof (*yyptr);                          \
      }                                                                 \
    while (0)

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYSIZE_T yyi;                         \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  100
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   2413

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  101
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  45
/* YYNRULES -- Number of rules.  */
#define YYNRULES  206
/* YYNSTATES -- Number of states.  */
#define YYNSTATES  397

/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
   by yylex, with out-of-bounds checking.  */
#define YYUNDEFTOK  2
#define YYMAXUTOK   331

#define YYTRANSLATE(YYX)                                                \
  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)

/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, without out-of-bounds checking.  */
static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    86,     2,     2,     2,    84,    67,     2,
      94,    99,    82,    80,    47,    81,    92,    83,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    62,    96,
      73,    49,    72,    61,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    93,     2,   100,    66,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    97,    65,    98,    89,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    48,    50,    51,    52,    53,    54,    55,    56,
      57,    58,    59,    60,    63,    64,    68,    69,    70,    71,
      74,    75,    76,    77,    78,    79,    85,    87,    88,    90,
      91,    95
};

#if YYDEBUG
  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
static const yytype_uint16 yyrline[] =
{
       0,   121,   121,   122,   125,   128,   133,   134,   139,   140,
     141,   145,   146,   147,   148,   149,   150,   151,   152,   156,
     157,   158,   159,   160,   161,   165,   173,   184,   193,   194,
     195,   196,   199,   200,   203,   204,   210,   211,   215,   221,
     222,   275,   276,   280,   281,   282,   283,   287,   294,   301,
     311,   312,   316,   325,   337,   347,   351,   360,   361,   365,
     376,   396,   420,   421,   422,   428,   429,   432,   433,   437,
     447,   457,   461,   465,   469,   475,   476,   479,   484,   492,
     493,   494,   495,   496,   497,   498,   499,   500,   501,   502,
     503,   504,   507,   515,   518,   523,   524,   525,   526,   527,
     528,   529,   530,   533,   534,   535,   536,   537,   538,   539,
     540,   543,   544,   548,   549,   550,   554,   555,   556,   557,
     558,   559,   560,   561,   562,   563,   564,   565,   566,   567,
     568,   572,   576,   580,   584,   588,   589,   593,   597,   598,
     599,   600,   601,   602,   603,   604,   605,   606,   607,   608,
     609,   610,   611,   612,   613,   614,   615,   616,   617,   618,
     619,   620,   621,   622,   623,   624,   626,   627,   630,   631,
     632,   638,   646,   651,   656,   661,   665,   669,   678,   684,
     689,   717,   723,   724,   725,   730,   737,   738,   742,   743,
     750,   751,   752,   753,   754,   755,   756,   757,   758,   762,
     766,   767,   768,   776,   777,   781,   782
};
#endif

#if YYDEBUG || YYERROR_VERBOSE || 1
/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "$end", "error", "$undefined", "STRING", "IDENTIFIER", "IF", "ELSE",
  "FOR", "IN", "WHILE", "DO", "CONTINUE", "SWITCH", "CASE", "DEFAULT",
  "BREAK", "FUNC", "RETURN", "LOCAL", "OF", "NEW", "DELETE", "TRY",
  "CATCH", "FINALLY", "THROW", "WITH", "UNDEF", "_TRUE", "_FALSE", "_THIS",
  "ARGUMENTS", "FNUMBER", "REGEXP", "TYPESTRING", "TYPENUMBER", "TYPENULL",
  "TYPEOBJECT", "TYPEBOOLEAN", "TYPEUSEROBJ", "TYPEITEROBJ", "TYPEREGEXP",
  "TYPEANY", "TYPEARRAY", "ELLIPSIS", "__DEBUG", "MIN_PRI", "','",
  "ARGCOMMA", "'='", "ADDAS", "MNSAS", "MULAS", "MODAS", "LSHFAS",
  "RSHFAS", "URSHFAS", "BANDAS", "BORAS", "BXORAS", "DIVAS", "'?'", "':'",
  "OR", "AND", "'|'", "'^'", "'&'", "EQU", "NEQ", "EEQU", "NNEQ", "'>'",
  "'<'", "LEQ", "GEQ", "INSTANCEOF", "LSHF", "RSHF", "URSHF", "'+'", "'-'",
  "'*'", "'/'", "'%'", "NEG", "'!'", "INC", "DEC", "'~'", "TYPEOF", "VOID",
  "'.'", "'['", "'('", "MAX_PRI", "';'", "'{'", "'}'", "')'", "']'",
  "$accept", "file", "statements", "statement", "commonstatement",
  "func_statement", "func_prefix", "iterstatement", "identifier_opt",
  "label_opt", "statement_or_empty", "with_statement", "switch_statement",
  "cases", "case", "try_statement", "vardecs", "vardec",
  "delete_statement", "if_statement", "inof", "for_statement", "for_init",
  "for_cond", "expr_opt", "while_statement", "do_statement", "func_expr",
  "args_opt", "typeid", "rettype", "argtype", "argdefault", "args",
  "func_statement_block", "expr", "fcall_exprs", "lvalue", "exprlist_opt",
  "exprlist", "value", "object", "items", "item", "array", YY_NULLPTR
};
#endif

# ifdef YYPRINT
/* YYTOKNUM[NUM] -- (External) token number corresponding to the
   (internal) symbol number NUM (which must be that of a token).  */
static const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
     295,   296,   297,   298,   299,   300,   301,    44,   302,    61,
     303,   304,   305,   306,   307,   308,   309,   310,   311,   312,
     313,    63,    58,   314,   315,   124,    94,    38,   316,   317,
     318,   319,    62,    60,   320,   321,   322,   323,   324,   325,
      43,    45,    42,    47,    37,   326,    33,   327,   328,   126,
     329,   330,    46,    91,    40,   331,    59,   123,   125,    41,
      93
};
# endif

#define YYPACT_NINF -295

#define yypact_value_is_default(Yystate) \
  (!!((Yystate) == (-295)))

#define YYTABLE_NINF -201

#define yytable_value_is_error(Yytable_value) \
  0

  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
     STATE-NUM.  */
static const yytype_int16 yypact[] =
{
     214,  -295,   -47,   -72,    50,    50,     4,  1248,    56,  1346,
     166,   -67,  1267,   -69,  -295,  -295,  -295,  -295,  -295,  -295,
    -295,  -295,  -295,  1267,  1267,  1267,   166,   166,  1267,  1267,
    1267,   432,  1267,  -295,   735,    79,   353,  -295,  -295,  -295,
       8,  -295,   248,  -295,  -295,  -295,  -295,  -295,  -295,  -295,
    -295,    16,  1788,  -295,   884,  -295,  -295,  -295,  1097,  1267,
    -295,     7,    12,  -295,     1,  -295,     5,  -295,    65,  1826,
      36,   -35,  -295,  1267,    18,    -3,    27,   110,   868,    59,
    1866,  1267,    21,    21,    21,    26,    26,    21,    21,    21,
    -295,   338,   -37,  1428,    58,   102,   964,  1788,   -31,  -295,
    -295,  -295,  1788,     1,    71,    77,  1134,    78,  1267,  1267,
    1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,
    1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,
    1267,  1267,  1267,   169,  1267,  -295,  1267,  1267,  1267,  1267,
    1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  1267,  -295,
    -295,   174,  1267,  1267,  -295,  1468,  -295,  -295,     1,   -22,
      88,    84,   137,    95,    58,   129,  -295,  1267,    56,  -295,
    1508,  1267,  1267,  1267,  -295,  -295,  1001,   106,   -67,  -295,
    1548,  1267,  -295,   107,  1267,  1097,  -295,    65,  -295,   108,
    1229,  1267,   831,  -295,   199,  1267,   111,   173,   205,   338,
    1982,  2137,  2168,  2205,  2236,  2262,   240,   240,   240,   240,
     185,   185,   185,   185,   246,   246,   246,    23,    23,    21,
      21,    21,   122,  1322,   338,   338,   338,   338,   338,   338,
     338,   338,   338,   338,   338,   338,   185,  -295,  1390,   123,
    1134,   127,    20,  2322,   135,   -27,     2,  1267,   338,  -295,
     134,   139,   150,   152,  -295,   217,  -295,  1134,   338,  1267,
     338,  1944,  -295,   -11,   249,  -295,  1267,  1904,   751,  1588,
    -295,   158,  1628,  -295,  1267,  1267,   162,  -295,  -295,   264,
      -9,  -295,  -295,  -295,  -295,  -295,  -295,   239,  -295,  -295,
    -295,  -295,  -295,  -295,  -295,  -295,  -295,  -295,  -295,  -295,
    -295,  -295,  -295,  -295,     6,  -295,  2322,  -295,    10,   180,
     338,  1267,  -295,  -295,  -295,   175,  -295,   176,  2322,  -295,
       9,   -34,   183,  2060,  -295,  -295,  -295,  1267,  1134,  1267,
     179,  2100,   182,  1267,  1134,  2322,  -295,  -295,    20,  2322,
     -67,   218,    20,  2322,   190,   186,   -67,  -295,   -67,  1267,
    -295,  1267,  1668,  -295,  1708,    19,  -295,   187,  -295,   -67,
    -295,  -295,  -295,  -295,    35,  -295,  -295,   260,  -295,  1748,
     188,  2060,  1134,  -295,  1267,   228,  -295,    51,  -295,  -295,
    -295,    20,   -67,  1134,  1134,  -295,  2022,   469,  -295,  -295,
    -295,  -295,  -295,  -295,   565,   602,   698
};

  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
     Performed when YYTABLE does not specify something else to do.  Zero
     means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
      34,   190,   181,     0,    32,    32,     0,     0,     0,     0,
       0,     0,     0,     0,   192,   193,   194,   183,   182,   195,
     196,   191,   176,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    22,    34,     0,    34,     6,     9,    24,
       0,     8,     0,    21,    31,    20,    13,    12,    28,    29,
      30,   114,     5,   165,   115,   113,   197,   198,    35,     0,
      33,     0,     0,    27,    75,   181,     0,    17,   200,     0,
      52,     0,    50,     0,   169,   167,   166,     0,    34,     0,
       0,     0,   120,   119,   122,   132,   134,   121,   133,   123,
     206,   188,     0,     0,   190,   181,    34,     0,     0,   201,
       1,     7,     4,    75,     0,     0,    34,     0,   186,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    11,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   130,
     131,     0,     0,   186,    10,     0,    15,    14,    75,   103,
       0,     0,    76,     0,     0,     0,    16,     0,     0,    18,
       0,   186,   186,   186,    54,   112,    34,     0,     0,    19,
       0,     0,   205,   135,     0,    35,    23,     0,   199,     0,
       0,     0,    34,    36,     0,     0,     0,   187,   129,   116,
       0,   137,   136,   147,   148,   146,   142,   143,   144,   145,
     139,   138,   140,   141,   149,   150,   151,   127,   128,   124,
     125,   126,   118,     0,   152,   153,   154,   155,   156,   157,
     158,   159,   160,   161,   162,   163,   164,   185,     0,     0,
      34,     0,     0,     0,     0,     0,     0,     0,    53,    51,
     168,     0,     0,     0,   111,     0,    48,    34,   189,   186,
     204,   203,   202,     0,     0,    62,    65,     0,   115,     0,
      37,     0,     0,   174,     0,   186,   117,   184,   180,    55,
       0,   102,    95,    99,   100,    98,   101,     0,    96,   104,
      89,    90,    79,    80,    88,    83,    81,    84,    85,    82,
      86,    87,    91,    93,   105,    77,     0,    71,   107,     0,
     203,   186,   173,   171,   170,     0,    38,     0,     0,    26,
      52,     0,     0,    66,    63,    57,    58,     0,    34,     0,
       0,   175,     0,   186,    34,     0,    73,    97,     0,     0,
       0,    92,     0,     0,     0,     0,     0,   179,     0,     0,
      64,    67,     0,    69,     0,     0,   177,     0,    56,     0,
     106,    94,    72,   108,   109,    78,   172,    47,    25,     0,
       0,    68,    34,    70,     0,     0,    39,     0,    41,   178,
      74,     0,     0,    34,    34,    61,     0,    34,    40,    42,
     110,    49,    60,    59,    34,    34,    34
};

  /* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -295,  -295,     3,     0,   -38,  -295,  -295,  -295,   286,  -295,
    -160,  -295,  -295,  -295,   -85,  -295,    29,   128,  -295,  -295,
     -23,  -295,  -295,  -295,  -295,  -295,  -295,   289,   -92,   -40,
    -294,  -239,  -148,  -295,  -171,    14,  -295,    -8,   -96,   275,
     300,  -295,  -295,   144,  -295
};

  /* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
      -1,    35,    96,   193,    38,    39,    40,    41,    61,    42,
     194,    43,    44,   377,   378,    45,    71,    72,    46,    47,
     327,    48,   266,   322,   370,    49,    50,    51,   161,   303,
     340,   341,   289,   162,    79,    97,    53,    54,   196,   197,
      55,    56,    98,    99,    57
};

  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
     positive, shift that token.  If negative, reduce the rule whose
     number is the opposite.  If YYTABLE_NINF, syntax error.  */
static const yytype_int16 yytable[] =
{
      37,    75,    77,    36,   304,   159,   308,   256,    63,   163,
     181,   189,   168,   168,    52,    58,   187,   325,    85,    86,
     154,    69,    59,   281,   348,    81,    80,   242,   326,   109,
      78,   109,   374,   375,    37,   306,   101,    82,    83,    84,
     243,   359,    87,    88,    89,    91,    93,   282,   283,   284,
     102,   318,   285,   335,    60,   338,   286,   239,   167,   342,
      70,   169,   350,   182,   374,   375,   241,   188,   164,   165,
      78,   339,   343,   155,   307,   251,   252,   253,    37,   100,
     279,   176,   177,   178,   381,   167,    78,   170,    78,   151,
     152,   172,   319,   160,   309,   180,   101,   316,    64,    64,
     339,   287,   103,   156,   364,   130,   131,   132,   157,   336,
     108,   288,   171,   133,   134,   133,   134,   376,   151,   152,
     184,   173,    91,   198,   199,   200,   201,   202,   203,   204,
     205,   206,   207,   208,   209,   210,   211,   212,   213,   214,
     215,   216,   217,   218,   219,   220,   221,   154,   223,   388,
     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,
     234,   235,   236,   317,   185,   190,   238,    91,   353,   362,
      65,   191,   195,   222,   358,   367,   101,   368,   237,   332,
     244,   248,   268,   245,   246,    91,    91,    91,   380,   158,
     360,   247,    37,   109,   363,   258,    17,    18,   260,   261,
     255,   259,   151,   152,   267,   269,   174,   263,   271,   272,
     273,   391,   385,   109,    -2,   345,   275,     1,     2,     3,
     181,   315,   278,   392,   393,     4,   280,   305,   311,     5,
       6,     7,     8,   390,     9,    10,    11,   357,   312,    12,
      13,    14,    15,    16,    17,    18,    19,    20,   109,   313,
      21,   314,   329,   320,   109,   104,   333,   105,   106,    22,
     107,   310,   125,   126,   127,   128,   129,   130,   131,   132,
     334,   337,   344,    91,   346,   347,   355,   133,   134,   351,
     323,   356,   365,   339,   382,   366,   379,   384,   331,    91,
     387,    62,   389,   321,    23,    24,   249,   349,    74,   361,
      25,    26,    27,    28,    29,    30,    92,    31,    32,    76,
      33,    34,   121,   122,   123,   124,     0,   125,   126,   127,
     128,   129,   130,   131,   132,    91,   128,   129,   130,   131,
     132,   262,   133,   134,     0,     0,     0,     0,   133,   134,
       0,   352,     0,   354,     0,     0,   109,    91,     0,     0,
       0,     0,     0,    -3,     0,     0,     1,     2,     3,     0,
       0,     0,     0,   369,     4,   371,     0,     0,     5,     6,
       7,     8,     0,     9,    10,    11,     0,     0,    12,    13,
      14,    15,    16,    17,    18,    19,    20,    37,   386,    21,
     395,     0,     0,     0,    37,   101,   101,   396,    22,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,     0,     0,     0,     0,     0,
     133,   134,     0,    23,    24,     1,    65,     0,     0,    25,
      26,    27,    28,    29,    30,     0,    31,    32,    66,    33,
      34,     0,     9,     0,     0,     0,     0,     0,     0,    14,
      15,    16,    17,    18,    19,    20,     0,     0,    21,     0,
       0,     0,     1,     2,     3,     0,     0,    22,     0,     0,
       4,     0,   -45,   -45,     5,     6,     7,     8,     0,     9,
      10,    11,     0,     0,    12,    13,    14,    15,    16,    17,
      18,    19,    20,     0,     0,    21,     0,     0,     0,     0,
       0,     0,    23,    24,    22,     0,     0,     0,    25,    26,
      27,    28,    29,    30,     0,    31,    32,     0,     0,    68,
       0,     0,    90,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    23,
      24,     0,     0,     0,     0,    25,    26,    27,    28,    29,
      30,     0,    31,    32,     0,    33,    34,   -45,     1,     2,
       3,     0,     0,     0,     0,     0,     4,     0,   -46,   -46,
       5,     6,     7,     8,     0,     9,    10,    11,     0,     0,
      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
       0,    21,     0,     0,     0,     1,     2,     3,     0,     0,
      22,     0,     0,     4,     0,   -44,   -44,     5,     6,     7,
       8,     0,     9,    10,    11,     0,     0,    12,    13,    14,
      15,    16,    17,    18,    19,    20,     0,     0,    21,     0,
       0,     0,     0,     0,     0,    23,    24,    22,     0,     0,
       0,    25,    26,    27,    28,    29,    30,     0,    31,    32,
       0,    33,    34,   -46,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    23,    24,     0,     0,     0,     0,    25,    26,
      27,    28,    29,    30,     0,    31,    32,     0,    33,    34,
     -44,     1,     2,     3,     0,     0,     0,     0,     0,     4,
       0,   -43,   -43,     5,     6,     7,     8,     0,     9,    10,
      11,     0,     0,    12,    13,    14,    15,    16,    17,    18,
      19,    20,     0,     0,    21,     0,     0,     0,    94,    95,
       3,     0,     0,    22,     0,     0,     4,     0,     0,     0,
       5,     6,     7,     8,     0,     9,    10,    11,     0,   325,
      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
     326,    21,     0,     0,     0,     0,     0,     0,    23,    24,
      22,     0,  -200,     0,    25,    26,    27,    28,    29,    30,
       0,    31,    32,     0,    33,    34,   -43,     0,     0,     0,
     136,   137,   138,   139,   140,   141,   142,   143,   144,   145,
     146,   147,     0,     0,     0,    23,    24,     0,     0,     0,
       0,    25,    26,    27,    28,    29,    30,   148,    31,    32,
       0,    33,    34,  -200,    94,    95,     3,     0,   149,   150,
       0,     0,     4,   151,   152,   153,     5,     6,     7,     8,
       0,     9,    10,    11,     0,     0,    12,    13,    14,    15,
      16,    17,    18,    19,    20,     0,     0,    21,     0,     0,
       0,     1,     2,     3,     0,     0,    22,     0,  -200,     4,
       0,     0,     0,     5,     6,     7,     8,     0,     9,    10,
      11,     0,     0,    12,    13,    14,    15,    16,    17,    18,
      19,    20,     0,     0,    21,     0,     0,     0,     0,     0,
       0,    23,    24,    22,     0,     0,     0,    25,    26,    27,
      28,    29,    30,     0,    31,    32,     0,    33,    34,   270,
       0,     0,     0,   136,   137,   138,   139,   140,   141,   142,
     143,   144,   145,   146,   147,     0,     0,     0,    23,    24,
       0,     0,     0,     0,    25,    26,    27,    28,    29,    30,
     148,    31,    32,     0,    33,    34,   175,     1,     2,     3,
       0,   149,   150,     0,     0,     4,   151,   152,   153,     5,
       6,     7,     8,     0,     9,    10,    11,     0,     0,    12,
      13,    14,    15,    16,    17,    18,    19,    20,     0,     0,
      21,     0,     0,     0,     1,     2,     3,     0,     0,    22,
       0,     0,     4,     0,     0,     0,     5,     6,     7,     8,
       0,     9,    10,    11,     0,     0,    12,    13,    14,    15,
      16,    17,    18,    19,    20,     0,     0,    21,     0,     0,
       0,     0,     0,     0,    23,    24,    22,     0,     0,     0,
      25,    26,    27,    28,    29,    30,     0,    31,    32,     0,
      33,    34,   186,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    23,    24,     0,     0,     0,     0,    25,    26,    27,
      28,    29,    30,     0,    31,    32,     0,    33,    34,   254,
       1,    65,     3,     0,     0,     0,     0,     0,     4,     0,
       0,     0,     5,     6,     7,     8,     0,     9,    10,    11,
       0,     0,    12,    13,    14,    15,    16,    17,    18,    19,
      20,     0,     0,    21,     0,     0,     0,     1,     2,     3,
       0,     0,    22,     0,     0,     4,     0,     0,     0,     5,
       6,     7,     8,     0,     9,    10,    11,     0,     0,    12,
      13,    14,    15,    16,    17,    18,    19,    20,     0,     0,
      21,     0,     0,     0,     0,     0,     0,    23,    24,    22,
       0,     0,     0,    25,    26,    27,    28,    29,    30,     0,
      31,    32,     0,    33,    34,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    23,    24,     0,     0,     0,     0,
      25,    26,    27,    28,    29,    30,     0,    31,    32,     0,
      33,   192,     1,    65,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    66,     0,   264,     0,     9,
       0,     1,    65,     0,     0,     0,    14,    15,    16,    17,
      18,    19,    20,     0,    66,    21,     0,     0,     9,     0,
       1,    65,     0,     0,    22,    14,    15,    16,    17,    18,
      19,    20,     0,    66,    21,     0,     0,     9,     0,     0,
       0,     0,     0,    22,    14,    15,    16,    17,    18,    19,
      20,     0,     0,    21,     0,     0,     0,     0,     0,    23,
      24,     0,    22,     0,     0,    25,    26,    27,    28,    29,
      30,     0,    31,    32,     0,   265,    68,     0,    23,    24,
     109,     0,     0,     0,    25,    26,    27,    28,    29,    30,
       0,    31,    32,     0,    67,    68,     0,    23,    24,     1,
      65,     0,     0,    25,    26,    27,    28,    29,    30,     0,
      31,    32,    66,     0,    68,     0,     0,     0,     0,   110,
       0,     0,     0,    14,    15,    16,    17,    18,    19,    20,
       0,     0,    21,   111,     0,   112,   113,   114,   115,   116,
     117,   118,   119,   120,   121,   122,   123,   124,   109,   125,
     126,   127,   128,   129,   130,   131,   132,     0,     0,     0,
       0,     0,     0,     0,   133,   134,     0,     0,     0,     0,
       0,     0,   276,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   109,   110,     0,    31,
      73,     0,     0,    68,     0,     0,     0,     0,     0,     0,
       0,   111,     0,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   121,   122,   123,   124,     0,   125,   126,   127,
     128,   129,   130,   131,   132,   110,   109,     0,     0,     0,
       0,     0,   133,   134,     0,     0,     0,     0,     0,   111,
     277,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   183,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   240,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   250,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   257,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   328,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   330,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   372,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,   110,   109,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   373,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,     0,   109,   110,     0,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,   383,     0,   111,
       0,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,     0,   125,   126,   127,   128,   129,
     130,   131,   132,   110,   109,     0,     0,     0,     0,     0,
     133,   134,     0,     0,   135,     0,     0,   111,     0,   112,
     113,   114,   115,   116,   117,   118,   119,   120,   121,   122,
     123,   124,     0,   125,   126,   127,   128,   129,   130,   131,
     132,     0,   109,   110,     0,     0,     0,     0,   133,   134,
       0,     0,   166,     0,     0,     0,     0,   111,     0,   112,
     113,   114,   115,   116,   117,   118,   119,   120,   121,   122,
     123,   124,     0,   125,   126,   127,   128,   129,   130,   131,
     132,   110,   109,     0,     0,     0,     0,     0,   133,   134,
       0,     0,   179,     0,     0,   111,     0,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
       0,   125,   126,   127,   128,   129,   130,   131,   132,     0,
     109,     0,     0,     0,     0,     0,   133,   134,     0,     0,
     324,     0,     0,     0,     0,   111,     0,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
       0,   125,   126,   127,   128,   129,   130,   131,   132,   110,
     109,     0,     0,     0,     0,     0,   133,   134,     0,     0,
     135,     0,     0,   111,   274,   112,   113,   114,   115,   116,
     117,   118,   119,   120,   121,   122,   123,   124,     0,   125,
     126,   127,   128,   129,   130,   131,   132,     0,   109,   110,
       0,     0,     0,     0,   133,   134,     0,     0,     0,     0,
       0,     0,     0,   111,   394,   112,   113,   114,   115,   116,
     117,   118,   119,   120,   121,   122,   123,   124,     0,   125,
     126,   127,   128,   129,   130,   131,   132,   110,   109,     0,
       0,     0,     0,     0,   133,   134,     0,     0,     0,     0,
       0,   111,     0,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   121,   122,   123,   124,     0,   125,   126,   127,
     128,   129,   130,   131,   132,   109,     0,     0,     0,     0,
       0,     0,   133,   134,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   121,   122,   123,   124,   109,   125,   126,   127,
     128,   129,   130,   131,   132,     0,     0,     0,     0,     0,
       0,     0,   133,   134,     0,     0,     0,     0,     0,     0,
       0,   113,   114,   115,   116,   117,   118,   119,   120,   121,
     122,   123,   124,   109,   125,   126,   127,   128,   129,   130,
     131,   132,     0,     0,     0,     0,     0,     0,     0,   133,
     134,     0,     0,   114,   115,   116,   117,   118,   119,   120,
     121,   122,   123,   124,   109,   125,   126,   127,   128,   129,
     130,   131,   132,     0,     0,     0,     0,     0,     0,     0,
     133,   134,     0,     0,     0,     0,     0,     0,     0,     0,
     109,   115,   116,   117,   118,   119,   120,   121,   122,   123,
     124,     0,   125,   126,   127,   128,   129,   130,   131,   132,
       0,     0,     0,     0,     0,     0,     0,   133,   134,     0,
       0,     0,     0,   116,   117,   118,   119,   120,   121,   122,
     123,   124,     0,   125,   126,   127,   128,   129,   130,   131,
     132,     0,     0,     0,     0,     0,     0,     0,   133,   134,
     117,   118,   119,   120,   121,   122,   123,   124,   290,   125,
     126,   127,   128,   129,   130,   131,   132,     0,     0,   291,
       0,     0,     0,     0,   133,   134,   292,   293,   294,   295,
     296,   297,   298,   299,   300,   301,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   302
};

static const yytype_int16 yycheck[] =
{
       0,     9,    10,     0,   243,     4,     4,   178,     4,     4,
      47,   103,    47,    47,     0,    62,    47,     8,    26,    27,
      58,     7,    94,     3,   318,    94,    12,    49,    19,     8,
      97,     8,    13,    14,    34,    62,    36,    23,    24,    25,
      62,   335,    28,    29,    30,    31,    32,    27,    28,    29,
      36,    62,    32,    62,     4,    49,    36,   153,    49,    49,
       4,    96,    96,   100,    13,    14,   158,    98,     3,     4,
      97,    65,    62,    59,   245,   171,   172,   173,    78,     0,
     240,    78,    23,    24,    49,    49,    97,    73,    97,    92,
      93,    94,   263,    92,    92,    81,    96,   257,    94,    94,
      65,    81,    94,    96,   343,    82,    83,    84,    96,   280,
      94,    91,    94,    92,    93,    92,    93,    98,    92,    93,
      62,    94,   108,   109,   110,   111,   112,   113,   114,   115,
     116,   117,   118,   119,   120,   121,   122,   123,   124,   125,
     126,   127,   128,   129,   130,   131,   132,   185,   134,    98,
     136,   137,   138,   139,   140,   141,   142,   143,   144,   145,
     146,   147,   148,   259,    62,    94,   152,   153,   328,   340,
       4,    94,    94,     4,   334,   346,   176,   348,     4,   275,
      92,   167,   190,    99,    47,   171,   172,   173,   359,    94,
     338,    62,   192,     8,   342,   181,    30,    31,   184,   185,
      94,    94,    92,    93,   190,   191,    96,    99,     9,   195,
      99,   382,   372,     8,     0,   311,    94,     3,     4,     5,
      47,     4,    99,   383,   384,    11,    99,    92,    94,    15,
      16,    17,    18,   381,    20,    21,    22,   333,    99,    25,
      26,    27,    28,    29,    30,    31,    32,    33,     8,    99,
      36,    99,    94,     4,     8,     7,    94,     9,    10,    45,
      12,   247,    77,    78,    79,    80,    81,    82,    83,    84,
       6,    32,    92,   259,    99,    99,    97,    92,    93,    96,
     266,    99,    92,    65,    24,    99,    99,    99,   274,   275,
      62,     5,   377,   264,    80,    81,   168,   320,     9,   339,
      86,    87,    88,    89,    90,    91,    31,    93,    94,     9,
      96,    97,    72,    73,    74,    75,    -1,    77,    78,    79,
      80,    81,    82,    83,    84,   311,    80,    81,    82,    83,
      84,   187,    92,    93,    -1,    -1,    -1,    -1,    92,    93,
      -1,   327,    -1,   329,    -1,    -1,     8,   333,    -1,    -1,
      -1,    -1,    -1,     0,    -1,    -1,     3,     4,     5,    -1,
      -1,    -1,    -1,   349,    11,   351,    -1,    -1,    15,    16,
      17,    18,    -1,    20,    21,    22,    -1,    -1,    25,    26,
      27,    28,    29,    30,    31,    32,    33,   387,   374,    36,
     387,    -1,    -1,    -1,   394,   395,   396,   394,    45,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      92,    93,    -1,    80,    81,     3,     4,    -1,    -1,    86,
      87,    88,    89,    90,    91,    -1,    93,    94,    16,    96,
      97,    -1,    20,    -1,    -1,    -1,    -1,    -1,    -1,    27,
      28,    29,    30,    31,    32,    33,    -1,    -1,    36,    -1,
      -1,    -1,     3,     4,     5,    -1,    -1,    45,    -1,    -1,
      11,    -1,    13,    14,    15,    16,    17,    18,    -1,    20,
      21,    22,    -1,    -1,    25,    26,    27,    28,    29,    30,
      31,    32,    33,    -1,    -1,    36,    -1,    -1,    -1,    -1,
      -1,    -1,    80,    81,    45,    -1,    -1,    -1,    86,    87,
      88,    89,    90,    91,    -1,    93,    94,    -1,    -1,    97,
      -1,    -1,   100,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    80,
      81,    -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,
      91,    -1,    93,    94,    -1,    96,    97,    98,     3,     4,
       5,    -1,    -1,    -1,    -1,    -1,    11,    -1,    13,    14,
      15,    16,    17,    18,    -1,    20,    21,    22,    -1,    -1,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
      -1,    36,    -1,    -1,    -1,     3,     4,     5,    -1,    -1,
      45,    -1,    -1,    11,    -1,    13,    14,    15,    16,    17,
      18,    -1,    20,    21,    22,    -1,    -1,    25,    26,    27,
      28,    29,    30,    31,    32,    33,    -1,    -1,    36,    -1,
      -1,    -1,    -1,    -1,    -1,    80,    81,    45,    -1,    -1,
      -1,    86,    87,    88,    89,    90,    91,    -1,    93,    94,
      -1,    96,    97,    98,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    80,    81,    -1,    -1,    -1,    -1,    86,    87,
      88,    89,    90,    91,    -1,    93,    94,    -1,    96,    97,
      98,     3,     4,     5,    -1,    -1,    -1,    -1,    -1,    11,
      -1,    13,    14,    15,    16,    17,    18,    -1,    20,    21,
      22,    -1,    -1,    25,    26,    27,    28,    29,    30,    31,
      32,    33,    -1,    -1,    36,    -1,    -1,    -1,     3,     4,
       5,    -1,    -1,    45,    -1,    -1,    11,    -1,    -1,    -1,
      15,    16,    17,    18,    -1,    20,    21,    22,    -1,     8,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
      19,    36,    -1,    -1,    -1,    -1,    -1,    -1,    80,    81,
      45,    -1,    47,    -1,    86,    87,    88,    89,    90,    91,
      -1,    93,    94,    -1,    96,    97,    98,    -1,    -1,    -1,
      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
      59,    60,    -1,    -1,    -1,    80,    81,    -1,    -1,    -1,
      -1,    86,    87,    88,    89,    90,    91,    76,    93,    94,
      -1,    96,    97,    98,     3,     4,     5,    -1,    87,    88,
      -1,    -1,    11,    92,    93,    94,    15,    16,    17,    18,
      -1,    20,    21,    22,    -1,    -1,    25,    26,    27,    28,
      29,    30,    31,    32,    33,    -1,    -1,    36,    -1,    -1,
      -1,     3,     4,     5,    -1,    -1,    45,    -1,    47,    11,
      -1,    -1,    -1,    15,    16,    17,    18,    -1,    20,    21,
      22,    -1,    -1,    25,    26,    27,    28,    29,    30,    31,
      32,    33,    -1,    -1,    36,    -1,    -1,    -1,    -1,    -1,
      -1,    80,    81,    45,    -1,    -1,    -1,    86,    87,    88,
      89,    90,    91,    -1,    93,    94,    -1,    96,    97,    98,
      -1,    -1,    -1,    49,    50,    51,    52,    53,    54,    55,
      56,    57,    58,    59,    60,    -1,    -1,    -1,    80,    81,
      -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
      76,    93,    94,    -1,    96,    97,    98,     3,     4,     5,
      -1,    87,    88,    -1,    -1,    11,    92,    93,    94,    15,
      16,    17,    18,    -1,    20,    21,    22,    -1,    -1,    25,
      26,    27,    28,    29,    30,    31,    32,    33,    -1,    -1,
      36,    -1,    -1,    -1,     3,     4,     5,    -1,    -1,    45,
      -1,    -1,    11,    -1,    -1,    -1,    15,    16,    17,    18,
      -1,    20,    21,    22,    -1,    -1,    25,    26,    27,    28,
      29,    30,    31,    32,    33,    -1,    -1,    36,    -1,    -1,
      -1,    -1,    -1,    -1,    80,    81,    45,    -1,    -1,    -1,
      86,    87,    88,    89,    90,    91,    -1,    93,    94,    -1,
      96,    97,    98,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    80,    81,    -1,    -1,    -1,    -1,    86,    87,    88,
      89,    90,    91,    -1,    93,    94,    -1,    96,    97,    98,
       3,     4,     5,    -1,    -1,    -1,    -1,    -1,    11,    -1,
      -1,    -1,    15,    16,    17,    18,    -1,    20,    21,    22,
      -1,    -1,    25,    26,    27,    28,    29,    30,    31,    32,
      33,    -1,    -1,    36,    -1,    -1,    -1,     3,     4,     5,
      -1,    -1,    45,    -1,    -1,    11,    -1,    -1,    -1,    15,
      16,    17,    18,    -1,    20,    21,    22,    -1,    -1,    25,
      26,    27,    28,    29,    30,    31,    32,    33,    -1,    -1,
      36,    -1,    -1,    -1,    -1,    -1,    -1,    80,    81,    45,
      -1,    -1,    -1,    86,    87,    88,    89,    90,    91,    -1,
      93,    94,    -1,    96,    97,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    80,    81,    -1,    -1,    -1,    -1,
      86,    87,    88,    89,    90,    91,    -1,    93,    94,    -1,
      96,    97,     3,     4,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    16,    -1,    18,    -1,    20,
      -1,     3,     4,    -1,    -1,    -1,    27,    28,    29,    30,
      31,    32,    33,    -1,    16,    36,    -1,    -1,    20,    -1,
       3,     4,    -1,    -1,    45,    27,    28,    29,    30,    31,
      32,    33,    -1,    16,    36,    -1,    -1,    20,    -1,    -1,
      -1,    -1,    -1,    45,    27,    28,    29,    30,    31,    32,
      33,    -1,    -1,    36,    -1,    -1,    -1,    -1,    -1,    80,
      81,    -1,    45,    -1,    -1,    86,    87,    88,    89,    90,
      91,    -1,    93,    94,    -1,    96,    97,    -1,    80,    81,
       8,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
      -1,    93,    94,    -1,    96,    97,    -1,    80,    81,     3,
       4,    -1,    -1,    86,    87,    88,    89,    90,    91,    -1,
      93,    94,    16,    -1,    97,    -1,    -1,    -1,    -1,    47,
      -1,    -1,    -1,    27,    28,    29,    30,    31,    32,    33,
      -1,    -1,    36,    61,    -1,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    72,    73,    74,    75,     8,    77,
      78,    79,    80,    81,    82,    83,    84,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    92,    93,    -1,    -1,    -1,    -1,
      -1,    -1,   100,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,     8,    47,    -1,    93,
      94,    -1,    -1,    97,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    61,    -1,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    72,    73,    74,    75,    -1,    77,    78,    79,
      80,    81,    82,    83,    84,    47,     8,    -1,    -1,    -1,
      -1,    -1,    92,    93,    -1,    -1,    -1,    -1,    -1,    61,
     100,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    47,     8,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,     8,    47,    -1,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    99,    -1,    61,
      -1,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,    -1,    77,    78,    79,    80,    81,
      82,    83,    84,    47,     8,    -1,    -1,    -1,    -1,    -1,
      92,    93,    -1,    -1,    96,    -1,    -1,    61,    -1,    63,
      64,    65,    66,    67,    68,    69,    70,    71,    72,    73,
      74,    75,    -1,    77,    78,    79,    80,    81,    82,    83,
      84,    -1,     8,    47,    -1,    -1,    -1,    -1,    92,    93,
      -1,    -1,    96,    -1,    -1,    -1,    -1,    61,    -1,    63,
      64,    65,    66,    67,    68,    69,    70,    71,    72,    73,
      74,    75,    -1,    77,    78,    79,    80,    81,    82,    83,
      84,    47,     8,    -1,    -1,    -1,    -1,    -1,    92,    93,
      -1,    -1,    96,    -1,    -1,    61,    -1,    63,    64,    65,
      66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
      -1,    77,    78,    79,    80,    81,    82,    83,    84,    -1,
       8,    -1,    -1,    -1,    -1,    -1,    92,    93,    -1,    -1,
      96,    -1,    -1,    -1,    -1,    61,    -1,    63,    64,    65,
      66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
      -1,    77,    78,    79,    80,    81,    82,    83,    84,    47,
       8,    -1,    -1,    -1,    -1,    -1,    92,    93,    -1,    -1,
      96,    -1,    -1,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    72,    73,    74,    75,    -1,    77,
      78,    79,    80,    81,    82,    83,    84,    -1,     8,    47,
      -1,    -1,    -1,    -1,    92,    93,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    72,    73,    74,    75,    -1,    77,
      78,    79,    80,    81,    82,    83,    84,    47,     8,    -1,
      -1,    -1,    -1,    -1,    92,    93,    -1,    -1,    -1,    -1,
      -1,    61,    -1,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    72,    73,    74,    75,    -1,    77,    78,    79,
      80,    81,    82,    83,    84,     8,    -1,    -1,    -1,    -1,
      -1,    -1,    92,    93,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    72,    73,    74,    75,     8,    77,    78,    79,
      80,    81,    82,    83,    84,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    92,    93,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    64,    65,    66,    67,    68,    69,    70,    71,    72,
      73,    74,    75,     8,    77,    78,    79,    80,    81,    82,
      83,    84,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    92,
      93,    -1,    -1,    65,    66,    67,    68,    69,    70,    71,
      72,    73,    74,    75,     8,    77,    78,    79,    80,    81,
      82,    83,    84,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      92,    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
       8,    66,    67,    68,    69,    70,    71,    72,    73,    74,
      75,    -1,    77,    78,    79,    80,    81,    82,    83,    84,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    92,    93,    -1,
      -1,    -1,    -1,    67,    68,    69,    70,    71,    72,    73,
      74,    75,    -1,    77,    78,    79,    80,    81,    82,    83,
      84,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    92,    93,
      68,    69,    70,    71,    72,    73,    74,    75,    16,    77,
      78,    79,    80,    81,    82,    83,    84,    -1,    -1,    27,
      -1,    -1,    -1,    -1,    92,    93,    34,    35,    36,    37,
      38,    39,    40,    41,    42,    43,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    91
};

  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
     symbol of state STATE-NUM.  */
static const yytype_uint8 yystos[] =
{
       0,     3,     4,     5,    11,    15,    16,    17,    18,    20,
      21,    22,    25,    26,    27,    28,    29,    30,    31,    32,
      33,    36,    45,    80,    81,    86,    87,    88,    89,    90,
      91,    93,    94,    96,    97,   102,   103,   104,   105,   106,
     107,   108,   110,   112,   113,   116,   119,   120,   122,   126,
     127,   128,   136,   137,   138,   141,   142,   145,    62,    94,
       4,   109,   109,     4,    94,     4,    16,    96,    97,   136,
       4,   117,   118,    94,   128,   138,   141,   138,    97,   135,
     136,    94,   136,   136,   136,   138,   138,   136,   136,   136,
     100,   136,   140,   136,     3,     4,   103,   136,   143,   144,
       0,   104,   136,    94,     7,     9,    10,    12,    94,     8,
      47,    61,    63,    64,    65,    66,    67,    68,    69,    70,
      71,    72,    73,    74,    75,    77,    78,    79,    80,    81,
      82,    83,    84,    92,    93,    96,    49,    50,    51,    52,
      53,    54,    55,    56,    57,    58,    59,    60,    76,    87,
      88,    92,    93,    94,   105,   136,    96,    96,    94,     4,
      92,   129,   134,     4,     3,     4,    96,    49,    47,    96,
     136,    94,    94,    94,    96,    98,   103,    23,    24,    96,
     136,    47,   100,    99,    62,    62,    98,    47,    98,   129,
      94,    94,    97,   104,   111,    94,   139,   140,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,     4,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,     4,   136,   139,
      99,   129,    49,    62,    92,    99,    47,    62,   136,   118,
      99,   139,   139,   139,    98,    94,   135,    99,   136,    94,
     136,   136,   144,    99,    18,    96,   123,   136,   138,   136,
      98,     9,   136,    99,    62,    94,   100,   100,    99,   111,
      99,     3,    27,    28,    29,    32,    36,    81,    91,   133,
      16,    27,    34,    35,    36,    37,    38,    39,    40,    41,
      42,    43,    91,   130,   132,    92,    62,   135,     4,    92,
     136,    94,    99,    99,    99,     4,   111,   139,    62,   135,
       4,   117,   124,   136,    96,     8,    19,   121,    99,    94,
      99,   136,   139,    94,     6,    62,   135,    32,    49,    65,
     131,   132,    49,    62,    92,   139,    99,    99,   131,   121,
      96,    96,   136,   111,   136,    97,    99,   139,   111,   131,
     133,   130,   135,   133,   132,    92,    99,   135,   135,   136,
     125,   136,    99,    99,    13,    14,    98,   114,   115,    99,
     135,    49,    24,    99,    99,   111,   136,    62,    98,   115,
     133,   135,   111,   111,    62,   103,   103
};

  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
static const yytype_uint8 yyr1[] =
{
       0,   101,   102,   102,   102,   102,   103,   103,   104,   104,
     104,   105,   105,   105,   105,   105,   105,   105,   105,   105,
     105,   105,   105,   105,   105,   106,   106,   107,   108,   108,
     108,   108,   109,   109,   110,   110,   111,   111,   112,   113,
     113,   114,   114,   115,   115,   115,   115,   116,   116,   116,
     117,   117,   118,   118,   119,   120,   120,   121,   121,   122,
     122,   122,   123,   123,   123,   124,   124,   125,   125,   126,
     127,   128,   128,   128,   128,   129,   129,   129,   129,   130,
     130,   130,   130,   130,   130,   130,   130,   130,   130,   130,
     130,   130,   131,   132,   132,   133,   133,   133,   133,   133,
     133,   133,   133,   134,   134,   134,   134,   134,   134,   134,
     134,   135,   135,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
     136,   136,   136,   136,   136,   136,   136,   137,   137,   137,
     137,   138,   138,   138,   138,   138,   139,   139,   140,   140,
     141,   141,   141,   141,   141,   141,   141,   141,   141,   142,
     143,   143,   143,   144,   144,   145,   145
};

  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
static const yytype_uint8 yyr2[] =
{
       0,     2,     0,     1,     2,     1,     1,     2,     1,     1,
       3,     2,     1,     1,     3,     3,     3,     2,     3,     3,
       1,     1,     1,     3,     1,     7,     5,     2,     1,     1,
       1,     1,     0,     1,     0,     2,     1,     2,     5,     7,
       8,     1,     2,     4,     3,     2,     3,     7,     4,     9,
       1,     3,     1,     3,     3,     5,     7,     1,     1,     9,
       9,     8,     1,     2,     3,     0,     1,     0,     1,     6,
       7,     5,     7,     6,     8,     0,     1,     3,     5,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     3,     1,     1,     2,     1,     1,
       1,     1,     1,     1,     3,     3,     5,     3,     5,     5,
       7,     3,     2,     1,     1,     1,     3,     4,     3,     2,
       2,     2,     2,     2,     3,     3,     3,     3,     3,     3,
       2,     2,     2,     2,     2,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     1,     2,     2,     4,     2,
       5,     5,     7,     5,     4,     5,     1,     6,     7,     6,
       4,     1,     1,     1,     4,     3,     0,     1,     1,     3,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     3,
       0,     1,     3,     3,     3,     3,     2
};


#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)
#define YYEMPTY         (-2)
#define YYEOF           0

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab


#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                  \
do                                                              \
  if (yychar == YYEMPTY)                                        \
    {                                                           \
      yychar = (Token);                                         \
      yylval = (Value);                                         \
      YYPOPSTACK (yylen);                                       \
      yystate = *yyssp;                                         \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    {                                                           \
      yyerror (&yylloc, pstate, YY_("syntax error: cannot back up")); \
      YYERROR;                                                  \
    }                                                           \
while (0)

/* Error token number */
#define YYTERROR        1
#define YYERRCODE       256


/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

#ifndef YYLLOC_DEFAULT
# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
    do                                                                  \
      if (N)                                                            \
        {                                                               \
          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).first_line   = (Current).last_line   =              \
            YYRHSLOC (Rhs, 0).last_line;                                \
          (Current).first_column = (Current).last_column =              \
            YYRHSLOC (Rhs, 0).last_column;                              \
        }                                                               \
    while (0)
#endif

#define YYRHSLOC(Rhs, K) ((Rhs)[K])


/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)


/* YY_LOCATION_PRINT -- Print the location on the stream.
   This macro was not mandated originally: define only if we know
   we won't break user code: when these are the locations we know.  */

#ifndef YY_LOCATION_PRINT
# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL

/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */

YY_ATTRIBUTE_UNUSED
static unsigned
yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
{
  unsigned res = 0;
  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
  if (0 <= yylocp->first_line)
    {
      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
      if (0 <= yylocp->first_column)
        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
    }
  if (0 <= yylocp->last_line)
    {
      if (yylocp->first_line < yylocp->last_line)
        {
          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
          if (0 <= end_col)
            res += YYFPRINTF (yyo, ".%d", end_col);
        }
      else if (0 <= end_col && yylocp->first_column < end_col)
        res += YYFPRINTF (yyo, "-%d", end_col);
    }
  return res;
 }

#  define YY_LOCATION_PRINT(File, Loc)          \
  yy_location_print_ (File, &(Loc))

# else
#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
# endif
#endif


# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Type, Value, Location, pstate); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)


/*----------------------------------------.
| Print this symbol's value on YYOUTPUT.  |
`----------------------------------------*/

static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, struct jsi_Pstate *pstate)
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  YYUSE (yylocationp);
  YYUSE (pstate);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# endif
  YYUSE (yytype);
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, struct jsi_Pstate *pstate)
{
  YYFPRINTF (yyoutput, "%s %s (",
             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);

  YY_LOCATION_PRINT (yyoutput, *yylocationp);
  YYFPRINTF (yyoutput, ": ");
  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp, pstate);
  YYFPRINTF (yyoutput, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, struct jsi_Pstate *pstate)
{
  unsigned long int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr,
                       yystos[yyssp[yyi + 1 - yynrhs]],
                       &(yyvsp[(yyi + 1) - (yynrhs)])
                       , &(yylsp[(yyi + 1) - (yynrhs)])                       , pstate);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, pstate); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
static YYSIZE_T
yystrlen (const char *yystr)
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
yystpcpy (char *yydest, const char *yysrc)
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
#  endif
# endif

# ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
        switch (*++yyp)
          {
          case '\'':
          case ',':
            goto do_not_strip_quotes;

          case '\\':
            if (*++yyp != '\\')
              goto do_not_strip_quotes;
            /* Fall through.  */
          default:
            if (yyres)
              yyres[yyn] = *yyp;
            yyn++;
            break;

          case '"':
            if (yyres)
              yyres[yyn] = '\0';
            return yyn;
          }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
# endif

/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
   required number of bytes is too large to store.  */
static int
yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                yytype_int16 *yyssp, int yytoken)
{
  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
  YYSIZE_T yysize = yysize0;
  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
  /* Internationalized format string. */
  const char *yyformat = YY_NULLPTR;
  /* Arguments of yyformat. */
  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
  /* Number of reported tokens (one for the "unexpected", one per
     "expected"). */
  int yycount = 0;

  /* There are many possibilities here to consider:
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yytoken != YYEMPTY)
    {
      int yyn = yypact[*yyssp];
      yyarg[yycount++] = yytname[yytoken];
      if (!yypact_value_is_default (yyn))
        {
          /* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */
          int yyxbegin = yyn < 0 ? -yyn : 0;
          /* Stay within bounds of both yycheck and yytname.  */
          int yychecklim = YYLAST - yyn + 1;
          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
          int yyx;

          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
                && !yytable_value_is_error (yytable[yyx + yyn]))
              {
                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
                  {
                    yycount = 1;
                    yysize = yysize0;
                    break;
                  }
                yyarg[yycount++] = yytname[yyx];
                {
                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
                  if (! (yysize <= yysize1
                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                    return 2;
                  yysize = yysize1;
                }
              }
        }
    }

  switch (yycount)
    {
# define YYCASE_(N, S)                      \
      case N:                               \
        yyformat = S;                       \
      break
      YYCASE_(0, YY_("syntax error"));
      YYCASE_(1, YY_("syntax error, unexpected %s"));
      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
# undef YYCASE_
    }

  {
    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
      return 2;
    yysize = yysize1;
  }

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return 1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yyarg[yyi++]);
          yyformat += 2;
        }
      else
        {
          yyp++;
          yyformat++;
        }
  }
  return 0;
}
#endif /* YYERROR_VERBOSE */

/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, struct jsi_Pstate *pstate)
{
  YYUSE (yyvaluep);
  YYUSE (yylocationp);
  YYUSE (pstate);
  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  switch (yytype)
    {
          case 32: /* FNUMBER  */
      { Jsi_Free(((*yyvaluep).num)); }
        break;

    case 33: /* REGEXP  */
      { Jsi_RegExpFree(((*yyvaluep).regex)); }
        break;

    case 103: /* statements  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 104: /* statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 105: /* commonstatement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 106: /* func_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 108: /* iterstatement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 111: /* statement_or_empty  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 112: /* with_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 113: /* switch_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 114: /* cases  */
      { Jsi_Free(((*yyvaluep).caselist));}
        break;

    case 115: /* case  */
      { Jsi_Free(((*yyvaluep).caseitem)); }
        break;

    case 116: /* try_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 117: /* vardecs  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 118: /* vardec  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 119: /* delete_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 120: /* if_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 122: /* for_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 123: /* for_init  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 124: /* for_cond  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 125: /* expr_opt  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 126: /* while_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 127: /* do_statement  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 128: /* func_expr  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 129: /* args_opt  */
      { jsi_ScopeStrsFree(pstate->interp, ((*yyvaluep).scopes)); }
        break;

    case 133: /* argdefault  */
      { Jsi_ValueFree(pstate->interp, ((*yyvaluep).value)); }
        break;

    case 134: /* args  */
      { jsi_ScopeStrsFree(pstate->interp, ((*yyvaluep).scopes)); }
        break;

    case 135: /* func_statement_block  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 136: /* expr  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 137: /* fcall_exprs  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 138: /* lvalue  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 139: /* exprlist_opt  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 140: /* exprlist  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 141: /* value  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 142: /* object  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 143: /* items  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 144: /* item  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;

    case 145: /* array  */
      { jsi_FreeOpcodes(((*yyvaluep).opcodes)); }
        break;


      default:
        break;
    }
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}




/*----------.
| yyparse.  |
`----------*/

int
yyparse (struct jsi_Pstate *pstate)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

/* Location data for the lookahead symbol.  */
static YYLTYPE yyloc_default
# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
  = { 1, 1, 1, 1 }
# endif
;
YYLTYPE yylloc = yyloc_default;

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.
       'yyls': related to locations.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    /* The location stack.  */
    YYLTYPE yylsa[YYINITDEPTH];
    YYLTYPE *yyls;
    YYLTYPE *yylsp;

    /* The locations where the error started and ended.  */
    YYLTYPE yyerror_range[3];

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;
  YYLTYPE yyloc;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yylsp = yyls = yylsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  yylsp[0] = yylloc;
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;
        YYLTYPE *yyls1 = yyls;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_("memory exhausted"),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yyls1, yysize * sizeof (*yylsp),
                    &yystacksize);

        yyls = yyls1;
        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        YYSTACK_RELOCATE (yyls_alloc, yyls);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;
      yylsp = yyls + yysize - 1;

      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, "Entering state %d\n", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token: "));
      yychar = yylex (&yylval, &yylloc, pstate);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END
  *++yylsp = yylloc;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];

  /* Default location.  */
  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 2:
    { pstate->opcodes = code_nop(); }
    break;

  case 3:
    {
        pstate->opcodes = (yyvsp[0].opcodes);
    }
    break;

  case 4:
    {
        pstate->opcodes = codes_join3((yyvsp[-1].opcodes), (yyvsp[0].opcodes), code_ret(pstate, &(yylsp[-1]), 1));
    }
    break;

  case 5:
    {    /* for json */
        pstate->opcodes = codes_join((yyvsp[0].opcodes), code_ret(pstate, &(yylsp[0]), 1));
    }
    break;

  case 6:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 7:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), (yyvsp[0].opcodes)); }
    break;

  case 8:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 9:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 10:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 11:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_pop(1)); }
    break;

  case 12:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 13:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 14:
    { (yyval.opcodes) = code_reserved(pstate, &(yylsp[-1]), RES_BREAK, (yyvsp[-1].str)); }
    break;

  case 15:
    { (yyval.opcodes) = code_reserved(pstate, &(yylsp[-1]), RES_CONTINUE, (yyvsp[-1].str)); }
    break;

  case 16:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_ret(pstate, &(yylsp[-1]), 1)); }
    break;

  case 17:
    { (yyval.opcodes) = code_ret(pstate, &(yylsp[-1]), 0); }
    break;

  case 18:
    {
        jsi_mark_local((yyvsp[-1].opcodes));
        (yyval.opcodes) = (yyvsp[-1].opcodes);
    }
    break;

  case 19:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_throw(pstate, &(yylsp[-1]))); }
    break;

  case 20:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 21:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 22:
    { (yyval.opcodes) = code_nop(); }
    break;

  case 23:
    { (yyval.opcodes) = (yyvsp[-1].opcodes); }
    break;

  case 24:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 25:
    {
        Jsi_OpCodes *ret = codes_join4(code_push_index(pstate, &(yylsp[-6]), (yyvsp[-6].str), 0),
          code_push_func(pstate, &(yylsp[-4]), jsi_FuncMake(pstate, (yyvsp[-4].scopes), (yyvsp[0].opcodes), &(yylsp[-6]), (yyvsp[-6].str))),
          code_assign(pstate, &(yylsp[-6]), 1), code_pop(1));
        if (pstate->eval_flag) ret = codes_join(code_local(pstate, &(yylsp[-6]), (yyvsp[-6].str)), ret);
        jsi_PstatePop(pstate);
        (yyval.opcodes) = ret;
    }
    break;

  case 26:
    {
        Jsi_OpCodes *ret = codes_join4(code_push_index(pstate, &(yylsp[-4]), (yyvsp[-4].str), 0),
          code_push_func(pstate, &(yylsp[-2]), jsi_FuncMake(pstate, (yyvsp[-2].scopes), (yyvsp[0].opcodes), &(yylsp[-4]), (yyvsp[-4].str))),
          code_assign(pstate, &(yylsp[-4]), 1), code_pop(1));
        if (pstate->eval_flag) ret = codes_join(code_local(pstate, &(yylsp[-4]), (yyvsp[-4].str)), ret);
        jsi_PstatePop(pstate);
        (yyval.opcodes) = ret;
    }
    break;

  case 27:
    {
        if (!pstate->eval_flag) {
            jsi_PstateAddVar(pstate, (yyvsp[0].str));
        }
        (yyval.str) = (yyvsp[0].str);
    }
    break;

  case 28:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 29:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 30:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 31:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 32:
    { (yyval.str) = NULL; }
    break;

  case 33:
    { (yyval.str) = (yyvsp[0].str); }
    break;

  case 34:
    { (yyval.str) = NULL; }
    break;

  case 35:
    {
        (yyval.str) = (yyvsp[-1].str);
    }
    break;

  case 36:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 37:
    { (yyval.opcodes) = code_nop(); }
    break;

  case 38:
    { 
        (yyval.opcodes) = codes_join4((yyvsp[-2].opcodes), code_with(pstate, &(yylsp[-2]), ((yyvsp[0].opcodes))->code_len + 1), (yyvsp[0].opcodes), code_ewith(pstate, &(yylsp[0])));
    }
    break;

  case 39:
    { (yyval.opcodes) = codes_join((yyvsp[-3].opcodes), code_pop(1)); }
    break;

  case 40:
    {
        jsi_CaseList *cl = (yyvsp[-1].caselist);
        Jsi_OpCodes *allstats = codes_new(3);
        jsi_CaseList *cldefault = NULL;
        jsi_CaseList *head = NULL;
        
        while (cl) {
            cl->off = allstats->code_len;
            allstats = codes_join(allstats, cl->es->stat);

            jsi_CaseList *t = cl;
            cl = cl->next;
            
            if (t->es->isdefault) {
                if (cldefault) {
                    if (cldefault->es) Jsi_Free(cldefault->es);
                    Jsi_Free(cldefault);
                    yyerror(&(yylsp[0]), pstate, "switch with more then one default\n");
                }
                cldefault = t;
            } else {
                t->next = head;
                head = t;
            }
        }
        code_reserved_replace(allstats, 0, 1, (yyvsp[-7].str), 1);
        
        Jsi_OpCodes *ophead = code_jmp(allstats->code_len + 1);
        if (cldefault) {
            ophead = codes_join(code_jmp(ophead->code_len + cldefault->off + 1), ophead);
            if (cldefault->es)
                Jsi_Free(cldefault->es);
            Jsi_Free(cldefault);
        }
        while (head) {
            Jsi_OpCodes *e = codes_join4(code_push_top(), head->es->expr, 
                                        code_eequ(), code_jtrue(ophead->code_len + head->off + 1));
            ophead = codes_join(e, ophead);
            jsi_CaseList *t = head;
            head = head->next;
            if (t->es)
                Jsi_Free(t->es);
            Jsi_Free(t);
        }
        jsi_OpCode *oc = ophead->codes;
        int i;
        for (i=0; i<ophead->code_len; i++)
            oc[i].nodebug = 1;
        (yyval.opcodes) = codes_join4(codes_join((yyvsp[-4].opcodes), code_unref()), ophead, allstats, code_pop(1));
    }
    break;

  case 41:
    { (yyval.caselist) = caselist_new(pstate, (yyvsp[0].caseitem)); }
    break;

  case 42:
    { (yyval.caselist) = caselist_insert(pstate, (yyvsp[-1].caselist), (yyvsp[0].caseitem)); }
    break;

  case 43:
    { (yyval.caseitem) = exprstat_new(pstate, (yyvsp[-2].opcodes), (yyvsp[0].opcodes), 0); }
    break;

  case 44:
    { (yyval.caseitem) = exprstat_new(pstate, NULL, (yyvsp[0].opcodes), 1); }
    break;

  case 45:
    { (yyval.caseitem) = exprstat_new(pstate, NULL, code_nop(), 1); }
    break;

  case 46:
    { (yyval.caseitem) = exprstat_new(pstate, (yyvsp[-1].opcodes), code_nop(), 0); }
    break;

  case 47:
    {
        Jsi_OpCodes *catchblock = codes_join3(code_scatch(pstate, &(yylsp[-2]), (yyvsp[-2].str)), (yyvsp[0].opcodes), code_ecatch(pstate, &(yylsp[0])));
        Jsi_OpCodes *finallyblock = codes_join(code_sfinal(pstate, &(yylsp[-2])), code_efinal(pstate, &(yylsp[-2])));
        Jsi_OpCodes *tryblock = codes_join((yyvsp[-5].opcodes), code_etry(pstate, &(yylsp[-5])));
        (yyval.opcodes) = codes_join4(code_stry(pstate, &(yylsp[-6]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 48:
    {
        Jsi_OpCodes *catchblock = codes_join(code_scatch(pstate, &(yylsp[-3]), NULL), code_ecatch(pstate, &(yylsp[-3])));
        Jsi_OpCodes *finallyblock = codes_join3(code_sfinal(pstate, &(yylsp[-3])), (yyvsp[0].opcodes), code_efinal(pstate, &(yylsp[0])));
        Jsi_OpCodes *tryblock = codes_join((yyvsp[-2].opcodes), code_etry(pstate, &(yylsp[-2])));
        (yyval.opcodes) = codes_join4(code_stry(pstate, &(yylsp[-3]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 49:
    {
        Jsi_OpCodes *catchblock = codes_join3(code_scatch(pstate, &(yylsp[-4]), (yyvsp[-4].str)), (yyvsp[-2].opcodes), code_ecatch(pstate, &(yylsp[-2])));
        Jsi_OpCodes *finallyblock = codes_join3(code_sfinal(pstate, &(yylsp[-8])), (yyvsp[0].opcodes), code_efinal(pstate, &(yylsp[-8])));
        Jsi_OpCodes *tryblock = codes_join((yyvsp[-7].opcodes), code_etry(pstate, &(yylsp[-7])));
        (yyval.opcodes) = codes_join4(code_stry(pstate, &(yylsp[-8]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 50:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 51:
    { (yyval.opcodes) = codes_join((yyvsp[-2].opcodes), (yyvsp[0].opcodes)); }
    break;

  case 52:
    {
        Jsi_OpCodes *ret = codes_join4(code_push_index(pstate, &(yylsp[0]), (yyvsp[0].str), 1),
                            code_push_undef(),
                            code_assign(pstate, &(yylsp[0]), 1),
                            code_pop(1));
        if (!pstate->eval_flag) jsi_PstateAddVar(pstate, (yyvsp[0].str));
        else ret = codes_join(code_local(pstate, &(yylsp[0]), (yyvsp[0].str)), ret);
        (yyval.opcodes) = ret;
    }
    break;

  case 53:
    {
        Jsi_OpCodes *ret = codes_join4(code_push_index(pstate, &(yylsp[-2]), (yyvsp[-2].str), 1),
                            (yyvsp[0].opcodes),
                            code_assign(pstate, &(yylsp[-2]), 1),
                            code_pop(1));
        if (!pstate->eval_flag) jsi_PstateAddVar(pstate, (yyvsp[-2].str));
        else ret = codes_join(code_local(pstate, &(yylsp[-2]), (yyvsp[-2].str)), ret);
        (yyval.opcodes) = ret;
    }
    break;

  case 54:
    {
        if (((yyvsp[-1].opcodes))->lvalue_flag == 2) {
            (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_delete(2));
        } else {
            (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_delete(1));
        }
    }
    break;

  case 55:
    {
        int offset = ((yyvsp[0].opcodes))->code_len;
        (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_jfalse(offset + 1), (yyvsp[0].opcodes));
    }
    break;

  case 56:
    {
        int len_block2 = ((yyvsp[0].opcodes))->code_len;
        Jsi_OpCodes *block1 = codes_join((yyvsp[-2].opcodes), code_jmp(len_block2 + 1));
        Jsi_OpCodes *condi = codes_join((yyvsp[-4].opcodes), code_jfalse(block1->code_len + 1));
        (yyval.opcodes) = codes_join3(condi, block1, (yyvsp[0].opcodes));
    }
    break;

  case 57:
    { (yyval.inum) = 0; }
    break;

  case 58:
    { (yyval.inum) = 1; }
    break;

  case 59:
    {
        Jsi_OpCodes *init = (yyvsp[-5].opcodes);
        Jsi_OpCodes *cond = (yyvsp[-4].opcodes);
        Jsi_OpCodes *step = ((yyvsp[-2].opcodes) ? codes_join((yyvsp[-2].opcodes), code_pop(1)) : code_nop());
        Jsi_OpCodes *stat = (yyvsp[0].opcodes);
        Jsi_OpCodes *cont_jmp = code_jfalse(step->code_len + stat->code_len + 2);
        Jsi_OpCodes *step_jmp = code_jmp(-(cond->code_len + step->code_len + stat->code_len + 1));
        code_reserved_replace(stat, step->code_len + 1, 0, (yyvsp[-8].str), 0);
        (yyval.opcodes) = codes_join(codes_join3(init, cond, cont_jmp),
                           codes_join3(stat, step, step_jmp));
    }
    break;

  case 60:
    {
        jsi_ForinVar *fv;
        int inof = (yyvsp[-3].inum);
        Jsi_OpCodes *loc = code_local(pstate, &(yylsp[-4]), (yyvsp[-4].str));
        jsi_mark_local(loc);
        fv = forinvar_new(pstate, (yyvsp[-4].str), loc, NULL);
        Jsi_OpCodes *lval;
        if (fv->varname) lval = code_push_index(pstate, &(yylsp[-7]), fv->varname, 1);
        else lval = fv->lval;
        
        Jsi_OpCodes *ret = make_forin(lval, &(yylsp[-7]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), (yyvsp[-8].str), (inof!=0));
        if (fv->varname && fv->local) {
            if (!pstate->eval_flag) {
                jsi_PstateAddVar(pstate,fv->varname);
                jsi_FreeOpcodes(fv->local);
            } else ret = codes_join(fv->local, ret);
        }
        Jsi_Free(fv);
        (yyval.opcodes) = ret;
    }
    break;

  case 61:
    {
        jsi_ForinVar *fv;
        int inof = (yyvsp[-3].inum);
        if (((yyvsp[-4].opcodes))->lvalue_flag == 2) 
            fv = forinvar_new(pstate, NULL, NULL, codes_join((yyvsp[-4].opcodes), code_subscript(pstate, &(yylsp[-4]), 0)));
        else fv = forinvar_new(pstate, NULL, NULL, (yyvsp[-4].opcodes));
        Jsi_OpCodes *lval;
        if (fv->varname) lval = code_push_index(pstate, &(yylsp[-7]), fv->varname, 0);
        else lval = fv->lval;
        
        Jsi_OpCodes *ret = make_forin(lval, &(yylsp[-6]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), (yyvsp[-7].str), (inof!=0));
        if (fv->varname && fv->local) {
            if (!pstate->eval_flag) {
                jsi_PstateAddVar(pstate,fv->varname);
                jsi_FreeOpcodes(fv->local);
            } else ret = codes_join(fv->local, ret);
        }
        Jsi_Free(fv);
        (yyval.opcodes) = ret;
    }
    break;

  case 62:
    { (yyval.opcodes) = code_nop(); }
    break;

  case 63:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_pop(1)); }
    break;

  case 64:
    {
        jsi_mark_local((yyvsp[-1].opcodes));
        (yyval.opcodes) = (yyvsp[-1].opcodes);
    }
    break;

  case 65:
    { (yyval.opcodes) = code_push_bool(1); }
    break;

  case 66:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 67:
    { (yyval.opcodes) = NULL; }
    break;

  case 68:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 69:
    {
        Jsi_OpCodes *cond = (yyvsp[-2].opcodes);
        Jsi_OpCodes *stat = (yyvsp[0].opcodes);
        code_reserved_replace(stat, 1, 0, (yyvsp[-5].str), 0);
        (yyval.opcodes) = codes_join4(cond, code_jfalse(stat->code_len + 2), stat,
                           code_jmp(-(stat->code_len + cond->code_len + 1)));
    }
    break;

  case 70:
    {
        Jsi_OpCodes *stat = (yyvsp[-4].opcodes);
        Jsi_OpCodes *cond = (yyvsp[-1].opcodes);
        code_reserved_replace(stat, cond->code_len + 1, 0, (yyvsp[-6].str), 0);
        (yyval.opcodes) = codes_join3(stat, cond,
                            code_jtrue(-(stat->code_len + cond->code_len)));
    }
    break;

  case 71:
    {
        (yyval.opcodes) = code_push_func(pstate,  &(yylsp[-2]), jsi_FuncMake(pstate, (yyvsp[-2].scopes), (yyvsp[0].opcodes), &(yylsp[0]), NULL));
        jsi_PstatePop(pstate);
    }
    break;

  case 72:
    {
        (yyval.opcodes) = code_push_func(pstate,  &(yylsp[-4]), jsi_FuncMake(pstate, (yyvsp[-4].scopes), (yyvsp[0].opcodes), &(yylsp[0]), NULL));
        jsi_PstatePop(pstate);
    }
    break;

  case 73:
    {
        (yyval.opcodes) = code_push_func(pstate, &(yylsp[-3]), jsi_FuncMake(pstate, (yyvsp[-2].scopes), (yyvsp[0].opcodes), &(yylsp[0]), (yyvsp[-4].str)));
        jsi_PstatePop(pstate);
    }
    break;

  case 74:
    {
        (yyval.opcodes) = code_push_func(pstate, &(yylsp[-5]), jsi_FuncMake(pstate, (yyvsp[-4].scopes), (yyvsp[0].opcodes), &(yylsp[0]), (yyvsp[-6].str)));
        jsi_PstatePop(pstate);
    }
    break;

  case 75:
    { (yyval.scopes) = jsi_ArgsOptAdd(pstate, jsi_ScopeStrsNew()); }
    break;

  case 76:
    {
        (yyval.scopes) = jsi_ArgsOptAdd(pstate, (yyvsp[0].scopes));
    }
    break;

  case 77:
    {
        Jsi_ScopeStrs *s = jsi_ArgsOptAdd(pstate, jsi_ScopeStrsNew());
        s->varargs = 1;
        (yyval.scopes) = s;
    }
    break;

  case 78:
    {
        Jsi_ScopeStrs *s = jsi_ArgsOptAdd(pstate, (yyvsp[-4].scopes));
        s->varargs = 1;
        (yyval.scopes) = s;
    }
    break;

  case 79:
    {    (yyval.inum) = (pstate->argType |= JSI_TT_STRING); }
    break;

  case 80:
    {  (yyval.inum) = (pstate->argType |= JSI_TT_NUMBER); }
    break;

  case 81:
    { (yyval.inum) = (pstate->argType |= JSI_TT_BOOLEAN); }
    break;

  case 82:
    {  (yyval.inum) = (pstate->argType |= JSI_TT_REGEXP); }
    break;

  case 83:
    {  (yyval.inum) = (pstate->argType |= JSI_TT_OBJECT); }
    break;

  case 84:
    { (yyval.inum) = (pstate->argType |= JSI_TT_USEROBJ); }
    break;

  case 85:
    { (yyval.inum) = (pstate->argType |= JSI_TT_ITEROBJ); }
    break;

  case 86:
    {     (yyval.inum) = (pstate->argType |= JSI_TT_ANY); }
    break;

  case 87:
    {   (yyval.inum) = (pstate->argType |= JSI_TT_ARRAY); }
    break;

  case 88:
    {    (yyval.inum) = (pstate->argType |= JSI_TT_NULL); }
    break;

  case 89:
    {        (yyval.inum) = (pstate->argType |= JSI_TT_FUNCTION); }
    break;

  case 90:
    {       (yyval.inum) = (pstate->argType |= JSI_TT_UNDEFINED); }
    break;

  case 91:
    {        (yyval.inum) = (pstate->argType |= JSI_TT_VOID); }
    break;

  case 92:
    {
        if (pstate->args)
            pstate->args->retType = pstate->argType;
        (yyval.inum) = pstate->argType;
        pstate->argType = 0;
    }
    break;

  case 93:
    {
        (yyval.inum) = pstate->argType;
    }
    break;

  case 94:
    {
        (yyval.inum) = pstate->argType;
    }
    break;

  case 95:
    {     (yyval.value) = Jsi_ValueNew(pstate->interp); (yyval.value)->d.num = 0; }
    break;

  case 96:
    {    (yyval.value) = Jsi_ValueNew(pstate->interp); (yyval.value)->d.num = 1; }
    break;

  case 97:
    { *(yyvsp[0].num) = *(yyvsp[0].num) * -1; (yyval.value) = Jsi_ValueNewNumber(pstate->interp, *(yyvsp[0].num)); Jsi_Free((yyvsp[0].num));}
    break;

  case 98:
    { (yyval.value) = Jsi_ValueNewNumber(pstate->interp, *(yyvsp[0].num)); Jsi_Free((yyvsp[0].num)); }
    break;

  case 99:
    {   (yyval.value) = Jsi_ValueNewBoolean(pstate->interp, 1); }
    break;

  case 100:
    {  (yyval.value) = Jsi_ValueNewBoolean(pstate->interp, 0); }
    break;

  case 101:
    {(yyval.value) = Jsi_ValueNewNull(pstate->interp); }
    break;

  case 102:
    {  (yyval.value) = Jsi_ValueNewStringKey(pstate->interp, (yyvsp[0].str)); }
    break;

  case 103:
    { (yyval.scopes) = jsi_argInsert(pstate, NULL, (yyvsp[0].str), NULL, &(yylsp[0]) ); }
    break;

  case 104:
    { (yyval.scopes) = jsi_argInsert(pstate, NULL, (yyvsp[-2].str), (yyvsp[0].value), &(yylsp[-2])); }
    break;

  case 105:
    { (yyval.scopes) = jsi_argInsert(pstate, NULL, (yyvsp[-2].str), NULL, &(yylsp[-2]));}
    break;

  case 106:
    { (yyval.scopes) = jsi_argInsert(pstate, NULL, (yyvsp[-4].str), (yyvsp[0].value), &(yylsp[-4]));}
    break;

  case 107:
    { (yyval.scopes) = jsi_argInsert(pstate, (yyvsp[-2].scopes), (yyvsp[0].str), NULL, &(yylsp[-2])); }
    break;

  case 108:
    { (yyval.scopes) = jsi_argInsert(pstate, (yyvsp[-4].scopes), (yyvsp[-2].str), (yyvsp[0].value), &(yylsp[-4])); }
    break;

  case 109:
    { (yyval.scopes) = jsi_argInsert(pstate, (yyvsp[-4].scopes), (yyvsp[-2].str), NULL, &(yylsp[-4]));}
    break;

  case 110:
    { (yyval.scopes) = jsi_argInsert(pstate, (yyvsp[-6].scopes), (yyvsp[-4].str), (yyvsp[0].value), &(yylsp[-6]));}
    break;

  case 111:
    { (yyval.opcodes) = (yyvsp[-1].opcodes); }
    break;

  case 112:
    { (yyval.opcodes) = code_nop(); }
    break;

  case 113:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 114:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 115:
    { 
        if (((yyvsp[0].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_subscript(pstate, &(yylsp[0]), 1)); 
        else (yyval.opcodes) = (yyvsp[0].opcodes);
    }
    break;

  case 116:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_pop(1), (yyvsp[0].opcodes)); }
    break;

  case 117:
    { (yyval.opcodes) = codes_join3((yyvsp[-3].opcodes), (yyvsp[-1].opcodes), code_subscript(pstate, &(yylsp[-3]), 1)); }
    break;

  case 118:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_push_string(pstate,&(yylsp[0]),(yyvsp[0].str)), code_subscript(pstate, &(yylsp[0]), 1)); }
    break;

  case 119:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_neg()); }
    break;

  case 120:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_pos()); }
    break;

  case 121:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_bnot()); }
    break;

  case 122:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_not()); }
    break;

  case 123:
    { (yyval.opcodes) = codes_join3((yyvsp[0].opcodes), code_pop(1), code_push_undef()); }
    break;

  case 124:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_mul()); }
    break;

  case 125:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_div()); }
    break;

  case 126:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_mod()); }
    break;

  case 127:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_add()); }
    break;

  case 128:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_sub()); }
    break;

  case 129:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_in()); }
    break;

  case 130:
    {
        if (((yyvsp[-1].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[-1].opcodes), code_subscript(pstate, &(yylsp[-1]), 0), code_inc(pstate, &(yylsp[-1]), 1));
        else (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_inc(pstate, &(yylsp[-1]), 1));
    }
    break;

  case 131:
    { 
        if (((yyvsp[-1].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[-1].opcodes), code_subscript(pstate, &(yylsp[-1]), 0), code_dec(pstate, &(yylsp[-1]), 1));
        else (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_dec(pstate, &(yylsp[-1]), 1)); 
    }
    break;

  case 132:
    {
        if (((yyvsp[0].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[0].opcodes), code_subscript(pstate, &(yylsp[0]), 0), code_inc(pstate, &(yylsp[0]), 0));
        else (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_inc(pstate, &(yylsp[0]), 0));
    }
    break;

  case 133:
    {
        if (((yyvsp[0].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[0].opcodes), code_subscript(pstate, &(yylsp[0]), 0), code_typeof(pstate, &(yylsp[0]), 0));
        else (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_typeof(pstate, &(yylsp[0]), 0));
    }
    break;

  case 134:
    { 
        if (((yyvsp[0].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[0].opcodes), code_subscript(pstate, &(yylsp[0]), 0), code_dec(pstate, &(yylsp[0]), 0));
        else (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_dec(pstate, &(yylsp[0]), 0));
    }
    break;

  case 135:
    { (yyval.opcodes) = (yyvsp[-1].opcodes); }
    break;

  case 136:
    {
        Jsi_OpCodes *expr2 = codes_join(code_pop(1), (yyvsp[0].opcodes));
        (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_jfalse_np(expr2->code_len + 1), expr2);
    }
    break;

  case 137:
    {
        Jsi_OpCodes *expr2 = codes_join(code_pop(1), (yyvsp[0].opcodes));
        (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_jtrue_np(expr2->code_len + 1), expr2);
    }
    break;

  case 138:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_less()); }
    break;

  case 139:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_greater()); }
    break;

  case 140:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_lessequ()); }
    break;

  case 141:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_greaterequ()); }
    break;

  case 142:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_equal()); }
    break;

  case 143:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_notequal()); }
    break;

  case 144:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_eequ());    }
    break;

  case 145:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_nneq()); }
    break;

  case 146:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_band()); }
    break;

  case 147:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_bor()); }
    break;

  case 148:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_bxor()); }
    break;

  case 149:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(0)); }
    break;

  case 150:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(1)); }
    break;

  case 151:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(2)); }
    break;

  case 152:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_assign(pstate, &(yylsp[-2]), ((yyvsp[-2].opcodes))->lvalue_flag)); }
    break;

  case 153:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_add()); }
    break;

  case 154:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_sub()); }
    break;

  case 155:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_mul()); }
    break;

  case 156:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_mod()); }
    break;

  case 157:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(0)); }
    break;

  case 158:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(1)); }
    break;

  case 159:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_shf(2)); }
    break;

  case 160:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_band()); }
    break;

  case 161:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_bor()); }
    break;

  case 162:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_bxor()); }
    break;

  case 163:
    { (yyval.opcodes) = opassign(pstate, &(yylsp[-2]), (yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_div()); }
    break;

  case 164:
    { (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), (yyvsp[0].opcodes), code_instanceof()); }
    break;

  case 165:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 166:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_newfcall(pstate, &(yylsp[-1]), 0, NULL, (yyvsp[0].opcodes))); }
    break;

  case 167:
    { 
        if (((yyvsp[0].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[0].opcodes), code_subscript(pstate, &(yylsp[0]), 1), code_newfcall(pstate, &(yylsp[0]), 0, NULL, (yyvsp[0].opcodes)));
        else (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_newfcall(pstate, &(yylsp[0]), 0, NULL, (yyvsp[0].opcodes)));}
    break;

  case 168:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_newfcall(pstate, &(yylsp[-3]),0, NULL, (yyvsp[-1].opcodes))); }
    break;

  case 169:
    { (yyval.opcodes) = codes_join((yyvsp[0].opcodes), code_newfcall(pstate, &(yylsp[-1]),0, NULL, (yyvsp[0].opcodes))); }
    break;

  case 170:
    {
        Jsi_OpCodes *lval = (yyvsp[-3].opcodes);
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3((yyvsp[-3].opcodes), (opl ? opl : code_nop()), code_newfcall(pstate, &(yylsp[-4]), expr_cnt, lval->lvalue_name, opl));
    }
    break;

  case 171:
    {
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        Jsi_OpCodes *lv = NULL;
        if (((yyvsp[-3].opcodes))->lvalue_flag == 2) lv = codes_join((yyvsp[-3].opcodes), code_subscript(pstate, &(yylsp[-3]), 1));
        else lv = (yyvsp[-3].opcodes);
        (yyval.opcodes) = codes_join3(lv, (opl ? opl : code_nop()), code_newfcall(pstate, &(yylsp[-4]),expr_cnt, lv?lv->lvalue_name:NULL, opl));
    }
    break;

  case 172:
    { 
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3((yyvsp[-4].opcodes), (opl ? opl : code_nop()), code_newfcall(pstate, &(yylsp[-6]),expr_cnt, NULL, opl));
    }
    break;

  case 173:
    {
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3((yyvsp[-3].opcodes), (opl ? opl : code_nop()), code_newfcall(pstate, &(yylsp[-4]),expr_cnt, NULL, opl));
    }
    break;

  case 174:
    {
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3((yyvsp[-3].opcodes), (opl ? opl : code_nop()), code_fcall(pstate, &(yylsp[-3]),expr_cnt, NULL, NULL, opl, NULL));
    }
    break;

  case 175:
    {
        Jsi_OpCodes *expr2 = codes_join((yyvsp[-2].opcodes), code_jmp(((yyvsp[0].opcodes))->code_len + 1));
        (yyval.opcodes) = codes_join4((yyvsp[-4].opcodes), code_jfalse(expr2->code_len + 1), expr2, (yyvsp[0].opcodes));
    }
    break;

  case 176:
    { (yyval.opcodes) = code_debug(pstate,&(yylsp[0])); }
    break;

  case 177:
    {
        Jsi_OpCodes *lval = (yyvsp[-5].opcodes);
        const char *n1 = lval->lvalue_name;
        const char *n2 = (yyvsp[-3].str);
        Jsi_OpCodes *ff = codes_join4((yyvsp[-5].opcodes), code_push_string(pstate,&(yylsp[-3]), (yyvsp[-3].str)), code_chthis(pstate,&(yylsp[-5]), 1), code_subscript(pstate, &(yylsp[-5]), 1));
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3(ff, (opl ? opl : code_nop()), code_fcall(pstate, &(yylsp[-3]), expr_cnt, n1, n2, opl, NULL));
    }
    break;

  case 178:
    {
        Jsi_OpCodes *ff = codes_join4((yyvsp[-6].opcodes), (yyvsp[-4].opcodes), code_chthis(pstate,&(yylsp[-6]), 1), code_subscript(pstate, &(yylsp[-6]), 1));
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join3(ff, (opl ? opl : code_nop()), code_fcall(pstate, &(yylsp[-4]), expr_cnt, NULL, NULL, opl, NULL));
    }
    break;

  case 179:
    {
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval.opcodes) = codes_join4((yyvsp[-4].opcodes), code_chthis(pstate,&(yylsp[-5]), 0), (opl ? opl : code_nop()), code_fcall(pstate, &(yylsp[-3]),expr_cnt, NULL, NULL, opl, NULL));
    }
    break;

  case 180:
    {
        Jsi_OpCodes *opl = (yyvsp[-1].opcodes);
        int expr_cnt = opl ? opl->expr_counter:0;
        Jsi_OpCodes *pref;
        Jsi_OpCodes *lval = (yyvsp[-3].opcodes);
        const char *n1 = lval->lvalue_name;
        if (lval->lvalue_flag == 2) {
            const char *n2 = NULL;
            pref = codes_join3((yyvsp[-3].opcodes), code_chthis(pstate,&(yylsp[-3]), 1), code_subscript(pstate, &(yylsp[-3]), 1));
            if (pref->code_len>=2 && pref->codes[0].op == OP_PUSHVAR && pref->codes[1].op == OP_PUSHSTR && !n1) {
                FastVar *fv = (FastVar*)pref->codes[0].data;
                n2 = fv->var.varname;
                n1 = (const char*)pref->codes[1].data;
            }
            (yyval.opcodes) = codes_join3(pref, (opl ? opl : code_nop()), code_fcall(pstate, &(yylsp[-2]), expr_cnt, n1, n2, opl, NULL));
        } else {
            if (lval->lvalue_name && Jsi_Strcmp(lval->lvalue_name, "eval") == 0) {
                (yyval.opcodes) = codes_join((opl ? opl : code_nop()), code_eval(pstate, &(yylsp[-3]), expr_cnt, lval));
            } else {
                jsi_Pline *jpl = &(yylsp[-3]);
                pref = codes_join((yyvsp[-3].opcodes), code_chthis(pstate,&(yylsp[-3]), 0));
                (yyval.opcodes) = codes_join3(pref, (opl ? opl : code_nop()), code_fcall(pstate, jpl, expr_cnt, n1, NULL, opl, pref));
            }
        }
    }
    break;

  case 181:
    {
        Jsi_OpCodes *lval = code_push_index(pstate, &(yylsp[0]), (yyvsp[0].str), 0); 
        (yyval.opcodes) = lval;
        lval->lvalue_flag = 1; 
        lval->lvalue_name = (yyvsp[0].str); 
    }
    break;

  case 182:
    { (yyval.opcodes) = code_push_args(); ((yyval.opcodes))->lvalue_flag = 1; }
    break;

  case 183:
    { (yyval.opcodes) = code_push_this(pstate,&(yylsp[0])); ((yyval.opcodes))->lvalue_flag = 1; }
    break;

  case 184:
    {
        if (((yyvsp[-3].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[-3].opcodes), code_subscript(pstate, &(yylsp[-3]), 1), (yyvsp[-1].opcodes)); 
        else (yyval.opcodes) = codes_join((yyvsp[-3].opcodes), (yyvsp[-1].opcodes)); 
        ((yyval.opcodes))->lvalue_flag = 2;
    }
    break;

  case 185:
    {
        if (((yyvsp[-2].opcodes))->lvalue_flag == 2) (yyval.opcodes) = codes_join3((yyvsp[-2].opcodes), code_subscript(pstate, &(yylsp[-2]), 1), code_push_string(pstate,&(yylsp[0]), (yyvsp[0].str))); 
        else (yyval.opcodes) = codes_join((yyvsp[-2].opcodes), code_push_string(pstate,&(yylsp[0]), (yyvsp[0].str)));
        ((yyval.opcodes))->lvalue_flag = 2;
    }
    break;

  case 186:
    { (yyval.opcodes) = NULL; }
    break;

  case 187:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 188:
    { (yyval.opcodes) = (yyvsp[0].opcodes); ((yyval.opcodes))->expr_counter = 1; }
    break;

  case 189:
    { 
        int exprcnt = ((yyvsp[-2].opcodes))->expr_counter + 1;
        (yyval.opcodes) = codes_join((yyvsp[-2].opcodes), (yyvsp[0].opcodes));
        ((yyval.opcodes))->expr_counter = exprcnt;
    }
    break;

  case 190:
    { (yyval.opcodes) = code_push_string(pstate,&(yylsp[0]), (yyvsp[0].str)); }
    break;

  case 191:
    { (yyval.opcodes) = code_push_null(); }
    break;

  case 192:
    { (yyval.opcodes) = code_push_undef(); }
    break;

  case 193:
    { (yyval.opcodes) = code_push_bool(1); }
    break;

  case 194:
    { (yyval.opcodes) = code_push_bool(0); }
    break;

  case 195:
    { (yyval.opcodes) = code_push_num((yyvsp[0].num)); }
    break;

  case 196:
    { (yyval.opcodes) = code_push_regex(pstate, &(yylsp[0]), (yyvsp[0].regex)); }
    break;

  case 197:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 198:
    { (yyval.opcodes) = (yyvsp[0].opcodes); }
    break;

  case 199:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_object(pstate, &(yylsp[-1]), ((yyvsp[-1].opcodes))->expr_counter)); }
    break;

  case 200:
    { (yyval.opcodes) = code_nop(); ((yyval.opcodes))->expr_counter = 0; }
    break;

  case 201:
    { (yyval.opcodes) = (yyvsp[0].opcodes); ((yyval.opcodes))->expr_counter = 1; }
    break;

  case 202:
    {
        int cnt = ((yyvsp[-2].opcodes))->expr_counter + 1;
        (yyval.opcodes) = codes_join((yyvsp[-2].opcodes), (yyvsp[0].opcodes));
        ((yyval.opcodes))->expr_counter = cnt;
    }
    break;

  case 203:
    { (yyval.opcodes) = codes_join(code_push_string(pstate,&(yylsp[-2]), (yyvsp[-2].str)), (yyvsp[0].opcodes)); }
    break;

  case 204:
    { (yyval.opcodes) = codes_join(code_push_string(pstate,&(yylsp[-2]), (yyvsp[-2].str)), (yyvsp[0].opcodes)); }
    break;

  case 205:
    { (yyval.opcodes) = codes_join((yyvsp[-1].opcodes), code_array(pstate, &(yylsp[-1]), ((yyvsp[-1].opcodes))->expr_counter)); }
    break;

  case 206:
    { (yyval.opcodes) = code_array(pstate, &(yylsp[-1]), 0); }
    break;


      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;
  *++yylsp = yyloc;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (&yylloc, pstate, YY_("syntax error"));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_("syntax error");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (&yylloc, pstate, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }

  yyerror_range[1] = yylloc;

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval, &yylloc, pstate);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  yyerror_range[1] = yylsp[1-yylen];
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;

      yyerror_range[1] = *yylsp;
      yydestruct ("Error: popping",
                  yystos[yystate], yyvsp, yylsp, pstate);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  yyerror_range[2] = yylloc;
  /* Using YYLLOC is tempting, but would change the location of
     the lookahead.  YYLOC is available though.  */
  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
  *++yylsp = yyloc;

  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (&yylloc, pstate, YY_("memory exhausted"));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval, &yylloc, pstate);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  yystos[*yyssp], yyvsp, yylsp, pstate);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
}


#endif //JSI_LITE_ONLY
#ifdef __WIN32
#ifndef JSI_AMALGAMATION
#include "../jsiInt.h"
#endif

#ifndef STRICT
#define STRICT
#endif
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

#define JSI__DLOPEN_COMPAT
#if defined(JSI__DLOPEN_COMPAT)
void *dlopen(const char *path, int mode)
{
    mode=mode;

    return (void *)LoadLibraryA(path);
}

int dlclose(void *handle)
{
    FreeLibrary((HANDLE)handle);
    return 0;
}

void *dlsym(void *handle, const char *symbol)
{
    return GetProcAddress((HMODULE)handle, symbol);
}

char *dlerror(void)
{
    static char msg[121];
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                   LANG_NEUTRAL, msg, sizeof(msg) - 1, NULL);
    return msg;
}
#endif

#ifdef _MSC_VER

#include <sys/timeb.h>

#ifdef _JSI_WIN_USE_FTIME
/* POSIX gettimeofday() compatibility for WIN32 */
int gettimeofday(struct timeval *tv, void *unused)
{
    struct _timeb tb;

    _ftime(&tb);
    tv->tv_sec = tb.time;
    tv->tv_usec = tb.millitm * 1000;

    return 0;
}
#else
LARGE_INTEGER
getFILETIMEoffset()
{
    SYSTEMTIME s;
    FILETIME f;
    LARGE_INTEGER t;

    s.wYear = 1970;
    s.wMonth = 1;
    s.wDay = 1;
    s.wHour = 0;
    s.wMinute = 0;
    s.wSecond = 0;
    s.wMilliseconds = 0;
    SystemTimeToFileTime(&s, &f);
    t.QuadPart = f.dwHighDateTime;
    t.QuadPart <<= 32;
    t.QuadPart |= f.dwLowDateTime;
    return (t);
}

int
clock_gettime(int X, struct timeval *tv)
{
    LARGE_INTEGER           t;
    FILETIME            f;
    double                  microseconds;
    static LARGE_INTEGER    offset;
    static double           frequencyToMicroseconds;
    static int              initialized = 0;
    static BOOL             usePerformanceCounter = 0;

    if (!initialized) {
        LARGE_INTEGER performanceFrequency;
        initialized = 1;
        usePerformanceCounter = QueryPerformanceFrequency(&performanceFrequency);
        if (usePerformanceCounter) {
            QueryPerformanceCounter(&offset);
            frequencyToMicroseconds = (double)performanceFrequency.QuadPart / 1000000.;
        } else {
            offset = getFILETIMEoffset();
            frequencyToMicroseconds = 10.;
        }
    }
    if (usePerformanceCounter) QueryPerformanceCounter(&t);
    else {
        GetSystemTimeAsFileTime(&f);
        t.QuadPart = f.dwHighDateTime;
        t.QuadPart <<= 32;
        t.QuadPart |= f.dwLowDateTime;
    }

    t.QuadPart -= offset.QuadPart;
    microseconds = (double)t.QuadPart / frequencyToMicroseconds;
    t.QuadPart = microseconds;
    tv->tv_sec = t.QuadPart / 1000000;
    tv->tv_usec = t.QuadPart % 1000000;
    return (0);
}
#endif

/* Posix dirent.h compatiblity layer for WIN32.
 * Copyright Kevlin Henney, 1997, 2003. All rights reserved.
 * Copyright Salvatore Sanfilippo ,2005.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose is hereby granted without fee, provided
 * that this copyright and permissions notice appear in all copies and
 * derivatives.
 *
 * This software is supplied "as is" without express or implied warranty.
 * This software was modified by Salvatore Sanfilippo for the Jsi Interpreter.
 */

DIR *opendir(const char *name)
{
    DIR *dir = 0;

    if (name && name[0]) {
        size_t base_length = strlen(name);
        const char *all =       /* search pattern must end with suitable wildcard */
            strchr("/\\", name[base_length - 1]) ? "*" : "/*";

        if ((dir = (DIR *) malloc(sizeof *dir)) != 0 &&
            (dir->name = (char *)malloc(base_length + strlen(all) + 1)) != 0) {
            strcat(strcpy(dir->name, name), all);

            if ((dir->handle = (long)_findfirst(dir->name, &dir->info)) != -1)
                dir->result.d_name = 0;
            else {              /* rollback */
                free(dir->name);
                free(dir);
                dir = 0;
            }
        }
        else {                  /* rollback */
            free(dir);
            dir = 0;
            errno = ENOMEM;
        }
    }
    else {
        errno = EINVAL;
    }
    return dir;
}

int closedir(DIR * dir)
{
    int result = -1;

    if (dir) {
        if (dir->handle != -1)
            result = _findclose(dir->handle);
        free(dir->name);
        free(dir);
    }
    if (result == -1)           /* map all errors to EBADF */
        errno = EBADF;
    return result;
}

struct dirent *readdir(DIR * dir)
{
    struct dirent *result = 0;

    if (dir && dir->handle != -1) {
        if (!dir->result.d_name || _findnext(dir->handle, &dir->info) != -1) {
            result = &dir->result;
            result->d_name = dir->info.name;
        }
    }
    else {
        errno = EBADF;
    }
    return result;
}

#endif

int scandir(const char *dirname,
            struct dirent ***namelist,
            int (*doselect)(const struct dirent *),
            int (*compar)(const struct dirent **,
                          const struct dirent **))
{
    WIN32_FIND_DATA wfd;
    HANDLE hf;
    struct dirent **plist, **newlist;
    struct dirent d;
    uint numentries = 0;
    uint allocentries = 255;
    uint i;
    char path[FILENAME_MAX];
    i = strlen(dirname);
    if (i > sizeof path - 5)
        return -1;
    strcpy(path, dirname);
    if (i>0 && dirname[i-1]!='\\' && dirname[i-1]!='/')
        strcat(path, "\\");
    strcat(path, "*.*");
    hf = FindFirstFile(path, &wfd);
    if (hf == INVALID_HANDLE_VALUE)
        return -1;
    plist = malloc(sizeof *plist * allocentries);
    if (plist==NULL)
    {
        FindClose(hf);
        return -1;
    }
    do
    {
        if (numentries==allocentries)
        {
            allocentries *= 2;
            newlist = realloc(plist, sizeof *plist * allocentries);
            if (newlist==NULL)
            {
                for (i=0; i<numentries; i++)
                    free(plist[i]);
                free(plist);
                FindClose(hf);
                return -1;
            }
            plist = newlist;
        }
        strncpy(d.d_name, wfd.cFileName, sizeof d.d_name);
        /* HACK. if is directory, set inode to 1. */
        d.d_ino =( (wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)?1:0);
        d.d_namlen = strlen(wfd.cFileName);
        d.d_reclen = sizeof d;
        if (doselect==NULL || doselect(&d))
        {
            plist[numentries] = malloc(sizeof d);
            if (plist[numentries]==NULL)
            {
                for (i=0; i<numentries; i++)
                    free(plist[i]);
                free(plist);
                FindClose(hf);
                return -1;
            };
            memcpy(plist[numentries], &d, sizeof d);
            numentries++;
        }
    }
    while (FindNextFile(hf, &wfd));
    FindClose(hf);
    if (numentries==0)
    {
        free(plist);
        *namelist = NULL;
    }
    else
    {
        newlist = realloc(plist, sizeof *plist * numentries);
        if (newlist!=NULL)
            plist = newlist;
        if (compar!=NULL)
            qsort(plist, numentries, sizeof *plist, (void*)compar);
        *namelist = plist;
    }
    return numentries;
}

int istrcmp(const char *s1, const char *s2)
{
    int d;
    for (;;)
    {
        d = tolower(*s1) - tolower(*s2);
        if (d!=0 || *s1=='\0' || *s2=='\0')
            return d;
        s1++;
        s2++;
    }
}

int alphasort(const struct dirent **d1,
              const struct dirent **d2)
{
    return istrcmp((*d1)->d_name, (*d2)->d_name);
}


static int32_t is_leap(int32_t year)
{
  if(year % 400 == 0)
  return 1;
  if(year % 100 == 0)
  return 0;
  if(year % 4 == 0)
  return 1;
  return 0;
}
static int32_t days_from_0(int32_t year)
{
  year--;
  return 365 * year + (year / 400) - (year/100) + (year / 4);
}

static int32_t days_from_1970(int32_t year)
{
  int days_from_0_to_1970 = days_from_0(1970);
  return days_from_0(year) - days_from_0_to_1970;
}

static int32_t days_from_1jan(int32_t year,int32_t month,int32_t day)
{
  static const int32_t days[2][12] =
  {
    { 0,31,59,90,120,151,181,212,243,273,304,334},
    { 0,31,60,91,121,152,182,213,244,274,305,335}
  };
  return days[is_leap(year)][month-1] + day - 1;
}

time_t internal_timegm(struct tm *t)
{
  int year = t->tm_year + 1900;
  int month = t->tm_mon;
  if(month > 11)
  {
    year += month/12;
    month %= 12;
  }
  else if(month < 0)
  {
    int years_diff = (-month + 11)/12;
    year -= years_diff;
    month+=12 * years_diff;
  }
  month++;
  int day = t->tm_mday;
  int day_of_year = days_from_1jan(year,month,day);
  int days_since_epoch = days_from_1970(year) + day_of_year;

  time_t seconds_in_day = 3600 * 24;
  time_t result = seconds_in_day * days_since_epoch + 3600 * t->tm_hour + 60 * t->tm_min + t->tm_sec;

  return result;
}

#endif
/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code was contributed to The NetBSD Foundation by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifdef __WIN32
#ifndef JSI_AMALGAMATION
#include "../jsiInt.h"
#include "compat.h"
#endif

#define TM_YEAR_BASE 1900
#include "ctype.h"
#include "string.h"
#include "time.h"
#include "stdio.h"


/*
 * We do not implement alternate representations. However, we always
 * check whether a given modifier is allowed for a certain conversion.
 */
#define ALT_E           0x01
#define ALT_O           0x02
#define LEGAL_ALT(x)        { if (alt_format & ~(x)) return (0); }


static int conv_num(const char **, int *, int, int);

static const char *day[7] = {
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday"
};
static const char *abday[7] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
static const char *mon[12] = {
    "January", "February", "March", "April", "May", "June", "July",
    "August", "September", "October", "November", "December"
};
static const char *abmon[12] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static const char *am_pm[2] = {
    "AM", "PM"
};


char *
strptime(const char *buf, const char *fmt, struct tm *tm)
{
    char c;
    const char *bp;
    size_t len = 0;
    int alt_format, i, split_year = 0;

    bp = buf;

    while ((c = *fmt) != '\0') {
    /* Clear `alternate' modifier prior to new conversion. */
    alt_format = 0;

    /* Eat up white-space. */
    if (isspace(c)) {
        while (isspace(*bp))
        bp++;

        fmt++;
        continue;
    }

    if ((c = *fmt++) != '%')
        goto literal;


      again:switch (c = *fmt++) {
    case '%':       /* "%%" is converted to "%". */
      literal:
        if (c != *bp++)
        return (0);
        break;

        /*
         *               * "Alternative" modifiers. Just set the appropriate flag
         *                               * and start over again.
         *                                               */
    case 'E':       /* "%E?" alternative conversion modifier. */
        LEGAL_ALT(0);
        alt_format |= ALT_E;
        goto again;

    case 'O':       /* "%O?" alternative conversion modifier. */
        LEGAL_ALT(0);
        alt_format |= ALT_O;
        goto again;

        /*
         *               * "Complex" conversion rules, implemented through recursion.
         *                               */
    case 'c':       /* Date and time, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%x %X", tm)))
        return (0);
        break;

    case 'D':       /* The date as "%m/%d/%y". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%m/%d/%y", tm)))
        return (0);
        break;

    case 'R':       /* The time as "%H:%M". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%H:%M", tm)))
        return (0);
        break;

    case 'r':       /* The time in 12-hour clock representation. */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%I:%M:%S %p", tm)))
        return (0);
        break;

    case 'T':       /* The time as "%H:%M:%S". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%H:%M:%S", tm)))
        return (0);
        break;

    case 'X':       /* The time, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%H:%M:%S", tm)))
        return (0);
        break;

    case 'x':       /* The date, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%m/%d/%y", tm)))
        return (0);
        break;

        /*
         *           * "Elementary" conversion rules.
         *                           */
    case 'A':       /* The day of week, using the locale's form. */
    case 'a':
        LEGAL_ALT(0);
        for (i = 0; i < 7; i++) {
        /* Full name. */
        len = strlen(day[i]);
        if (strncasecmp(day[i], bp, len) == 0)
            break;

        /* Abbreviated name. */
        len = strlen(abday[i]);
        if (strncasecmp(abday[i], bp, len) == 0)
            break;
        }

        /* Nothing matched. */
        if (i == 7)
        return (0);

        tm->tm_wday = i;
        bp += len;
        break;

    case 'B':       /* The month, using the locale's form. */
    case 'b':
    case 'h':
        LEGAL_ALT(0);
        for (i = 0; i < 12; i++) {
        /* Full name. */
        len = strlen(mon[i]);
        if (strncasecmp(mon[i], bp, len) == 0)
            break;

        /* Abbreviated name. */
        len = strlen(abmon[i]);
        if (strncasecmp(abmon[i], bp, len) == 0)
            break;
        }

        /* Nothing matched. */
        if (i == 12)
        return (0);

        tm->tm_mon = i;
        bp += len;
        break;

    case 'C':       /* The century number. */
        LEGAL_ALT(ALT_E);
        if (!(conv_num(&bp, &i, 0, 99)))
        return (0);

        if (split_year) {
        tm->tm_year = (tm->tm_year % 100) + (i * 100);
        } else {
        tm->tm_year = i * 100;
        split_year = 1;
        }
        break;

    case 'd':       /* The day of month. */
    case 'e':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_mday, 1, 31)))
        return (0);
        break;

    case 'k':       /* The hour (24-hour clock representation). */
        LEGAL_ALT(0);
        /* FALLTHROUGH */
    case 'H':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_hour, 0, 23)))
        return (0);
        break;

    case 'l':       /* The hour (12-hour clock representation). */
        LEGAL_ALT(0);
        /* FALLTHROUGH */
    case 'I':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_hour, 1, 12)))
        return (0);
        if (tm->tm_hour == 12)
        tm->tm_hour = 0;
        break;

    case 'j':       /* The day of year. */
        LEGAL_ALT(0);
        if (!(conv_num(&bp, &i, 1, 366)))
        return (0);
        tm->tm_yday = i - 1;
        break;

    case 'M':       /* The minute. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_min, 0, 59)))
        return (0);
        break;

    case 'm':       /* The month. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &i, 1, 12)))
        return (0);
        tm->tm_mon = i - 1;
        break;

    case 'p':       /* The locale's equivalent of AM/PM. */
        LEGAL_ALT(0);
        /* AM? */
        if (strcasecmp(am_pm[0], bp) == 0) {
        if (tm->tm_hour > 11)
            return (0);

        bp += strlen(am_pm[0]);
        break;
        }
        /* PM? */
        else if (strcasecmp(am_pm[1], bp) == 0) {
        if (tm->tm_hour > 11)
            return (0);

        tm->tm_hour += 12;
        bp += strlen(am_pm[1]);
        break;
        }

        /* Nothing matched. */
        return (0);

    case 'S':       /* The seconds. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_sec, 0, 61)))
        return (0);
        break;

    case 'U':       /* The week of year, beginning on sunday. */
    case 'W':       /* The week of year, beginning on monday. */
        LEGAL_ALT(ALT_O);
        /*
         *                   * XXX This is bogus, as we can not assume any valid
         *                                           * information present in the tm structure at this
         *                                                                   * point to calculate a real value, so just check the
         *                                                                                           * range for now.
         *                                                                                                                   */
        if (!(conv_num(&bp, &i, 0, 53)))
        return (0);
        break;

    case 'w':       /* The day of week, beginning on sunday. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_wday, 0, 6)))
        return (0);
        break;

    case 'Y':       /* The year. */
        LEGAL_ALT(ALT_E);
        if (!(conv_num(&bp, &i, 0, 9999)))
        return (0);

        tm->tm_year = i - TM_YEAR_BASE;
        break;

    case 'y':       /* The year within 100 years of the epoch. */
        LEGAL_ALT(ALT_E | ALT_O);
        if (!(conv_num(&bp, &i, 0, 99)))
        return (0);

        if (split_year) {
        tm->tm_year = ((tm->tm_year / 100) * 100) + i;
        break;
        }
        split_year = 1;
        if (i <= 68)
        tm->tm_year = i + 2000 - TM_YEAR_BASE;
        else
        tm->tm_year = i + 1900 - TM_YEAR_BASE;
        break;

        /*
         *               * Miscellaneous conversions.
         *                               */
    case 'n':       /* Any kind of white-space. */
    case 't':
        LEGAL_ALT(0);
        while (isspace(*bp))
        bp++;
        break;


    default:        /* Unknown/unsupported conversion. */
        return (0);
    }


    }

    /* LINTED functional specification */
    return ((char *) bp);
}


static int
conv_num(const char **buf, int *dest, int llim, int ulim)
{
    int result = 0;

    /* The limit also determines the number of valid digits. */
    int rulim = ulim;

    if (**buf < '0' || **buf > '9')
    return (0);

    do {
    result *= 10;
    result += *(*buf)++ - '0';
    rulim /= 10;
    } while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');

    if (result < llim || result > ulim)
    return (0);

    *dest = result;
    return (1);
}
#endif
/* The interpreter evaluation engine for jsi. */
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <math.h>

/*#define USE_INLINE*/
#ifdef INLINE_ALL
#define INLINE inline
#else
#define INLINE
#endif

#define _jsi_STACK (interp->Stack)
#define _jsi_STACKIDX(s) interp->Stack[s]
#define _jsi_TOP (interp->Stack[interp->framePtr->Sp-1])
#define _jsi_TOQ (interp->Stack[interp->framePtr->Sp-2])
#define _jsi_THIS (interp->Obj_this)
#define _jsi_THISIDX(s) interp->Obj_this[s]

static Jsi_RC _jsi_LogErr(Jsi_Interp *interp, const char *str) { Jsi_LogMsg(interp, JSI_ERROR, "%s", str); return JSI_ERROR; }

#define _jsi_StrictChk(v) ((strict==0 || !Jsi_NumberIsNaN(v->d.num)) ? JSI_OK : _jsi_LogErr(interp, "value is NaN"))
#define _jsi_StrictChk2(v1,v2)  ((strict==0  || (Jsi_NumberIsNaN(v1->d.num)==0 && Jsi_NumberIsNaN(v2->d.num)==0))  ? JSI_OK : _jsi_LogErr(interp, "value is NaN"))
#define _jsi_StrictUChk(v) ((strict==0 || v->vt != JSI_VT_UNDEF) ? JSI_OK : _jsi_LogErr(interp, "value is undefined"))
#define _jsi_StrictUChk2(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF && v2->vt != JSI_VT_UNDEF))  ? JSI_OK : _jsi_LogErr(interp, "value is undefined"))
#define _jsi_StrictUChk3(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF || v2->vt == JSI_VT_UNDEF))  ? JSI_OK : _jsi_LogErr(interp, "lhs value undefined in ===/!==") )

static jsi_Pstate* jsiNewParser(Jsi_Interp* interp, char *codeStr, Jsi_Channel fp, int iseval)
{
    bool isNew, cache = 1; //(interp->nocacheOpCodes==0);
    Jsi_HashEntry *hPtr = NULL;
    hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)codeStr, &isNew);
    if (!hPtr) return NULL;
    jsi_Pstate *ps;

    if (cache && isNew==0 && ((ps = (jsi_Pstate *)Jsi_HashValueGet(hPtr)))) {
        interp->codeCacheHit++;
        return ps;
    }
    ps = jsi_PstateNew(interp);
    ps->eval_flag = iseval;
    if (codeStr)
        jsi_PstateSetString(ps, codeStr);
    else
        jsi_PstateSetFile(ps, fp, 1);
        
    interp->inParse++;
    yyparse(ps);
    interp->inParse--;
    
    if (ps->err_count) {
        if (cache) Jsi_HashEntryDelete(hPtr);
        jsi_PstateFree(ps);
        return NULL;
    }
    if (isNew) {
        if (cache) {
            Jsi_HashValueSet(hPtr, ps);
            ps->hPtr = hPtr;
        } else {
            /* only using caching now. */
            assert(0);
        }
    }
    return ps;
}

/* eval here is diff from Jsi_CmdProc, current scope Jsi_LogWarn should be past to eval */
/* make evaling script execute in the same context */
static Jsi_RC jsiEvalOp(Jsi_Interp* interp, jsi_Pstate *ps, char *program,
                       jsi_ScopeChain *scope, Jsi_Value *currentScope, Jsi_Value *_this, Jsi_Value **ret)
{
    Jsi_RC r = JSI_OK;
    jsi_Pstate *newps = jsiNewParser(interp, program, NULL, 1);
    if (newps) {
        int oef = newps->eval_flag;
        newps->eval_flag = 1;
        interp->ps = newps;
        r = jsi_evalcode(newps, NULL, newps->opcodes, scope, currentScope, _this, ret);
        if (r) {
            Jsi_ValueDup2(interp, &ps->last_exception, newps->last_exception);
        }
        newps->eval_flag = oef;
        interp->ps = ps;
    } else  {
        //Jsi_ValueMakeStringKey(interp, &ps->last_exception, "Syntax Error");
        r = JSI_ERROR;
    }
    return r;
}
                     
static Jsi_Value** ValuesAlloc(Jsi_Interp *interp, int cnt, Jsi_Value**old, int oldsz) {
    int i;
    Jsi_Value **v = (Jsi_Value **)Jsi_Realloc(old, cnt* sizeof(Jsi_Value*));
    for (i=oldsz; i<cnt; i++)
        v[i] = NULL;
    return v;
}

static void jsiSetupStack(Jsi_Interp *interp)
{
    int oldsz = interp->maxStack;
    if (interp->maxStack)
        interp->maxStack += STACK_INCR_SIZE;
    else
        interp->maxStack = STACK_INIT_SIZE;
    _jsi_STACK = ValuesAlloc(interp, interp->maxStack, _jsi_STACK, oldsz);
    _jsi_THIS = ValuesAlloc(interp, interp->maxStack, _jsi_THIS, oldsz); //TODO:!!! use interp->framePtr for this.
}

static void jsiPush(Jsi_Interp* interp, int n) {
    int i = 0;
    do {
        if (!_jsi_STACKIDX(interp->framePtr->Sp))
            _jsi_STACKIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);
        if (!_jsi_THISIDX(interp->framePtr->Sp))
            _jsi_THISIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);
        if (i++ >= n) break;
        interp->framePtr->Sp++;
    } while (1);
}

/* Before setting a value in the _jsi_STACK/obj, unlink any reference to it. */

static void ClearStack(register Jsi_Interp *interp, int ofs) {
    Jsi_Value **vPtr = &_jsi_STACKIDX(interp->framePtr->Sp-ofs), *v = *vPtr;
    if (!v) return;
#ifndef XX_NEWSTACK
    Jsi_ValueReset(interp, vPtr);
#else
    if (v->refCnt<=1)
        Jsi_ValueReset(interp, vPtr);
    else {
        Jsi_DecrRefCount(interp, v);
        _jsi_STACKIDX(interp->framePtr->Sp-ofs) = Jsi_ValueNew1(interp);
    }
#endif
}

static void ClearThis(register Jsi_Interp *interp, int ofs) {
    Jsi_Value **vPtr = &_jsi_THISIDX(ofs), *v = *vPtr;
    if (!v) return;
#ifndef XX_NEWSTACK
    Jsi_ValueReset(interp, vPtr);
#else
    if (v->refCnt<=1)
        Jsi_ValueReset(interp, vPtr);
    else {
        Jsi_DecrRefCount(interp, v);
        _jsi_THISIDX(ofs) = Jsi_ValueNew1(interp);
    }
#endif
}


static Jsi_RC inline jsi_ValueAssign(Jsi_Interp *interp, Jsi_Value *dst, Jsi_Value* src, int lop)
{
    Jsi_Value *v;
    if (dst->vt != JSI_VT_VARIABLE) {
        if (jsi_IsStrictMode(interp)) 
            return Jsi_LogError("operand not a left value");
    } else {
        v = dst->d.lval;
        SIGASSERT(v, VALUE);
        int strict = jsi_IsStrictMode(interp);
        if (strict && lop == OP_PUSHFUN && interp->curIp[-1].local)
            dst->f.bits.local = 1;
        if (strict && dst->f.bits.local==0) {
            const char *varname = "";
            if (v->f.bits.lookupfailed)
                varname = v->d.lookupFail;
            Jsi_LogType("function created global: \"%s\"", varname);
            dst->f.bits.local=1;
            if (interp->typeCheck.error) {
                if (interp->framePtr->tryDepth) //Fixes tests/strict.js leak in try 
                    Jsi_HashSet(interp->genValueTbl, v, v);
                return JSI_ERROR;
            }
        }
        if (v == src)
            return JSI_OK;
        if (v->f.bits.readonly) {
            if (jsi_IsStrictMode(interp)) 
                return Jsi_LogError("assign to readonly variable");
            return JSI_OK;
        }
        if (Jsi_ValueIsFunction(interp, src))
            Jsi_ValueMove(interp,v, src);
        else
            Jsi_ValueCopy(interp,v, src);
        SIGASSERT(v, VALUE);
#ifdef JSI_MEM_DEBUG
    if (!v->VD.label2)
        v->VD.label2 = "ValueAssign";
#endif
    }
    return JSI_OK;
}

/* pop n values from _jsi_STACK */
static INLINE void jsiPop(Jsi_Interp* interp, int n) {
    int t = n;
    while (t > 0) {
        Assert((interp->framePtr->Sp-t)>=0);
/*        Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp-t);
         if (v->refCnt>1) puts("OO");*/
        ClearStack(interp,t);
        --t;
    }
    interp->framePtr->Sp -= n;
}

/* Convert preceding _jsi_STACK variable(s) into value(s). */
static INLINE void VarDeref(Jsi_Interp* interp, int n) {
    while(interp->framePtr->Sp<n) // Assert and Log may map-out Ops.
        jsiPush(interp, 1);
    int i;
    for (i=1; i<=n; i++) {
        Jsi_Value *vb = _jsi_STACKIDX(interp->framePtr->Sp - i);
        if (vb->vt == JSI_VT_VARIABLE) {
            SIGASSERT(vb->d.lval, VALUE);
            Jsi_ValueCopy(interp, vb, vb->d.lval);
        }
    }
}

#define common_math_opr(opr) {                      \
    VarDeref(interp,2);                                     \
    Jsi_ValueToNumber(interp, _jsi_TOP);     \
    Jsi_ValueToNumber(interp, _jsi_TOQ);     \
    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \
    _jsi_TOQ->d.num = _jsi_TOQ->d.num opr _jsi_TOP->d.num;            \
    jsiPop(interp, 1);                                          \
}

#define common_bitwise_opr(opr) {                       \
    int a, b;                                       \
    VarDeref(interp,2);                                     \
    Jsi_ValueToNumber(interp, _jsi_TOP);     \
    Jsi_ValueToNumber(interp, _jsi_TOQ);     \
    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \
    a = _jsi_TOQ->d.num; b = _jsi_TOP->d.num;                   \
    _jsi_TOQ->d.num = (Jsi_Number)(a opr b);                  \
    jsiPop(interp, 1);                                          \
}

static INLINE Jsi_RC logic_less(Jsi_Interp* interp, int i1, int i2) {
    Jsi_Value *v, *v1 = _jsi_STACK[interp->framePtr->Sp-i1], *v2 = _jsi_STACK[interp->framePtr->Sp-i2], *res = _jsi_TOQ;
    int val = 0, l1 = 0, l2 = 0; 
    bool strict = jsi_IsStrictMode(interp);
    Jsi_RC rc = JSI_OK;
    rc = _jsi_StrictUChk2(v1, v2);
    if (rc != JSI_OK)
        return JSI_ERROR;
    char *s1 = Jsi_ValueString(interp, v1, &l1);
    char *s2 = Jsi_ValueString(interp, v2, &l2);
    Jsi_Number n1, n2;

    if (s1 || s2) {
        char *str;
        if (!(s1 && s2)) {
            v = (s1 ? v2 : v1);
            jsi_ValueToPrimitive(interp, &v);
            Jsi_ValueToString(interp, v, NULL);
            str = Jsi_ValueString(interp, v, (s1?&l2:&l1));
            if (s1) s2 = str; else s1 = str;
        }
        Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);
        Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);
        //int mlen = (l1>l2?l1:l2);
        val = Jsi_Strcmp(s1, s2);
  
        if (val > 0) val = 0;
        else if (val < 0) val = 1;
        else val = (l1 < l2);
        ClearStack(interp,2);
        Jsi_ValueMakeBool(interp, &res, val);
    } else {
        Jsi_ValueToNumber(interp, v1);
        Jsi_ValueToNumber(interp, v2);
        rc = _jsi_StrictChk2(v1,v2);
        if (rc != JSI_OK)
            return JSI_ERROR;
        n1 = v1->d.num; n2 = v2->d.num;
        if (Jsi_NumberIsNaN(n1) || Jsi_NumberIsNaN(n2)) {
            ClearStack(interp,2);
            Jsi_ValueMakeUndef(interp, &res);
        } else {
            val = (n1 < n2);
            ClearStack(interp,2);
            Jsi_ValueMakeBool(interp, &res, val);
        }
    }
    return JSI_OK;
}

static const char *vprint(Jsi_Value *v)
{
    static char buf[100];
    if (v->vt == JSI_VT_NUMBER) {
        snprintf(buf, 100, "NUM:%" JSI_NUMGFMT " ", v->d.num);
    } else if (v->vt == JSI_VT_BOOL) {
        snprintf(buf, 100, "BOO:%d", v->d.val);
    } else if (v->vt == JSI_VT_STRING) {
        snprintf(buf, 100, "STR:'%s'", v->d.s.str);
    } else if (v->vt == JSI_VT_VARIABLE) {
        snprintf(buf, 100, "VAR:%p", v->d.lval);
    } else if (v->vt == JSI_VT_NULL) {
        snprintf(buf, 100, "NULL");
    } else if (v->vt == JSI_VT_OBJECT) {
        snprintf(buf, 100, "OBJ:%p", v->d.obj);
    } else if (v->vt == JSI_VT_UNDEF) {
        snprintf(buf, 100, "UNDEFINED");
    }
    return buf;
}

typedef enum {
        TL_TRY,
        TL_WITH,
} try_op_type;                            /* type of try */

typedef enum { LOP_NOOP, LOP_THROW, LOP_JMP } last_try_op_t; 

typedef struct TryList {
    try_op_type type;
    union {
        struct {                    /* try data */
            jsi_OpCode *tstart;         /* try start ip */
            jsi_OpCode *tend;           /* try end ip */
            jsi_OpCode *cstart;         /* ...*/
            jsi_OpCode *cend;
            jsi_OpCode *fstart;
            jsi_OpCode *fend;
            int tsp;
            last_try_op_t last_op;              /* what to do after finally block */
                                    /* depend on last jmp code in catch block */
            union {
                jsi_OpCode *tojmp;
            } ld;                   /* jmp out of catch (target)*/
        } td;
        struct {                    /* with data */
            jsi_OpCode *wstart;         /* with start */
            jsi_OpCode *wend;           /* with end */
        } wd;
    } d;
    
    jsi_ScopeChain *scope_save;         /* saved scope (used in catch block/with block)*/
    Jsi_Value *curscope_save;           /* saved current scope */
    struct TryList *next;
    bool inCatch;
    bool inFinal;
} TryList;

/* destroy top of trylist */
#define pop_try(head) _pop_try(interp, &head)
static INLINE void _pop_try(Jsi_Interp* interp, TryList **head)
{
    interp->framePtr->tryDepth--;
    TryList *t = (*head)->next;
    Jsi_Free((*head));
    (*head) = t;
}

#define push_try(head, n) _push_try(interp, &head, n)
static INLINE void _push_try(Jsi_Interp* interp, TryList **head, TryList *n)
{
    interp->framePtr->tryDepth++;
    (n)->next = (*head);
    (*head) = (n);
}

/* restore scope chain */
#define restore_scope() _restore_scope(interp, ps, trylist, \
    &scope, &currentScope, &context_id)
static INLINE void _restore_scope(Jsi_Interp* interp, jsi_Pstate *ps, TryList* trylist,
  jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id) {

/* restore_scope(scope_save, curscope_save)*/
    if (*scope != (trylist->scope_save)) {
        jsi_ScopeChainFree(interp, *scope);
        *scope = (trylist->scope_save);
        interp->framePtr->ingsc = *scope;
    }
    if (*currentScope != (trylist->curscope_save)) {
        Jsi_DecrRefCount(interp, *currentScope);
        *currentScope = (trylist->curscope_save); 
        interp->framePtr->incsc = *currentScope;
    }
    *context_id = ps->_context_id++; 
}

#define do_throw(nam) if (_do_throw(interp, ps, &ip, &trylist,&scope, &currentScope, &context_id, (interp->framePtr->Sp?_jsi_TOP:NULL), nam) != JSI_OK) { rc = JSI_ERROR; break; }

static int _do_throw(Jsi_Interp *interp, jsi_Pstate *ps, jsi_OpCode **ipp, TryList **tlp,
     jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id, Jsi_Value *top, const char *nam) {
    if (Jsi_InterpGone(interp))
        return JSI_ERROR;
    TryList *trylist = *tlp;
    while (1) {
        if (trylist == NULL) {
            const char *str = (top?Jsi_ValueString(interp, top, NULL):"");
            if (str)
                Jsi_LogError("%s: %s", nam, str);
            return JSI_ERROR;
        }
        if (trylist->type == TL_TRY) {
            int n = interp->framePtr->Sp - trylist->d.td.tsp;
            jsiPop(interp, n);
            if (*ipp >= trylist->d.td.tstart && *ipp < trylist->d.td.tend) {
                *ipp = trylist->d.td.cstart - 1;
                break;
            } else if (*ipp >= trylist->d.td.cstart && *ipp < trylist->d.td.cend) {
                trylist->d.td.last_op = LOP_THROW;
                *ipp = trylist->d.td.fstart - 1;
                break;
            } else if (*ipp >= trylist->d.td.fstart && *ipp < trylist->d.td.fend) {
                _pop_try(interp, tlp);
                trylist = *tlp;
            } else Jsi_LogBug("Throw within a try, but not in its scope?");
        } else {
            _restore_scope(interp, ps, trylist, scope, currentScope, context_id);
            _pop_try(interp, tlp);
            trylist = *tlp;
        }
    }
    return JSI_OK;
}

static TryList *trylist_new(try_op_type t, jsi_ScopeChain *scope_save, Jsi_Value *curscope_save)
{
    TryList *n = (TryList *)Jsi_Calloc(1,sizeof(*n));
    
    n->type = t;
    n->curscope_save = curscope_save;
    /*Jsi_IncrRefCount(interp, curscope_save);*/
    n->scope_save = scope_save;
    
    return n;
}

static void DumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,
    TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)
{
    int i;
    char buf[200];
    jsi_code_decode(ip, ip - opcodes->codes, buf, sizeof(buf));
    Jsi_Printf(jsi_Stderr, "%p: %-30.200s : THIS=%s, STACK=[", ip, buf, vprint(_this));
    for (i = 0; i < interp->framePtr->Sp; ++i) {
        Jsi_Printf(jsi_Stderr, "%s%s", (i>0?", ":""), vprint(_jsi_STACKIDX(i)));
    }
    Jsi_Printf(jsi_Stderr, "]");
    if (ip->fname) {
        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');
        if (cp) fn = cp+1;
        Jsi_Printf(jsi_Stderr, ", %s:%d", fn, ip->Line);
    }
    Jsi_Printf(jsi_Stderr, "\n");
    TryList *tlt = trylist;
    for (i = 0; tlt; tlt = tlt->next) i++;
    if (ps->last_exception)
        Jsi_Printf(jsi_Stderr, "TL: %d, excpt: %s\n", i, vprint(ps->last_exception));
}

static int cmpstringp(const void *p1, const void *p2)
{
   return Jsi_Strcmp(* (char * const *) p1, * (char * const *) p2);
}

void jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep) {
    int argc, i;
    char **argv;
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(Jsi_DSValue(dStr), &argc, &argv, sep, &sStr);
    qsort(argv, argc, sizeof(char*), cmpstringp);
    Jsi_DSSetLength(dStr, 0);
    for (i=0; i<argc; i++)
        Jsi_DSAppend(dStr, (i?" ":""), argv[i], NULL);
    Jsi_DSFree(&sStr);
}

static void ValueObjDelete(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, int force)
{
    if (target->vt != JSI_VT_OBJECT) return;
    const char *kstr = Jsi_ValueToString(interp, key, NULL);
    Jsi_TreeEntry *hPtr;
    if (!Jsi_ValueIsStringKey(interp, key)) {
        Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, kstr);
        if (hePtr)
            kstr = (char*)Jsi_MapKeyGet(hePtr, 0);
    }
    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);
    if (hPtr == NULL || (hPtr->f.bits.dontdel && !force))
        return;
    Jsi_TreeEntryDelete(hPtr);
}

static void ObjGetNames(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_DString* dStr, int flags) {
    Jsi_TreeEntry *hPtr;
    Jsi_TreeSearch srch;
    Jsi_Value *v;
    int m = 0;
    Jsi_DSInit(dStr);
    if (obj->isarrlist)
        obj = interp->Array_prototype->d.obj;
    for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch)) {
        v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
        if (!v) continue;
        if ((flags&JSI_NAME_FUNCTIONS) && !Jsi_ValueIsFunction(interp,v)) {
            continue;
        }
        if ((flags&JSI_NAME_DATA) && Jsi_ValueIsFunction(interp,v)) {
            continue;
        }

        Jsi_DSAppend(dStr, (m++?" ":""), Jsi_TreeKeyGet(hPtr), NULL);
    }
    Jsi_TreeSearchDone(&srch);
}

static void DumpFunctions(Jsi_Interp *interp, const char *spnam) {
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_MapEntry *hPtr;
    Jsi_MapSearch search;
    Jsi_CmdSpecItem *csi = NULL;
    Jsi_CmdSpec *cs;
    Jsi_Value *lsf = interp->lastSubscriptFail;
    Jsi_Obj *lso = ((lsf && lsf->vt == JSI_VT_OBJECT)?lsf->d.obj:0);
    const char *varname = NULL;
    int m = 0;
    
    if (lso) {
        spnam = interp->lastSubscriptFailStr;
        if (!spnam) spnam = interp->lastPushStr;
        if (lso->ot == JSI_OT_USEROBJ && lso->d.uobj->reg && lso->d.uobj->interp == interp) {
            cs = lso->d.uobj->reg->spec;
            if (cs)
                goto dumpspec;
        } else if (lso->ot == JSI_OT_FUNCTION) {
            cs = lso->d.fobj->func->cmdSpec;
            if (cs)
                goto dumpspec;
        } else if (lso->ot == JSI_OT_OBJECT) {
            ObjGetNames(interp, lso, &dStr, JSI_NAME_FUNCTIONS);
            Jsi_LogError("'%s', functions are: %s.",
                spnam, Jsi_DSValue(&dStr));
            Jsi_DSFree(&dStr);
            return;
        } else {
            const char *sustr = NULL;
            switch (lso->ot) {
                case JSI_OT_STRING: sustr = "String"; break;
                case JSI_OT_NUMBER: sustr = "Number"; break;
                case JSI_OT_BOOL: sustr = "Boolean"; break;
                default: break;
            }
            if (sustr) {
                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, sustr);
                csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);
                cs = csi->spec;
                if (!spnam[0])
                    spnam = sustr;
                goto dumpspec;
            }
        }
    }
    if (!*spnam) {
        for (hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);
            hPtr; hPtr = Jsi_MapSearchNext(&search)) {
            csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);
            if (csi->name && csi->name[0])
                Jsi_DSAppend(&dStr, (m++?" ":""), csi->name, NULL);
        }
        Jsi_MapSearchDone(&search);
    }
    
    varname = spnam;
    if ((hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, spnam))) {
        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);
        while (csi) {
            int n;
            cs = csi->spec;
dumpspec:
            n = 0;
            while (cs->name) {
                if (n != 0 || !(cs->flags & JSI_CMD_IS_CONSTRUCTOR)) {
                    if (!*cs->name) continue;
                    Jsi_DSAppend(&dStr, (m?" ":""), cs->name, NULL);
                    n++; m++;
                }
                cs++;
            }
            csi = (csi?csi->next:NULL);
        }
        jsi_SortDString(interp, &dStr, " ");
        if (varname)
            spnam = varname;
        else if (interp->lastPushStr && !spnam[0])
            spnam = interp->lastPushStr;
        Jsi_LogError("'%s' sub-commands are: %s.",
            spnam, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
    } else {
        Jsi_LogError("can not execute expression: '%s' not a function",
            varname ? varname : "");
    }
}

/* Attempt to dynamically load function XX by doing an eval of Jsi_Auto.XX */
/* TODO: prevent infinite loop/recursion. */
Jsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret) {
    Jsi_DString dStr = {};
    Jsi_Value *v;
    int i;
    const char *curFile = interp->curFile;
    interp->curFile = "<jsiLoadFunction>";
    for (i=0; i<2; i++) {
        Jsi_DSAppend(&dStr, "Jsi_Auto.", str, NULL);
        Jsi_VarLookup(interp, Jsi_DSValue(&dStr));
        v = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
        if (v)
            jsi_ValueDebugLabel(v, "jsiLoadFunction","f1");
        Jsi_DSFree(&dStr);
        if (v) {
            const char *cp = Jsi_ValueGetDString(interp, v, &dStr, 0);
            Jsi_DecrRefCount(interp, v);
            v = NULL;
            if (Jsi_EvalString(interp, cp, 0) == JSI_OK) {
                v = Jsi_NameLookup(interp, str);
                if (v)
                    jsi_ValueDebugLabel(v, "jsiLoadFunction","f2");
            }
            Jsi_DSFree(&dStr);
            if (v) {
                tret = v;
                break;
            }
        }
        if (interp->autoLoaded++ || i>0)
            break;
        /*  Index not in memory, so try loading Jsi_Auto from the autoload.jsi file. */
        if (interp->autoFiles == NULL)
            return tret;
        Jsi_Value **ifs = &interp->autoFiles;
        int i, ifn = 1;
        if (Jsi_ValueIsArray(interp, interp->autoFiles)) {
            ifs = interp->autoFiles->d.obj->arr;
            ifn = interp->autoFiles->d.obj->arrCnt;
        }
        for (i=0; i<ifn; i++) {  
            if (Jsi_EvalFile(interp, ifs[i], 0) != JSI_OK)
                break;
            interp->autoLoaded++;
        }
    }
    interp->curFile = curFile;
    return tret;
}

void jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *fstatic, jsi_OpCode *iPtr,
    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret)
{
    jsi_OpCode *ip = (iPtr ? iPtr : interp->curIp);
    if (!ip)
        return;
    const char *ff, *fname = ip->fname?ip->fname:"";
    if ((interp->traceCall&jsi_callTraceFullPath)==0 && ((ff=Jsi_Strrchr(fname,'/'))))
        fname = ff+1;
    if (interp->traceHook)
        (*interp->traceHook)(interp, fstatic->name, ip->fname, ip->Line, fstatic->cmdSpec, _this, args, ret);
    else {
        const char *fp = ((interp->traceCall&jsi_callTraceNoParent)?NULL:fstatic->parent);
        if (fp && !*fp)
            fp = NULL;
        Jsi_DString aStr;
        Jsi_DSInit(&aStr);
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        Jsi_DString *sPtr = NULL;
        int plen = 0;
        if (ret) {
            sPtr = &dStr;
            Jsi_DSAppend(sPtr, " <-- ", NULL);
            plen = Jsi_DSLength(sPtr);
            Jsi_ValueGetDString(interp, ret, sPtr, 0);
        } else if ((interp->traceCall&jsi_callTraceArgs)) {
            sPtr = &aStr;
            Jsi_ValueGetDString(interp, args, sPtr, JSI_OUTPUT_JSON);
        }
        if (sPtr) {
            if (!(interp->traceCall&jsi_callTraceNoTrunc)) {
                const char *cp0 = Jsi_DSValue(sPtr), *cp1 = Jsi_Strchr(cp0, '\n');
                int nlen = 0, clen = Jsi_DSLength(sPtr);
                if (cp1) {
                    nlen = (cp1-cp0);
                    if (nlen>60) nlen = 60;
                }  else if (clen>60)
                    nlen = 60;
                else nlen = clen;
                if (nlen != clen && clen>plen) {
                    Jsi_DSSetLength(sPtr, nlen);
                    Jsi_DSAppend(sPtr, "...", NULL);
                }
            }
        }
        if (interp->parent && interp->debugOpts.traceCallback) {
            Jsi_DString jStr={}, kStr={}, lStr={};
            Jsi_DSPrintf(&kStr, "[\"%s%s%s\", %s, %s, \"%s\", %d, %d ]",
                (fp?fp:""), (fp?".":""), fstatic->name, 
                (ret?"null":Jsi_JSONQuote(interp, Jsi_DSValue(&aStr),-1, &jStr)),
                (ret?Jsi_JSONQuote(interp, Jsi_DSValue(&dStr),-1, &lStr):"null"),
                 fname, ip->Line, ip->Lofs);
            if (Jsi_CommandInvokeJSON(interp->parent, interp->debugOpts.traceCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)
                Jsi_Printf(jsi_Stderr, "failed trace call\n");
            Jsi_DSFree(&jStr);
            Jsi_DSFree(&kStr);
            Jsi_DSFree(&lStr);
        } else if ((interp->traceCall&jsi_callTraceBefore))
            Jsi_Printf(jsi_Stderr, "%s:%d %*s#%d: %c %s%s%s(%s) %s\n",
                fname, ip->Line,
                (interp->level-1)*2, "", interp->level,
                (ret?'<':'>'), (fp?fp:""), (fp?".":""), fstatic->name, Jsi_DSValue(&aStr),
            Jsi_DSValue(&dStr));
        else
            Jsi_Printf(jsi_Stderr, "%*s#%d: %c %s%s%s(%s) in %s:%d%s\n", (interp->level-1)*2, "", interp->level,
                (ret?'<':'>'), (fp?fp:""), (fp?".":""), fstatic->name, Jsi_DSValue(&aStr),
            fname, ip->Line, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        Jsi_DSFree(&aStr);
    }
}

static INLINE Jsi_RC jsiEvalFunction(register jsi_Pstate *ps, jsi_OpCode *ip, int discard) {
    Jsi_RC excpt_ret = JSI_OK;
    register Jsi_Interp *interp = ps->interp;
    int as_constructor = (ip->op == OP_NEWFCALL);
    int stackargc = (int)(uintptr_t)ip->data;
    const char *oldCurFunc = interp->curFunction;
    VarDeref(interp, stackargc + 1);
    
    int tocall_index = interp->framePtr->Sp - stackargc - 1, adds;
    Jsi_Value *tocall = _jsi_STACKIDX(tocall_index);
    const char *spnam = "";
    //char *lpv = interp->lastPushStr;
    if (tocall->vt == JSI_VT_UNDEF && tocall->f.bits.lookupfailed && tocall->d.lookupFail) {
        spnam = tocall->d.lookupFail;
        tocall->f.bits.lookupfailed = 0;
        tocall = jsi_LoadFunction(interp, spnam, tocall);
        interp->lastPushStr = (char*)spnam;
        interp->curIp = ip;
    }
    if (!Jsi_ValueIsFunction(interp, tocall)) {
       // if (tocall->f.bits.subscriptfailed && tocall->d.lookupFail)
       //     spnam = tocall->d.lookupFail;
        DumpFunctions(interp, spnam);
        excpt_ret = JSI_ERROR;
        goto empty_func;
    }

    if (tocall->d.obj->d.fobj==NULL || tocall->d.obj->d.fobj->func==NULL) {   /* empty function */
empty_func:
        jsiPop(interp, stackargc);
        ClearStack(interp,1);
        Jsi_ValueMakeUndef(interp, &_jsi_TOP);
    } else {
        Jsi_FuncObj *fobj = tocall->d.obj->d.fobj;
        Jsi_Func *fstatic = fobj->func;
        if (fstatic->callback == jsi_NoOpCmd || tocall->d.obj->isNoOp)
            goto empty_func;
        if (!interp->asserts && fstatic->callback == jsi_AssertCmd)
            goto empty_func;
        const char *onam = fstatic->name;
//        if (!onam) // Override blank name with last index.
//            fstatic->name = lpv;
        if (fstatic->name && fstatic->name[0] && fstatic->type == FC_NORMAL)
            interp->curFunction = fstatic->name;
        adds = fstatic->callflags.bits.addargs;
        if (adds && (fstatic->cmdSpec->flags&JSI_CMDSPEC_NONTHIS))
            adds = 0;
        /* create new scope, prepare arguments */
        /* here we shared scope and 'arguments' with the same object */
        /* so that arguments[0] is easier to shared space with first local variable */
        Jsi_Value *fargs = Jsi_ValueNew1(interp);
        Jsi_Obj *ao = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->framePtr->Sp - stackargc), stackargc, 1);
      
        Jsi_ValueMakeObject(interp, &fargs, ao);        
        fargs->d.obj->__proto__ = interp->Object_prototype;          // ecma

        Jsi_Func *pprevActive = interp->prevActiveFunc, *prevActive = interp->prevActiveFunc = interp->activeFunc;
        interp->activeFunc = fstatic;

        excpt_ret = jsi_SharedArgs(interp, fargs, fstatic, 1); /* make arg vars to share arguments */
        fstatic->callflags.bits.addargs = 0;
        jsi_InitLocalVar(interp, fargs, fstatic);
        jsi_SetCallee(interp, fargs, tocall);
        
        jsiPop(interp, stackargc);
    
        Jsi_Value *ntPtr;
        if (_jsi_THISIDX(tocall_index)->vt == JSI_VT_OBJECT) {
            ntPtr = Jsi_ValueDup(interp, _jsi_THISIDX(tocall_index));
            ClearThis(interp, tocall_index);
        } else {
            ntPtr = Jsi_ValueDup(interp, interp->Top_object);
        }
        int calltrc = 0;

        if (as_constructor) {                       /* new Constructor */
            Jsi_Obj *newobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
            Jsi_Value *proto = Jsi_ValueObjLookup(interp, tocall, "prototype", 0);
            if (proto && proto->vt == JSI_VT_OBJECT) {
                newobj->__proto__ = proto;
                newobj->clearProto = 1;
                Jsi_IncrRefCount(interp, proto);
            }
            Jsi_ValueReset(interp, &ntPtr);
            Jsi_ValueMakeObject(interp, &ntPtr, newobj);            
            /* TODO: constructor specifics??? */
            calltrc = (interp->traceCall&jsi_callTraceNew);
        }
        if (fstatic->type == FC_NORMAL)
            calltrc = (interp->traceCall&jsi_callTraceFuncs);
        else
            calltrc = (interp->traceCall&jsi_callTraceCmds);
        if (calltrc && fstatic->name)
            jsi_TraceFuncCall(interp, fstatic, ip, ntPtr, fargs, 0);

        Jsi_Value *spretPtr = Jsi_ValueNew1(interp), *spretPtrOld = spretPtr;
        
        double timStart = 0;
        interp->activeFunc = fstatic;
        int docall = (excpt_ret==JSI_OK);
        if (interp->profile || interp->coverage)
            timStart = jsi_GetTimestamp();
        if (fstatic->type == FC_NORMAL) {
            if (docall) {
                excpt_ret = jsi_evalcode(ps, fstatic, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                    fargs, ntPtr, &spretPtr);
            }
            interp->funcCallCnt++;
        } else if (!fstatic->callback) {
            Jsi_LogError("can not call:\"%s()\"", fstatic->name);
        } else {
            int oldcf = fstatic->callflags.i;
            fstatic->callflags.bits.iscons = (as_constructor?JSI_CALL_CONSTRUCTOR:0);
            if (fstatic->f.bits.hasattr)
            {
#define SPTR(s) (s?s:"")
                if ((fstatic->f.bits.isobj) && ntPtr->vt != JSI_VT_OBJECT) {
                    excpt_ret = JSI_ERROR;
                    docall = 0;
                    Jsi_LogError("'this' is not object: \"%s()\"", fstatic->name);
                } else if ((!(fstatic->f.bits.iscons)) && as_constructor) {
                    excpt_ret = JSI_ERROR;
                    docall = 0;
                    Jsi_LogError("can not call as constructor: \"%s()\"", fstatic->name);
                } else {
                    int aCnt = Jsi_ValueGetLength(interp, fargs);
                    if (aCnt<(fstatic->cmdSpec->minArgs+adds)) {
                        Jsi_LogError("missing args, expected \"%s(%s)\" ", fstatic->cmdSpec->name, SPTR(fstatic->cmdSpec->argStr));
                        excpt_ret = JSI_ERROR;
                        docall = 0;
                    } else if (fstatic->cmdSpec->maxArgs>=0 && (aCnt>fstatic->cmdSpec->maxArgs+adds)) {
                        Jsi_LogError("extra args, expected \"%s(%s)\" ", fstatic->cmdSpec->name, SPTR(fstatic->cmdSpec->argStr));
                        excpt_ret = JSI_ERROR;
                        docall = 0;
                    }
                }
            }
            if (docall) {
                fstatic->fobj = fobj; // Backlink for bind.
                fstatic->callflags.bits.isdiscard = discard;
                excpt_ret = fstatic->callback(interp, fargs, 
                    ntPtr, &spretPtr, fstatic);
                interp->cmdCallCnt++;
            }
            fstatic->callflags.i = oldcf;
        }
        if (interp->profile || interp->coverage) {
            double timEnd = jsi_GetTimestamp(), timUsed = (timEnd - timStart);;
            assert(timUsed>=0);
            fstatic->allTime += timUsed;
            if (interp->framePtr->evalFuncPtr)
                interp->framePtr->evalFuncPtr->subTime += timUsed;
            else
                interp->subTime += timUsed;
        }
        if (calltrc && (interp->traceCall&jsi_callTraceReturn) && fstatic->name)
            jsi_TraceFuncCall(interp, fstatic, ip, ntPtr, NULL, spretPtr);
        if (!onam)
            fstatic->name = NULL;
        if (docall) {
            fstatic->callCnt++;
            if (excpt_ret == JSI_OK && !as_constructor && fstatic->retType && (interp->typeCheck.all || interp->typeCheck.run))
                excpt_ret = jsi_ArgTypeCheck(interp, fstatic->retType, spretPtr, "returned from", fstatic->name, 0, fstatic, 0);
        }
        interp->prevActiveFunc = pprevActive;
        interp->activeFunc = prevActive;

        if (as_constructor) {
            if (ntPtr->vt == JSI_VT_OBJECT)
                ntPtr->d.obj->constructor = tocall->d.obj;
            if (spretPtr->vt != JSI_VT_OBJECT) {
                Jsi_ValueReset(interp,&spretPtr);
                Jsi_ValueCopy(interp, spretPtr, ntPtr);
            }
        }
        
        jsi_SharedArgs(interp, fargs, fstatic, 0); /* make arg vars to shared arguments */
        Jsi_DecrRefCount(interp, ntPtr);
        ClearStack(interp,1);
        if (spretPtr == spretPtrOld) {
            Jsi_ValueMove(interp, _jsi_TOP, spretPtr);
            Jsi_DecrRefCount(interp, spretPtr);
        } else {
            /*  returning a (non-copied) value reference */
            Jsi_DecrRefCount(interp, _jsi_TOP);
            _jsi_TOP = spretPtr;
        }
        Jsi_DecrRefCount(interp, fargs);
    }
    interp->curFunction = oldCurFunc;
    return excpt_ret;
}

static INLINE Jsi_RC jsi_PushVar(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope, int context_id) {
    register Jsi_Interp *interp = ps->interp;
    FastVar *fvar = (FastVar *)ip->data;
    SIGASSERT(fvar,FASTVAR);
    Jsi_Value **dvPtr = &_jsi_STACKIDX(interp->framePtr->Sp), *dv = *dvPtr, *v = NULL;
    if (fvar->context_id == context_id && fvar->ps == ps) {
        v = fvar->var.lval;
    } else {
        char *varname = fvar->var.varname;
        v = Jsi_ValueObjLookup(interp, currentScope, varname, 1);
        if (v) {
            fvar->local = 1;
            if (v->vt == JSI_VT_UNDEF) {
                v->d.lookupFail = varname;
                v->f.bits.lookupfailed = 1;
            }
        } else {
            v = jsi_ScopeChainObjLookupUni(scope, varname);
            if (v) 
                fvar->local = 1;
            else {
                /* add to global scope.  TODO: do not define if a right_val??? */
                Jsi_Value *global_scope = scope->chains_cnt > 0 ? scope->chains[0]:currentScope;
                Jsi_Value key = VALINIT, *kPtr = &key; // Note: a string key so no reset needed.
                Jsi_ValueMakeStringKey(interp, &kPtr, varname);
                v = jsi_ValueObjKeyAssign(interp, global_scope, &key, NULL, JSI_OM_DONTENUM);
                if (v->vt == JSI_VT_UNDEF) {
                    v->d.lookupFail = varname;
                    v->f.bits.lookupfailed = 1;
                }
                jsi_ValueDebugLabel(v, "var", varname);
                bool isNew;
                Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);
                if (hPtr && isNew)
                    Jsi_HashValueSet(hPtr, 0);
            }
        }
        
        Jsi_IncrRefCount(interp, v);
        //if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT)
        //    v->f.bits.onstack = 1;  /* Indicate that a double free is required for object. */

    }
    if (dv != v && (dv->vt != JSI_VT_VARIABLE || dv->d.lval != v)) {
        if (dv->vt != JSI_VT_VARIABLE)
            Jsi_ValueReset(interp, dvPtr);
        dv->vt = JSI_VT_VARIABLE;
        SIGASSERT(v, VALUE);
        dv->d.lval = v;
        dv->f.bits.local = (fvar->local);
        //Jsi_IncrRefCount(interp, v);
    }
    SIGASSERT(v, VALUE);
    jsiPush(interp,1);
    return JSI_OK;
}

static INLINE void jsi_PushFunc(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope) {
    /* TODO: now that we're caching ps, may need to reference function ps for context_id??? */
    Jsi_Interp *interp = ps->interp;
    Jsi_FuncObj *fo = jsi_FuncObjNew(interp, (Jsi_Func *)ip->data);
    fo->scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);
    obj->d.fobj = fo;
    
    Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp), *fun_prototype = jsi_ObjValueNew(interp);
    fun_prototype->d.obj->__proto__ = interp->Object_prototype;                
    Jsi_ValueMakeObject(interp, &v, obj);
    Jsi_ValueInsert(interp, v, "prototype", fun_prototype, JSI_OM_DONTDEL|JSI_OM_DONTENUM);
    /* TODO: make own prototype and prototype.constructor */
    
    bool isNew;
    Jsi_HashEntry *hPtr;  Jsi_Value *vv;
    if (interp->framePtr->Sp == 1 && (vv=_jsi_STACKIDX(0))->vt == JSI_VT_VARIABLE) {
        const char *varname = NULL;
        vv = vv->d.lval;
        if (vv && vv->f.bits.lookupfailed && vv->d.lookupFail) {
            varname = vv->d.lookupFail;
            vv->f.bits.lookupfailed = 0;
        }
        if (varname) {
            if (!fo->func->name)
                fo->func->name = varname;
            hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);
            if (hPtr)
                Jsi_HashValueSet(hPtr, obj);
        }
    }
    hPtr = Jsi_HashEntryNew(interp->funcObjTbl, fo, &isNew);
    if (hPtr && isNew) {
        Jsi_ObjIncrRefCount(interp, obj);
        Jsi_HashValueSet(hPtr, obj);
    }
    jsiPush(interp,1);
}

static Jsi_RC evalSubscript(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *idx, jsi_OpCode *ip,  jsi_OpCode *end,
    Jsi_Value *currentScope)
{
    Jsi_RC rc = JSI_OK;
    VarDeref(interp,2);
    int isnull;
    if ((isnull=Jsi_ValueIsNull(interp, src)) || Jsi_ValueIsUndef(interp, src)) {
        Jsi_LogError("invalid subscript of %s", (isnull?"null":"undefined"));
        jsiPop(interp, 1);
        return JSI_ERROR;
    }
    Jsi_String *str = jsi_ValueString(src);
    if (str && Jsi_ValueIsNumber(interp, idx)) {
        int bLen, cLen;
        char bbuf[10], *cp = Jsi_ValueString(interp, src, &bLen);
        int n = (int)idx->d.num;
        cLen = bLen;
#if JSI__UTF8
        if (str->flags&JSI_IS_UTF || !(str->flags&JSI_UTF_CHECKED)) {
            cLen = Jsi_NumUtfChars(cp, -1);
            str->flags |= JSI_UTF_CHECKED;
            if (cLen != bLen)
                str->flags |= JSI_IS_UTF;
        }
#endif
        if (n<0 || n>=cLen) {
            Jsi_ValueMakeUndef(interp, &src);
        } else {
            if (cLen != bLen)
                Jsi_UtfGetIndex(cp, n, bbuf);
            else {
                bbuf[0] = cp[n];
                bbuf[1] = 0;
            }
            Jsi_ValueMakeStringDup(interp, &src, bbuf);
        }
        jsiPop(interp, 1);
        return rc;
    }
    Jsi_ValueToObject(interp, src);
    if (interp->hasCallee && (src->d.obj == currentScope->d.obj || (interp->framePtr->arguments && src->d.obj == interp->framePtr->arguments->d.obj))) {
        if (idx->vt == JSI_VT_STRING && Jsi_Strcmp(idx->d.s.str, "callee") == 0) {
            ClearStack(interp,1);
            Jsi_ValueMakeStringKey(interp, &idx, "\1callee\1");
        }
    }
    int bsc = Jsi_ValueIsObjType(interp, src, JSI_OT_NUMBER); // Previous bad subscript.
    if (bsc == 0 && interp->lastSubscriptFail && interp->lastSubscriptFail->vt != JSI_VT_UNDEF)
        Jsi_ValueReset(interp, &interp->lastSubscriptFail);

    if (src->vt != JSI_VT_UNDEF) {
        Jsi_Value res = VALINIT, *resPtr = &res;
        jsi_ValueSubscriptLen(interp, src, idx, &resPtr, (uintptr_t)ip->data);
        //int isfcall = ((ip+3)<end && ip[2].op == OP_FCALL);
        if (res.vt == JSI_VT_UNDEF && bsc == 0) {
            /* eg. so we can list available commands for  "db.xx()" */
            if (idx->vt == JSI_VT_STRING)
                interp->lastSubscriptFailStr = idx->d.s.str;
            Jsi_ValueDup2(interp, &interp->lastSubscriptFail, src);
        }
        ClearStack(interp,2);
        if (resPtr == &res) {
            Jsi_ValueCopy(interp, src, &res); /*TODO: need to rethink this. */
        } else
            Jsi_ValueMove(interp, src, resPtr); 
        if (res.vt == JSI_VT_OBJECT || res.vt == JSI_VT_STRING)  // TODO:*** Undo using ValueCopy twice. ***
            Jsi_ValueReset(interp, &resPtr);
    }
    jsiPop(interp, 1);
    return rc;
}

void jsi_Debugger(void) {
}

Jsi_RC _jsi_evalcode(jsi_Pstate *ps, Jsi_OpCodes *opcodes, 
     jsi_ScopeChain *scope, Jsi_Value *currentScope,
     Jsi_Value *_this, Jsi_Value *vret)
{
    register Jsi_Interp* interp = ps->interp;
    jsi_OpCode *ip = &opcodes->codes[0];
    Jsi_RC rc = JSI_OK;
    int curLine = 0;
    int context_id = ps->_context_id++, lop = -1;
    jsi_OpCode *end = &opcodes->codes[opcodes->code_len];
    TryList  *trylist = NULL;
    bool strict = jsi_IsStrictMode(interp);
    const char *curFile = NULL;
    
    if (currentScope->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Eval: current scope is not a object");
        return JSI_ERROR;
    }
    
    while(ip < end && rc == JSI_OK) {
        int plop = ip->op;

        if (ip->logflag) { // Mask out LogDebug, etc if not enabled.
            interp->curIp = ip;
            switch (ip->logflag) {
                case jsi_Oplf_assert:
                    if (!interp->asserts) {
                        ip++;
                        if (ip->logflag != jsi_Oplf_assert && (ip->op == OP_POP || ip->op == OP_RET))
                            ip++;
                        continue;
                    }
                    break;
                case jsi_Oplf_debug:
                    if (!interp->logOpts.debug && !(interp->framePtr->logflag &(1<<jsi_Oplf_debug))) {
                        ip++;
                        if (ip->logflag != jsi_Oplf_debug && (ip->op == OP_POP || ip->op == OP_RET))
                            ip++;
                        continue;
                    }
                    break;
                case jsi_Oplf_test:
                    if (!interp->logOpts.test && !(interp->framePtr->logflag &(1<<jsi_Oplf_test))) {
                        ip++;
                        if (ip->logflag != jsi_Oplf_test && (ip->op == OP_POP || ip->op == OP_RET))
                            ip++;
                        continue;
                    }
                    break;
                case jsi_Oplf_trace:
                    if (!interp->logOpts.trace && !(interp->framePtr->logflag &(1<<jsi_Oplf_trace))) {
                        ip++;
                        if (ip->logflag != jsi_Oplf_trace && (ip->op == OP_POP || ip->op == OP_RET))
                            ip++;
                        continue;
                    }
                    break;
                default:
                    break;
            }
        }
        if (interp->exited) {
            rc = JSI_ERROR;
            break;
        }
        interp->opCnt++;
        if (interp->maxOpCnt && interp->opCnt > interp->maxOpCnt) {
            rc = Jsi_LogError("Exceeded execution cap: %d", interp->opCnt);
        }
        if (interp->level > interp->maxDepth) {
            rc = Jsi_LogError("Exceeded call depth: %d", interp->level);
            break;
        }
        if (interp->opTrace) {
            DumpInstr(interp, ps, _this, trylist, ip, opcodes);
        }
        if (interp->parent && interp->busyCallback && (interp->opCnt%(interp->busyInterval<=0?100000:interp->busyInterval))==0) {
            // TODO: use actual time interval rather than opCnt.
            if (interp->busyCallback[0]==0 || !Jsi_Strcmp(interp->busyCallback, "update"))
                Jsi_EventProcess(interp->parent, -1);
            else {
                Jsi_DString nStr;
                Jsi_DSInit(&nStr);
                Jsi_DSPrintf(&nStr, "[\"#Interp_%d\", %d]", interp->objId, interp->opCnt);
                if (Jsi_CommandInvokeJSON(interp->parent, interp->busyCallback, Jsi_DSValue(&nStr), NULL) != JSI_OK)
                    rc = JSI_ERROR;
                Jsi_DSFree(&nStr);
            }
        }
        ip->hit=1;
#ifndef USE_STATIC_STACK
        if ((interp->maxStack-interp->framePtr->Sp)<STACK_MIN_PAD)
            jsiSetupStack(interp);
#endif
        jsiPush(interp,0);
        interp->curIp = ip;
        // Fill in line/file info from previous OPs.
        if (!ip->fname) {
            ip->Line = curLine;
            ip->fname = curFile;
        } else {
            curLine = ip->Line;
            curFile = ip->fname;
        }
        if (interp->debugOpts.hook) {
            interp->framePtr->fileName = ip->fname;
            interp->framePtr->line = ip->Line;
            if ((rc = (*interp->debugOpts.hook)(interp, ip->fname, ip->Line, interp->framePtr->level, interp->curFunction, jsi_opcode_string(ip->op), ip, NULL)) != JSI_OK)
                break;
        }

        switch(ip->op) {
            case OP_NOP:
            case OP_LASTOP:
                break;
            case OP_PUSHUND:
                Jsi_ValueMakeUndef(interp, &_jsi_STACKIDX(interp->framePtr->Sp));
                jsiPush(interp,1);
                break;
            case OP_PUSHNULL:
                Jsi_ValueMakeNull(interp, &_jsi_STACKIDX(interp->framePtr->Sp));
                jsiPush(interp,1);
                break;
            case OP_PUSHBOO:
                Jsi_ValueMakeBool(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (uintptr_t)ip->data);
                jsiPush(interp,1);
                break;
            case OP_PUSHNUM:
                Jsi_ValueMakeNumber(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (*((Jsi_Number *)ip->data)));
                jsiPush(interp,1);
                break;
            case OP_PUSHSTR: {
                Jsi_ValueMakeStringKey(interp,&_jsi_STACKIDX(interp->framePtr->Sp), (char*)ip->data);
                interp->lastPushStr = Jsi_ValueString(interp, _jsi_STACKIDX(interp->framePtr->Sp), NULL);
                jsiPush(interp,1);
                break;
            }
            case OP_PUSHVAR: {
                rc = jsi_PushVar(ps, ip, scope, currentScope, context_id);      
                break;
            }
            case OP_PUSHFUN: {
                jsi_PushFunc(ps, ip, scope, currentScope);
                break;
            }
            case OP_NEWFCALL:
                if (interp->maxUserObjs && interp->userObjCnt > interp->maxUserObjs) {
                    rc = Jsi_LogError("Max 'new' count exceeded");
                    break;
                }
            case OP_FCALL: {
                /* TODO: need reliable way to capture func string name to handle unknown functions.*/
                int discard = ((ip+2)<end && ip[1].op == OP_POP);
                if (jsiEvalFunction(ps, ip, discard) != JSI_OK) {        /* throw an execption */
                    do_throw("fcall");

                }
                strict = jsi_IsStrictMode(interp);
                /* TODO: new Function return a function without scopechain, add here */
                break;
            }
            case OP_SUBSCRIPT: {
                rc = evalSubscript(interp, _jsi_TOQ, _jsi_TOP, ip, end, currentScope);
                break;
            }
            case OP_ASSIGN: {
                if ((uintptr_t)ip->data == 1) {
                    VarDeref(interp,1);
                    rc = jsi_ValueAssign(interp, _jsi_TOQ, _jsi_TOP, lop);                    
                    jsiPop(interp,1);
                } else {
                    VarDeref(interp, 3);
                    Jsi_Value *v3 = _jsi_STACKIDX(interp->framePtr->Sp-3);
                    if (v3->vt == JSI_VT_OBJECT) {
                        jsi_ValueObjKeyAssign(interp, v3, _jsi_TOQ, _jsi_TOP, 0);
                        jsi_ValueDebugLabel(_jsi_TOP, "assign", NULL);
                    } else if (strict)
                        Jsi_LogWarn("assign to a non-exist object");
                    ClearStack(interp,3);
                    Jsi_ValueCopy(interp,v3, _jsi_TOP);
                    jsiPop(interp, 2);
                }
                break;
            }
            case OP_PUSHREG: {
                Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
                obj->d.robj = (Jsi_Regex *)ip->data;
                Jsi_ValueMakeObject(interp, &_jsi_STACKIDX(interp->framePtr->Sp), obj);
                jsiPush(interp,1);
                break;
            }
            case OP_PUSHARG:
                //Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), currentScope);
                
                if (!interp->framePtr->arguments) {
                    interp->framePtr->arguments = Jsi_ValueNewObj(interp,
                        Jsi_ObjNewArray(interp, currentScope->d.obj->arr, currentScope->d.obj->arrCnt, 0));
                    Jsi_IncrRefCount(interp, interp->framePtr->arguments);
                    if (interp->hasCallee) {
                        Jsi_Value *callee = Jsi_ValueObjLookup(interp, currentScope, "\1callee\1", 0);
                        if (callee)
                            Jsi_ValueInsert(interp, interp->framePtr->arguments, "\1callee\1", callee, JSI_OM_DONTENUM);
                    }
                    // interp->framePtr->arguments->d.obj->__proto__ = interp->Object_prototype; // ecma
                }
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), interp->framePtr->arguments);
                jsiPush(interp,1);
                break;
            case OP_PUSHTHS: //TODO: Value copy can cause memory leak!
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), _this);
                jsiPush(interp,1);
                break;
            case OP_PUSHTOP:
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), _jsi_TOP);
                jsiPush(interp,1);
                break;
            case OP_UNREF:
                VarDeref(interp,1);
                break;
            case OP_PUSHTOP2:
                Jsi_ValueCopy(interp, _jsi_STACKIDX(interp->framePtr->Sp), _jsi_TOQ);
                Jsi_ValueCopy(interp, _jsi_STACKIDX(interp->framePtr->Sp+1), _jsi_TOP);
                jsiPush(interp, 2);
                break;
            case OP_CHTHIS: {
                if (ip->data) {
                    int t = interp->framePtr->Sp - 2;
                    Assert(t>=0);
                    Jsi_Value *v = _jsi_THISIDX(t);
                    ClearThis(interp, t);
                    Jsi_ValueCopy(interp, v, _jsi_TOQ);
                    if (v->vt == JSI_VT_VARIABLE) {
                        Jsi_ValueCopy(interp, v, v->d.lval);
                    }
                    Jsi_ValueToObject(interp, v);
                }
                break;
            }
            case OP_LOCAL: {
                Jsi_Value key = VALINIT, *kPtr = &key; // Note we use a string key so no reset needed.
                Jsi_ValueMakeStringKey(interp, &kPtr, (char*)ip->data);
                jsi_ValueObjKeyAssign(interp, currentScope, kPtr, NULL, JSI_OM_DONTENUM);
                context_id = ps->_context_id++;
                break;
            }
            case OP_POP:
                if ((interp->evalFlags&JSI_EVAL_RETURN) && (ip+1) >= end && 
                (Jsi_ValueIsObjType(interp, _jsi_TOP, JSI_OT_ITER)==0 &&
                Jsi_ValueIsObjType(interp, _jsi_TOP, JSI_OT_FUNCTION)==0)) {
                    /* Interactive and last instruction is a pop: save result. */
                    Jsi_ValueMove(interp, vret,_jsi_TOP); /*TODO***: correct ***/
                    _jsi_TOP->vt = JSI_VT_UNDEF;
                }
                jsiPop(interp, (uintptr_t)ip->data);
                break;
            case OP_NEG:
                VarDeref(interp,1);
                Jsi_ValueToNumber(interp, _jsi_TOP);
                rc = _jsi_StrictChk(_jsi_TOP);
                _jsi_TOP->d.num = -(_jsi_TOP->d.num);
                break;
            case OP_POS:
                VarDeref(interp,1);
                Jsi_ValueToNumber(interp, _jsi_TOP);
                rc = _jsi_StrictChk(_jsi_TOP);
                break;
            case OP_NOT: {
                int val = 0;
                VarDeref(interp,1);
                
                val = Jsi_ValueIsTrue(interp, _jsi_TOP);
                
                ClearStack(interp,1);
                Jsi_ValueMakeBool(interp, &_jsi_TOP, !val);
                break;
            }
            case OP_BNOT: {
                VarDeref(interp,1);
                jsi_ValueToOInt32(interp, _jsi_TOP);
                rc = _jsi_StrictChk(_jsi_TOP);
                _jsi_TOP->d.num = (Jsi_Number)(~((int)_jsi_TOP->d.num));
                break;
            }
            case OP_ADD: {
                VarDeref(interp,2);
                Jsi_Value *v, *v1 = _jsi_TOP, *v2 = _jsi_TOQ;
                int l1, l2;
                if (strict)
                    if (Jsi_ValueIsUndef(interp, v1) || Jsi_ValueIsUndef(interp, v2)) {
                        rc = Jsi_LogError("operand value to + is undefined");
                        break;
                    }
                char *s1 = Jsi_ValueString(interp, v1, &l1);
                char *s2 = Jsi_ValueString(interp, v2, &l2);
                if (s1 || s2) {
                    char *str;
                    if (!(s1 && s2)) {
                        v = (s1 ? v2 : v1);
                        jsi_ValueToPrimitive(interp, &v);
                        Jsi_ValueToString(interp, v, NULL);
                        str = Jsi_ValueString(interp, v, (s1?&l2:&l1));
                        if (s1) s2 = str; else s1 = str;
                    }
                    Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);
                    Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);
                    str = (char*)Jsi_Malloc(l1+l2+1);
                    memcpy(str, s2, l2);
                    memcpy(str+l2, s1, l1);
                    str[l1+l2] = 0;
                    ClearStack(interp,2);
                    Jsi_ValueMakeString(interp, &v2, str);
                } else {
                    Jsi_ValueToNumber(interp, v1);
                    Jsi_ValueToNumber(interp, v2);
                    rc = _jsi_StrictChk2(v1, v2);
                    Jsi_Number n = v1->d.num + v2->d.num;
                    ClearStack(interp,2);
                    Jsi_ValueMakeNumber(interp, &v2, n);
                }
                jsiPop(interp,1);
                break;
            }
            case OP_IN: {
                Jsi_Value *v, *vl;
                const char *cp = NULL;
                Jsi_Number nval;
                VarDeref(interp,2);
                vl = _jsi_TOQ;
                v = _jsi_TOP;
                if (Jsi_ValueIsString(interp,vl))
                    cp = Jsi_ValueGetStringLen(interp, vl, NULL);
                else if (Jsi_ValueIsNumber(interp,vl))
                    Jsi_ValueGetNumber(interp, vl, &nval);
                else {
                    if (strict)
                        Jsi_LogWarn("expected string or number before IN");
                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);
                    jsiPop(interp,1);
                    break;
                }
                
                if (v->vt == JSI_VT_VARIABLE) {
                    v = v->d.lval;
                    SIGASSERT(v, VALUE);
                }
                if (v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_OBJECT) {
                    if (strict)
                        Jsi_LogWarn("expected object after IN");
                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);
                    jsiPop(interp,1);
                    break;
                }
                int bval = 0;
                char nbuf[100];
                Jsi_Value *vv;
                Jsi_Obj *obj = v->d.obj;
                if (!cp) {
                    snprintf(nbuf, sizeof(nbuf), "%d", (int)nval);
                    cp = nbuf;
                }
                if (obj->arr) {
                    vv = jsi_ObjArrayLookup(interp, obj, (char*)cp);
                } else {
                    vv = Jsi_TreeObjGetValue(obj, (char*)cp, 1);
                }
                bval = (vv != 0);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, bval);
                jsiPop(interp,1);
                break;
            }
            case OP_SUB: 
                common_math_opr(-); break;
            case OP_MUL:
                common_math_opr(*); break;
            case OP_DIV:
                common_math_opr(/); break;
            case OP_MOD: {
                VarDeref(interp,2);
                if (!Jsi_ValueIsType(interp,_jsi_TOP, JSI_VT_NUMBER))
                    Jsi_ValueToNumber(interp, _jsi_TOP);
                if (!Jsi_ValueIsType(interp,_jsi_TOQ, JSI_VT_NUMBER))
                    Jsi_ValueToNumber(interp, _jsi_TOQ);
                rc = _jsi_StrictChk2(_jsi_TOP,_jsi_TOQ);
                _jsi_TOQ->d.num = fmod(_jsi_TOQ->d.num, _jsi_TOP->d.num);
                jsiPop(interp,1);
                break;
            }
            case OP_LESS:
                VarDeref(interp,2);
                rc = logic_less(interp,2,1);
                jsiPop(interp,1);
                break;
            case OP_GREATER:
                VarDeref(interp,2);
                rc = logic_less(interp,1,2);
                jsiPop(interp,1);
                break;
            case OP_LESSEQU:
                VarDeref(interp,2);
                rc = logic_less(interp,1,2);
                _jsi_TOQ->d.val = !_jsi_TOQ->d.val;
                jsiPop(interp,1);
                break;
            case OP_GREATEREQU:
                VarDeref(interp,2);
                rc = logic_less(interp,2,1);
                _jsi_TOQ->d.val = !_jsi_TOQ->d.val;
                jsiPop(interp,1);
                break;
            case OP_EQUAL:
            case OP_NOTEQUAL: {
                VarDeref(interp,2);
                int r = Jsi_ValueCmp(interp, _jsi_TOP, _jsi_TOQ, 0);
                r = (ip->op == OP_EQUAL ? !r : r);
                ClearStack(interp,2);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);
                jsiPop(interp,1);
                break;
            }
            case OP_STRICTEQU:
            case OP_STRICTNEQ: {
                int r = 0;
                VarDeref(interp,2);
                rc = _jsi_StrictUChk3(_jsi_TOQ, _jsi_TOP);
                r = !Jsi_ValueIsEqual(interp, _jsi_TOP, _jsi_TOQ);
                r = (ip->op == OP_STRICTEQU ? !r : r);
                ClearStack(interp,2);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);
                jsiPop(interp,1);
                break;
            }
            case OP_BAND: 
                common_bitwise_opr(&); break;
            case OP_BOR:
                common_bitwise_opr(|); break;
            case OP_BXOR:
                common_bitwise_opr(^); break;
            case OP_SHF: {
                VarDeref(interp,2);
                jsi_ValueToOInt32(interp, _jsi_TOQ);
                jsi_ValueToOInt32(interp, _jsi_TOP);
                int t1 = (int)_jsi_TOQ->d.num;
                int t2 = ((unsigned int)_jsi_TOP->d.num) & 0x1f;
                if (ip->data) {                 /* shift right */
                    if ((uintptr_t)ip->data == 2) {   /* unsigned shift */
                        unsigned int t3 = (unsigned int)t1;
                        t3 >>= t2;
                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t3);
                    } else {
                        t1 >>= t2;
                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);
                    }
                } else {
                    t1 <<= t2;
                    Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);
                }
                jsiPop(interp,1);
                break;
            }
            case OP_KEY: {
                VarDeref(interp,1);
                if (ip->isof && !Jsi_ValueIsArray(interp, _jsi_TOP)) {
                    rc = Jsi_LogError("operand not an array");
                    break;
                }
                if (_jsi_TOP->vt != JSI_VT_UNDEF && _jsi_TOP->vt != JSI_VT_NULL)
                    Jsi_ValueToObject(interp, _jsi_TOP);
                Jsi_Value *spret = Jsi_ValueNew1(interp);
                jsi_ValueObjGetKeys(interp, _jsi_TOP, spret, ip->isof);
                Jsi_ValueReplace(interp, _jsi_STACK+interp->framePtr->Sp, spret);  
                Jsi_DecrRefCount(interp, spret);  
                jsiPush(interp,1);
                break;
            }
            case OP_NEXT: {
                Jsi_Value *toq = _jsi_TOQ, *top = _jsi_TOP;
                if (toq->vt != JSI_VT_OBJECT || toq->d.obj->ot != JSI_OT_ITER) Jsi_LogBug("next: toq not a iter\n");
                if (top->vt != JSI_VT_VARIABLE) {
                    rc = Jsi_LogError ("invalid for/in left hand-side");
                    break;
                }
                if (strict && top->f.bits.local==0) {
                    const char *varname = "";
                    Jsi_Value *v = top->d.lval;
                    if (v->f.bits.lookupfailed)
                        varname = v->d.lookupFail;

                    rc = Jsi_LogError("function created global: \"%s\"", varname);
                    break;
                }
                
                Jsi_IterObj *io = toq->d.obj->d.iobj;
                if (io->iterCmd) {
                    io->iterCmd(io, top, _jsi_STACKIDX(interp->framePtr->Sp-3), io->iter++);
                } else {
                    while (io->iter < io->count) {
                        if (!io->isArrayList) {
                            if (Jsi_ValueKeyPresent(interp, _jsi_STACKIDX(interp->framePtr->Sp-3), io->keys[io->iter],1)) 
                                break;
                        } else {
                            while (io->cur < io->obj->arrCnt) {
                                if (io->obj->arr[io->cur]) break;
                                io->cur++;
                            }
                            if (io->cur >= io->obj->arrCnt) {
                                /* TODO: Is this really a bug??? */
                                /* Jsi_LogBug("NOT FOUND LIST ARRAY");*/
                                io->iter = io->count;
                                break;
                            } else if (io->obj->arr[io->cur]) {
                                io->cur++;
                                break;
                            }
                        }
                        io->iter++;
                    }
                    if (io->iter >= io->count) {
                        ClearStack(interp,1);
                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 0);
                    } else {
                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;
                        SIGASSERT(v, VALUE);
                        Jsi_ValueReset(interp, vPtr);
                        if (io->isArrayList) {
                            if (!io->isof)
                                Jsi_ValueMakeNumber(interp, &v, io->cur-1);
                            else if (!io->obj->arr[io->cur-1])
                                Jsi_ValueMakeNull(interp, &v);
                            else
                                Jsi_ValueCopy(interp, v, io->obj->arr[io->cur-1]);
                        } else
                            Jsi_ValueMakeStringKey(interp, &v, io->keys[io->iter]);
                        io->iter++;
                        
                        ClearStack(interp,1);
                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 1);
                    }
                    break;
                }
            }
            case OP_INC:
            case OP_DEC: {
                int inc = ip->op == OP_INC ? 1 : -1;
                
                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {
                    rc = Jsi_LogError("operand not left value");
                    break;
                }
                Jsi_Value *v = _jsi_TOP->d.lval;
                SIGASSERT(v, VALUE);
                Jsi_ValueToNumber(interp, v);
                rc = _jsi_StrictChk(v);
                v->d.num += inc;
                    
                VarDeref(interp,1);
                if (ip->data) {
                    _jsi_TOP->d.num -= inc;
                }
                break;
            }
            case OP_TYPEOF: {
                const char *typ;
                Jsi_Value *v = _jsi_TOP;
                if (v->vt == JSI_VT_VARIABLE) {
                    v = v->d.lval;
                    SIGASSERT(v, VALUE);
                }
                typ = Jsi_ValueTypeStr(interp, v);
                VarDeref(interp,1);
                Jsi_ValueMakeStringKey(interp, &_jsi_TOP, (char*)typ);
                break;
            }
            case OP_INSTANCEOF: {

                VarDeref(interp,2);
                int bval = Jsi_ValueInstanceOf(interp, _jsi_TOQ, _jsi_TOP);
                jsiPop(interp,1);
                Jsi_ValueMakeBool(interp, &_jsi_TOP, bval);
                break;
            }
            case OP_JTRUE:
            case OP_JFALSE: 
            case OP_JTRUE_NP:
            case OP_JFALSE_NP: {
                VarDeref(interp,1);
                int off = (uintptr_t)ip->data - 1; 
                int r = Jsi_ValueIsTrue(interp, _jsi_TOP);
                
                if (ip->op == OP_JTRUE || ip->op == OP_JFALSE) jsiPop(interp,1);
                ip += ((ip->op == OP_JTRUE || ip->op == OP_JTRUE_NP) ^ r) ? 0 : off;
                break;
            }
            case OP_JMPPOP: 
                jsiPop(interp, ((jsi_JmpPopInfo *)ip->data)->topop);
            case OP_JMP: {
                int off = (ip->op == OP_JMP ? (uintptr_t)ip->data - 1
                            : (uintptr_t)((jsi_JmpPopInfo *)ip->data)->off - 1);

                while (1) {
                    if (trylist == NULL) break;
                    jsi_OpCode *tojmp = ip + off;

                    /* jmp out of a try block, should execute the finally block */
                    /* while jmp out a 'with' block, restore the scope */

                    if (trylist->type == TL_TRY) { 
                        if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) break;
                        
                        if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {
                            trylist->d.td.last_op = LOP_JMP;
                            trylist->d.td.ld.tojmp = tojmp;
                            
                            ip = trylist->d.td.fstart - 1;
                            off = 0;
                            break;
                        } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {
                            pop_try(trylist);
                        } else Jsi_LogBug("jmp within a try, but not in its scope?");
                    } else {
                        /* with block */
                        
                        if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) break;
                        
                        restore_scope();
                        pop_try(trylist);
                    }
                }
                
                ip += off;
                break;
            }
            case OP_EVAL: {
                int stackargc = (uintptr_t)ip->data;
                VarDeref(interp, stackargc);

                int r = 0;
                Jsi_Value *spPtr = Jsi_ValueNew1(interp);
                if (stackargc > 0) {
                    if (_jsi_STACKIDX(interp->framePtr->Sp - stackargc)->vt == JSI_VT_UNDEF) {
                        Jsi_LogError("undefined value to eval()");
                        goto undef_eval;
                    }
                    char *pro = Jsi_ValueString(interp, _jsi_STACKIDX(interp->framePtr->Sp - stackargc), NULL);
                    if (pro) {
                        pro = Jsi_Strdup(pro);
                        r = jsiEvalOp(interp, ps, pro, scope, currentScope, _this, &spPtr);
                        Jsi_Free(pro);
                    } else {
                        Jsi_ValueCopy(interp, spPtr, _jsi_STACKIDX(interp->framePtr->Sp - stackargc));
                    }
                }
undef_eval:
                jsiPop(interp, stackargc);
                Jsi_ValueCopy(interp, _jsi_STACK[interp->framePtr->Sp], spPtr); /*TODO: is this correct?*/
                Jsi_DecrRefCount(interp, spPtr);
                jsiPush(interp,1);

                if (r) {
                    do_throw("eval");
                }
                break;
            }
            case OP_RET: {
                if (interp->framePtr->Sp>=1 && ip->data) {
                    VarDeref(interp,1);
                    Jsi_ValueMove(interp, vret, _jsi_TOP);
                }
                jsiPop(interp, (uintptr_t)ip->data);
                interp->didReturn = 1;
                if (interp->framePtr->withDepth) {
                    rc=Jsi_LogError("return inside 'with' is not supported in Jsi");
                    goto done;
                }
                if (trylist) {
                    int isTry = 0;
                    while (trylist) {
                        if (trylist->type == TL_TRY && trylist->inCatch)
                            restore_scope();
                        pop_try(trylist);
                    }
                    if (isTry)
                        rc = Jsi_LogError("return inside 'try/catch' is not supported in Jsi");
                    goto done;
                }
                ip = end;
                break;
            }
            case OP_DELETE: {
                int count = (uintptr_t)ip->data;
                if (count == 1) { // Non-standard.
                    if (_jsi_TOP->vt != JSI_VT_VARIABLE)
                        rc = Jsi_LogError("delete a right value");
                    else {
                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;
                        SIGASSERT(v, VALUE);
                        if (v->f.bits.dontdel) {
                            if (strict) rc = Jsi_LogWarn("delete not allowed");
                        } else if (v != currentScope) {
                            Jsi_ValueReset(interp,vPtr);     /* not allow to delete arguments */
                        }
                        else if (strict)
                            Jsi_LogWarn("Delete arguments");
                    }
                    jsiPop(interp,1);
                } else if (count == 2) {
                    VarDeref(interp,2);
                    assert(interp->framePtr->Sp>=2);
                    if (strict) {
                        if (_jsi_TOQ->vt != JSI_VT_OBJECT) Jsi_LogWarn("delete non-object key, ignore");
                        if (_jsi_TOQ->d.obj == currentScope->d.obj) Jsi_LogWarn("Delete arguments");
                    }
                    ValueObjDelete(interp, _jsi_TOQ, _jsi_TOP, 0);
                    
                    jsiPop(interp,2);
                } else Jsi_LogBug("delete");
                break;
            }
            case OP_OBJECT: {
                int itemcount = (uintptr_t)ip->data;
                Assert(itemcount>=0);
                VarDeref(interp, itemcount * 2);
                Jsi_Obj *obj = Jsi_ObjNewObj(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount*2), itemcount*2);
                jsiPop(interp, itemcount * 2 - 1);       /* one left */
                ClearStack(interp,1);
                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);
                break;
            }
            case OP_ARRAY: {
                int itemcount = (uintptr_t)ip->data;
                Assert(itemcount>=0);
                VarDeref(interp, itemcount);
                Jsi_Obj *obj = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount), itemcount, 1);
                jsiPop(interp, itemcount - 1);
                ClearStack(interp,1);
                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);
                break;
            }
            case OP_STRY: {
                jsi_TryInfo *ti = (jsi_TryInfo *)ip->data;
                TryList *n = trylist_new(TL_TRY, scope, currentScope);
                
                n->d.td.tstart = ip;                            /* make every thing pointed to right pos */
                n->d.td.tend = n->d.td.tstart + ti->trylen;
                n->d.td.cstart = n->d.td.tend + 1;
                n->d.td.cend = n->d.td.tend + ti->catchlen;
                n->d.td.fstart = n->d.td.cend + 1;
                n->d.td.fend = n->d.td.cend + ti->finallen;
                n->d.td.tsp = interp->framePtr->Sp;
                n->inCatch=0;
                n->inFinal=0;

                push_try(trylist, n);
                break;
            }
            case OP_ETRY: {             /* means nothing happen go to final */
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected ETRY opcode??");

                ip = trylist->d.td.fstart - 1;
                break;
            }
            case OP_SCATCH: {
                if (trylist == NULL || trylist->type != TL_TRY) 
                    Jsi_LogBug("Unexpected SCATCH opcode??");

                if (!ip->data) {
                    do_throw("catch");
                } else {
                    trylist->inCatch=1;
                    /* new scope and make var */
                    scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
                    currentScope = jsi_ObjValueNew(interp);
                    interp->framePtr->ingsc = scope;  //TODO: changing frame
                    interp->framePtr->incsc = currentScope;
                    Jsi_IncrRefCount(interp, currentScope);
                    Jsi_Value *excpt = Jsi_ValueNew1(interp);
                    if (ps->last_exception && ps->last_exception->vt != JSI_VT_UNDEF) {
                        Jsi_Value *ple = ps->last_exception;
                        Jsi_ValueCopy(interp, excpt, ple);
                        Jsi_ValueReset(interp, &ps->last_exception);
                    } else if (interp->errMsgBuf[0]) {
                        Jsi_ValueMakeStringDup(interp, &excpt, interp->errMsgBuf);
                        interp->errMsgBuf[0] = 0;
                    }
                    Jsi_ValueInsert(interp, currentScope, (char*)ip->data, excpt, JSI_OM_DONTENUM);
                    Jsi_DecrRefCount(interp, excpt);
                    context_id = ps->_context_id++;
                }
                break;
            }
            case OP_ECATCH: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected ECATCH opcode??");

                trylist->inCatch=0;
                ip = trylist->d.td.fstart - 1;
                break;
            }
            case OP_SFINAL: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected SFINAL opcode??");

                /* restore scatch scope chain */
                trylist->inFinal = 1;
                restore_scope();
                break;
            }
            case OP_EFINAL: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected EFINAL opcode??");

                trylist->inFinal = 0;
                int last_op = trylist->d.td.last_op;
                jsi_OpCode *tojmp = (last_op == LOP_JMP ? trylist->d.td.ld.tojmp : 0);
                
                pop_try(trylist);

                if (last_op == LOP_THROW) {
                    do_throw("finally");
                } else if (last_op == LOP_JMP) {
                    while (1) {
                        if (trylist == NULL) {
                            ip = tojmp;
                            break;
                        }
                        /* same as jmp opcode, see above */
                        if (trylist->type == TL_TRY) {
                            if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) {
                                ip = tojmp;
                                break;
                            }
                            
                            if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {
                                trylist->d.td.last_op = LOP_JMP;
                                trylist->d.td.ld.tojmp = tojmp;
                                
                                ip = trylist->d.td.fstart - 1;
                                break;
                            } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {
                                pop_try(trylist);
                            } else Jsi_LogBug("jmp within a try, but not in its scope?");
                        } else {        /* 'with' block */
                            if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) {
                                ip = tojmp;
                                break;
                            }
                            restore_scope();
                            pop_try(trylist);
                        }
                    }
                }
                break;
            }
            case OP_THROW: {
                VarDeref(interp,1);
                Jsi_ValueDup2(interp,&ps->last_exception, _jsi_TOP);
                interp->didReturn = 1; /* TODO: could possibly hide _jsi_STACK problem */
                do_throw("throw");
                break;
            }
            case OP_WITH: {
                static int warnwith = 1;
                if (strict && warnwith && interp->typeCheck.nowith) {
                    warnwith = 0;
                    rc = Jsi_LogError("use of with is illegal due to \"use nowith\"");
                    break;
                }
                VarDeref(interp,1);
                Jsi_ValueToObject(interp, _jsi_TOP);
                
                TryList *n = trylist_new(TL_WITH, scope, currentScope);
                
                n->d.wd.wstart = ip;
                n->d.wd.wend = n->d.wd.wstart + (uintptr_t)ip->data;

                push_try(trylist, n);
                interp->framePtr->withDepth++;
                
                /* make expr to top of scope chain */
                scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
                currentScope = Jsi_ValueNew1(interp);
                interp->framePtr->ingsc = scope;
                interp->framePtr->incsc = currentScope;
                Jsi_ValueCopy(interp, currentScope, _jsi_TOP);
                jsiPop(interp,1);
                
                context_id = ps->_context_id++;
                break;
            }
            case OP_EWITH: {
                if (trylist == NULL || trylist->type != TL_WITH)
                    Jsi_LogBug("Unexpected EWITH opcode??");

                restore_scope();
                
                pop_try(trylist);
                interp->framePtr->withDepth--;
                break;
            }
            case OP_DEBUG: {
                jsi_Debugger();
                jsiPush(interp,1);
                break;
            }
            case OP_RESERVED: {
                jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ip->data;
                const char *cmd = ri->type == RES_CONTINUE ? "continue" : "break";
                /* TODO: continue/break out of labeled scope not working. */
                if (ri->label) {
                    Jsi_LogError("%s: label(%s) not found", cmd, ri->label);
                } else {
                    Jsi_LogError("%s must be inside loop(or switch)", cmd);
                }
                rc = JSI_ERROR;
                break;
            }
#ifndef __cplusplus
            default:
                Jsi_LogBug("invalid op ceod: %d", ip->op);
#endif
        }
        lop = plop;
        ip++;
    }
done:
    while (trylist) {
        pop_try(trylist);
    }
    return rc;
}

// Bottom-most eval() routine creates stack frame.
Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, 
         jsi_ScopeChain *scope, Jsi_Value *fargs,
         Jsi_Value *_this,
         Jsi_Value **vret)
{
    Jsi_Interp *interp = ps->interp;
    if (interp->exited)
        return JSI_ERROR;
    Jsi_RC rc;
    jsi_Frame frame = *interp->framePtr;
    frame.parent = interp->framePtr;
    interp->framePtr = &frame;
    frame.parent->child = interp->framePtr = &frame;
    frame.ps = ps;
    frame.ingsc = scope;
    frame.incsc = fargs;
    frame.inthis = _this;
    frame.opcodes = opcodes;
    frame.fileName = interp->curFile;
    frame.funcName = interp->curFunction;
    frame.dirName = interp->curDir;
    frame.logflag = frame.parent->logflag;
    frame.level = frame.parent->level+1;
    frame.evalFuncPtr = func;
    frame.arguments = NULL;
   // if (func && func->strict)
    //    frame.strict = 1;
    if (interp->curIp)
        frame.parent->line = interp->curIp->Line;
    frame.ip = interp->curIp;
    interp->refCount++;
    interp->level++;
    Jsi_IncrRefCount(interp, fargs);
    rc = _jsi_evalcode(ps, opcodes, scope, fargs, _this, *vret);
    Jsi_DecrRefCount(interp, fargs);
    if (interp->didReturn == 0 && !interp->exited) {
        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)
            Jsi_ValueMakeUndef(interp, vret);
        /*if (interp->framePtr->Sp != oldSp) //TODO: at some point after memory refs???
            Jsi_LogBug("Stack not balance after execute script");*/
    }
    if (frame.arguments)
        Jsi_DecrRefCount(interp, frame.arguments);
    interp->didReturn = 0;
    interp->refCount--;
    interp->level--;
    interp->framePtr = frame.parent;
    interp->framePtr->child = NULL;
    interp->curIp = frame.ip;
    if (interp->exited)
        rc = JSI_ERROR;
    return rc;
}

Jsi_RC jsi_JsPreprocessLine(Jsi_Interp* interp, char *buf, size_t bsiz, uint ilen, int jOpts[4], int lineNo) {
    if (interp->unitTest&1 && buf[0]==';' && buf[1] && buf[2]) {
        // Wrap ";XXX;" in a puts("XXX ==> ", XXX)
        if (!jOpts[0]) {
            if (!Jsi_Strcmp(buf, "=!EXPECTSTART!=\n") || !Jsi_Strcmp(buf, "=!INPUTSTART!=\n") ) {
                return JSI_OK;
            }
        } else {
            if (!Jsi_Strcmp(buf, "=!EXPECTEND!=\n") || !Jsi_Strcmp(buf, "=!INPUTEND!=\n")) {
                jOpts[0] = 0;
                return JSI_OK;
            }
        }
        if (buf[ilen-1]=='\n' && buf[ilen-2]==';' && (2*ilen+12)<bsiz) {
            if (Jsi_Strchr(buf, '"')) {
                return Jsi_LogError("double-quote is illegal in unitTest on line %d: %s", lineNo, buf);
            }
            char ubuf[bsiz], *ucp = ubuf;
            buf[ilen-=2] = 0;
            Jsi_Strcpy(ubuf, buf+1);
            while (*ucp && isspace(*ucp)) ucp++;
            if (ilen>2 && ucp[0]=='\'' && ubuf[ilen-2]=='\'')
                snprintf(buf, bsiz, "puts(\"%s\");\n", ucp);
            else
                snprintf(buf, bsiz, "puts(\"%s ==> \", %s);\n", ucp, ucp);
        }
    }
    else if (interp->jsppCallback) {
        Jsi_DString dStr = {};
        buf[ilen-1] = 0; // Remove newline for length of call.
        Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, buf);
        Jsi_IncrRefCount(interp, inStr);
        if (Jsi_FunctionInvokeString(interp, interp->jsppCallback, inStr, &dStr) != JSI_OK) {
            Jsi_DSFree(&dStr);
            Jsi_DecrRefCount(interp, inStr);
            return JSI_ERROR;
        }
        Jsi_DecrRefCount(interp, inStr);
        Jsi_DSAppendLen(&dStr, "\n", 1);
        Jsi_Strncpy(buf, Jsi_DSValue(&dStr), bsiz);
        buf[bsiz-1] = 0;
        Jsi_DSFree(&dStr);
    }
    return JSI_OK;
}

Jsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, char *str, int flags, int level)
{
    Jsi_Channel tinput = NULL, input = Jsi_GetStdChannel(interp, 0);
    Jsi_Value *npath = path;
    Jsi_RC rc = JSI_ERROR;
    const char *ustr = NULL;
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return rc;
    int oldSp, uskip = 0, fncOfs = 0;
    int oldef = interp->evalFlags;
    jsi_Pstate *oldps = interp->ps;
    const char *oldFile = interp->curFile;
    char *origFile = Jsi_ValueString(interp, path, NULL);
    const char *fname = origFile;
    char *oldDir = interp->curDir;
    char dirBuf[PATH_MAX];
    jsi_Pstate *ps = NULL;
    bool oldStrict = interp->framePtr->strict;
    
    oldSp = interp->framePtr->Sp;
    dirBuf[0] = 0;
    Jsi_DString dStr = {};
    Jsi_DSInit(&dStr);

    if (str == NULL) {
        if (fname != NULL) {
            char *cp;
            if (!Jsi_Strcmp(fname,"-"))
                input = Jsi_GetStdChannel(interp, 0);
            else {
    
                /* Use translated FileName. */
                if (interp->curDir && fname[0] != '/' && fname[0] != '~') {
                    char dirBuf2[PATH_MAX], *np;
                    snprintf(dirBuf, sizeof(dirBuf), "%s/%s", interp->curDir, fname);
                    if ((np=Jsi_FileRealpathStr(interp, dirBuf, dirBuf2)) == NULL) {
                        Jsi_LogError("Can not open '%s'", fname);
                        goto bail;
                    }
                    npath = Jsi_ValueNewStringDup(interp, np);
                    Jsi_IncrRefCount(interp, npath);
                    fname = Jsi_ValueString(interp, npath, NULL);
                    if (flags&JSI_EVAL_ARGV0) {
                        interp->argv0 = Jsi_ValueNewStringDup(interp, np);
                        Jsi_IncrRefCount(interp, interp->argv0);
                    }
                } else {
                    if (flags&JSI_EVAL_ARGV0) {
                        interp->argv0 = Jsi_ValueNewStringDup(interp, fname);
                        Jsi_IncrRefCount(interp, interp->argv0);
                    }
                }
                
                tinput = input = Jsi_Open(interp, npath, "r");
                if (!input) {
                    //Jsi_LogError("Can not open '%s'", fname);
                    goto bail;
                }
            }
            bool isNew;
            Jsi_HashEntry *hPtr;
            jsi_FileInfo *fi = NULL;
            hPtr = Jsi_HashEntryNew(interp->fileTbl, fname, &isNew);
            if (isNew == 0 && hPtr) {
                if ((flags & JSI_EVAL_ONCE)) {
                    rc = JSI_OK;
                    goto bail;
                }
                fi = (jsi_FileInfo *)Jsi_HashValueGet(hPtr);
                if (!fi) goto bail;
                interp->curFile = fi->fileName;
                interp->curDir = fi->dirName;
                
            } else {
                fi = (jsi_FileInfo *)Jsi_Calloc(1,sizeof(*fi));
                if (!fi) goto bail;
                Jsi_HashValueSet(hPtr, fi);
                fi->origFile = (char*)Jsi_KeyAdd(interp, origFile);
                interp->curFile = fi->fileName = (char*)Jsi_KeyAdd(interp, fname);
                char *dfname = Jsi_Strdup(fname);
                if ((cp = Jsi_Strrchr(dfname,'/')))
                    *cp = 0;
                interp->curDir = fi->dirName = (char*)Jsi_KeyAdd(interp, dfname);
                Jsi_Free(dfname);
            }
            if (!input->fname)
                input->fname = interp->curFile;

            int cnt = 0, noncmt = 0, jppOpts[4]={};
            uint ilen;
            char buf[8192];
            while (cnt<MAX_LOOP_COUNT) {
                if (!Jsi_Gets(input, buf, sizeof(buf)))
                    break;
                if (++cnt==1 && (!(flags&JSI_EVAL_NOSKIPBANG)) && (buf[0] == '#' && buf[1] == '!')) {
                    interp->typeCheck.run = 1;
                    Jsi_DSAppend(&dStr, "\n", NULL);
                    uskip=1;
                    continue;
                }
                if (!noncmt) {
                    int bi;
                    if (!buf[0] || (buf[0] == '/' && buf[1] == '/'))
                        goto cont;
                    for (bi=0; buf[bi]; bi++) if (!isspace(buf[bi])) break;
                    if (!buf[bi])
                        goto cont;
                }
                if (!noncmt++)
                    fncOfs = Jsi_DSLength(&dStr)-uskip;
                const char *jpp = interp->jsppChars;
                uint jlen;
                if (jpp || interp->unitTest)
                    ilen = Jsi_Strlen(buf);
                if ((interp->unitTest && buf[0]==';' && buf[1] && buf[2]) || (jpp && buf[0] && jpp[0] == buf[0] && ilen>2 && (buf[ilen-2]==jpp[0]
                    || ((jlen=Jsi_Strlen(jpp))<(ilen-3) && !Jsi_Strncmp(jpp, buf+ilen-jlen-1, jlen))))) {
                    if (jsi_JsPreprocessLine(interp, buf, sizeof(buf), ilen, jppOpts, cnt) != JSI_OK)
                        goto bail;
                }
cont:
                Jsi_DSAppend(&dStr, buf,  NULL);
            }
            if (cnt>=MAX_LOOP_COUNT)
                Jsi_LogError("source file too large");
            str = Jsi_DSValue(&dStr);

        }
        if (interp->curDir && (flags&JSI_EVAL_AUTOINDEX))
            Jsi_AddAutoFiles(interp, interp->curDir);
    }
    ustr = str + fncOfs;
    // See if "use XXX" is on first non // or empty line (or second if there is a #! on first line)
    if (ustr && *ustr && !Jsi_Strncmp(ustr+uskip, "\"use ", 5)) {
        ustr += 5+uskip;
        const char *cpe = ustr;
        while (*cpe && *cpe != '\"' && *cpe != '\n' && (isalpha(*cpe) || *cpe ==',' || *cpe =='!')) cpe++;
        if (*cpe == '\"') {
            Jsi_DString cStr;
            Jsi_DSInit(&cStr);
            cpe = Jsi_DSAppendLen(&cStr, ustr, (cpe-ustr));
            rc = jsi_ParseTypeCheckStr(interp, cpe);
            Jsi_DSFree(&cStr);
            if (rc != JSI_OK)
                goto bail;
        }
    }

    /* TODO: cleanup interp->framePtr->Sp stuff. */
    oldSp = interp->framePtr->Sp;
    // Evaluate code.
    rc = JSI_OK;
    ps = jsiNewParser(interp, str, input, 0);
    interp->evalFlags = flags;
    if (!ps)
        rc = JSI_ERROR;
    else {
        Jsi_ValueMakeUndef(interp, &interp->retPtr);
        interp->ps = ps;
        Jsi_Value *retPtr = interp->retPtr;
        bool strict = (jsi_GetDirective(interp, ps->opcodes, "use strict")!=NULL);
        const char *cext;
        if (!strict && fname && ((cext=Jsi_Strstr(fname,".jsi"))) && !cext[4])
            strict = 1;
        if (strict) {
            interp->framePtr->strict = 1;
            if (interp->framePtr->level<=1)
                interp->strict = 1;
        }
        const char *curFile = interp->curFile;
        if (!path && !Jsi_Strncmp(str, "Jsi_Main(", 9))
            interp->curFile = "<Jsi_Main>";

        if (level <= 1)
            rc = jsi_evalcode(ps, NULL, ps->opcodes, interp->gsc, interp->csc, interp->csc, &retPtr);
        else {
            jsi_Frame *fptr = interp->framePtr;
            while (fptr && fptr->level != level)
                fptr = fptr->parent;
            if (!fptr)
                rc = JSI_ERROR;
            else
                rc = jsi_evalcode(ps, NULL, ps->opcodes, fptr->ingsc, fptr->incsc, fptr->inthis, &retPtr);
        }
        interp->curFile = curFile;
        if (rc != JSI_OK)
            rc = JSI_ERROR;
        else
            Jsi_ValueDup2(interp, &oldps->last_exception, ps->last_exception); //TODO: dup even if null?
        interp->ps = oldps;
        interp->evalFlags = oldef;
    }
    
bail:
    interp->framePtr->strict = oldStrict;
    interp->curFile = oldFile;
    interp->curDir = oldDir;
    interp->framePtr->Sp = oldSp;
    if (path != npath)
        Jsi_DecrRefCount(interp, npath);
    Jsi_DSFree(&dStr);
    if (tinput)
        Jsi_Close(tinput);
    Jsi_MutexUnlock(interp, interp->Mutex);
    if (interp->exited && interp->level <= 0)
    {
        rc = JSI_EXIT;
        if (!interp->parent)
            Jsi_InterpDelete(interp);
    }

    return rc;
}

Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags)
{
    int isnull;
    if ((isnull=Jsi_ValueIsNull(interp, fname)) || Jsi_ValueIsUndef(interp, fname)) 
        return Jsi_LogError("invalid file eval %s", (isnull?"null":"undefined"));
    return jsi_evalStrFile(interp, fname, NULL, flags, 0);
}

Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags)
{
    return jsi_evalStrFile(interp, NULL, (char*)str, flags, 0);
}

#undef _jsi_THIS
#undef _jsi_STACK
#undef _jsi_STACKIDX
#undef _jsi_THISIDX
#undef _jsi_TOP
#undef _jsi_TOQ

#endif
#if JSI__MAIN==1
/* JSI main program */
#ifndef JSI_AMALGAMATION
#include "jsi.h"
#endif
#include <string.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
     // A replacement for shebang "#!/usr/bin/env".
    Jsi_DString sStr = {};
    FILE *fp = NULL;
    if (argc >= 3 && Jsi_Strchr(argv[1], ' ') && Jsi_Strstr(argv[1], "%s")) {
        Jsi_DString tStr = {};
        int i;
        Jsi_DSAppend(&tStr, argv[0], " ", NULL);
        Jsi_DSPrintf(&tStr, argv[1], argv[2]);
        for (i=3; i<argc; i++)
            Jsi_DSAppend(&tStr, " ", argv[i], NULL);
        Jsi_SplitStr(Jsi_DSValue(&tStr), &argc, &argv, NULL, &sStr);
        Jsi_DSFree(&tStr);
    }
    // Perform shebang extraction.
    else if (argc == 3 && !Jsi_Strcmp(argv[1], "-!") && (fp=fopen(argv[2],"r+"))) {
        char ibuf[1024], *icp = fgets(ibuf, sizeof(ibuf), fp);
        fclose(fp);
        if (icp && icp[0] == '#' && icp[1] == '!') {
            Jsi_DString tStr = {};
            icp += 2;
            if (strstr(icp, "%s")) {
                icp = Jsi_DSPrintf(&tStr, icp, argv[2]);
            } else {
                int len = strlen(icp);
                if (len>0 && icp[len-1]=='\n') icp[len-1] = 0;
                icp = Jsi_DSAppend(&tStr, icp, " ", argv[2], NULL);
            }
            int rc = system(icp);
            Jsi_DSFree(&tStr);
            return rc;
        }
    }
    Jsi_InterpOpts opts = {.argc=argc, .argv=argv};
    Jsi_Interp *interp = Jsi_Main(&opts);
    if (!interp) return opts.exitCode;
    Jsi_InterpDelete(interp);
    Jsi_DSFree(&sStr);
    return 0;
}
#endif //JSI__MAIN==1
#endif //JSI_IN_AMALGAMATION
