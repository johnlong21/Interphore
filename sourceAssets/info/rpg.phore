function createRpgChar() {
	var rpgChar;

	rpgChar = {
		name: "unnamed",
		hp: 100,
		maxHp: 100,
		mp: 100,
		maxMp: 100,
		attack: 50,
		defence: 20,
		speed: 50,
		friendly: false,
		dead: false,
		spellNames: [],
		sprite: null,
		statBox: null,
		nameTf: null,
		hpBar: null,
		mpBar: null,
		limitBar: null
	};

	return rpgChar;
}

var rpg = null;
var MICRO_DELAY = 0.25;
var SMALL_DELAY = 0.5;
function initRpgBattle() {
	rpg = {
		players: null,
		enemies: null,
		units: [],
		turnIndex: 0,
		currentUnit: null,
		currentSpell: null,
		activeSpell: null,
		spells: []
	};

	var fireballSpell = createRpgSpell();
	fireballSpell.name = "Fireball";
	fireballSpell.execute = function(source, target) {
		var targetSpr = target.sprite;

		var spr = addRectImage(64, 64, 0xCC0000);
		spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2;
		spr.y = targetSpr.y + targetSpr.height/2 - spr.height/2;
		tween(spr, 1, {scaleX: 3, scaleY: 3, alpha: 0}, {onComplete: function() {
			spr.destroy();
			fireballSpell.done = true;
		}});
	};

	var lightningSpell = createRpgSpell();
	lightningSpell.name = "Lightning";
	lightningSpell.execute = function(source, target) {
		var targetSpr = target.sprite;

		var strikes = 10;
		var strikesArr = [];
		for (var i = 0; i < strikes; i++) strikesArr.push(i);
		strikesArr.forEach(function(i) {

			timer(i * 0.2, function() {
				var spr = addRectImage(32, gameHeight, 0xFFFF00);
				spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2 + rndFloat(-50, 50);
				spr.y = 0;
				lightningSpell.doPartialDamage(target, 1/(strikes));
				tween(spr, 0.5, {alpha: 0}, {onComplete: function() {
					spr.destroy();
					if (i == strikesArr.length-1) lightningSpell.done = true;
				}});
			});
		});
	};

	var lovingBap = createRpgSpell();
	lovingBap.name = "Loving Bap";
	lovingBap.damage = 9;
	lovingBap.isAttack = true;
	lovingBap.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			lovingBap.done = true;
		});
	};

	var gutPunch = createRpgSpell();
	gutPunch.name = "Gut Punch";
	gutPunch.damage = 15;
	gutPunch.isAttack = true;
	gutPunch.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		var endX = lerp(0.65, sourceSpr.x, targetSpr.x);
		var endY = lerp(0.90, sourceSpr.y, targetSpr.y);

		tween(sourceSpr, 1, {x: endX, y: endY}, {onComplete: function() {
			tween(sourceSpr, 0.5, {x: targetSpr.x}, {ease: QUART_OUT, startDelay: 0.5, onComplete: function() {
				gutPunch.done = true;
			}});
		}});


	};

	var punchSlam = createRpgSpell();
	punchSlam.name = "Punch Slam";
	punchSlam.damage = 13;
	punchSlam.isAttack = true;
	punchSlam.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			punchSlam.done = true;
		});
	};

	var dancingSweep = createRpgSpell();
	dancingSweep.name = "Dancing Sweep";
	dancingSweep.damage = 11;
	dancingSweep.isAttack = true;
	dancingSweep.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			dancingSweep.done = true;
		});
	};
}

function createRpgSpell() {
	var spell;
	spell = {
		name: "Unnamed spell",
		done: false,
		damage: 20,
		cost: 30,
		damagePercDone: 0,
		isAttack: false,
		target: null,
		doPartialDamage: function(target, perc) {
			if (Math.abs(perc) <= 0.001) return;
			if (spell.damagePercDone + perc >= 1) perc = 1 - spell.damagePercDone;
			doDamage(target, spell.damage * perc);
			spell.damagePercDone += perc;
		},
		execute: function(target) {
			doDamage(target, spell.damage);
			spell.done = true;
		}
	};

	rpg.spells.push(spell);
	return spell;
}

function startRpgBattle(players, enemies) {
	rpg.players = players;
	rpg.enemies = enemies;

	players.forEach(function(unit) {
		unit.friendly = true;
		rpg.units.push(unit);
	});

	enemies.forEach(function(unit) {
		unit.friendly = false;
		rpg.units.push(unit);
	});

	rpg.units.sort(function(a, b) {
		return b.speed - a.speed;
	});

	clear();
	choicesPerPage = 8;
	append("Battle start!\n");

	rpg.units.forEach(function(unit) {
		unit.sprite = addRectImage(64, 128, 0xFFFFFF);

		unit.statBox = addEmptyImage(128, 64);

		unit.nameTf = addEmptyImage(unit.statBox.width, 64);
		unit.nameTf.tint = 0xFFFFFFFF;
		unit.nameTf.setFont("NunitoSans-Light_22");
		unit.nameTf.setText(unit.name);
		unit.statBox.addChild(unit.nameTf);

		unit.hpBar = addRectImage(128, 4, 0xFFFFFF);
		unit.hpBar.y = unit.nameTf.y + unit.nameTf.textHeight;
		unit.statBox.addChild(unit.hpBar);

		unit.mpBar = addRectImage(128, 4, 0xFFFFFF);
		unit.mpBar.y = unit.hpBar.y + unit.hpBar.height;
		unit.statBox.addChild(unit.mpBar);

		unit.limitBar = addRectImage(128, 4, 0xFFFFFF);
		unit.limitBar.y = unit.mpBar.y + unit.mpBar.height;
		unit.statBox.addChild(unit.limitBar);
	});

	tempUpdateFunctions.push(updateRpgBattle);

	rpg.turnIndex = -1;
	nextTurn();
}

function updateRpgBattle() {
	if (rpg.activeSpell) {
		if (rpg.activeSpell.done) {
			rpg.activeSpell.doPartialDamage(rpg.activeSpell.target, 1-rpg.activeSpell.damagePercDone);
			rpg.activeSpell = null;

			rpg.units.forEach(function(unit) {
				if (unit.hp <= 0) {
					unit.dead = true;
					unit.hp = 0;
				}
			});

			nextTurn();
		}
	}

	rpg.units.forEach(function(unit) {
		unit.statBox.x = unit.sprite.x + unit.sprite.width + 32;
		unit.statBox.y = unit.sprite.y;

		unit.hpBar.tint = 0xFF00FF00;
		unit.mpBar.tint = 0xFF0000FF;
		unit.limitBar.tint = 0xFFFF00FF;

		unit.hpBar.scaleX = unit.hp / unit.maxHp;
		unit.mpBar.scaleX = unit.mp / unit.maxMp;

		if (unit.statBox.x + unit.statBox.width > gameWidth) unit.statBox.x = unit.sprite.x - unit.statBox.width - 32;
	});
}

function resetUnitPositions() {
	rpg.units.forEach(function(unit) {
		unit.sprite.rotation = unit.dead ? 90 : 0;
	});

	rpg.players.forEach(function(unit, i) {
		var spr = unit.sprite;
		spr.x = 128 + spr.width/2 + i*16;
		spr.y = 128 + i*(spr.height-16);
		unit.sprite.tint = 0xFF0000FF;
	});

	rpg.enemies.forEach(function(unit, i) {
		var spr = unit.sprite;
		spr.x = gameWidth - 128 - spr.width/2 - i*16;
		spr.y = 128 + i*(spr.height - 16);
		unit.sprite.tint = 0xFFFF6100;
	});
}

function startTurn() {
	resetUnitPositions();

	if (rpg.currentUnit.friendly) {
		showMenu();
	} else {
		skip();
	}
}

function showMenu() {
	clearChoices();
	addChoice("Attack", chooseAttack);
	// addChoice("Item", item);
	addChoice("Magic", chooseMagic);
	addChoice("Skip", skip);
}

function chooseAttack() {
	clearChoices();
	rpg.currentUnit.spellNames.forEach(function(spellName) {
		var spell = getSpell(spellName);
		if (!spell.isAttack) return;
		var magicChoice = addChoice(spellName, function() {
			rpg.currentSpell = spell;
			chooseMagicTarget();
		});
	});

	addChoice("Go back", showMenu);
}

function chooseMagic() {
	clearChoices();
	rpg.currentUnit.spellNames.forEach(function(spellName) {
		var spell = getSpell(spellName);
		if (spell.isAttack) return;
		var magicChoice = addChoice(spellName + "\n" + spell.cost + "mp", function() {
			rpg.currentSpell = spell;
			chooseMagicTarget();
		});

		if (spell.cost > rpg.currentUnit.mp) magicChoice.enabled = false;
	});

	addChoice("Go back", showMenu);
}

function chooseMagicTarget() {
	clearChoices();
	rpg.units.forEach(function(unit) {
		if (!unit.friendly && !unit.dead) {
			addChoice(unit.name, function() { 
				clearChoices();
				rpg.activeSpell = rpg.currentSpell;
				rpg.activeSpell.done = false;
				rpg.activeSpell.damagePercDone = 0;
				rpg.activeSpell.target = unit;
				if (!rpg.activeSpell.isAttack) rpg.currentUnit.mp -= rpg.activeSpell.cost;
				rpg.activeSpell.execute(rpg.currentUnit, unit);
			})
		}
	});

	addChoice("Go back", showMenu);
}

function getSpell(spellName) {
	var retSpell = null;
	rpg.spells.forEach(function(spell) {
		if (spellName == spell.name) {
			retSpell = spell;
			return;
		}
	});

	return retSpell;
}

function item() {
	clearChoices();
}

function skip() {
	clearChoices();
	append(rpg.currentUnit.name+" skipped turn.\n");
	timer(SMALL_DELAY, nextTurn);
}

function nextTurn() {
	rpg.turnIndex++;
	if (rpg.turnIndex >= rpg.units.length) rpg.turnIndex = 0;
	rpg.currentUnit = rpg.units[rpg.turnIndex];

	if (rpg.currentUnit.dead) {
		nextTurn();
		return;
	}

	startTurn();
}

function doDamage(unit, amount) {
	unit.hp -= amount;
	var tf = addEmptyImage(128, 128);
	tf.tint = amount > 0 ? 0xFFFF0000 : 0xFF00FF00;
	tf.setFont("NunitoSans-Light_22");
	tf.setText((amount > 0 ? "-" : "+") + amount);
	tf.x = unit.sprite.x + rndFloat(-20, 20);
	tf.y = unit.sprite.y + rndFloat(-20, 20);

	tween(tf, 2, { y: tf.y - 100, alpha: 0 }, { onComplete: function() {
		tf.destroy();
	}});
}
