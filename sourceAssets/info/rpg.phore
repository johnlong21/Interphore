function createRpgChar() {
	var rpgChar;

	rpgChar = {
		name: "unnamed",
		attack: 50,
		defence: 50,
		speed: 50,
		friendly: false,
		sprite: null
	};

	return rpgChar;
}

var rpg = null;
var SMALL_DELAY = 0.5;
var MICRO_DELAY = 0.25;
function startRpgBattle(players, enemies) {
	rpg = {
		players: players,
		enemies: enemies,
		units: [],
		turnIndex: 0,
		currentUnit: null
	};

	players.forEach(function(unit) {
		unit.friendly = true;
		rpg.units.push(unit);
	});

	enemies.forEach(function(unit) {
		unit.friendly = false;
		rpg.units.push(unit);
	});

	rpg.units.sort(function(a, b) {
		return b.speed - a.speed;
	});

	clear();
	append("Battle start!\n");

	rpg.units.forEach(function(unit) {
		unit.sprite = addRectImage(64, 128, 0xFFFFFF);
	});

	// tempUpdateFunctions.push(updateRpgBattle);
	startTurn();
}

// function updateRpgBattle() {
// }

function resetUnitPositions() {
	rpg.players.forEach(function(unit, i) {
		var spr = unit.sprite;
		spr.x = 128 + spr.width/2 + i*16;
		spr.y = 128 + i*(spr.height-16);
		unit.sprite.tint = 0xFF0000FF;
	});

	rpg.enemies.forEach(function(unit, i) {
		var spr = unit.sprite;
		spr.x = gameWidth - 128 - spr.width/2 - i*16;
		spr.y = 128 + i*(spr.height - 16);
		unit.sprite.tint = 0xFFFF0000;
	});
}

function startTurn() {
	resetUnitPositions();
	rpg.currentUnit = rpg.units[rpg.turnIndex];

	if (rpg.currentUnit.friendly) {
		showMenu();
	} else {
		skip();
	}
}

function showMenu() {
	clearChoices();
	addChoice("Attack", chooseAttack);
	addChoice("Item", item);
	addChoice("Skip", skip);
}

function chooseAttack() {
	clearChoices();
	rpg.units.forEach(function(unit) {
		if (!unit.friendly) {
			addChoice(unit.name, function() { attack(rpg.currentUnit, unit); })
		}
	});

	addChoice("Go back", showMenu);
}

function attack(unit1, unit2) {
	clearChoices();
	append(unit1.name + " attacked " + unit2.name+"\n");
	var spr1 = unit1.sprite;
	var spr2 = unit2.sprite;

	timer(MICRO_DELAY, function() {
		if (unit1.friendly) {
			spr1.x = spr2.x - spr2.width - 16;
		} else {
			spr1.x = spr2.x + spr2.width + 16;
		}
		spr1.y = spr2.y;

		timer(SMALL_DELAY, nextTurn);
	});

}

function item() {
	clearChoices();
}

function skip() {
	clearChoices();
	append(rpg.currentUnit.name+" skipped turn.\n");
	timer(SMALL_DELAY, nextTurn);
}

function nextTurn() {
	rpg.turnIndex++;
	if (rpg.turnIndex >= rpg.units.length) rpg.turnIndex = 0;
	startTurn();
}
