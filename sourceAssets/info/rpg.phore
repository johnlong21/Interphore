var rpg = null;
var MICRO_DELAY = 0.25;
var SMALL_DELAY = 0.5;

var MAGIC_DAMAGE = 1;
var PHYSICAL_DAMAGE = 2;

function initRpgBattle() {
	rpg = {
		players: null,
		enemies: null,
		units: [],
		turnIndex: 0,
		unitArrow: null,
		currentUnit: null,
		currentSpell: null,
		spells: [],
		buffs: [],
		ais: []
	};

	/// Spells
	var swampFire = createSpell();
	swampFire.name = "Swamp Fire";
	swampFire.affinities = ["Drug"];
	swampFire.execute = function(source, target) {
		var targetSpr = target.sprite;

		var spr = addRectImage(64, 64, 0xCC0000);
		spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2;
		spr.y = targetSpr.y + targetSpr.height/2 - spr.height/2;
		tween(spr, 1, {scaleX: 3, scaleY: 3, alpha: 0}, {onComplete: function() {
			spr.destroy();
			spellDone();
		}});
	};

	var staticJolt = createSpell();
	staticJolt.name = "Static Jolt";
	staticJolt.affinities = ["Electrostim"];
	staticJolt.execute = function(source, target) {
		var targetSpr = target.sprite;

		var strikes = 10;
		var strikesArr = [];
		for (var i = 0; i < strikes; i++) strikesArr.push(i);
		strikesArr.forEach(function(i) {

			timer(i * 0.2, function() {
				var spr = addRectImage(32, gameHeight, 0xFFFF00);
				spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2 + rndFloat(-50, 50);
				spr.y = 0;
				staticJolt.doPartialDamage(target, 1/(strikes));
				tween(spr, 0.5, {alpha: 0}, {onComplete: function() {
					spr.destroy();
					if (i == strikesArr.length-1) spellDone();
				}});
			});
		});
	};

	var lovingBap = createSpell();
	lovingBap.name = "Loving Bap";
	lovingBap.baseDamage = 9;
	lovingBap.isAttack = true;
	lovingBap.affinities = ["Love"];
	lovingBap.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			spellDone();
		});
	};

	var gutPunch = createSpell();
	gutPunch.name = "Gut Punch";
	gutPunch.baseDamage = 15;
	gutPunch.isAttack = true;
	gutPunch.affinities = ["Abuse"];
	gutPunch.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		var endX = lerp(0.65, sourceSpr.x, targetSpr.x);
		var endY = lerp(0.90, sourceSpr.y, targetSpr.y);

		tween(sourceSpr, 1, {x: endX, y: endY}, {onComplete: function() {
			tween(sourceSpr, 0.5, {x: targetSpr.x}, {ease: QUART_OUT, startDelay: 0.5, onComplete: function() {
				spellDone();
			}});
		}});
	};

	var paunchSlam = createSpell();
	paunchSlam.name = "Paunch Slam";
	paunchSlam.baseDamage = 13;
	paunchSlam.isAttack = true;
	paunchSlam.affinities = ["Raunch"];
	paunchSlam.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			spellDone();
		});
	};

	var dancingSweep = createSpell();
	dancingSweep.name = "Dancing Sweep";
	dancingSweep.baseDamage = 11;
	dancingSweep.isAttack = true;
	dancingSweep.affinities = ["Hypnosis"];
	dancingSweep.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			spellDone();
		});
	};

	var sappySlappy = createSpell();
	sappySlappy.name = "Sappy Slappy";
	sappySlappy.baseDamage = 8;
	sappySlappy.isAttack = true;
	sappySlappy.affinities = ["Tentacle"];
	sappySlappy.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			spellDone();
		});
	};

	var claw = createSpell();
	claw.name = "Claw";
	claw.baseDamage = 10;
	claw.isAttack = true;
	claw.affinities = ["Abuse"];
	claw.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			spellDone();
		});
	};

	var marked = createSpell();
	marked.name = "Marked";
	marked.baseDamage = 0;
	marked.affinities = ["Raunch"];
	marked.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			applyBuff("Marked", target);
			spellDone();
		});
	};

	var healingPie = createSpell();
	healingPie.name = "Healing Pie";
	healingPie.baseDamage = 0;
	healingPie.targetsEnemies = false;
	healingPie.targetsAllies = true;
	healingPie.affinities = ["Foodplay"];
	healingPie.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = gameWidth/2 - sourceSpr.width/2;
		sourceSpr.y = gameHeight/2 - sourceSpr.height/2;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(0.85, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			doDamage(target, -30);
			spellDone();
		});
	};

	var goldenRay = createSpell();
	goldenRay.name = "Golden Ray";
	goldenRay.affinities = ["Piss"];
	goldenRay.baseDamage = 20;
	goldenRay.execute = function(source, target) {
		var targetSpr = target.sprite;

		var strikes = 2;
		var strikesArr = [];
		for (var i = 0; i < strikes; i++) strikesArr.push(i);
		strikesArr.forEach(function(i) {

			timer(i * 0.4, function() {
				var spr = addRectImage(32, 32, 0xAAAA00);
				spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2 + rndFloat(-50, 50);
				spr.y = targetSpr.y + targetSpr.height/2 - spr.height/2 + rndFloat(-50, 50);
				goldenRay.doPartialDamage(target, 1/strikes);
				tween(spr, 1, {y: spr.y - rndFloat(20, 60), alpha: 0}, {onComplete: function() {
					spr.destroy();
					if (i == strikesArr.length-1) spellDone();
				}});
			});
		});
	};

	var xylemFlow = createSpell();
	xylemFlow.name = "Xylem Flow";
	xylemFlow.baseDamage = 0;
	xylemFlow.targetsEnemies = false;
	xylemFlow.targetsAllies = true;
	xylemFlow.affinities = ["Foodplay"];
	xylemFlow.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = gameWidth/2 - sourceSpr.width/2;
		sourceSpr.y = gameHeight/2 - sourceSpr.height/2;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(0.85, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			doDamage(target, -30);
			spellDone();
		});
	};

	var phloemPressure = createSpell();
	phloemPressure.name = "Phloem Pressure";
	phloemPressure.baseDamage = 20;
	phloemPressure.affinities = ["Electrostim"];
	phloemPressure.execute = function(source, target) {
		var targetSpr = target.sprite;

		var spr = addRectImage(64, 64, 0xCC0000);
		spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2;
		spr.y = targetSpr.y + targetSpr.height/2 - spr.height/2;
		tween(spr, 1, {scaleX: 3, scaleY: 3, alpha: 0}, {onComplete: function() {
			spr.destroy();
			spellDone();
		}});
	};

	var glowingBile = createSpell();
	glowingBile.name = "Glowing Bile";
	glowingBile.affinities = ["Trash"];
	glowingBile.baseDamage = 12;
	glowingBile.execute = function(source, target) {
		var targetSpr = target.sprite;

		var strikes = 4;
		var strikesArr = [];
		for (var i = 0; i < strikes; i++) strikesArr.push(i);
		strikesArr.forEach(function(i) {

			timer(i * 0.2, function() {
				var spr = addRectImage(32, 32, 0x00AA00);
				spr.x = targetSpr.x + targetSpr.width/2 - spr.width/2 + rndFloat(-50, 50);
				spr.y = targetSpr.y + targetSpr.height/2 - spr.height/2 + rndFloat(-50, 50);
				glowingBile.doPartialDamage(target, 1/strikes);
				tween(spr, 1, {y: spr.y - rndFloat(20, 60), alpha: 0}, {onComplete: function() {
					spr.destroy();
					if (i == strikesArr.length-1) spellDone();
				}});
			});
		});
	};

	var chaseTail = createSpell();
	chaseTail.name = "Chase Tail";
	chaseTail.baseDamage = 0;
	chaseTail.affinities = ["Love"];
	chaseTail.targetsAllies = true;
	chaseTail.targetsEnemies = false;
	chaseTail.execute = function(source, target) {
		var sourceSpr = source.sprite;
		var targetSpr = target.sprite;

		sourceSpr.x = lerp(0.85, sourceSpr.x, targetSpr.x);
		sourceSpr.y = lerp(1, sourceSpr.y, targetSpr.y);

		timer(SMALL_DELAY, function() {
			applyBuff("Chase Tail", target);
			spellDone();
		});
	};

	/// AIs
	var skipperAi = createAi();
	skipperAi.name = "Skipper";
	skipperAi.execute = function() {
		skip();
	};

	var simpleAi = createAi();
	simpleAi.name = "Simple";
	simpleAi.execute = function() {
		castSpell("Loving Bap", rpg.players[0]);
	};

	/// Buffs
	var markedBuff = createBuff();
	markedBuff.name = "Marked";
	markedBuff.executeDamaged = function(unit, damage) {
		removeBuff("Marked", unit);
		return damage*2;
	}

	var chaseTailBuff = createBuff();
	chaseTailBuff.name = "Chase Tail";
	chaseTailBuff.executeDamaged = function(unit, damage) {
		removeBuff("Chase Tail", unit);
		return damage*0.5;
	}
}

function deinitRpgBattle() {
	rpg.units.forEach(function(unit) {
		unit.sprite = null;
		unit.statBox = null;
		unit.nameTf = null;
		unit.hpBar = null;
		unit.mpBar = null;
		unit.limitBar = null;

		unit.buffTrackers.forEach(function(buffTracker) {
			buffTrackers.icon = null;
		});
	});
}

function createUnit() {
	var unit;

	unit = {
		name: "unnamed",
		hp: 100,
		maxHp: 100,
		mp: 100,
		maxMp: 100,
		limit: 0,
		attack: 10,
		defence: 10,
		speed: 5,
		specialAttack: 10,
		specialDefence: 10,
		friendly: false,
		dead: false,
		spellNames: [],
		ai: "Skipper",
		buffTrackers: [],
		affinities: [],
		/// Temp:
		originX: 0,
		originY: 0,
		sprite: null,
		statBox: null,
		nameTf: null,
		hpBar: null,
		mpBar: null,
		limitBar: null
	};

	return unit;
}

function createBuff() {
	var buff;
	buff = {
		name: "Unnamed buff",
		iconName: "Abuse.png",
		lastingTurns: 999,
		executeDamaged: function(unit, damage) {
			return damage;
		}
	};

	rpg.buffs.push(buff);
	return buff;
}

function createSpell() {
	var spell;
	spell = {
		name: "Unnamed spell",
		baseDamage: 20,
		cost: 30,
		damageType: MAGIC_DAMAGE,
		targetsAllies: false,
		targetsEnemies: true,
		targetsDead: false,
		isAttack: false,
		affinities: [],
		doPartialDamage: function(target, perc) {
			if (Math.abs(perc) <= 0.001) return;
			if (spell.damagePercDone + perc >= 1) perc = 1 - spell.damagePercDone;
			if (spell.baseDamage != 0) doDamage(target, spell.damage * perc);
			spell.damagePercDone += perc;
		},
		execute: function(source, target) {
			spellDone();
		},
		damage: 0,
		damagePercDone: 0,
		target: null,
	};

	rpg.spells.push(spell);
	return spell;
}

function createAi() {
	var ai;
	ai = {
		name: "Unnamed AI",
		execute: function() {
			skip();
		}
	};

	rpg.ais.push(ai);
	return ai;
}

function startRpgBattle(players, enemies) {
	rpg.players = players;
	rpg.enemies = enemies;

	players.forEach(function(unit) {
		rpg.units.push(unit);
	});

	enemies.forEach(function(unit) {
		rpg.units.push(unit);
	});

	rpg.units.sort(function(a, b) {
		var order = b.speed - a.speed;
		if (order == 0) {
			return a.name < b.name ? -1 : 1;
		} else {
			return order;
		}
	});

	clear();
	choicesPerPage = 8;
	append("Battle start!\n");

	rpg.units.forEach(function(unit) {
		unit.sprite = addRectImage(64, 128, 0xFFFFFF);

		unit.statBox = addEmptyImage(128, 64);

		unit.nameTf = addEmptyImage(unit.statBox.width, 64);
		unit.nameTf.tint = 0xFFFFFFFF;
		unit.nameTf.setFont("NunitoSans-Light_22");
		unit.nameTf.setText(unit.name);
		unit.statBox.addChild(unit.nameTf);

		unit.hpBar = addRectImage(128, 4, 0xFFFFFF);
		unit.hpBar.y = unit.nameTf.y + unit.nameTf.textHeight;
		unit.statBox.addChild(unit.hpBar);

		unit.mpBar = addRectImage(128, 4, 0xFFFFFF);
		unit.mpBar.y = unit.hpBar.y + unit.hpBar.height;
		unit.statBox.addChild(unit.mpBar);

		unit.limitBar = addRectImage(128, 4, 0xFFFFFF);
		unit.limitBar.y = unit.mpBar.y + unit.mpBar.height;
		unit.statBox.addChild(unit.limitBar);
	});

	players.forEach(function(unit, i) {
		unit.friendly = true;
		unit.originX = 32 + i*70;
		unit.originY = 128 + i*(unit.sprite.height - 55);
		unit.sprite.tint = 0xFF0000FF;
	});

	enemies.forEach(function(unit, i) {
		unit.friendly = false;
		unit.originX = gameWidth - unit.sprite.width - 32 - i*70;
		unit.originY = 128 + i*(unit.sprite.height - 55);
		unit.sprite.tint = 0xFFFF6100;
	});

	rpg.unitArrow = addRectImage(32, 32, 0xFFFF00);

	tempUpdateFunctions.push(updateRpgBattle);

	rpg.turnIndex = -1;
	nextTurn();
}

function updateRpgBattle() {
	rpg.units.forEach(function(unit) {
		unit.hp = clamp(unit.hp, 0, unit.maxHp);
		unit.mp = clamp(unit.mp, 0, unit.maxMp);
		unit.limit = clamp(unit.limit, 0, 100);

		if (unit.hp == 0) unit.dead = true;

		unit.statBox.x = unit.sprite.x + unit.sprite.width + 32;
		unit.statBox.y = unit.sprite.y;

		unit.hpBar.tint = 0xFF00FF00;
		unit.mpBar.tint = 0xFF0000FF;
		unit.limitBar.tint = 0xFFFFFF00;

		unit.hpBar.scaleX = unit.hp / unit.maxHp;
		unit.mpBar.scaleX = unit.mp / unit.maxMp;
		unit.limitBar.scaleX = unit.limit / 100;

		if (unit.statBox.x + unit.statBox.width > gameWidth) unit.statBox.x = unit.sprite.x - unit.statBox.width - 32;
	});

	if (rpg.currentUnit) {
		var unitSpr = rpg.currentUnit.sprite;
		rpg.unitArrow.x = unitSpr.x + unitSpr.width/2 - rpg.unitArrow.width/2;
		rpg.unitArrow.y = unitSpr.y - rpg.unitArrow.height - 20 + Math.sin(time)*20;
	}
}

function spellDone() {
	rpg.currentSpell.doPartialDamage(rpg.currentSpell.target, 1-rpg.currentSpell.damagePercDone);
	rpg.currentSpell = null;

	nextTurn();
}

function resetUnitPositions() {
	rpg.units.forEach(function(unit) {
		unit.sprite.rotation = unit.dead ? 90 : 0;
		unit.sprite.x = unit.originX;
		unit.sprite.y = unit.originY;
	});
}

function startTurn() {
	resetUnitPositions();

	if (rpg.currentUnit.friendly) {
		showMenu();
	} else {
		getAi(rpg.currentUnit.ai).execute();
	}
}

function showMenu() {
	clearChoices();

	var chooseAttack = function() {
		clearChoices();
		rpg.currentUnit.spellNames.forEach(function(spellName) {
			var spell = getSpell(spellName);
			if (!spell.isAttack) return;
			var magicChoice = addChoice(spellName, function() {
				rpg.currentSpell = spell;
				chooseTarget();
			});
		});

		addChoice("Go back", showMenu);
	}

	var chooseMagic = function() {
		clearChoices();
		rpg.currentUnit.spellNames.forEach(function(spellName) {
			var spell = getSpell(spellName);
			if (spell.isAttack) return;
			var magicChoice = addChoice(spellName + "\n" + spell.cost + "mp", function() {
				rpg.currentSpell = spell;
				chooseTarget();
			});

			if (spell.cost > rpg.currentUnit.mp) magicChoice.enabled = false;
		});

		addChoice("Go back", showMenu);
	}

	var chooseTarget = function() {
		clearChoices();

		var unitChoices = [];
		rpg.units.forEach(function(unit) {
			if ((rpg.currentSpell.targetsAllies && unit.friendly) || (rpg.currentSpell.targetsEnemies && !unit.friendly) || (rpg.currentSpell.targetsDead && unit.dead)) {
				unitChoices.push(unit);
			}
		});

		unitChoices.sort(function(a, b) {
			return a.name < b.name ? -1 : 1;
		});

		unitChoices.forEach(function(unit) {
			addChoice(unit.name, function() { 
				clearChoices();
				castSpell(rpg.currentSpell.name, unit);
			});
		});

		addChoice("Go back", showMenu);
	}

	addChoice("Attack", chooseAttack);
	// addChoice("Item", item);
	addChoice("Magic", chooseMagic);
	addChoice("Skip", skip);
}

function skip() {
	clearChoices();
	append(rpg.currentUnit.name+" skipped turn.\n");
	timer(SMALL_DELAY, nextTurn);
}

function castSpell(spellName, target) {
	rpg.currentSpell = getSpell(spellName);
	rpg.currentSpell.damagePercDone = 0;
	rpg.currentSpell.target = target;
	rpg.currentSpell.damage = rpg.currentSpell.baseDamage;

	if (rpg.currentSpell.isAttack) {
		rpg.currentSpell.damage += rpg.currentUnit.attack;
		rpg.currentSpell.damage -= target.defence;
	}

	var hasAffinity = arrayContainsAny(rpg.currentUnit.affinities, rpg.currentSpell.affinities);

	if (rpg.currentSpell.isAttack) {
		if (hasAffinity) rpg.currentUnit.limit += rpg.currentSpell.damage;
	} else {
		rpg.currentUnit.mp -= rpg.currentSpell.cost;
		if (hasAffinity) rpg.currentUnit.limit += rpg.currentSpell.cost;
	}

	rpg.currentSpell.execute(rpg.currentUnit, target);
}

function nextTurn() {
	if (rpg.currentUnit) {
		for (var i = rpg.currentUnit.buffTrackers.length-1; i > 0; i--) {
			var tracker = rpg.currentUnit.buffTrackers[i];
			if (tracker.remove) arrayForceRemove(rpg.currentUnit.buffTrackers, tracker);
		}
	}

	rpg.turnIndex++;
	if (rpg.turnIndex >= rpg.units.length) rpg.turnIndex = 0;
	rpg.currentUnit = rpg.units[rpg.turnIndex];

	if (rpg.currentUnit.dead) {
		nextTurn();
		return;
	}

	startTurn();
}

function doDamage(unit, amount) {
	var buffs = getBuffs(unit);
	buffs.forEach(function(buff) {
		amount = buff.executeDamaged(unit, amount);
	});

	unit.hp -= amount;

	var tf = addEmptyImage(128, 128);
	tf.tint = amount > 0 ? 0xFFFF0000 : 0xFF00FF00;
	tf.setFont("NunitoSans-Light_22");
	if (amount > 0) {
		tf.setText("-" + amount);
	} else {
		tf.setText("+" + (-amount));
	}

	tf.x = unit.sprite.x + rndFloat(-20, 20);
	tf.y = unit.sprite.y + rndFloat(-20, 20);

	tween(tf, 2, { y: tf.y - 100, alpha: 0 }, { onComplete: function() {
		tf.destroy();
	}});
}

function getSpell(spellName) {
	var retSpell = null;
	rpg.spells.forEach(function(spell) {
		if (spellName == spell.name) {
			retSpell = spell;
			return;
		}
	});

	return retSpell;
}

function getAi(aiName) {
	var retAi = null;
	rpg.ais.forEach(function(ai) {
		if (aiName == ai.name) {
			retAi = ai;
			return;
		}
	});

	return retAi;
}

function getBuff(buffName) {
	var retBuff = null;
	rpg.buffs.forEach(function(buff) {
		if (buffName == buff.name) {
			retBuff = buff;
			return;
		}
	});

	return retBuff;
}

function getBuffs(unit) {
	var buffs = [];

	unit.buffTrackers.forEach(function(buffTracker) {
		if (buffTracker.remove) return;
		buffs.push(getBuff(buffTracker.name));
	});

	return buffs;
}

function applyBuff(buffName, unit) {
	rpg.buffs.forEach(function(buff) {
		if (buff.name == buffName) {
			var icon = addImage(buff.iconName);
			unit.statBox.addChild(icon);

			var buffTracker = {
				name: buff.name,
				turns: buff.lastingTurns,
				remove: false,
				/// Temp:
				icon: icon
			};

			unit.buffTrackers.push(buffTracker);
		}
	});

	updateBuffPosition(unit);
}

function removeBuff(buffName, unit) {
	unit.buffTrackers.some(function(buffTracker) {
		if (buffTracker.name == buffName && !buffTracker.remove) {
			buffTracker.remove = true;
			buffTracker.icon.destroy();
			return true;
		}
	});

	updateBuffPosition(unit);
}

function updateBuffPosition(unit) {
	var xpos = 0;
	unit.buffTrackers.forEach(function(buffTracker) {
		if (buffTracker.remove) return;
		buffTracker.icon.x = xpos;
		buffTracker.icon.y = unit.limitBar.y + unit.limitBar.height;
		xpos += buffTracker.icon.width;
	});
}
