//TODO(fallow): Do save fixups

data.mapEntries = [];

var map = {
	nodes: [],
	lines: [],
	container: null,

	dragging: false,
	dragPointX: 0,
	dragPointY: 0,

	newlyUpdatedNodes: [],
	prevLocX: 0,
	prevLocY: 0,
	startMoveTime: 0,
	curPhase: 0,
	poofAnim: null,

	saveButton: null,
	loadButton: null,
	extrasButton: null,
};

map.clear = function() {
	//TODO(fallow): Do this
};

map.getEntry = function(entryName) {
	var entry = data.mapEntries[entryName];

	if (!entry) {
		entry = {
			name: entryName,
			unlocked: false,
			seenUnlocked: false,
			started: false,
			completed: false,
			seenCompleted: false,
		};

		data.mapEntries[entryName] = entry;
	}

	return entry;
};

map.unlockEntry = function(entryName) {
	var entry = map.getEntry(entryName);
	entry.unlocked = true;
};

map.completeEntry = function(entryName) {
	var entry = map.getEntry(entryName);
	entry.completed = true;
};

map.createNode = function(entryName, dest, connectedDirection, connectedNodeName) {
	var entry = map.getEntry(entryName);

	var node = {
		sprite: null,
		textField: null,
		progressIcon: null,
		dest: dest,

		entry: entry,
		connectedNodeName: connectedNodeName,
		connectedDirection: connectedDirection,
	};

	map.nodes[entryName] = node;

	return entry;
};

map.show = function() {
	if (preventNextCheckpoint) {
		data = JSON.parse(checkpointStr);
		preventNextCheckpoint = false;
	} else {
		msg("Autosaved", {silent: true});
		saveCheckpoint();
	}

	map.container = addEmptyImage(1, 1);

	Object.keys(map.nodes).forEach(function(nodeKey) {
		var node = map.nodes[nodeKey];

		node.textField = addEmptyImage(256, 256);
		node.textField.setFont("NunitoSans-Light_22");
		node.textField.setText(node.entry.name);
		node.textField.tint = 0xFFa5e3f2;
		node.textField.layer = GRAPH_NODE_TEXT_LAYER;

		var textPadding = 50;
		node.sprite = add9SliceImage(
			"img/writer/nodeChoice",
			node.textField.textWidth + textPadding,
			node.textField.textHeight + textPadding,
			22, 22, 44, 44
		);
		node.sprite.layer = GRAPH_NODE_LAYER;
		node.sprite.centerPivot = true;
		map.container.addChild(node.sprite);

		node.textField.x = node.sprite.width/2 - node.textField.textWidth/2;
		node.textField.y = node.sprite.height/2 - node.textField.textHeight/2;
		node.sprite.addChild(node.textField);

		if (!node.connectedNodeName) {
			node.sprite.x = gameWidth/2 - node.sprite.width/2;
			node.sprite.y = gameHeight/2 - node.sprite.height/2;
		} else {
			var parentNode = map.nodes[node.connectedNodeName];
			node.sprite.x = parentNode.sprite.x;
			node.sprite.y = parentNode.sprite.y;

			var nodePadding = 20;
			if (node.connectedDirection == LEFT) {
				node.sprite.x -= node.sprite.width/2 + parentNode.sprite.width/2 + nodePadding;
			} else if (node.connectedDirection == RIGHT) {
				node.sprite.x += node.sprite.width/2 + parentNode.sprite.width/2 + nodePadding;
			} else if (node.connectedDirection == TOP) {
				node.sprite.y -= node.sprite.height/2 + parentNode.sprite.height/2 + nodePadding;
			} else if (node.connectedDirection == BOTTOM) {
				node.sprite.y += node.sprite.height/2 + parentNode.sprite.height/2 + nodePadding;
			}

			var x1 = node.sprite.x + node.sprite.width/2;
			var y1 = node.sprite.y + node.sprite.height/2;
			var x2 = parentNode.sprite.x + parentNode.sprite.width/2;
			var y2 = parentNode.sprite.y + parentNode.sprite.height/2;
			var dist = pointDistance(x1, y1, x2, y2);
			var line = addRectImage(dist, 4, 0x752b2b);
			map.container.addChild(line);
			line.x = x1;
			line.y = y1;
			line.layer = GRAPH_LINE_LAYER;
			line.rotation = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
		}

		var icon = null;
		if (!node.entry.seenUnlocked) {
			icon = addImage("writer/nodeLock");
		} else if (node.entry.seenCompleted) {
			icon = addImage("writer/fullCheck");
		} else if (node.entry.started) {
			icon = addImage("writer/halfCheck");
		} else {
			icon = addEmptyImage(32, 32);
		}

		icon.x = node.sprite.width - icon.width/2;
		icon.y = -icon.height/2;
		node.sprite.addChild(icon);
		node.progressIcon = icon;

		if (node.entry.unlocked && !node.entry.seenUnlocked) {
			map.newlyUpdatedNodes.push(node);
		}

		if (node.entry.completed && !node.entry.seenCompleted) {
			map.newlyUpdatedNodes.push(node);
		}
	});

	map.prevLocX = 0;
	map.prevLocY = 0;
	map.startMoveTime = time;
	map.curPhase = 0;

	map.poofAnim = addImage("writer/poof");
	map.poofAnim.alpha = 0;
	map.container.addChild(map.poofAnim);

	enableExit();

	var buttonPad = 10;
	var buttonEdgePad = 10;
	map.saveButton = addImage("writer/save");
	map.saveButton.scaleX = map.saveButton.scaleY = 2;
	map.saveButton.x = exitButton.x;
	map.saveButton.y = exitButton.y + exitButton.height * exitButton.scaleY + buttonPad;

	map.loadButton = addImage("writer/load");
	map.loadButton.scaleX = map.loadButton.scaleY = 2;
	map.loadButton.x = map.saveButton.x;
	map.loadButton.y = map.saveButton.y + map.saveButton.height * map.saveButton.scaleY  + buttonPad;

	map.extrasButton = addImage("writer/extras");
	map.extrasButton.scaleX = map.extrasButton.scaleY = 2;
	map.extrasButton.x = map.loadButton.x;
	map.extrasButton.y = map.loadButton.y + map.loadButton.height * map.loadButton.scaleY   + buttonPad;

	hookTempUpdate(map.update);
};

map.update = function() {
	if (mouseJustDown) {
		map.dragging = true;
		map.dragPointX = mouseX - map.container.x;
		map.dragPointY = mouseY - map.container.y;
	}

	if (mouseJustUp) {
		map.dragging = false;
	}

	if (map.dragging) {
		map.container.x = mouseX - map.dragPointX;
		map.container.y = mouseY - map.dragPointY;
	}

	var currentFocusedNode = map.newlyUpdatedNodes[0];
	if (currentFocusedNode) {
		var nextPosX = currentFocusedNode.sprite.x + currentFocusedNode.sprite.width/2;
		var nextPosY = currentFocusedNode.sprite.y + currentFocusedNode.sprite.height/2;

		nextPosX = gameWidth/2 - nextPosX;
		nextPosY = gameHeight/2 - nextPosY;

		if (map.curPhase == 0) {
			var perc = (time - map.startMoveTime) / 0.5;
			var tweenPerc = perc;
			perc = tweenEase(perc, ELASTIC_OUT);

			var curX = lerp(perc, map.prevLocX, nextPosX);
			var curY = lerp(perc, map.prevLocY, nextPosY);
			map.container.x = curX;
			map.container.y = curY;

			if (tweenPerc >= 1) {
				map.startMoveTime = time;
				map.curPhase = 1;

				map.poofAnim.alpha = 1;
				map.poofAnim.x = currentFocusedNode.sprite.x + currentFocusedNode.sprite.width/2 - map.poofAnim.width/2;
				map.poofAnim.y = currentFocusedNode.sprite.y + currentFocusedNode.sprite.height/2 - map.poofAnim.height/2;
			}
		}

		if (map.curPhase == 1) {
			if (map.poofAnim.alpha == 0) {
				map.startMoveTime = time;
				map.curPhase = 0;
				map.newlyUpdatedNodes.shift();
				map.prevLocX = map.container.x;
				map.prevLocY = map.container.y;
			}
		} else {
			map.poofAnim.gotoFrame(0);
		}
	}

	Object.keys(map.nodes).forEach(function(nodeKey) {
		var node = map.nodes[nodeKey];

		var spr = node.sprite;
		if (node.entry.seenUnlocked) {
			node.sprite.tint = 0;

			if (spr.justReleased) {
				gotoPassage(node.dest);
				node.entry.started = true;
			}

			var scaleSpeed = 0.05;
			if (spr.hovering) {
				spr.scaleX += scaleSpeed;
				spr.scaleY += scaleSpeed;
				var maxScale = 1.25;
				if (spr.scaleX > maxScale) spr.scaleX = maxScale;
				if (spr.scaleY > maxScale) spr.scaleY = maxScale;
			} else {
				spr.scaleX -= scaleSpeed;
				spr.scaleY -= scaleSpeed;
				if (spr.scaleX < 1) spr.scaleX = 1;
				if (spr.scaleY < 1) spr.scaleY = 1;
			}
		} else {
			node.sprite.tint = 0xCC0d0d0d;
		}
	});

	if (map.saveButton.justReleased) {
		saveGame();
	}

	if (map.loadButton.justReleased) {
		loadGame();
	}

	if (map.extrasButton.justReleased) {
		gotoPassage("scratchModStart");
	}

	if (map.poofAnim.alpha != 0 && map.poofAnim.currentFrame == round((map.poofAnim.totalFrames-2)/2)) {
		if (currentFocusedNode.entry.unlocked && !currentFocusedNode.entry.seenUnlocked) {
			currentFocusedNode.entry.seenUnlocked = true;
			currentFocusedNode.progressIcon.destroy();
		}

		if (currentFocusedNode.entry.completed && !currentFocusedNode.entry.seenCompleted) {
			currentFocusedNode.entry.seenCompleted = true;
			currentFocusedNode.progressIcon.destroy();
			currentFocusedNode.progressIcon = addImage("writer/fullCheck");
			currentFocusedNode.progressIcon.x = currentFocusedNode.sprite.width - currentFocusedNode.progressIcon.width/2;
			currentFocusedNode.progressIcon.y = -currentFocusedNode.progressIcon.height/2;
			currentFocusedNode.sprite.addChild(currentFocusedNode.progressIcon);
		}
	}

	//@hack Doing this one frame early because update timing is bad
	if (map.poofAnim.alpha != 0 && map.poofAnim.currentFrame == map.poofAnim.totalFrames-2) {
		map.poofAnim.alpha = 0;
	}
};
